[
     {
          "operator": "initial",
          "algorithm_description": "The BI-RRT (Bidirectional Rapidly-exploring Random Tree) algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -41.67642381483319,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005017662048339843,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 48.01655913766018,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 17.314426604944877
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013940382003784179,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": 0.0,
                    "time_improvement": 3.305655285096027,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 2.6502648761345116
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009051012992858886,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": 0.0,
                    "time_improvement": 69.15565132115084,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 21.711732333753805
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "The algorithm is a simplified and generalized bidirectional RRT* (BI-RRT*) path planner that builds two trees growing from start and goal positions respectively, incrementally searching for an optimal path in a given environment with obstacles. It samples free points within the map bounds, extends trees toward sampled points while rewiring nearby nodes to minimize path cost, and attempts to connect the two trees when close enough, returning an optimized feasible path.",
          "planning_mechanism": "The planner iteratively samples collision-free points within the environment, extends the nearest node in one tree towards this sample with a fixed step size, rewires nearby nodes to improve path cost, then attempts to connect the other tree to the newly added node. Collision checks on nodes and edges ensure path validity. Upon connecting the two trees, the final path is constructed by concatenating paths from both trees and returned along with the explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                success = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        r = self.neighbor_radius\n        return [node for node in tree if math.dist(node.position, position) <= r]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        current_pos = nearest.position\n\n        while True:\n            new_pos = self._steer(current_pos, target_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n            min_cost = self._nearest(tree, current_pos).cost + math.dist(current_pos, new_pos)\n            best_parent = self._nearest(tree, current_pos)\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            connect_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(connect_node)\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                return connect_node\n\n            current_pos = connect_node.position\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 15.44831,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008229565620422364,
                    "num_nodes_avg": 52.3,
                    "path_length_avg": 154.7943637949193,
                    "success_improvement": 0.0,
                    "time_improvement": 14.740942369063248,
                    "length_improvement": 22.63526478083162,
                    "objective_score": 8.949335666885299
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03801658153533936,
                    "num_nodes_avg": 239.4,
                    "path_length_avg": 232.41204773470093,
                    "success_improvement": 0.0,
                    "time_improvement": -163.69352280751656,
                    "length_improvement": 22.877819712112878,
                    "objective_score": -44.53249289983239
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01417546272277832,
                    "num_nodes_avg": 117.1,
                    "path_length_avg": 125.17394587738166,
                    "success_improvement": 0.0,
                    "time_improvement": 51.692377941521784,
                    "length_improvement": 23.135656625921193,
                    "objective_score": 20.134844707640774
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "The BI-RRT* (Bidirectional Rapidly-exploring Random Tree Star) algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 30.287311908068716,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01235060691833496,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": -27.953424955292306,
                    "length_improvement": 21.158844301429212,
                    "objective_score": -4.154258626301849
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03940980434417725,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": 0.0,
                    "time_improvement": -173.3573014977898,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -46.540470320591325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015583133697509766,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": 0.0,
                    "time_improvement": 46.89526910917684,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 20.407417038824455
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "RRT*-Connect is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 48.50098346980033,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018834543228149415,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -95.12760218549002,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -26.05798334824908
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03362276554107666,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -133.2167999854471,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -37.12695823072576
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017261362075805663,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 41.1761455918712,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 14.683958109174508
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "RRT-Connect is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 68.10583921264231,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01512143611907959,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": -56.659470621362885,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": -15.81252681774724
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030667328834533693,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -112.71707367895338,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -33.737770041601834
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04805226325988769,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": -63.754130500665006,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": -18.55554235329323
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced RRT* variant with adaptive parameters and informed sampling to improve path planning efficiency, path quality, and robustness. The algorithm incorporates goal biasing, adaptive neighbor radius based on the number of nodes, heuristic pruning by sampling within an informed ellipsoidal region, and early stopping to reduce search time and improve success rate. It maintains collision and edge checks ensuring safety and correctness.",
          "planning_mechanism": "The planner incrementally samples points biased toward the goal and within an informed ellipsoidal subset to focus the search. It connects nodes with collision-free edges, rewires to optimize paths, and dynamically adjusts the neighbor radius based on the explored tree size to balance exploration and exploitation. Early termination occurs when the goal is connected, thus reducing unnecessary iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.1, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic(p):\n            # Euclidean heuristic to goal\n            return dist(p, goal_position)\n\n        def sample_in_bounds():\n            if is_3d:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]))\n            else:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]))\n\n        def informed_sample(c_best):\n            # Sample inside ellipsoid only if c_best < inf\n            if c_best == float('inf'):\n                return sample_in_bounds()\n\n            # Define ellipsoid parameters\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                c_best = c_min\n\n            # Unit vector from start to goal\n            dx = (goal_position[0] - start_position[0]) / c_min\n            dy = (goal_position[1] - start_position[1]) / c_min\n            if is_3d:\n                dz = (goal_position[2] - start_position[2]) / c_min\n\n            # Radii of the ellipsoid\n            a = c_best / 2.0\n            if is_3d:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                c = b\n            else:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            from random import uniform\n            import math as m\n\n            while True:\n                # Sample random point in unit ball\n                if is_3d:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    z = uniform(-1, 1)\n                    if x * x + y * y + z * z > 1:\n                        continue\n                    # Scale to ellipsoid\n                    px = a*x\n                    py = b*y\n                    pz = c*z\n                    # Rotate and translate\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                        start_position[2] + (c_min/2)*dz + pz,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(3)):\n                        return sample\n                else:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    if x*x + y*y > 1:\n                        continue\n                    px = a*x\n                    py = b*y\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(2)):\n                        return sample\n\n        for i in range(self.max_iter):\n            # Adaptive neighbor radius: gamma * (log(n)/n)^{1/d} with gamma ~ base_neighbor_radius\n            n = len(nodes)\n            dim = len(bounds)\n            gamma = self.base_neighbor_radius\n            r = min(gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 20)\n\n            # Goal biasing + informed sampling after initial solution found\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif best_goal_cost == float('inf'):\n                sample = sample_in_bounds()\n            else:\n                sample = informed_sample(best_goal_cost)\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            step = min(self.step_size, dist_to_sample)\n            new_position = tuple(nearest_node.position[d] + unit[d] * step for d in range(dim))\n\n            # Check bounds\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if dist(n.position, new_position) <= r]\n\n            # Choose best parent among near nodes\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to new_node if cheaper path found\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal closer than previous best\n            dist_to_goal = dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        goal_node = Node(goal_position)\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        # Early exit after connecting goal for efficiency\n                        break\n\n        if success_state and goal_node:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 623.91658,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034694790840148926,
                    "num_nodes_avg": 180.9,
                    "path_length_avg": 189.07139379721863,
                    "success_improvement": 0.0,
                    "time_improvement": -259.44122790550625,
                    "length_improvement": 5.503934639246591,
                    "objective_score": -76.73158144380255
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.22140061855316162,
                    "num_nodes_avg": 740.6,
                    "path_length_avg": 306.5156055242495,
                    "success_improvement": 0.0,
                    "time_improvement": -1435.6959174189792,
                    "length_improvement": -1.712247797395705,
                    "objective_score": -431.05122478517285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14426853656768798,
                    "num_nodes_avg": 551.6,
                    "path_length_avg": 151.78324040380903,
                    "success_improvement": 0.0,
                    "time_improvement": -391.64320599163295,
                    "length_improvement": 6.795946815823351,
                    "objective_score": -116.13377243432521
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "RRT (Rapidly-exploring Random Tree) is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 1276.628921384641,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03680808544158935,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "success_improvement": 0.0,
                    "time_improvement": -281.33515457500516,
                    "length_improvement": 8.639069807597604,
                    "objective_score": -82.67273241098204
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5104677438735962,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "success_improvement": 0.0,
                    "time_improvement": -3440.7454385793735,
                    "length_improvement": -1.1692154216563917,
                    "objective_score": -1032.4574746581434
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.18886771202087402,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "success_improvement": 0.0,
                    "time_improvement": -543.6297868917591,
                    "length_improvement": 7.95110876006046,
                    "objective_score": -161.49871431551563
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized version of RRT*, specifically tuned for improved planning efficiency, path quality, robustness, success rate, and path smoothness by adjusting parameters such as step size, goal bias, and neighbor radius. It incrementally builds and rewires a tree rooted at the start position, always performing collision and obstacle intersection checks, while ensuring samples remain within bounds.",
          "planning_mechanism": "The planner samples points with an adaptive goal bias, finds the nearest node, steers toward the sample with a carefully chosen step size, selects the lowest-cost parent among neighbors within an adaptively tuned radius, and rewires neighbors to improve the path iteratively. The process terminates upon reaching the goal or exhausting iterations, returning a smooth, optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]\n        dim = len(bounds)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle descriptions\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for i in range(self.max_iter):\n            # Goal biasing with increased rate to accelerate goal reaching\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and Limit step_size\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            length = min(self.step_size, dist)\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * length for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n\n            # Find neighbors according to adaptive radius reduced over time (improves efficiency)\n            radius = self.neighbor_radius * (1.0 - i / self.max_iter) + 3.0\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for path quality improvement\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal check with improved step size tolerance and obstacle checks\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Optional: Path smoothing using shortcut heuristic\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 100\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            # Check if direct edge is collision free\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
          "objective": 2116.54822,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.25391206741333006,
                    "num_nodes_avg": 414.8,
                    "path_length_avg": 166.86145382751903,
                    "success_improvement": 0.0,
                    "time_improvement": -2530.5523993953348,
                    "length_improvement": 16.604249165335506,
                    "objective_score": -755.8448699855334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5644539594650269,
                    "num_nodes_avg": 1141.2,
                    "path_length_avg": 221.74677084348986,
                    "success_improvement": 0.0,
                    "time_improvement": -3815.2087595151906,
                    "length_improvement": 26.416919406992452,
                    "objective_score": -1139.2792439731586
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.25168962478637696,
                    "num_nodes_avg": 672.5,
                    "path_length_avg": 114.88430352297128,
                    "success_improvement": 0.0,
                    "time_improvement": -757.7164292974472,
                    "length_improvement": 29.454116890013392,
                    "objective_score": -221.4241054112315
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "RRT* (Rapidly-exploring Random Tree Star) is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 2344.951140538794,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09505188465118408,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "success_improvement": 0.0,
                    "time_improvement": -884.7462776520804,
                    "length_improvement": 21.16112596316623,
                    "objective_score": -261.19165810299086
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.8762087821960449,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "success_improvement": 0.0,
                    "time_improvement": -5977.626424074445,
                    "length_improvement": 25.195979140247676,
                    "objective_score": -1788.2487313942838
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.32371039390563966,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "success_improvement": 0.0,
                    "time_improvement": -1003.1512459954355,
                    "length_improvement": 27.173113785558407,
                    "objective_score": -295.5107510415189
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* inspired planner that grows two trees from the start and goal positions, alternately extending them with goal biasing and adaptive step sizing. It performs collision checks on nodes and edges before adding them. Nearby nodes are rewired for path cost improvement. The planner attempts to connect the two trees at every iteration to find a feasible, near-optimal, and smooth path efficiently.",
          "planning_mechanism": "A bidirectional incremental sampling approach that alternately grows start and goal trees toward randomly sampled points biased by the goal. Each new node undergoes collision checks, and rewiring locally improves path cost. The trees try to connect every iteration, reconstructing a smooth, high-quality path once connected while respecting map bounds and obstacles.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position           # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent               # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                        # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                        # Tuple[float, ...]\n        goal = map.goal                          # Tuple[float, ...]\n        obstacles = map.obstacles                # List of rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        def sample() -> Tuple[float, ...]:\n            # Goal biasing for start tree growth; uniform random otherwise\n            if random.random() < self.goal_sample_rate:\n                return goal\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            rand_point = sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step = self._adaptive_step(nearest.position, rand_point, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, rand_point, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + 1e-8 >= c_best:\n                # Prune expansions exceeding current best path cost\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in tree_a to improve path cost\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Attempt connection to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d) -> float:\n        base_step = self.step_size\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(base_step * 0.5, 1.0)\n        return base_step\n\n    def _in_bounds(self, pos, bounds) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0) -> bool:\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while True:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                next_idx = j\n                break\n            smoothed.append(path[next_idx])\n            if next_idx == len(path) - 1:\n                break\n            idx = next_idx\n        return smoothed",
          "objective": 14698.73309,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.2550732851028443,
                    "num_nodes_avg": 2881.5,
                    "path_length_avg": 150.2908476159304,
                    "success_improvement": 0.0,
                    "time_improvement": -23262.766887652775,
                    "length_improvement": 24.886078881558923,
                    "objective_score": -6973.852850519521
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.5137412548065186,
                    "num_nodes_avg": 3415.1,
                    "path_length_avg": 224.9319970260605,
                    "success_improvement": 0.0,
                    "time_improvement": -17336.00450478013,
                    "length_improvement": 25.359953598617825,
                    "objective_score": -5195.729360714315
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.5090816497802733,
                    "num_nodes_avg": 3345.2,
                    "path_length_avg": 113.92078839710514,
                    "success_improvement": 0.0,
                    "time_improvement": -8450.533440907127,
                    "length_improvement": 30.045773220422934,
                    "objective_score": -2529.150877628054
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional RRT* planner integrating informed sampling from Algorithm 2 and adaptive step sizing plus local rewiring from Algorithm 1, enhanced with pruning, node rejection, and path smoothing to boost planning efficiency, success rate, and path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, using informed heuristic sampling constrained by the current best path cost to focus exploration. It adaptively adjusts step size near obstacles and prunes expansions unlikely to improve the current best path. Each new node undergoes collision and edge checks before insertion. Local rewiring optimizes path cost. Upon connecting both trees with valid edges, a smoothed, near-optimal path is extracted.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / norm_a1\n\n            # Create rotation matrix C aligning x-axis with vector a1\n            eye = np.eye(dim)\n            M = np.outer(a1, eye[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):  # sample up to 100 times to get a valid point\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                x_rand_clip = np.clip(x_rand, [0]*dim, np.array(bounds))\n                x_rand_tuple = tuple(x_rand_clip)\n                if in_bounds(x_rand_tuple):\n                    return x_rand_tuple\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            return tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            step_val = self.step_size\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step_val = max(self.step_size * 0.3, 1.0)\n                    break\n            return step_val\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while True:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not in_bounds(path[j]):\n                        continue\n                    if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        continue\n                    next_idx = j\n                    break\n                smoothed.append(path[next_idx])\n                if next_idx == len(path) - 1:\n                    break\n                idx = next_idx\n            return smoothed\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sampled_point = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sampled_point))\n            step = adaptive_step(nearest.position, sampled_point)\n            new_pos = steer(nearest.position, sampled_point, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune expansions that cannot improve best path cost\n            heuristic_cost = new_cost + math.dist(new_pos, goal)\n            if heuristic_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring to improve costs\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect both trees\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16137.02705,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.5810898542404175,
                    "num_nodes_avg": 2094.8,
                    "path_length_avg": 151.77689065690328,
                    "success_improvement": 0.0,
                    "time_improvement": -26640.32856451247,
                    "length_improvement": 24.143368852778615,
                    "objective_score": -7987.269895583185
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.6184764385223387,
                    "num_nodes_avg": 2665.2,
                    "path_length_avg": 232.55277351067917,
                    "success_improvement": 0.0,
                    "time_improvement": -18062.476702977223,
                    "length_improvement": 22.83112213867841,
                    "objective_score": -5414.176786465431
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.7108699321746825,
                    "num_nodes_avg": 2621.2,
                    "path_length_avg": 114.98911993316067,
                    "success_improvement": 0.0,
                    "time_improvement": -9138.194385200315,
                    "length_improvement": 29.389753299910325,
                    "objective_score": -2735.5803649001123
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner with Adaptive Step Sizing, Dynamic Rewiring, Branch Pruning, and Incremental Path Smoothing for Enhanced Efficiency and Path Quality",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately using informed sampling restricted to an ellipsoidal heuristic region guided by the best known path cost, integrating goal biasing. It employs adaptive step sizing near obstacles and dynamically adjusts rewiring radius based on node density. The algorithm rewires nodes locally to reduce path cost, prunes branches unlikely to yield better solutions, performs strict collision and edge checks before node/edge additions, and incrementally smooths the best found path to ensure robustness, improved success rate, and high-quality smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0, goal_sample_rate: float = 0.15, rewire_base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            # If near obstacle, reduce step size adaptively\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            return tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sampling in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            val = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(val) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _valid_node_and_edge(from_pos, to_pos):\n            if not _in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                for j in range(len(path_in) - 1, idx, -1):\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) \n                        and _in_bounds(path_in[j])):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        # Initialize start and goal nodes costs\n        tree_start[0].cost = 0.0\n        tree_goal[0].cost = 0.0\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample with goal bias and informed sampling region\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _valid_node_and_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            if new_cost + c_min - 1e-9 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            curr_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_radius and n is not new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if _valid_node_and_edge(new_node.position, near.position):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect new_node in tree_a to nearest in tree_b\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_b.position)\n            total_path_cost = new_node.cost + dist_between + nearest_b.cost\n\n            if total_path_cost + 1e-9 < c_best:\n                if _valid_node_and_edge(new_node.position, nearest_b.position):\n                    c_best = total_path_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune trees to reduce search space\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 400 iterations if path found\n            if success and iteration % 400 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        # Final path smoothing\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17423.34785,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.0039466381073,
                    "num_nodes_avg": 754.7,
                    "path_length_avg": 158.9066197858871,
                    "success_improvement": 0.0,
                    "time_improvement": -20661.071700275657,
                    "length_improvement": 20.579998761481207,
                    "objective_score": -6194.205510330401
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.752269744873047,
                    "num_nodes_avg": 2709.9,
                    "path_length_avg": 235.2432028075281,
                    "success_improvement": 0.0,
                    "time_improvement": -25926.780620184523,
                    "length_improvement": 21.938346676709898,
                    "objective_score": -7773.646516720014
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.4142481803894045,
                    "num_nodes_avg": 2891.6,
                    "path_length_avg": 121.63826340464034,
                    "success_improvement": 0.0,
                    "time_improvement": -11535.190606305092,
                    "length_improvement": 25.306778657280017,
                    "objective_score": -3455.4958261600714
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "A refined RRT*-Connect inspired planner that integrates bidirectional search with adaptive step sizing, goal biasing, informed heuristic sampling, dynamic rewiring radius, branch pruning, and incremental path smoothing for efficient, high-quality, and robust path planning in 2D/3D environments.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal points, alternately expanding them using informed sampling restricted inside an ellipsoidal heuristic region biased by current best path cost. It adapts step sizes near obstacles and dynamically adjusts rewiring radius based on node density. Nodes are connected only after strict collision and edge checks. It attempts early tree connections to accelerate search, rewires locally for path cost reduction, prunes branches unlikely to improve solutions, and applies intermittent path smoothing to enhance path quality and smoothness within the iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 4.5, goal_sample_rate: float = 0.12, rewire_base_radius: float = 18.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            # Check points along the path for obstacle proximity to adapt step size\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacles, but keep minimum 1.0\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            new_pos = tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n            return new_pos\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            # Rotation matrix to align x-axis with a_unit vector\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            r2_sq = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(r2_sq) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim -1))\n\n            for _ in range(100):\n                # Sample unit ball\n                x_ball = np.random.normal(0,1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback uniform sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            # Adaptive rewiring radius ~ gamma * (log(n)/n)^{1/d}\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _try_connect_nodes(from_node, to_node):\n            if self._is_edge_in_obstacle(from_node.position, to_node.position, obstacles, is_3d):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            # Remove nodes and descendants whose cost > cost_threshold (to prune search space)\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                # Disconnect node from parent\n                if node.parent:\n                    node.parent.remove_child(node)\n                # Disconnect children recursively\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) -1:\n                next_idx = len(path_in) -1\n                for j in range(len(path_in)-1, idx, -1):\n                    if not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) and _in_bounds(path_in[j]):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing & informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            # Prune expansions that can't beat current best\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius based on tree size\n            curr_rewire_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_rewire_radius]\n            for near_node in near_nodes:\n                if near_node is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try connect new_node in tree_a to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between + nearest_to_new.cost\n\n            # Only attempt if total cost could improve best known path\n            if total_cost + 1e-6 < c_best:\n                if _try_connect_nodes(new_node, nearest_to_new):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune both trees to nodes that can improve the best path cost\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 500 iterations if path found\n            if success and iteration % 500 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17508.66314,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.970580530166626,
                    "num_nodes_avg": 888.1,
                    "path_length_avg": 160.88313224173535,
                    "success_improvement": 0.0,
                    "time_improvement": -20315.39574955786,
                    "length_improvement": 19.592156833291394,
                    "objective_score": -6090.7002935007
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.728665590286255,
                    "num_nodes_avg": 2668.8,
                    "path_length_avg": 234.32515379280804,
                    "success_improvement": 0.0,
                    "time_improvement": -25763.055676370248,
                    "length_improvement": 22.242986398774466,
                    "objective_score": -7724.468105631319
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.6472797632217406,
                    "num_nodes_avg": 2934.6,
                    "path_length_avg": 119.67619978901351,
                    "success_improvement": 0.0,
                    "time_improvement": -12329.323528193027,
                    "length_improvement": 26.511603913975694,
                    "objective_score": -3693.494737675113
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "Improved RRT*-Connect is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 19428.65639105263,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.5165858030319215,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "success_improvement": 0.0,
                    "time_improvement": -25972.060654263783,
                    "length_improvement": 22.74960801803148,
                    "objective_score": -7787.068274675528
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.050779104232788,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "success_improvement": 0.0,
                    "time_improvement": -27997.324087839905,
                    "length_improvement": 23.81225076558798,
                    "objective_score": -8394.434776198854
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.2109699726104735,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "success_improvement": 0.0,
                    "time_improvement": -10842.45224381552,
                    "length_improvement": 27.91166483203798,
                    "objective_score": -3247.153340178248
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates bidirectional RRT* growth with informed elliptical sampling and adaptive step sizing, enhanced by heuristic-driven node rejection, rewiring for cost minimization, and aggressive pruning. It alternates expansions between start and goal trees, opportunistically attempts tree connection, and carefully maintains collision-free nodes and edges. The planner aims for rapid convergence to high-quality, smooth paths with improved efficiency and robustness.",
          "planning_mechanism": "It generates samples inside the ellipsoidal informed subset defined by the current best cost; expands trees adaptively near obstacles; rewires neighbors to optimize path costs; prunes nodes that cannot improve the solution; and promptly updates and returns the best found path, ensuring all new nodes and edges pass collision checks and remain within map bounds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Path cost\n        self.children = []\n        self.valid = True                         # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                          # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start                  # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal                    # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles                    # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        tree_a = [Node(start_position)]\n        tree_b = [Node(goal_position)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def informed_sample() -> Tuple[float, ...]:\n            if c_best == float(\"inf\"):\n                # Uniform random sample inside bounds & collision-free\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback if no free sample found fast enough\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s,g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best**2 - c_min**2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        return candidate\n            # fallback uniform sampling inside bounds if failure\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos) -> float:\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # never prune root\n                    h_cost = math.dist(node.position, goal_position)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            main_tree, other_tree = (tree_a, tree_b) if i%2==0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue  # prune non-improving expansion\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connection_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connection_cost < c_best:\n                c_best = connection_cost\n                path_from_a = new_node.path_from_root()\n                path_from_b = other_nearest.path_from_root()\n                best_path = path_from_a + path_from_b[::-1]\n                success = True\n                prune(tree_a)\n                prune(tree_b)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 31003.29177,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.937959551811218,
                    "num_nodes_avg": 2292.6,
                    "path_length_avg": 158.15569516447223,
                    "success_improvement": 0.0,
                    "time_improvement": -51057.71565905566,
                    "length_improvement": 20.95530366975476,
                    "objective_score": -15313.123636982747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.726552891731262,
                    "num_nodes_avg": 2795.5,
                    "path_length_avg": 260.4220472040613,
                    "success_improvement": 0.0,
                    "time_improvement": -32684.677959486744,
                    "length_improvement": 13.583154267722925,
                    "objective_score": -9802.686756992478
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 5.793317031860352,
                    "num_nodes_avg": 2556.2,
                    "path_length_avg": 119.55481531647267,
                    "success_improvement": 0.0,
                    "time_improvement": -19642.66202896855,
                    "length_improvement": 26.586141292439425,
                    "objective_score": -5887.481380432077
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "The hybrid planner combines the asymptotic optimality and bidirectional growth of BI-RRT* with the informed sampling, adaptive step sizing, node rejection, and pruning strategies from Improved RRT*-Connect. By integrating heuristic elliptical sampling for focused exploration, adaptive step adjustments near obstacles to maintain collision safety, and rewiring for cost optimization, it robustly searches the free space. The planner simultaneously grows two trees from start and goal, alternates sampling from an informed set when possible to improve convergence speed, aggressively prunes suboptimal branches, and attempts to connect the trees for fast discovery of high-quality paths.",
          "planning_mechanism": "The planner performs bidirectional RRT*-style growth with informed heuristic sampling within the current best path cost ellipse. Each expansion adapts step size based on nearby obstacles, rejects nodes that cannot improve the solution, and rewires neighbors for cost efficiency. When trees connect successfully, the best path is updated. The alternating growth of start and goal trees plus pruning accelerates search and enhances path quality and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:  # Start == Goal\n            return PlannerResult(True, [start], nodes, edges)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Informed sampling inside an ellipsoid defined by start, goal, c_best, and c_min\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(max(0.0, c_best**2 - c_min**2)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            # Prune nodes where cost + heuristic exceeds current best path cost\n            nonlocal edges, nodes\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # Never prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            main_tree, other_tree = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                # Prune by ignoring expansion that cannot improve best path\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            # Attempt to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connect_cost < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                # Aggressively prune both trees by c_best\n                prune(tree_a)\n                prune(tree_b)\n\n                # Early exit if solution is good enough (optional)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 31258.82349,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 5.141939425468445,
                    "num_nodes_avg": 2306.4,
                    "path_length_avg": 154.2503621041932,
                    "success_improvement": 0.0,
                    "time_improvement": -53170.965933229934,
                    "length_improvement": 22.90715159718602,
                    "objective_score": -15946.708349649543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.733148503303528,
                    "num_nodes_avg": 2789.4,
                    "path_length_avg": 259.2117263996173,
                    "success_improvement": 0.0,
                    "time_improvement": -32730.42694533241,
                    "length_improvement": 13.984779657612615,
                    "objective_score": -9816.3311276682
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 5.410043072700501,
                    "num_nodes_avg": 2536.3,
                    "path_length_avg": 120.71782418764846,
                    "success_improvement": 0.0,
                    "time_improvement": -18336.528047592466,
                    "length_improvement": 25.87198378470435,
                    "objective_score": -5495.784017520798
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional RRT* with informed sampling and adaptive step sizing to efficiently find high-quality, collision-free paths in 2D or 3D environments. It balances exploration and exploitation by sampling inside an informed ellipsoidal region based on the current best path cost and prunes nodes that cannot improve the solution. The planner rewires nearby nodes to optimize cost dynamically and alternates expansions between the start and goal trees to connect paths quickly.",
          "planning_mechanism": "The planner grows two trees from start and goal, samples points preferentially within an ellipsoidal informed subset reflecting the current best path, and expands trees adaptively while checking collisions. It rewires neighbors to minimize cost and prunes nodes unlikely to yield improvements. The path is updated whenever trees connect with lower cost, ensuring robust convergence toward an optimal path within map bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start == goal:\n            root = Node(start)\n            return PlannerResult(True, [start], [root], [])\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def sample_informed():\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(s, obstacles, is_3d):\n                        return s\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best ** 2 - c_min ** 2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            check_steps = max(2, int(dist))\n            for i in range(1, check_steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / check_steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def rewire(tree, new_node, radius=15.0):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_occurred = True\n            while prune_occurred:\n                prune_occurred = False\n                to_remove = []\n                for node in tree[1:]:  # Do not prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_occurred = True\n\n        for i in range(self.max_iter):\n            curr_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = sample_informed()\n            nearest_node = nearest(curr_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            est_tot_cost = new_cost + math.dist(new_pos, goal)\n            if est_tot_cost >= c_best:\n                continue  # Discard expansions that cannot improve path\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(curr_tree, new_node)\n            prune(curr_tree)\n\n            other_near = nearest(other_tree, new_pos)\n            if self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d):\n                continue\n\n            total_cost = new_node.cost + other_near.cost + math.dist(new_node.position, other_near.position)\n            if total_cost < c_best:\n                c_best = total_cost\n                path_a = new_node.path_from_root()\n                path_b = other_near.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n                prune(tree_start)\n                prune(tree_goal)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 31366.25511,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 5.059916830062866,
                    "num_nodes_avg": 2317.2,
                    "path_length_avg": 156.00261761957682,
                    "success_improvement": 0.0,
                    "time_improvement": -52321.20429193878,
                    "length_improvement": 22.03139113239555,
                    "objective_score": -15691.955009355155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.770031833648682,
                    "num_nodes_avg": 2754.0,
                    "path_length_avg": 254.64024606805137,
                    "success_improvement": 0.0,
                    "time_improvement": -32986.25992449036,
                    "length_improvement": 15.501751491689003,
                    "objective_score": -9892.77762704877
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 5.689538669586182,
                    "num_nodes_avg": 2664.5,
                    "path_length_avg": 120.68598190294082,
                    "success_improvement": 0.0,
                    "time_improvement": -19289.002610533295,
                    "length_improvement": 25.891536865726344,
                    "objective_score": -5781.522475786844
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid planner combining bidirectional RRT*-Connect's informed sampling and adaptive step sizing with RRT*'s optimal rewiring and goal biasing. It uses two trees grown from start and goal, includes heuristic-based sampling within an ellipsoidal informed subset, dynamically adjusts expansion steps near obstacles, prunes non-promising branches, and rewires nodes efficiently to improve solution quality. The planner attempts early connections between trees to quickly find high-quality paths and refines them incrementally for robustness and enhanced performance.",
          "planning_mechanism": "The planner alternates growth between two trees (start and goal), samples candidates with informed heuristics biased towards shortest path ellipsoid, adapts step sizes based on obstacle proximity, rejects costly expansions, and rewires locally to improve path costs. It integrates goal biasing and tries to connect the two trees at every iteration. Upon successful connection, it reconstructs the combined path and returns the best path found within the iteration limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random, numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a == tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a to the sample\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                # Prune paths that cannot improve existing best path\n                continue\n\n            new_node = Node(new_position)\n            # Ensure child's position is not in obstacle before connecting\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                continue\n\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find near nodes in tree_a for rewiring\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire if cheaper path found\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Verify connection path collision free\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Optional pruning near best path could be inserted here (not mandatory)\n\n        # Post-processing: Optional path smoothing for improved path quality\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        # If no solution, sample uniformly in bounds\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Calculate rotation matrix C that aligns x-axis with vector a1\n        # Using SVD-based method to get a proper rotation\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        r2_sq = c_best**2 - c_min**2\n        r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # reduce step near obstacle but keep minimum step size of 1\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n\n        path_smoothed = [path[0]]\n        idx = 0\n        while idx < len(path_smoothed):\n            # Attempt to skip intermediate nodes if straight connection is collision free\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(path_smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == len(path) - 1:\n                path_smoothed += path[idx+1:]\n                break\n            if next_idx == idx:\n                # No farther progress, just add next node\n                path_smoothed.append(path[idx+1])\n                idx += 1\n            else:\n                path_smoothed.append(path[next_idx])\n                idx = next_idx\n        return path_smoothed\n\n    # Dummy implementations for obstacle checks - actual implementations should exist elsewhere\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Check if pos lies inside any obstacle; placeholder\n        for obs in obstacles:\n            if self._point_in_rect(pos, obs):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if the line segment p1-p2 intersects any obstacle; placeholder\n        for obs in obstacles:\n            if self._line_intersects_rect(p1, p2, obs):\n                return True\n        return False\n\n    def _point_in_rect(self, point, rect):\n        # rect assumed as (xmin, ymin, xmax, ymax) or (xmin, ymin, zmin, xmax, ymax, zmax)\n        dims = len(point)\n        if dims == 2:\n            xmin, ymin, xmax, ymax = rect\n            x, y = point\n            return xmin <= x <= xmax and ymin <= y <= ymax\n        else:  # 3D\n            xmin, ymin, zmin, xmax, ymax, zmax = rect\n            x, y, z = point\n            return xmin <= x <= xmax and ymin <= y <= ymax and zmin <= z <= zmax\n\n    def _line_intersects_rect(self, p1, p2, rect):\n        # Simple sampling-based collision checking for the edge\n        import numpy as np\n        num_samples = 10\n        for i in range(num_samples + 1):\n            t = i / num_samples\n            point = tuple(p1[d] + t * (p2[d] - p1[d]) for d in range(len(p1)))\n            if self._point_in_rect(point, rect):\n                return True\n        return False",
          "objective": 31465.51903,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 8.487454676628113,
                    "num_nodes_avg": 4.9,
                    "path_length_avg": 138.84358021507737,
                    "success_improvement": 0.0,
                    "time_improvement": -87830.81200043473,
                    "length_improvement": 30.60731310313128,
                    "objective_score": -26343.122137509792
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.8722915172576904,
                    "num_nodes_avg": 7.1,
                    "path_length_avg": 93.033084549548,
                    "success_improvement": 0.0,
                    "time_improvement": -12886.73173571295,
                    "length_improvement": 69.12847509713148,
                    "objective_score": -3852.1938256944586
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.2877106666564941,
                    "num_nodes_avg": 13.0,
                    "path_length_avg": 30.223865024651694,
                    "success_improvement": 0.0,
                    "time_improvement": -4288.304030848655,
                    "length_improvement": 81.44072615860215,
                    "objective_score": -1270.203064022876
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "Informed RRT* is an optimal path planning algorithm that enhances RRT* by focusing exploration within an ellipsoidal subset of the search space after finding an initial solution. This ellipsoid is defined by the start and goal states as focal points and the current best path cost as its transverse diameter, significantly improving convergence speed and path quality.",
          "planning_mechanism": "The planner starts like RRT*, building a tree through uniform sampling. After discovering a valid path, it switches to informed sampling within a prolate hyperspheroid defined by the current best cost. Samples are drawn by transforming points from the unit n-ball to the ellipsoid, ensuring all new samples can potentially improve the path. Tree rewiring is done locally to maintain asymptotic optimality.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        solution_nodes = []\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        edges.remove((n.parent, n))\n                        n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                solution_nodes.append(goal_node)\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 53766.4640260838,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 9.0110613822937,
                    "num_nodes_avg": 3092.9,
                    "path_length_avg": 144.17782833834022,
                    "success_improvement": 0.0,
                    "time_improvement": -93255.42568642368,
                    "length_improvement": 27.94130716123327,
                    "objective_score": -27971.039444494858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 8.04806592464447,
                    "num_nodes_avg": 4230.3,
                    "path_length_avg": 216.04260686110948,
                    "success_improvement": 0.0,
                    "time_improvement": -55723.610902097105,
                    "length_improvement": 28.30975399680244,
                    "objective_score": -16711.42131982977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 8.921127724647523,
                    "num_nodes_avg": 4590.3,
                    "path_length_avg": 109.81726433629747,
                    "success_improvement": 0.0,
                    "time_improvement": -30301.721261993385,
                    "length_improvement": 32.56558419420729,
                    "objective_score": -9084.003261759173
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "The algorithm is an improved Bidirectional Informed RRT* (Inverse RRT*) planner that combines the efficiency of bidirectional search with heuristic-guided sampling to focus exploration within an informed ellipsoidal subset of the configuration space. It incrementally rewires the tree to improve path quality and shortens the path length by considering optimal parent choices for each new node. Obstacles are rigorously checked to ensure collision-free nodes and edges. This enhances planning efficiency, success rate, and path smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees rooted at the start and goal positions, biased by heuristic sampling within an ellipsoidal informed subset defined by the current best solution cost. Each extension step involves connecting the trees by extending one tree toward a sampled informed point, then extending the other tree toward the new node. The planner rewires locally for path optimality and terminates early upon a successful connection, extracting the smoothest available path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius  # radius for rewiring neighborhood\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def path_cost(node):\n            c = 0.0\n            while node.parent is not None:\n                c += distance(node.position, node.parent.position)\n                node = node.parent\n            return c\n\n        def backtrace_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def informed_sample(c_best):\n            \"\"\"Upper bound c_best defines an ellipsoidal region to bias sampling.\"\"\"\n            if not math.isfinite(c_best):\n                # No solution yet, sample uniformly\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Compute unit vector in direction start->goal\n            c_min = distance(start_position, goal_position)\n            if c_min == 0:\n                return start_position  # trivial\n\n            center = tuple((start_position[i] + goal_position[i]) / 2.0 for i in range(dim))\n\n            # Alignment unit vector (a1)\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(dim))\n\n            # Create orthonormal basis using Gram-Schmidt\n            # Only needed for dim=2 or 3, simple case:\n\n            import numpy as np\n\n            if dim == 2:\n                # In 2D, a1_perp is perpendicular to a1:\n                a1_perp = (-a1[1], a1[0])\n                basis = np.array([a1, a1_perp])\n            elif dim == 3:\n                a1_np = np.array(a1)\n                # Arbitrary vector not parallel to a1_np\n                if abs(a1_np[0]) < 0.9:\n                    v = np.array([1, 0, 0])\n                else:\n                    v = np.array([0, 1, 0])\n                a2 = v - (np.dot(v, a1_np)) * a1_np\n                a2 /= np.linalg.norm(a2)\n                a3 = np.cross(a1_np, a2)\n                basis = np.vstack((a1_np, a2, a3))\n            else:\n                # fallback: uniform sample\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Radii of the ellipsoid along each axis:\n            r1 = c_best / 2.0\n            r_other = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            # Sample random point in unit ball\n            while True:\n                # Sample point in unit ball for given dim\n                if dim == 2:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        rnd_ball = np.array([x, y])\n                        break\n                else:\n                    x, y, z = random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y + z*z <= 1:\n                        rnd_ball = np.array([x, y, z])\n                        break\n\n            # Stretch point along ellipsoid axes:\n            rnd_diagonal = np.diag(radii)\n            scaled = rnd_diagonal @ rnd_ball\n\n            # Transform back to world frame:\n            sample_np = basis.T @ scaled + np.array(center)\n\n            sample = tuple(float(sample_np[i]) for i in range(dim))\n\n            # Clamp sample inside bounds:\n            clamped = tuple(\n                max(0.0, min(sample[i], bounds[i])) for i in range(dim)\n            )\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def collision_free(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if not all(0 <= pos[i] <= bounds[i] for i in range(dim)):\n                return False\n            return True\n\n        def collision_free_edge(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_extend(tree_a, tree_b, sample, best_cost_local):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not collision_free(new_pos):\n                return None\n\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            # Choose parent with minimal cost in neighbor radius (rewiring prep)\n            neighbors = near(tree_a, new_pos, self.neighbor_radius)\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                if collision_free_edge(nb.position, new_pos):\n                    cost_through_nb = nb.cost + distance(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring neighbors to new_node if beneficial\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, nb.position)\n                if cost_through_new < nb.cost and collision_free_edge(new_node.position, nb.position):\n                    # Rewire\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    nb.parent = new_node\n                    nb.cost = cost_through_new\n                    new_node.add_child(nb)\n                    # edges update\n                    # Remove old edge and add new edge\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except Exception:\n                        pass\n                    edges.append((new_node, nb))\n\n            # Try to connect tree_b to new_node directly\n            connect_node = nearest(tree_b, new_node.position)\n            if distance(connect_node.position, new_node.position) <= self.step_size:\n                if collision_free_edge(connect_node.position, new_node.position):\n                    # Connect by making connect_node the parent of new_node or vice versa\n                    # Choose direction to minimize cost path\n                    connect_cost = connect_node.cost + distance(connect_node.position, new_node.position)\n                    new_cost = new_node.cost + distance(new_node.position, connect_node.position)\n\n                    if connect_cost < new_cost:\n                        # connect_node -> new_node\n                        new_node.parent.remove_child(new_node)\n                        new_node.parent = connect_node\n                        new_node.cost = connect_cost\n                        connect_node.add_child(new_node)\n                    else:\n                        # new_node -> connect_node\n                        if connect_node.parent:\n                            connect_node.parent.remove_child(connect_node)\n                        connect_node.parent = new_node\n                        connect_node.cost = new_cost\n                        new_node.add_child(connect_node)\n\n                    # Update nodes and edges accordingly\n                    # Remove old edges involving connect_node parent if rewired above\n                    edges.append((new_node, connect_node) if connect_cost > new_cost else (connect_node, new_node))\n                    return new_node, connect_node\n\n            else:\n                # Attempt incremental connection from connect_node to new_node\n                current = connect_node\n                last = None\n                while distance(current.position, new_node.position) > self.step_size:\n                    new_p = steer(current.position, new_node.position, self.step_size)\n                    if not collision_free(new_p) or not collision_free_edge(current.position, new_p):\n                        break\n                    intermediate = Node(new_p, parent=current, cost=current.cost + distance(current.position, new_p))\n                    current.add_child(intermediate)\n                    tree_b.append(intermediate)\n                    nodes.append(intermediate)\n                    edges.append((current, intermediate))\n\n                    last = current\n                    current = intermediate\n                else:\n                    # Final connect\n                    if collision_free_edge(current.position, new_node.position):\n                        if current.parent:\n                            current.parent.remove_child(current)\n                        current.parent = new_node\n                        current.cost = new_node.cost + distance(new_node.position, current.position)\n                        new_node.add_child(current)\n                        edges.append((new_node, current))\n                        return new_node, current\n\n            return None\n\n        c_best = float(\"inf\")\n\n        for itr in range(self.max_iter):\n            s = informed_sample(c_best)\n\n            # Extend start_tree towards sample\n            result = try_extend(start_tree, goal_tree, s, c_best)\n            if result:\n                n_start, n_goal = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Extend goal_tree towards sample\n            result = try_extend(goal_tree, start_tree, s, c_best)\n            if result:\n                n_goal, n_start = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Early termination if path found with cost close to direct distance:\n            if success_state and c_best <= distance(start_position, goal_position) * 1.01:\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 71244.98359,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08393318653106689,
                    "num_nodes_avg": 139.9,
                    "path_length_avg": 113.65247525554082,
                    "success_improvement": 0.0,
                    "time_improvement": -769.5555412842224,
                    "length_improvement": 43.19758523768294,
                    "objective_score": -222.2271453377301
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 26.41049716472626,
                    "num_nodes_avg": 3265.9,
                    "path_length_avg": 89.09022823701214,
                    "success_improvement": 0.0,
                    "time_improvement": -183090.5120135739,
                    "length_improvement": 70.43684821439662,
                    "objective_score": -54913.06623442929
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 15.803206944465638,
                    "num_nodes_avg": 1863.2,
                    "path_length_avg": 26.6995063258948,
                    "success_improvement": 0.0,
                    "time_improvement": -53754.70395674949,
                    "length_improvement": 83.60489471057893,
                    "objective_score": -16109.69020808273
               }
          ]
     }
]