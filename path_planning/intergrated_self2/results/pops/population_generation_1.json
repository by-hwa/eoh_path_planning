[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm implements an improved RRT* inspired planning method with goal biasing and dynamic shortcutting.\n    It balances exploration and exploitation by sampling points with a goal bias probability and uses a rewiring procedure\n    to optimize the path incrementally for lower cost and smoother connection. Adaptive step size scaling is used based\n    on distance to goal to speed up exploration in open spaces and fine movements near the goal.\n    The algorithm includes early stopping when a high-quality path is found or after a time budget (10 seconds).\n    Once a path is found, a shortcut smoothing step is applied to reduce unnecessary bends in the path.\n    This algorithm aims to improve efficiency, path quality and robustness over baseline RRT and RRT-Connect implementations.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0   # maximum step size for extension\n        self._goal_sample_rate = 0.2 # probability of sampling the goal to bias growth\n        self._iterations_limit = 10000  # max iterations\n        self._rewire_radius = 20.0    # radius to attempt rewiring for optimization\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling with probability goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, vertices: List[Vertex]) -> Vertex:\n        # Choose parent among nearby vertices that minimizes cost to q_new (RRT* rewiring parent selection)\n        cost_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n\n        for v in vertices:\n            if v == q_near:\n                continue\n            cost_to_new = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost_to_new < cost_min:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    cost_min = cost_to_new\n                    best_parent = v\n\n        q_new.cost = cost_min\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if cost improves (RRT* rewiring)\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    # Remove old edge(s) to v from parents and add q_new as parent\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _extract_path(self, end_vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [end_vertex]\n        current = end_vertex\n        while len(current.parents) != 0:\n            # Choose parent with minimum cost leading to current\n            min_parent = None\n            min_cost = float(\"inf\")\n            for p in current.parents:\n                cost = p.cost + self._get_grid().get_movement_cost(p.position, current.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            current = min_parent\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: repeatedly try to directly connect non-adjacent points\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next point\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialize start vertex cost and root vertices\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_goal_vertex: Vertex = None\n        best_goal_cost = float(\"inf\")\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached: treat as no path found\n                break\n\n            q_sample = self._get_random_sample()\n            root_verts = self._graph.root_vertices\n\n            # Nearest vertex to sample\n            q_near = self._get_nearest_vertex(root_verts, q_sample)\n            # Adaptive max step size based on distance to goal (closer -> smaller)\n            dist_to_goal = self._get_distance(q_near.position, goal_vertex.position)\n            max_dist = min(self._max_dist_base, dist_to_goal * 1.2)\n\n            # New vertex toward sample relative to max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check validity of edge q_near->q_new\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            # Find nearby vertices for possible better parent and rewiring (RRT* neighborhood)\n            neighbors = self._get_vertices_within_radius(root_verts, q_new.position, self._rewire_radius)\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n\n            # Add new vertex and edge with best_parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better cost paths through q_new\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to root vertices for sampling & rewiring\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new is close enough to goal to connect\n            if self._get_distance(q_new.position, goal_vertex.position) <= max_dist:\n                # Attempt connect q_new to goal vertex if valid line\n                goal_line = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line):\n                    # Connect goal vertex\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.root_vertices.append(goal_vertex)\n                    path_found = True\n                    best_goal_vertex = goal_vertex\n                    best_goal_cost = goal_vertex.cost\n                    break\n\n            self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            # Extract and shortcut path\n            raw_path = self._extract_path(best_goal_vertex)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            # Animate movement along smoothed path\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
          "objective": 3822.335,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.67,
               "average_steps": 11.08,
               "average_distance": 11.8,
               "average_smoothness": 0.34,
               "average_clearance": 2.14,
               "average_time": 0.1855,
               "average_distance_from_goal": 0.25,
               "average_original_distance_from_goal": 8.42,
               "average memory": 50.26,
               "goal_found_perc_improvement": -0.68,
               "average_steps_improvement": -21.49,
               "average_distance_improvement": -22.53,
               "average_smoothness_improvement": -30.77,
               "average_clearance_improvement": 6.47,
               "average_time_improvement": -2441.1,
               "average_distance_from_goal_improvement": -25.0,
               "average_path_deviation": 2.17,
               "average_memory_improvement": -35.03
          }
     },
     {
          "algorithm": "Improved Path Planning Algorithm inspired by RRT* with Goal-Biased Adaptive Sampling, \n    Heuristic-Guided Vertex Expansion, and Dynamic Step Sizing. \n\n    Key features:\n    - Goal-biased sampling (sampling towards the goal with increasing probability as the tree grows)\n    - Adaptive step size that decreases based on distance to goal, promoting finer movements near goal\n    - Heuristic cost function combining path cost + Euclidean distance to goal (A*-style)\n    - Rewiring vertices for path optimality (like RRT*)\n    - Early stopping if goal is connected or 10 seconds runtime exceeded\n    - Shortcut smoothing on extracted path to enhance path quality\n    - Uses a Forest graph with vertices and edges, consistent with prior algorithms\n    \n    This approach balances exploration and exploitation, reduces planning time, improves success rate\n    and produces smoother, shorter paths than basic RRT* or SPRM variants.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _max_runtime_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n    def _get_random_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Goal biased sampling:\n        - Probability to sample directly the goal increases linearly with iteration progress\n        \"\"\"\n        prob_goal_sample = min(0.2 + 0.8 * (iteration / max_iterations), 0.95)\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_cost\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        # Shortcut path smoothing by attempting to connect non-adjacent points directly if collision free\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i+1])\n                    i += 1\n            return smoothed_path\n\n        path = try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):  # For ROS map integration\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n            # Check elapsed time for early stopping\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Failed to find path in time\n                return\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size decreases near goal to allow finer connection attempts\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision-free path from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute radius for neighbor search for rewiring\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            # Choose best parent based on cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in neighbors:\n                # Cost from neighbor to new vertex\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better via q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    # Add edge from new parent q_new\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal proximity and link if possible\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
          "objective": 5558.53,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.67,
               "average_steps": 10.05,
               "average_distance": 10.63,
               "average_smoothness": 0.33,
               "average_clearance": 2.07,
               "average_time": 0.2748,
               "average_distance_from_goal": 0.28,
               "average_original_distance_from_goal": 8.42,
               "average memory": 46.0,
               "goal_found_perc_improvement": -0.68,
               "average_steps_improvement": -10.08,
               "average_distance_improvement": -10.27,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 2.99,
               "average_time_improvement": -3613.51,
               "average_distance_from_goal_improvement": -40.0,
               "average_path_deviation": 0.9900000000000002,
               "average_memory_improvement": -23.59
          }
     }
]