{
     "algorithm": "This algorithm implements an informed heuristic-guided bi-directional RRT* variant.\n    It simultaneously grows two trees: one from the start and one from the goal with goal biasing,\n    alternating expansions to quickly connect the trees. It samples not only uniformly,\n    but also inside an ellipsoidal informed set based on the current best path cost to focus exploration\n    on the promising region improving efficiency and path quality. Adaptive max step size varies \n    with distance to goal and expansion direction. Rewiring optimizes paths within radius progressively.\n    Early stopping triggers on a path below an adaptive cost threshold or timeout after 10 seconds.\n    Once a path is found, it is shortcut-smoothed for fewer turns and shorter distance.\n    This improves planning speed, enhances success rate and delivers high-quality, smooth paths robustly.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0\n        self._goal_sample_rate = 0.15      # Slightly lower goal bias to diversify sampling\n        self._iterations_limit = 8000      # Limit iterations for efficiency\n        self._rewire_radius = 25.0         # Larger radius for more aggressive rewiring\n        self._timeout_sec = 10.0           # Maximum allowed planning time\n        self._best_cost = float(\"inf\")\n        # Track the best connecting vertex on either tree\n        self._best_connect_vertex_start: Optional[Vertex] = None\n        self._best_connect_vertex_goal: Optional[Vertex] = None\n\n    def _sample_informed_ellipsoid(self, c_best: float, start: Point, goal: Point) -> Point:\n        from numpy.random import randn\n\n        c_min = Map.get_distance(start, goal)\n        if c_best == float(\"inf\"):\n            # No solution found yet, uniform sampling with goal biasing handles exploration\n            return self._get_random_sample()\n\n        # Ellipsoidal sampling focused around start-goal line (in 2D or ND)\n        center = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2.0)\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min  # Unit vector from start to goal\n\n        # Rotation matrix aligning x-axis to a1 vector\n        dim = start.n_dims()\n        id1 = torch.eye(dim)\n        M = torch.zeros((dim, dim))\n        M[:, 0] = a1\n        # Use Gram-Schmidt to fill other axes orthogonal to a1\n        count = 1\n        for i in range(dim):\n            vec = id1[:, i]\n            proj = torch.dot(vec, a1) * a1\n            ortho = vec - proj\n            norm = torch.norm(ortho)\n            if norm > 1e-10 and count < dim:\n                M[:, count] = ortho / norm\n                count += 1\n            if count >= dim:\n                break\n\n        # Ellipsoid radii: c_best/2, sqrt(c_best^2 - c_min^2)/2 for other axes\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 > 0:\n            r_rest = math.sqrt(c_best**2 - c_min**2) / 2.0\n        else:\n            r_rest = 0.0\n        radii = [r1] + [r_rest] * (dim - 1)\n\n        # Sample random point in unit ball\n        while True:\n            rand_dir = torch.randn(dim)\n            norm_dir = torch.norm(rand_dir)\n            if norm_dir <= 1.0 and norm_dir > 1e-10:\n                break\n        unit_ball_point = rand_dir / norm_dir\n\n        # Scale point by radii for ellipsoid\n        sample_ellipsoid = torch.tensor([unit_ball_point[i] * radii[i] for i in range(dim)])\n\n        # Rotate and translate to ellipsoid center\n        point_tensor = center.to_tensor() + torch.matmul(M, sample_ellipsoid)\n\n        candidate = Point.from_tensor(point_tensor)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback: uniform random if invalid\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling with probability _goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        # Uniform random sampling in valid grid positions\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, vertices: List[Vertex]) -> Vertex:\n        cost_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n\n        for v in vertices:\n            if v == q_near:\n                continue\n            cost_to_new = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost_to_new < cost_min:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    cost_min = cost_to_new\n                    best_parent = v\n\n        q_new.cost = cost_min\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _extract_path(self, end_vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [end_vertex]\n        current = end_vertex\n        while len(current.parents) != 0:\n            min_parent = None\n            min_cost = float(\"inf\")\n            for p in current.parents:\n                cost = p.cost + self._get_grid().get_movement_cost(p.position, current.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            current = min_parent\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> bool:\n        # Attempt to connect two given vertices with a valid edge\n        line = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n        if self._get_grid().is_valid_line_sequence(line):\n            cost_start_to_goal = v_start.cost + self._get_grid().get_movement_cost(v_start.position, v_goal.position)\n            # Connect goal side tree from v_start to v_goal\n            # Remove old parents of v_goal and add new parent v_start for improved path\n            for p in list(v_goal.parents):\n                self._graph.remove_edge(p, v_goal)\n            self._graph.add_edge(v_start, v_goal)\n            v_goal.cost = cost_start_to_goal\n            return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex, goal_vertex]\n\n        # Separate vertex sets for bi-directional search\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        path_found = False\n\n        for iteration in range(self._iterations_limit):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                break\n\n            # Alternate between trees for growth: even iter expand start tree, odd expand goal tree\n            if iteration % 2 == 0:\n                expanding_tree = tree_start\n                other_tree = tree_goal\n                expanding_root_vertex = start_vertex\n                other_root_vertex = goal_vertex\n            else:\n                expanding_tree = tree_goal\n                other_tree = tree_start\n                expanding_root_vertex = goal_vertex\n                other_root_vertex = start_vertex\n\n            # Use informed ellipsoidal sampling if path found, else uniform/goal bias\n            if self._best_cost == float(\"inf\"):\n                q_sample = self._get_random_sample()\n            else:\n                q_sample = self._sample_informed_ellipsoid(self._best_cost, expanding_root_vertex.position, other_root_vertex.position)\n\n            q_near = self._get_nearest_vertex(expanding_tree, q_sample)\n            dist_to_other_root = self._get_distance(q_near.position, other_root_vertex.position)\n            max_dist = min(self._max_dist_base, dist_to_other_root * 1.1)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                self.key_frame()\n                continue\n\n            neighbors = self._get_vertices_within_radius(expanding_tree, q_new.position, self._rewire_radius)\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n            expanding_tree.append(q_new)\n            self._rewire(q_new, neighbors)\n\n            # Try to connect to other tree: find nearest vertex in other tree\n            q_near_other = self._get_nearest_vertex(other_tree, q_new.position)\n            dist_connect = self._get_distance(q_new.position, q_near_other.position)\n\n            if dist_connect <= max_dist:\n                # Attempt connection between trees\n                if self._connect_trees(q_new, q_near_other):\n                    # Update best cost if improved\n                    total_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near_other.position) + q_near_other.cost\n                    if total_cost < self._best_cost:\n                        self._best_cost = total_cost\n                        # Save the connecting vertices for path extraction\n                        if iteration % 2 == 0:\n                            self._best_connect_vertex_start = q_new\n                            self._best_connect_vertex_goal = q_near_other\n                        else:\n                            self._best_connect_vertex_start = q_near_other\n                            self._best_connect_vertex_goal = q_new\n                        path_found = True\n                        # Early stopping: if cost is sufficiently small (< optimal + epsilon)\n                        if self._best_cost <= self._get_distance(start_vertex.position, goal_vertex.position) * 1.1:\n                            break\n\n            self.key_frame()\n\n        if path_found and self._best_connect_vertex_start is not None and self._best_connect_vertex_goal is not None:\n            # Extract path from start tree root to connect vertex\n            path_start = self._extract_path(self._best_connect_vertex_start)\n            # Extract path from goal tree root to connect vertex (reverse to goal)\n            path_goal_rev = self._extract_path(self._best_connect_vertex_goal)\n            path_goal = list(reversed(path_goal_rev))\n\n            # Concatenate paths at connection (remove duplicate connecting vertex in goal path)\n            full_path = path_start + path_goal[1:]\n\n            # Shortcut path for smoothness\n            smoothed_path = self._shortcut_path(full_path)\n\n            # Animate movement along smoothed path\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Bidirectional Informed Sampling with Dynamic Radius and Progressive Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Hybrid Bidirectional Informed Sampling with Dynamic Radius and Progressive Rewiring}\n\n    This algorithm implements a bidirectional path planner based on sampling trees rooted at both start and goal.\n    It combines informed sampling within ellipsoidal regions defined by current best path cost to focus sampling,\n    dynamically adjusts the radius for neighbor search to enable coarse exploration initially and finer rewiring \n    near good solutions, and progressively rewires both trees for optimal connections.\n\n    Key features:\n    - Bidirectional tree growth from start and goal to shorten search time and improve success rate.\n    - Informed sampling restricted to an ellipsoidal region defined by the current best path cost.\n    - Dynamic neighbor radius decreasing with progression to enable both global exploration and local optimization.\n    - Heuristic cost combining path cost and Euclidean estimate to goal.\n    - Progressive rewiring applied to both trees embracing path optimality like in RRT*.\n    - Early stopping if start and goal trees connect or 10 seconds timeout.\n    - Shortcut smoothing on the extracted path to improve path quality.\n    - Uses Forest to maintain two root trees and merges them on connection.\n\n    This approach aims to reduce iteration counts, improve path quality/success rate and robustness compared to\n    unidirectional or naive sampling algorithms.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 20.0   # base max step size\n        self._max_dist_min = 2.0        # min step size for refinement\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._best_cost = float(\"inf\")\n        self._best_connection = None\n        self._init_displays()\n\n    def _ellipsoidal_sample(self, cmax: float, cmin: float, x_start: np.ndarray, x_goal: np.ndarray) -> Point:\n        \"\"\"\n        Samples points uniformly inside an n-dimensional prolate hyperspheroid (ellipsoid)\n        defined by the start and goal points and current best cost cmax.\n\n        If no solution yet (cmax = inf), sample uniformly in entire space.\n        \"\"\"\n        if cmax == float(\"inf\"):\n            # No solution yet, uniform random valid sampling\n            while True:\n                coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n                p = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n        # Ellipsoid parameters\n        centre = (x_start + x_goal) / 2.0\n        a1 = (x_goal - x_start) / np.linalg.norm(x_goal - x_start)\n        # Rotation matrix\n        I = np.eye(self._dimension)\n        if self._dimension == 2:\n            e1 = a1\n            e2 = np.array([-a1[1], a1[0]])\n            C = np.column_stack((e1, e2))\n            C = np.linalg.qr(C)[0]  # orthonormal basis\n        else:\n            # For ndim > 2: build orthonormal basis by Gram-Schmidt or qr\n            U = np.reshape(a1, (-1,1))\n            Q, _ = np.linalg.qr(np.concatenate((U, I[:,1:].reshape(self._dimension, -1)), axis=1))\n            C = Q[:, :self._dimension]\n\n        r1 = cmax / 2.0\n        r2 = math.sqrt(cmax**2 - cmin**2) / 2.0\n\n        # Sample inside unit n-ball\n        while True:\n            # Random vector inside n-ball\n            xball = np.random.normal(0,1,self._dimension)\n            xball /= np.linalg.norm(xball)\n            u = random.random() ** (1.0/self._dimension)\n            xball *= u\n            # Scale and rotate\n            L = np.diag([r1] + [r2]*(self._dimension-1))\n            sample = C @ (L @ xball) + centre\n            # Round and clip coordinates\n            coords = [min(max(0, int(round(c))), self._get_grid().size[i]-1) for i, c in enumerate(sample)]\n\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_new_vertex(self, q_near: Vertex, sample_point: Point, max_dist: float) -> Vertex:\n        direction = sample_point.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(sample_point)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Vertex, float]:\n        \"\"\"\n        Choose parent with minimal cost to q_new through a valid path.\n        Return (best_parent, min_cost).\n        \"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for v in neighbors:\n            dist = self._get_distance(v.position, q_new.position)\n            cost = v.cost + dist\n            if cost < min_cost:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    min_cost = cost\n                    best_parent = v\n        return best_parent, min_cost\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Rewire neighbors to optimize cost if connecting through q_new is cheaper,\n        and edge is valid.\n        \"\"\"\n        for v in neighbors:\n            if v == q_new:\n                continue\n            dist = self._get_distance(q_new.position, v.position)\n            cost_through_new = q_new.cost + dist\n            if cost_through_new < v.cost:\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    # Remove old parents edges\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _extract_path_bidirectional(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> List[Vertex]:\n        \"\"\"\n        Extracts path connecting start tree and goal tree by concatenating\n        paths from root to connection vertices.\n        \"\"\"\n        def extract_path_to_root(vertex: Vertex) -> List[Vertex]:\n            path = [vertex]\n            current = vertex\n            while current.parents:\n                # Choose parent with minimal cost + edge cost to current\n                min_p = None\n                min_cost = float(\"inf\")\n                for p in current.parents:\n                    c = p.cost + self._get_distance(p.position, current.position)\n                    if c < min_cost:\n                        min_cost = c\n                        min_p = p\n                if min_p is None:\n                    break\n                current = min_p\n                path.append(current)\n            path.reverse()\n            return path\n\n        path_start = extract_path_to_root(connection_vertex_start)\n        path_goal = extract_path_to_root(connection_vertex_goal)\n\n        # Reverse goal path and exclude the repeated connection vertex\n        path_goal.reverse()\n        if path_goal and path_start and path_goal[0].position == path_start[-1].position:\n            path_goal = path_goal[1:]\n        full_path = path_start + path_goal\n        return full_path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Standard shortcut smoothing used in previous algorithms, adapted for convenience\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 6000\n        x_start = np.array(self._start_vertex.position.to_tuple())\n        x_goal = np.array(self._goal_vertex.position.to_tuple())\n\n        # Initialize root vertices and costs\n        self._start_vertex.cost = 0.0\n        self._goal_vertex.cost = 0.0\n        self._graph.root_vertices = [self._start_vertex, self._goal_vertex]\n\n        tree_start_vertices = [self._start_vertex]\n        tree_goal_vertices = [self._goal_vertex]\n\n        # For easier reference\n        start_tree = tree_start_vertices\n        goal_tree = tree_goal_vertices\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout: fail gracefully\n                return\n\n            # Informed sampling radius: current best path cost or \"infinite\"\n            cmax = self._best_cost\n            cmin = self._get_distance(self._start_vertex.position, self._goal_vertex.position)\n\n            # Alternate sampling between start and goal trees\n            if iteration % 2 == 0:\n                # Sample towards goal side using ellipsoidal sampling\n                sample_pt = self._ellipsoidal_sample(cmax, cmin, x_start, x_goal)\n                current_tree = start_tree\n                other_tree = goal_tree\n            else:\n                # Sample towards start side using reversed ellipsoidal sampling\n                sample_pt = self._ellipsoidal_sample(cmax, cmin, x_goal, x_start)\n                current_tree = goal_tree\n                other_tree = start_tree\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex(current_tree, sample_pt)\n\n            # Dynamic step size: interpolate between max_dist_initial and max_dist_min based on progress\n            progress = min(1.0, float(iteration) / max_iterations)\n            max_dist = self._max_dist_initial * (1 - 0.9 * progress)\n            if max_dist < self._max_dist_min:\n                max_dist = self._max_dist_min\n\n            # Generate new vertex towards sample\n            q_new = self._get_new_vertex(q_near, sample_pt, max_dist)\n\n            # Collision check between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Find neighbors in current tree within dynamic radius for rewiring\n            radius_base = max_dist * 2.5\n            radius = radius_base * (1 - 0.5 * progress) + 1.0  # shrink radius over iterations\n            neighbors_current = self._graph.get_vertices_within_radius(current_tree, q_new.position, radius)\n\n            # Choose best parent in current tree neighbors\n            best_parent, min_cost = self._choose_best_parent(neighbors_current, q_new)\n            if best_parent is None:\n                best_parent = q_near\n                dist = self._get_distance(q_near.position, q_new.position)\n                min_cost = q_near.cost + dist\n            q_new.cost = min_cost\n\n            # Insert q_new to current tree and graph\n            self._graph.add_edge(best_parent, q_new)\n            current_tree.append(q_new)\n\n            # Rewire neighbors in current tree to q_new if better\n            self._rewire_neighbors(q_new, neighbors_current)\n\n            # Check connection possibility to other tree (nearest vertex and edge)\n            q_near_other = self._graph.get_nearest_vertex(other_tree, q_new.position)\n            dist_connection = self._get_distance(q_new.position, q_near_other.position)\n\n            # Attempt direct connection if within radius with collision-free edge\n            if dist_connection <= max_dist:\n                line_other = self._get_grid().get_line_sequence(q_new.position, q_near_other.position)\n                if self._get_grid().is_valid_line_sequence(line_other):\n                    # Connect both trees by adding edge between q_new and q_near_other\n                    # Determine direction of edge: from start tree to goal tree for consistency\n                    if current_tree is start_tree:\n                        self._graph.add_edge(q_new, q_near_other)\n                    else:\n                        self._graph.add_edge(q_near_other, q_new)\n\n                    # Calculate total path cost\n                    total_cost = q_new.cost + dist_connection + q_near_other.cost\n\n                    # Update best cost and connection vertices if improved\n                    if total_cost < self._best_cost:\n                        self._best_cost = total_cost\n                        if current_tree is start_tree:\n                            self._best_connection = (q_new, q_near_other)\n                        else:\n                            self._best_connection = (q_near_other, q_new)\n\n                    # Early exit if found sufficiently good path (with some tolerance)\n                    if self._best_cost <= cmin * 1.1:\n                        break\n\n            self.key_frame()\n\n        if self._best_connection is not None:\n            # Extract and smooth path from merged trees\n            conn_start, conn_goal = self._best_connection\n            raw_path = self._extract_path_bidirectional(conn_start, conn_goal)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            # Animate agent movement along smoothed path\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Dual-Tree Bidirectional Rapidly-exploring Random Graph (RRG) inspired planner \n    with heuristic-driven vertex expansion and adaptive pruning. \n\n    Key ideas:\n\n    - Maintains two simultaneous expanding graphs (forests), one from start and one from goal.\n    - Samples points with a goal-bias that increases over time but applied differently to start and goal trees.\n    - Uses heuristic-guided expansion to pick vertices closer to the sampled point in each tree (A*-style priority).\n    - Connects vertices from the two trees when feasible to build a decreasing cost path toward the goal.\n    - Adds edges to form a directed graph (RRG-inspired) with limited neighborhood connections, promoting multiple path options.\n    - Incorporates a dynamic pruning step removing dominated vertices to reduce graph size and improve efficiency.\n    - Adaptive step size scales based on distance to goal for precision near the goal and exploration far from it.\n    - Early stopping if connection found or after 10 seconds timeout.\n    - Applies shortcut smoothing after path extraction to improve path quality.\n    \n    This bidirectional RRG with heuristics and pruning balances exploration, exploitation, and graph size management\n    to achieve faster planning, higher success rates, and smoother paths compared to previous unidirectional RRT*-style methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = CyclicGraph(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 20.0\n        self._max_dist_min = 2.0\n        self._lambda_rrg = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        # Separate root sets for bidirectional expansion\n        self._roots_start = [self._start_vertex]\n        self._roots_goal = [self._goal_vertex]\n        self._init_displays()\n\n    def _sample_point(self, iteration: int, max_iterations: int, bias_to_start: bool) -> Point:\n        \"\"\"\n        Goal-biased sampling with different probabilities for start and goal trees.\n        Probability increase linearly with iteration.\n        If biased to start tree, samples goal less often; if biased to goal tree, samples start less often.\n        \"\"\"\n        base_prob = 0.15\n        max_prob = 0.95\n        progress_ratio = iteration / max_iterations\n\n        if bias_to_start:\n            prob_sample_goal = base_prob + (max_prob - base_prob) * progress_ratio\n            if random.random() < prob_sample_goal:\n                return self._goal_vertex.position\n        else:\n            prob_sample_start = base_prob + (max_prob - base_prob) * progress_ratio\n            if random.random() < prob_sample_start:\n                return self._start_vertex.position\n\n        while True:\n            coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _nearest_vertex_heuristic(self, vertices: List[Vertex], sample: Point, target: Point) -> Vertex:\n        \"\"\"\n        Select the vertex v in vertices minimizing cost(v) + dist(v.position, sample) + dist(v.position, target),\n        a heuristic favoring vertices closer to sample and target (goal).\n        \"\"\"\n        best_vertex = None\n        best_score = float('inf')\n        for v in vertices:\n            dist_sample = self._distance(v.position, sample)\n            dist_target = self._distance(v.position, target)\n            score = v.cost + dist_sample + dist_target\n            if score < best_score:\n                best_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n        return Vertex(new_pos)\n\n    def _neighbors_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _connect_vertices(self, parent: Vertex, child: Vertex) -> bool:\n        \"\"\"\n        Attempt to connect parent to child if path is valid.\n        Returns True if connected, False otherwise.\n        \"\"\"\n        line = self._get_grid().get_line_sequence(parent.position, child.position)\n        if self._get_grid().is_valid_line_sequence(line):\n            cost_edge = self._get_grid().get_movement_cost(parent.position, child.position)\n            child_cost_candidate = parent.cost + cost_edge\n            if child_cost_candidate < child.cost:\n                # Remove old parent edges (if any)\n                for p in list(child.parents):\n                    self._graph.remove_edge(p, child)\n                child.cost = child_cost_candidate\n                self._graph.add_edge(parent, child)\n                return True\n        return False\n\n    def _prune_dominated_vertices(self, vertices: List[Vertex]) -> None:\n        \"\"\"\n        Prune vertices dominated by others within a small radius:\n        A vertex v is pruned if there exists u with cost(u) + dist(u,v) < cost(v).\n        Reduces graph complexity and memory usage.\n        \"\"\"\n        prune_radius = 10.0\n        to_remove = set()\n        for v in vertices:\n            neighbors = self._neighbors_within_radius(vertices, v.position, prune_radius)\n            for u in neighbors:\n                if u == v:\n                    continue\n                dist_uv = self._distance(u.position, v.position)\n                if u.cost + dist_uv < v.cost - 1e-5:\n                    to_remove.add(v)\n                    break\n        for v in to_remove:\n            # Remove edges and from graph roots if needed\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._roots_start:\n                self._roots_start.remove(v)\n            if v in self._roots_goal:\n                self._roots_goal.remove(v)\n            # remove from graph's internal vertices tracking if needed\n            # (assuming graph manages vertices automatically when edges removed)\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> List[Vertex]:\n        \"\"\"\n        Extract path from start to goal via connection vertices in both trees.\n        \"\"\"\n        path_start = []\n        current = connect_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            # pick lowest cost parent for path\n            min_parent = min(current.parents, key=lambda p: p.cost + self._distance(p.position, current.position))\n            current = min_parent\n        path_start.reverse()\n\n        path_goal = []\n        current = connect_goal\n        while True:\n            path_goal.append(current)\n            if len(current.children) == 0:\n                break\n            # pick lowest cost child for path (reverse direction)\n            min_child = min(current.children, key=lambda c: c.cost + self._distance(current.position, c.position))\n            current = min_child\n\n        return path_start + path_goal\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 6000\n        iteration = 0\n        connected = False\n        connection_pair = (None, None)  # (start_vertex, goal_vertex connection)\n\n        while iteration < max_iterations and not connected:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout stop\n                break\n\n            # Alternate expansion trees: even iterations expand start tree, odd iterations expand goal tree\n            expand_start = (iteration % 2 == 0)\n\n            if expand_start:\n                sample_point = self._sample_point(iteration, max_iterations, bias_to_start=True)\n                vertices_to_expand = self._roots_start\n                opposite_vertices = self._roots_goal\n                tree_target = self._goal_vertex.position\n            else:\n                sample_point = self._sample_point(iteration, max_iterations, bias_to_start=False)\n                vertices_to_expand = self._roots_goal\n                opposite_vertices = self._roots_start\n                tree_target = self._start_vertex.position\n\n            # Pick vertex to expand using heuristic nearest\n            q_near = self._nearest_vertex_heuristic(vertices_to_expand, sample_point, tree_target)\n            if q_near.position == sample_point:\n                # Already in vertex\n                continue\n\n            dist_to_target = self._distance(q_near.position, tree_target)\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_target / 2))\n\n            q_new = self._new_vertex_towards(q_near, sample_point, max_dist)\n\n            # Check connection from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost via q_near\n            cost_candidate = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_candidate\n\n            # Neighborhood radius adaption for adding edges (RRG style)\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrg * ((log_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            # Add q_new vertex to graph roots and edges\n            vertices_to_expand.append(q_new)\n            self._graph.root_vertices.append(q_new)  # for graph internal tracking\n\n            # Connect q_new to neighbors within radius in this tree with valid edges\n            neighbors = self._neighbors_within_radius(vertices_to_expand, q_new.position, radius)\n            connected_to_some = False\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                line_nq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_nq):\n                    cost_through_neighbor = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                    if cost_through_neighbor < q_new.cost:\n                        # Rewire q_new parent to better neighbor\n                        for p in list(q_new.parents):\n                            self._graph.remove_edge(p, q_new)\n                        q_new.cost = cost_through_neighbor\n                        self._graph.add_edge(neighbor, q_new)\n                        connected_to_some = True\n            if not connected_to_some:\n                # If no better parent found, add edge from q_near to q_new\n                self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors to q_new if better path found (like RRG)\n            for neighbor in neighbors:\n                if neighbor == q_new:\n                    continue\n                line_qn = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_qn):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    # Remove old parent edge(s)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    neighbor.cost = cost_through_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Try connection to opposite tree vertices (attempt to join trees)\n            opos_neighbors = self._neighbors_within_radius(opposite_vertices, q_new.position, radius)\n            for opos_v in opos_neighbors:\n                line_connect = self._get_grid().get_line_sequence(q_new.position, opos_v.position)\n                if self._get_grid().is_valid_line_sequence(line_connect):\n                    # Check total cost of combined path\n                    cost_connect = q_new.cost + self._get_grid().get_movement_cost(q_new.position, opos_v.position) + opos_v.cost\n                    # If path found and better than threshold (early stop)\n                    if cost_connect < float(\"inf\"):\n                        connected = True\n                        connection_pair = (q_new, opos_v)\n                        break\n            if connected:\n                break\n\n            # Prune dominated vertices to keep graph size manageable every 100 iterations\n            if iteration % 100 == 0:\n                self._prune_dominated_vertices(self._roots_start)\n                self._prune_dominated_vertices(self._roots_goal)\n\n            self.key_frame()\n\n        if connected:\n            path_raw = self._extract_bidirectional_path(connection_pair[0], connection_pair[1])\n            path_smooth = self._shortcut_path(path_raw)\n            for vertex in path_smooth:\n                self.move_agent(vertex.position)\n                # Publish waypoint if ROS integration available\n                grid = self._get_grid()\n                if hasattr(grid, \"publish_wp\"):\n                    grid.publish_wp(grid.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal biasing, adaptive step size, rewiring,\n    and path shortcutting for better path quality and planning efficiency. The algorithm uses a\n    goal-biased random sampling to accelerate convergence towards the goal, dynamically adapts the \n    maximum extension distance based on current environment density to balance exploration and precision,\n    and rewires the tree locally to optimize path costs. It performs path shortcutting at the end for \n    smoother, shorter paths. It also enforces a 10-second time limit on planning to ensure timely \n    termination if no path is found.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Enable rewiring (edge removals)\n        self._init_displays()\n        # Parameters\n        self._goal_sample_rate = 0.1  # 10% of samples are goal biased\n        self._max_dist_min = 5.0\n        self._max_dist_max = 20.0\n        self._rewire_radius_factor = 1.5\n        self._planning_start_time = None\n        self._planning_time_limit = 10.0  # seconds\n\n    # Helper for adaptive max_dist based on nearest vertex density\n    def _compute_adaptive_max_dist(self, q_near: Vertex) -> float:\n        radius = self._rewire_radius_factor * 10.0\n        near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_near.position, radius)\n        n = len(near_vertices)\n        # More nearby vertices => smaller max_dist for fine exploration, else larger for exploration\n        if n == 0:\n            return self._max_dist_max\n        factor = max(0.0, min(1.0, 1.0 - (n / 15.0)))  # Normalize count to [0,1]\n        return self._max_dist_min + factor * (self._max_dist_max - self._max_dist_min)\n\n    def _get_goal_biased_sample(self) -> Point:\n        \"\"\" With probability goal_sample_rate, return the goal position, else random valid sample \"\"\"\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose best parent for q_new from near vertices considering path cost + movement cost\n        \"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        line_cache = None\n\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n                line_cache = line_seq\n\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire near vertices through the new vertex q_new if it improves their costs.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Remove old parent edges\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                # Add new edge from q_new to vertex\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Shortcut path by attempted straight-line connections skipping intermediate vertices\n        \"\"\"\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to connect farthest reachable vertex\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[next_idx])\n                    idx = next_idx\n                    break\n                next_idx -= 1\n            else:\n                # Can't shortcut further; add next vertex forcedly\n                shortcut_path.append(path[idx + 1])\n                idx += 1\n        return shortcut_path\n\n    def _extract_optimized_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from q_goal to start and perform shortcutting.\n        Animates moves along the path.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Pick parent with minimal cost\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n\n        path.reverse()\n\n        # Shortcut path for smoother navigation\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._planning_start_time = time.time()\n\n        iterations_limit = 15000\n        for iteration in range(iterations_limit):\n            # Timeout check\n            if time.time() - self._planning_start_time > self._planning_time_limit:\n                # Planning failed due to timeout\n                break\n\n            q_sample: Point = self._get_goal_biased_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            # If sample coincides with nearest vertex skip\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._compute_adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new.cost = float(\"inf\")  # initialize cost\n            near_radius = max_dist * self._rewire_radius_factor\n            near_vertices = self._get_near_vertices(q_new, near_radius)\n\n            # Choose best parent from near vertices or q_near\n            best_parent = self._choose_parent(near_vertices + [q_near], q_new)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire tree locally\n            self._rewire(q_new, near_vertices)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add direct connection to goal vertex if possible\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_optimized_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based planner inspired by RRT* that incorporates:\n     - Goal-biased sampling (20% towards the goal) to improve convergence speed.\n     - Adaptive step size based on local obstacle density estimation.\n     - Rewiring neighbors within a dynamic radius to improve path quality (RRT* style).\n     - Early stopping upon goal reach or timeout (10 seconds).\n     - Shortcut smoothing of the final path to reduce unnecessary waypoints.\n     - Uses heuristics and cost-to-come + estimated cost-to-go for connection decisions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges for RRT*\n        self._init_displays()\n        self._goal_bias_rate = 0.2  # 20% samples biased toward goal\n        self._max_dist_default = 10.0\n        self._rewire_radius_constant = 25.0  # Radius for neighbor rewiring\n\n    def _get_adaptive_max_dist(self, position: Point) -> float:\n        # Estimate local obstacle density by counting invalid neighbors in 8 directions around position\n        directions = [Point(1,0), Point(-1,0), Point(0,1), Point(0,-1),\n                      Point(1,1), Point(1,-1), Point(-1,1), Point(-1,-1)]\n        invalid_count = 0\n        for d in directions:\n            neighbor = Point(position.x + d.x, position.y + d.y)\n            if not self._get_grid().is_agent_valid_pos(neighbor):\n                invalid_count += 1\n        # More obstacles => smaller step size\n        adaptive_max = max(3.0, self._max_dist_default - invalid_count * 2.0)\n        return adaptive_max\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling with probability self._goal_bias_rate\n        if random.random() < self._goal_bias_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as base but allow adaptive max dist per sample\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from goal to start via parents, then smooth shortcuts.\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost (for robust path extraction)\n            best_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost < min_cost:\n                    min_cost = parent.cost\n                    best_parent = parent\n            if best_parent is None:\n                break\n            path.append(best_parent)\n\n        path.reverse()\n\n        # Shortcut smoothing:\n        def can_connect_directly(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        smoothed_path: List[Vertex] = []\n        idx = 0\n        while idx < len(path):\n            smoothed_path.append(path[idx])\n            next_idx = len(path) - 1  # Try to connect to farthest vertex in path\n            while next_idx > idx + 1:\n                if can_connect_directly(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            if next_idx == idx:\n                idx += 1\n            else:\n                idx = next_idx\n\n        # Animate smooth path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_cost(self, parent: Vertex, child_pos: Point) -> float:\n        # Cost = parent's cost + cost from parent's point to child's point\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child_pos)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 10000\n        start_time = time.time()\n\n        root_start = self._graph.root_vertex_start\n        root_goal_pos = self._get_grid().goal.position\n\n        root_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n\n            # Enforce time limit: 10 sec max to find path\n            if time.time() - start_time > 10.0:\n                # Timeout - no path found\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([root_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adapt step size per neighborhood\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check validity of path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within a radius for potential rewiring (RRT*)\n            rewire_radius = max(self._rewire_radius_constant * math.sqrt(math.log(self._graph.size + 1) / (self._graph.size + 1)), max_dist)\n            neighbors = self._graph.get_vertices_within_radius([root_start], q_new.position, rewire_radius)\n\n            # Choose best parent for q_new from neighbors (lowest cost + valid edge)\n            best_parent = q_near\n            best_cost = self._calculate_cost(q_near, q_new.position)\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                test_cost = self._calculate_cost(neighbor, q_new.position)\n                if test_cost < best_cost:\n                    # Check if connection is valid\n                    test_line = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(test_line):\n                        best_parent = neighbor\n                        best_cost = test_cost\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to potentially reduce cost through q_new\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                # Calculate cost if rewired through q_new\n                potential_cost = self._calculate_cost(q_new, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    # Check validity of new connection\n                    test_line = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                    if self._get_grid().is_valid_line_sequence(test_line):\n                        # Rewire edges: remove old parent edge and add new edge\n                        for parent in list(neighbor.parents):\n                            self._graph.remove_edge(parent, neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = potential_cost\n\n            # Check if q_new is in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex if possible\n                goal_vertex = Vertex(root_goal_pos)\n                goal_line = self._get_grid().get_line_sequence(q_new.position, root_goal_pos)\n                if self._get_grid().is_valid_line_sequence(goal_line):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, root_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* enhanced with:\n    - Enhanced Goal-Biased Adaptive Sampling using a dynamic goal attractor region to improve exploration-exploitation balance.\n    - Dynamic step sizing scaled by local obstacle density estimated via sampling neighbors, allowing cautious movement in cluttered spaces.\n    - Heuristic-guided vertex expansion using combined path cost and Euclidean distance (A*-like) for informed tree growth.\n    - Efficient rewiring of vertices within a dynamically scaled radius to promote path optimality and consistency.\n    - Early termination if goal connected or 10s runtime exceeded to limit planning overhead.\n    - Aggressive shortcut smoothing including iterative multi-point shortcut attempts to improve final path quality.\n    - Uses Forest graph structure, maintains start and goal root vertices, integrates with existing environment and move validation.\n    This algorithm aims to improve planning efficiency, path smoothness, success rate, and robustness in complex grid environments.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Add attribute for dynamic obstacle density estimation radius and smoothing passes\n        self._obstacle_density_radius = 5.0\n        self._smoothing_iterations = 3\n\n    def _estimate_local_obstacle_density(self, center: Point, radius: float) -> float:\n        \"\"\"\n        Estimate local obstacle density near 'center' within 'radius' by sampling points \n        around center and checking validity. Returns ratio of obstacles in sampled points.\n        \"\"\"\n        grid = self._get_grid()\n        sampling_points = []\n        dim = len(center)\n        # Use a naive grid sampling in a square/cube neighborhood\n        coords_range = []\n        for d in range(dim):\n            min_coord = max(0, center[d] - int(radius))\n            max_coord = min(grid.size[d] - 1, center[d] + int(radius))\n            coords_range.append(range(min_coord, max_coord + 1))\n        # Cartesian product of coordinates in the region\n        import itertools\n        for coord_tuple in itertools.product(*coords_range):\n            sampling_points.append(Point(*coord_tuple))\n        if len(sampling_points) == 0:\n            return 0.0\n        obstacle_count = 0\n        for p in sampling_points:\n            if not grid.is_agent_valid_pos(p):\n                obstacle_count += 1\n        return obstacle_count / len(sampling_points)\n\n    def _adaptive_max_dist(self, dist_to_goal: float, local_obstacle_density: float) -> float:\n        \"\"\"\n        Compute adaptive step size based on distance to goal and local obstacle density.\n        Larger step if far from goal and low density; smaller step if near goal or high density.\n        \"\"\"\n        base_step = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n        # Reduce step linearly with obstacle density (0..1)\n        density_factor = max(0.2, 1.0 - local_obstacle_density)\n        step = base_step * density_factor\n        return max(self._max_dist_min, min(self._max_dist_initial, step))\n\n    def _get_best_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Vertex, float]:\n        \"\"\"\n        Select best parent for q_new from neighbors, minimizing cost + distance and with collision free path.\n        Returns tuple (best_parent, best_cost).\n        \"\"\"\n        grid = self._get_grid()\n        q_min = None\n        c_min = float('inf')\n        for q_near in neighbors:\n            dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n            if cost_through_neighbor >= c_min:\n                continue\n            line_seq_check = grid.get_line_sequence(q_near.position, q_new.position)\n            if grid.is_valid_line_sequence(line_seq_check):\n                q_min = q_near\n                c_min = cost_through_neighbor\n        return q_min, c_min\n\n    def _rewire_vertices(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to rewire neighbors through q_new if it improves their cost and path is collision free.\n        \"\"\"\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            cost_through_new = q_new.cost + dist_new_to_near\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq_check = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq_check):\n                continue\n            # Remove existing parent edge (assume single parent)\n            existing_parent = None\n            for p in q_near.parents:\n                existing_parent = p\n                break\n            if existing_parent is not None:\n                self._graph.remove_edge(existing_parent, q_near)\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n    def _try_path_shortcut_iterative(self, path_points: List[Vertex], iterations: int) -> List[Vertex]:\n        \"\"\"\n        Improved shortcut smoothing: repeat multiple passes trying multi-level vertex shortcuts to aggressively smooth path.\n        \"\"\"\n        grid = self._get_grid()\n        path = path_points\n        for _ in range(iterations):\n            smoothed_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Attempt to find farthest reachable vertex to shortcut to\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path[i+1])\n                    i += 1\n            path = smoothed_path\n        return path\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        # Reuse but replace smoothing with iterative shortcut\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Get parent with lowest cost for stable path\n            min_cost_parent = None\n            min_cost_val = float(\"inf\")\n            for p in current.parents:\n                if p.cost < min_cost_val:\n                    min_cost_parent = p\n                    min_cost_val = p.cost\n            current = min_cost_parent\n        path.reverse()\n\n        # Aggressively smooth path using multi-pass shortcutting\n        path = self._try_path_shortcut_iterative(path, self._smoothing_iterations)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # Reduced upper iteration to improve speed with adaptive sampling\n        iteration: int = 0\n        grid = self._get_grid()\n        goal_pos_tensor = self._goal_vertex.position.to_tensor()\n        start_pos_tensor = self._start_vertex.position.to_tensor()\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout reached without success\n                return\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - goal_pos_tensor)\n            local_obst_density = self._estimate_local_obstacle_density(q_nearest.position, self._obstacle_density_radius)\n            max_dist = self._adaptive_max_dist(dist_to_goal, local_obst_density)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = max(1.0, float(self._graph.size))\n            radius = min(\n                self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / self._dimension)),\n                30.0,\n            )\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            # Ensure q_nearest also considered (could be excluded if outside radius)\n            if q_nearest not in neighbors:\n                neighbors.append(q_nearest)\n\n            q_min, c_min = self._get_best_parent(neighbors, q_new)\n            if q_min is None:\n                # No valid parent; discard this vertex\n                continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            self._rewire_vertices(q_new, neighbors)\n\n            dist_to_goal_new = torch.norm(q_new.position.to_tensor() - goal_pos_tensor)\n            if dist_to_goal_new <= max_dist:\n                line_seq_goal = grid.get_line_sequence(q_new.position, self._goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal_new\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            # Key frame update occasionally to reduce overhead: e.g. every 10 iterations\n            if iteration % 10 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired path planning algorithm with heuristic cost-guided sampling, adaptive step size,\n    dynamic rewiring, and early stopping based on path cost thresholds. This implementation introduces:\n    - Heuristic biasing of samples toward the goal via an A*-like cost combining actual path cost and heuristic distance.\n    - Dynamically adjusting max step size based on environment complexity (local obstacle density estimation).\n    - Enhanced rewiring radius adjusted to current graph density for efficient graph optimization.\n    - Early stopping when a sufficiently low-cost path is found or after 10 seconds timeout.\n    - Post-processing shortcut smoothing to produce smooth, short, and robust paths.\n    - Uses existing helper methods for consistency and reusability.\n    This approach improves planning efficiency, path quality, robustness, and success rate over standard RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters enhancement\n        self._max_dist_base = 15.0\n        self._goal_sample_rate = 0.2\n        self._iterations_limit = 10000\n        self._rewire_radius_base = 20.0\n        self._early_stopping_cost_threshold = None  # To be adaptive based on heuristic\n        self._density_check_radius = 10.0  # Radius for local obstacle density estimate\n\n    def _estimate_local_obstacle_density(self, point: Point) -> float:\n        # Estimate obstacle density in local neighborhood for adaptive step size scaling\n        grid = self._get_grid()\n        obstacle_count = 0\n        count_checks = 0\n        \n        neighbors = grid.get_vertices_within_radius([], point, self._density_check_radius)\n        # Instead of vertices, we check map cells around point\n        # Since vertices are not related to obstacle points directly, we use next positions and check obstacles\n        # We'll approximate by checking 8-connected neighbors in radius\n        for dx in range(-int(self._density_check_radius), int(self._density_check_radius) + 1):\n            for dy in range(-int(self._density_check_radius), int(self._density_check_radius) + 1):\n                check_point = Point(point.x + dx, point.y + dy)\n                if not grid.is_agent_valid_pos(check_point):\n                    obstacle_count += 1\n                count_checks += 1\n        if count_checks == 0:\n            return 0.0\n        return obstacle_count / count_checks  # ratio of obstacles in the vicinity\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean heuristic cost estimate (used for better sampling bias)\n        return self._get_distance(from_pos, to_pos)\n\n    def _get_random_sample(self) -> Point:\n        grid = self._get_grid()\n        # Combined goal bias and heuristic biased sampling\n        # With goal_sample_rate: target goal\n        # Otherwise sample biased within ellipse bounded near start-goal line for efficiency\n\n        if np.random.rand() < self._goal_sample_rate:\n            return grid.goal.position\n\n        # Elliptical sampling around start-goal line to focus sampling near optimal corridor\n        start = grid.agent.position\n        goal = grid.goal.position\n        c = self._get_distance(start, goal) / 2.0\n        center = Point((start.x + goal.x) / 2.0, (start.y + goal.y) / 2.0)\n        axis_a = c + np.random.uniform(-c * 0.25, c * 0.25)  # long axis ~distance(start,goal)\n        axis_b = axis_a * np.random.uniform(0.3, 0.7)  # short axis smaller\n\n        # Sample point in ellipse parametric coordinates\n        angle = np.random.uniform(0, 2 * math.pi)\n        r = np.sqrt(np.random.uniform(0, 1))\n        x_ellipse = axis_a * r * math.cos(angle)\n        y_ellipse = axis_b * r * math.sin(angle)\n\n        # Rotate ellipse aligned with start-goal line\n        direction = np.array([goal.x - start.x, goal.y - start.y])\n        theta = math.atan2(direction[1], direction[0])\n\n        sample_x = center.x + x_ellipse * math.cos(theta) - y_ellipse * math.sin(theta)\n        sample_y = center.y + x_ellipse * math.sin(theta) + y_ellipse * math.cos(theta)\n\n        sample = Point(int(round(sample_x)), int(round(sample_y)))\n        if grid.is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback to uniform random if invalid\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                fallback_sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(fallback_sample):\n                    return fallback_sample\n\n    def _choose_parent(\n        self, q_near: Vertex, q_new: Vertex, neighbors: List[Vertex]\n    ) -> Vertex:\n        grid = self._get_grid()\n\n        # Modified cost function includes an exploration term favoring vertices reducing heuristic+cost\n        goal_pos = grid.goal.position\n\n        cost_min = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n        heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n\n        for v in neighbors:\n            if v == q_near:\n                continue\n            cost_to_new = v.cost + grid.get_movement_cost(v.position, q_new.position)\n            heuristic_v = self._heuristic_cost(v.position, goal_pos)\n            # Combined cost and heuristic weighted for A*-like improvement\n            combined_cost = cost_to_new + heuristic_new * 0.5\n            combined_existing = cost_min + heuristic_v * 0.5\n\n            if combined_cost < combined_existing:\n                line = grid.get_line_sequence(v.position, q_new.position)\n                if grid.is_valid_line_sequence(line):\n                    cost_min = cost_to_new\n                    best_parent = v\n\n        q_new.cost = cost_min\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        grid = self._get_grid()\n\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + grid.get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line = grid.get_line_sequence(q_new.position, v.position)\n                if grid.is_valid_line_sequence(line):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_goal_vertex: Vertex = None\n        best_goal_cost = float(\"inf\")\n\n        # Dynamic rewiring radius based on number of vertices for better local optimization\n        def _adjust_rewire_radius(vertex_count: int) -> float:\n            return max(\n                min(self._rewire_radius_base, 40.0 / math.sqrt(max(1, vertex_count))),\n                5.0,\n            )\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout reached\n                break\n\n            # Adaptive rewiring radius based on current graph size\n            current_rewire_radius = _adjust_rewire_radius(self._graph.size)\n\n            q_sample = self._get_random_sample()\n\n            root_verts = self._graph.root_vertices\n            q_near = self._get_nearest_vertex(root_verts, q_sample)\n\n            # Local obstacle density estimation for step sizing (higher density -> smaller step)\n            local_density = self._estimate_local_obstacle_density(q_near.position)\n            density_factor = max(0.3, 1.0 - local_density)  # scale down step if dense\n\n            # Distance to goal for adaptive step scaling\n            dist_to_goal = self._get_distance(q_near.position, goal_vertex.position)\n            max_dist = min(\n                self._max_dist_base * density_factor, dist_to_goal * 1.2\n            )\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            neighbors = self._get_vertices_within_radius(root_verts, q_new.position, current_rewire_radius)\n\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(q_new, neighbors)\n\n            self._graph.root_vertices.append(q_new)\n\n            # Check connection to goal if within step size\n            dist_to_goal_new = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal_new <= max_dist:\n                goal_line = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(goal_line):\n                    goal_vertex_cost = (\n                        q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                    )\n                    if goal_vertex_cost < best_goal_cost:\n                        goal_vertex.cost = goal_vertex_cost\n                        # Remove any existing parents for precise connection\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                        if goal_vertex not in self._graph.root_vertices:\n                            self._graph.root_vertices.append(goal_vertex)\n\n                        best_goal_vertex = goal_vertex\n                        best_goal_cost = goal_vertex_cost\n                        path_found = True\n\n                        # Early stopping if path is good enough (relative to heuristic)\n                        heuristic_to_goal = self._heuristic_cost(start_vertex.position, goal_vertex.position)\n                        if best_goal_cost <= heuristic_to_goal * 1.5:\n                            break\n\n            self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            raw_path = self._extract_path(best_goal_vertex)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Enhanced Adaptive Sampling and Heuristic Expansion.\n\n    Key improvements and features:\n    - Dynamic goal-biased sampling with adaptive goal attraction increasing with iteration progress.\n    - Adaptive step size that decreases near obstacles and goal to enable fine maneuvering.\n    - Heuristic-guided vertex expansion using an A*-style cost function balancing exploration and exploitation.\n    - Rewiring neighbors to optimize path costs (improves upon basic RRT* rewiring, incorporating collision checks).\n    - Adaptive neighborhood radius that scales with graph size and density for efficient rewiring.\n    - Early stopping criteria triggered by either connection to goal or exceeding 10 seconds runtime.\n    - Enhanced shortcut smoothing: iterative path shortcutting with repeated attempts to reduce path length.\n    - Integrated collision-aware sampling retry mechanism to avoid invalid vertices.\n    - Bias against revisiting identical samples for more diverse exploration.\n    \n    This algorithm aims to reduce planning time, increase success rate, and generate smoother,\n    shorter paths through smarter sampling, expansion, and optimization strategies compared to classical RRT*.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n        # Additional member variables\n        self._sample_memory = set()  # Cache to avoid resampling identical samples\n\n    def _sample_with_collision_check(self, iteration: int, max_iterations: int, max_tries: int = 15) -> Point:\n        \"\"\"\n        Samples a valid point with goal biasing and retries in case of invalid position or collisions.\n        Avoids sampling points already tried to increase exploration diversity.\n        \"\"\"\n        for _ in range(max_tries):\n            sample = self._get_random_sample(iteration, max_iterations)\n            if sample in self._sample_memory:\n                continue\n            if self._get_grid().is_agent_valid_pos(sample):\n                # Check collision line from nearest vertex to sample to ensure feasibility\n                q_near = self._graph.get_nearest_vertex([self._start_vertex], sample)\n                if q_near.position == sample:\n                    self._sample_memory.add(sample)\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_near.position, sample)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    self._sample_memory.add(sample)\n                    return sample\n            self._sample_memory.add(sample)\n        # If no valid sample found after retries, fallback to random valid sample ignoring collision check\n        while True:\n            sample = self._get_random_sample(iteration, max_iterations)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_step_size(self, q_near_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size based on distance to goal and proximity to nearby obstacles.\n        Smaller step size near obstacles or near goal to allow precise navigation.\n        \"\"\"\n        dist_to_goal = torch.norm(q_near_pos.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n        max_step = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 3.0))\n\n        # Check obstacles within a small radius and reduce step size if close\n        obstacle_radius_reduce = 0.7 * max_step\n        grid = self._get_grid()\n        nearby_positions = grid.get_next_positions(q_near_pos)\n        for pos in nearby_positions:\n            if not grid.is_agent_valid_pos(pos):\n                max_step = max(self._max_dist_min, max_step * 0.5)\n                break\n        return max_step\n\n    def _heuristic_total_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        \"\"\"\n        Heuristic cost: path cost so far + Euclidean distance to target point.\n        Acts as A* style expanded cost guiding vertex expansion.\n        \"\"\"\n        euclid_dist = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor()).item()\n        return from_vertex.cost + euclid_dist\n\n    def _iterative_path_shortcut(self, path_points: List[Vertex], max_attempts: int = 4) -> List[Vertex]:\n        \"\"\"\n        Iteratively attempts to shortcut the path by connecting non-adjacent vertices directly if collision free.\n        Repeated attempts improve path smoothing beyond a single-pass shortcutting.\n        \"\"\"\n        for _ in range(max_attempts):\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i + 1])\n                    i += 1\n            if len(smoothed_path) >= len(path_points):\n                break  # No improvement, stop early\n            path_points = smoothed_path\n        return path_points\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path by walking back parents from connection vertex to start,\n        then perform iterative shortcut smoothing and move agent along the smoothed path.\n        \"\"\"\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            parents_list = list(current.parents)\n            if not parents_list:\n                break\n            current = parents_list[0]\n        path.reverse()\n\n        path = self._iterative_path_shortcut(path, max_attempts=4)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            # Publish waypoint if ROS map used\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # reduced for efficiency given improvements\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Failed to find path within time limit\n                return\n\n            q_sample = self._sample_with_collision_check(iteration, max_iterations)\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step_size(q_nearest.position)\n            # Generate new vertex in direction of sample but limited by adaptive step size\n            direction_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist = torch.norm(direction_vec).item()\n            if dist == 0.0:\n                continue\n            if dist > max_dist:\n                direction_vec = direction_vec / dist * max_dist\n            q_new_pos_tensor = q_nearest.position.to_tensor() + direction_vec\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            q_new = Vertex(q_new_pos)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Adaptive neighborhood radius for rewiring\n            cardinality = max(1.0, float(self._graph.size))\n            log_card = math.log(cardinality)\n            radius = min(self._lambda_rrt_star * ((log_card / cardinality) ** (1 / self._dimension)), 28.0)\n\n            neighbors = self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n            # Heuristic guided parent selection (choose best cost + estimated to new vertex)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n\n            for q_near in neighbors:\n                dist_neighbor_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                candidate_cost = q_near.cost + dist_neighbor_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check) and candidate_cost < c_min:\n                    q_min = q_near\n                    c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if improves cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                new_cost = q_new.cost + dist_new_near\n                if new_cost + 1e-6 < q_near.cost:\n                    line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_check):\n                        # Remove old parent edge\n                        old_parent = None\n                        for p in q_near.parents:\n                            old_parent = p\n                            break\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, q_near)\n                        # Add new parent edge with better cost\n                        q_near.cost = new_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n            if dist_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* and Informed RRT*, \n    with Goal-Biased Adaptive Sampling, Heuristic-Guided Vertex Expansion, \n    Dynamic Step Sizing, and Informed Ellipsoidal Sampling region.\n    \n    Key Features:\n    - Goal-biased sampling with probability increasing linearly along iteration progress.\n    - Informed sampling within ellipsoidal region defined by current best path cost to focus search, improving efficiency.\n    - Adaptive step size that decreases with proximity to goal for finer path construction near goal.\n    - Heuristic cost guides parent selection and rewiring similar to RRT*.\n    - Rewiring vertices within radius to maintain path optimality.\n    - Early stopping on success or 10 seconds timeout.\n    - Shortcut smoothing on extracted final path.\n    \n    This approach improves path quality and success rate by focusing sampling near the promising region,\n    reducing unnecessary exploration, and refining connections near the goal.\n    \"\"\"\n\n    def _get_informed_sample(self, best_cost: float, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Sample within an ellipsoidal region between start and goal if a solution exists,\n        else fallback to goal biased sampling.\n        The ellipsoid defined by the start-to-goal segment and the ellipse radii based on cost.\n        \"\"\"\n        start = self._start_vertex.position.to_numpy()\n        goal = self._goal_vertex.position.to_numpy()\n        dimension = self._dimension\n\n        # Fallback: if no path found yet or best_cost is infinite or very large\n        if best_cost == float('inf') or best_cost <= np.linalg.norm(goal - start):\n            return self._get_random_sample(iteration, max_iterations)\n\n        c_min = np.linalg.norm(goal - start)\n        c_best = best_cost\n\n        # Ellipse center\n        center = (start + goal) / 2.0\n        # Rotation matrix from unit vector along x-axis to start->goal vector\n        unit_vec = (goal - start) / c_min\n        I = np.eye(dimension)\n        a1 = unit_vec.reshape((dimension, 1))\n        M = a1 @ np.array([[1]])  # Outer product as rank 1 matrix\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] + [0]*(dimension-1)) @ Vt  # Ensures rotation matrix\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            # Numerical safety; fallback sample\n            return self._get_random_sample(iteration, max_iterations)\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        # Radii vector (elongated ellipse)\n        radii = np.array([r1] + [r2] * (dimension - 1))\n\n        # Sample uniformly in unit ball\n        while True:\n            x = np.random.normal(0, 1, dimension)\n            norm_x = np.linalg.norm(x)\n            if norm_x > 0:\n                break\n        x_unit = x / norm_x\n        # Sample radius within unit ball (uniform)\n        radius_sample = np.random.rand() ** (1.0/dimension)\n        x_ball = x_unit * radius_sample\n\n        # Scale by radii and rotate and translate\n        sample_point = C @ (radii * x_ball) + center\n        # Round and clamp to grid bounds\n        sample_coords = [int(round(coord)) for coord in sample_point]\n        grid_size = [self._get_grid().size[i]-1 for i in range(dimension)]\n        for i in range(dimension):\n            sample_coords[i] = max(0, min(grid_size[i], sample_coords[i]))\n        sample = Point(*sample_coords)\n\n        # Validate position\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n        else:\n            # Fallback to uniform goal biased sampling if invalid\n            return self._get_random_sample(iteration, max_iterations)\n\n    def _heuristic_cost_vertex(self, v: Vertex) -> float:\n        # f = g + h ; g = cost, h = Euclidean dist to goal\n        dist_to_goal = torch.norm(v.position.to_tensor() - self._goal_vertex.position.to_tensor())\n        return v.cost + dist_to_goal\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # Reduced iterations since informed focusing used\n        iteration: int = 0\n        best_cost: float = float('inf')\n        best_vertex: Vertex = None\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Fail safe: abort search when exceeding time limit\n                return\n\n            # Sample informed if path found, else goal biased\n            q_sample: Point = self._get_informed_sample(best_cost, iteration, max_iterations)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist: smaller when near goal, promoting smoother approach\n            dist_to_goal_val = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal_val / 3.0))\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision free edge\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbor search adapts with graph size and dimension, bounded\n            n_vertices = max(1.0, float(self._graph.size))\n            radius = min(self._lambda_rrt_star * ((math.log(n_vertices) / n_vertices) ** (1 / self._dimension)), 25.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Select best parent with minimum path cost + edge cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in neighbors:\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for potential cost improvement\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    # Add new edge from q_new\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Update best found solution if q_new connects goal region better\n            dist_to_goal_new = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal_new <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    total_cost = q_new.cost + dist_to_goal_new\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_vertex = q_new\n                        self._goal_vertex.cost = total_cost\n                        # Connect goal vertex if not connected already, or update edge\n                        if self._goal_vertex not in q_new.children:\n                            self._graph.add_edge(q_new, self._goal_vertex)\n\n            # Early stopping if goal is connected and path found\n            if best_vertex is not None:\n                # Using heuristic cost: if we found a path, we can continue a few iterations to refine path, then stop\n                if iteration > 50 and iteration % 50 == 0:\n                    dist_goal_check = torch.norm(best_vertex.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                    if dist_goal_check <= max_dist:\n                        # Smooth and extract path, then stop\n                        self._extract_and_smooth_path(best_vertex)\n                        return\n\n            self.key_frame()\n\n        # If timeout or no path found within iterations but best found solution exists\n        if best_vertex is not None:\n            self._extract_and_smooth_path(best_vertex)\n        else:\n            # No path found\n            return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "self._start_vertex",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Goal-Biased Adaptive Sampling,\n    Heuristic-Guided Vertex Expansion, and Dynamic Step Sizing.\n    \n    Key improvements over baseline:\n    - Adaptive goal-bias sampling with dynamic probability scaling based on elapsed time.\n    - Step size adaptation not only by distance to goal but also by local obstacle density,\n      enabling finer moves in complex regions.\n    - Uses a heuristic combining path cost and Euclidean distance (A*-style) for guiding expansions.\n    - Enhanced rewiring for better path optimality with neighborhood radius adjusted dynamically.\n    - Early stopping criteria based on goal connection and max runtime (10 seconds).\n    - Post-processing shortcut smoothing with multi-pass refinement for higher path smoothness.\n    - Prioritizes vertex expansions closer to goal for improved convergence speed.\n    \"\"\"\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        iteration: int = 0\n        start_time = time.perf_counter()\n        goal_pos = self._goal_vertex.position\n        dimension = self._dimension\n\n        # Parameters for adaptive goal bias and rewiring radius\n        max_runtime = self._max_runtime_seconds\n        max_dist_initial = self._max_dist_initial\n        max_dist_min = self._max_dist_min\n        lambda_rrt_star = self._lambda_rrt_star\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            elapsed = time.perf_counter() - start_time\n            if elapsed > max_runtime:\n                # Timeout: Treat as failure (no path found)\n                return\n\n            # Adaptive goal bias probability grows with elapsed time, speeding convergence near timeout\n            progress_ratio = min(elapsed / max_runtime, 1.0)\n            goal_sample_prob = 0.15 + 0.8 * progress_ratio  # from 15% to 95%\n            if random.random() < goal_sample_prob:\n                q_sample = goal_pos\n            else:\n                # Uniform random sample in free space\n                while True:\n                    rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(dimension)]\n                    sample_point = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        q_sample = sample_point\n                        break\n\n            # Find nearest vertex considering heuristic favoring vertices closer to goal\n            # Rather than simple Euclidean, add heuristic cost balancing cost and distance to goal\n            nearest_vertex = None\n            min_vertex_cost = float('inf')\n            for vertex in self._graph.root_vertices[0].children | {self._start_vertex}:\n                dist_to_sample = torch.norm(vertex.position.to_tensor() - q_sample.to_tensor()).item()\n                est_cost = vertex.cost + dist_to_sample + torch.norm(vertex.position.to_tensor() - goal_pos.to_tensor()).item()\n                if est_cost < min_vertex_cost:\n                    min_vertex_cost = est_cost\n                    nearest_vertex = vertex\n            if nearest_vertex is None:\n                nearest_vertex = self._start_vertex\n\n            # Adaptive dynamic step size modulated by goal distance and local obstacle density\n            dist_to_goal = torch.norm(nearest_vertex.position.to_tensor() - goal_pos.to_tensor()).item()\n            dynamic_max_dist = max(max_dist_min, min(max_dist_initial, dist_to_goal / 2.0))\n\n            # Check local obstacle density by sampling neighbors around nearest vertex\n            neighbors_pos = self._get_grid().get_next_positions(nearest_vertex.position)\n            obstacle_count = 0\n            for pos in neighbors_pos:\n                if not self._get_grid().is_agent_valid_pos(pos):\n                    obstacle_count += 1\n            # Reduce step size if many obstacles adjacent, promoting smaller moves in complex regions\n            dynamic_max_dist *= (1.0 - 0.6 * min(obstacle_count / max(len(neighbors_pos), 1), 1.0))\n            dynamic_max_dist = max(dynamic_max_dist, max_dist_min)\n\n            # Generate new vertex toward q_sample capped by dynamic_max_dist\n            dir_vec = q_sample.to_tensor() - nearest_vertex.position.to_tensor()\n            dist_to_sample = torch.norm(dir_vec).item()\n            if dist_to_sample <= dynamic_max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist_to_sample\n                q_new_pos_tensor = nearest_vertex.position.to_tensor() + dynamic_max_dist * dir_norm\n                q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            q_new = Vertex(q_new_pos)\n\n            # Collision check on line from nearest_vertex -> q_new\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Increase count of vertices for radius calculation\n            vertex_count = max(1.0, float(self._graph.size))\n\n            # Radius for rewiring neighbors (dynamic with cardinality)\n            radius = min(\n                lambda_rrt_star * ((math.log(vertex_count) / vertex_count) ** (1 / dimension)),\n                30.0\n            )\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Cost and parent selection with heuristic (path cost + distance)\n            q_min = nearest_vertex\n            dist_near_to_new = torch.norm(nearest_vertex.position.to_tensor() - q_new.position.to_tensor()).item()\n            c_min = nearest_vertex.cost + dist_near_to_new\n\n            for neighbor in neighbors:\n                dist_neighbor_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                tentative_cost = neighbor.cost + dist_neighbor_new\n                line_neighbor_check = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_neighbor_check) and tentative_cost < c_min:\n                    q_min = neighbor\n                    c_min = tentative_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors to q_new if it improves costs\n            for neighbor in neighbors:\n                if neighbor == q_min:\n                    continue\n                line_check = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_check):\n                    continue\n                dist_new_neighbor = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_neighbor\n                if cost_through_new < neighbor.cost:\n                    # Remove old parent edge\n                    old_parent = None\n                    for parent in neighbor.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, neighbor)\n                    neighbor.cost = cost_through_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Check if q_new can connect to goal with collision free path\n            dist_new_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            if dist_new_to_goal <= dynamic_max_dist:\n                line_goal_check = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_goal_check):\n                    self._goal_vertex.cost = q_new.cost + dist_new_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n\n                    # Extract and smooth the path with multi-pass shortcut smoothing for higher quality\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        # Extract path from start to goal using parents\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Multi-pass shortcut smoothing to improve path smoothness beyond single pass\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            changed = True\n            smoothed_path = path_points\n            for _ in range(3):  # 3 smoothing passes\n                if not changed:\n                    break\n                changed = False\n                new_path = [smoothed_path[0]]\n                i = 0\n                while i < len(smoothed_path) - 1:\n                    j = len(smoothed_path) - 1\n                    while j > i + 1:\n                        line_seq = self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[j].position)\n                        if self._get_grid().is_valid_line_sequence(line_seq):\n                            new_path.append(smoothed_path[j])\n                            i = j\n                            changed = True\n                            break\n                        j -= 1\n                    else:\n                        new_path.append(smoothed_path[i+1])\n                        i += 1\n                smoothed_path = new_path\n            return smoothed_path\n\n        path = try_shortcut(path)\n\n        # Move agent along smoothed path with key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm builds on an RRT*-inspired approach with several enhancements to improve smoothness, \n    planning efficiency, and robustness:\n    - Uses heuristic-guided sampling biased towards regions closer to the goal and along the current best path,\n      achieved by adaptive goal biasing combined with sampling near the current best solution vertices.\n    - Employs adaptive step size that dynamically varies based on local environment complexity estimated by the density\n      of nearby vertices and the distance to the goal, allowing larger steps in free space and finer steps near obstacles and the goal.\n    - Enhances rewiring with a smoothing rewiring step that attempts direct shortcut edges beyond immediate neighbors,\n      optimizing path smoothness incrementally.\n    - Introduces a \"lazy\" collision check filter for rewiring candidates, delaying expensive verifications until promising connections appear.\n    - Early stopping once a path is found with cost improvement below a threshold for a consecutive number of iterations.\n    - Keeps path shortcutting for final smoothing, combined with the incremental smoothing steps.\n    These improvements target shorter, smoother paths with fewer iterations and higher success in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position), \n            Vertex(self._get_grid().goal.position), \n            [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0   # base maximum step size for extension\n        self._goal_sample_rate = 0.15  # probability of sampling the goal to bias growth\n        self._best_path_sample_rate = 0.3  # probability to sample near current best path vertex\n        self._iterations_limit = 10000  # max iterations\n        self._rewire_radius = 20.0    # radius to attempt rewiring for optimization\n        self._rewire_smooth_radius = 35.0  # larger radius for smoothing rewiring attempts\n        self._early_stop_thresh = 1e-3  # minimum improvement to continue searching\n        self._early_stop_patience = 100  # iterations to wait for improvement\n        self._shortcut_tries = 10  # tries to shortcut path incrementally\n\n    def _adaptive_max_dist(self, q_near: Vertex, goal_vertex: Vertex) -> float:\n        # Adapt step size: larger in open space, smaller near goal or crowded areas\n        dist_to_goal = self._get_distance(q_near.position, goal_vertex.position)\n        neighbors = self._get_vertices_within_radius(self._graph.root_vertices, q_near.position, self._rewire_radius)\n        density_factor = min(1.0, len(neighbors) / 10.0)  # scale density [0,1]\n        dist_factor = min(1.0, dist_to_goal / (self._max_dist_base * 2))\n        max_dist = self._max_dist_base * (0.5 + 0.5 * dist_factor) * (1.0 - 0.6 * density_factor)\n        max_dist = max(1.0, max_dist)\n        return max_dist\n\n    def _sample_near_path_vertex(self, best_path_vertices: List[Vertex]) -> Point:\n        # Sample near a randomly selected vertex in best known path, with small Gaussian offset\n        pivot_vertex = random.choice(best_path_vertices)\n        pivot_pos = pivot_vertex.position\n        dim = self._get_grid().size.n_dim\n        offset = [random.gauss(0, 3) for _ in range(dim)]\n        candidate = Point(*(pivot_pos[i] + offset[i] for i in range(dim)))\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sample\n        return self._get_random_sample()\n\n    def _find_best_goal_vertex(self) -> Optional[Vertex]:\n        # Find the goal vertex with lowest cost in root_vertices (sometimes multiple goals after connections)\n        goal_vertex = self._graph.root_vertex_goal\n        candidates = [v for v in self._graph.root_vertices if v.position == goal_vertex.position]\n        if not candidates:\n            return None\n        best = min(candidates, key=lambda v: v.cost)\n        return best\n\n    def _attempt_smooth_rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempt rewiring beyond immediate neighbors within smooth radius:\n        For neighbors within _rewire_smooth_radius, check if direct connection to q_new improves cost and smooths path,\n        try lazy collision checking by skipping some expensive checks if heuristics are promising.\n        \"\"\"\n        grid = self._get_grid()\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + grid.get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                # Check if line is collision-free before rewiring\n                line = grid.get_line_sequence(q_new.position, v.position)\n                # Lazy check: skip if line too long and cost improvement very small\n                if len(line) > 20 and (v.cost - cost_through_new) < 1.0:\n                    # skip expensive check for small improvement on long path temporarily\n                    continue\n                if grid.is_valid_line_sequence(line):\n                    # Rewire edges to use q_new as parent if better\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _iterative_shortcut(self, path: List[Vertex]) -> List[Vertex]:\n        # Incremental shortcut attempts to further smooth path by random shortcut attempts\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        for _ in range(self._shortcut_tries):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            line = grid.get_line_sequence(path[i].position, path[j].position)\n            if grid.is_valid_line_sequence(line):\n                # Remove intermediate points between i and j, splice path\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_goal_vertex: Optional[Vertex] = None\n        best_goal_cost = float(\"inf\")\n        no_improve_count = 0\n\n        # Maintain the best path vertices for heuristic sampling near them\n        best_path_vertices: List[Vertex] = [start_vertex]\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached: treat as no path found\n                break\n\n            # Sampling strategy:\n            sample_type = np.random.rand()\n            if sample_type < self._goal_sample_rate:\n                q_sample = goal_vertex.position\n            elif path_found and sample_type < (self._goal_sample_rate + self._best_path_sample_rate):\n                q_sample = self._sample_near_path_vertex(best_path_vertices)\n            else:\n                q_sample = self._get_random_sample()\n\n            root_verts = self._graph.root_vertices\n            q_near = self._get_nearest_vertex(root_verts, q_sample)\n            max_dist = self._adaptive_max_dist(q_near, goal_vertex)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            neighbors = self._get_vertices_within_radius(root_verts, q_new.position, self._rewire_radius)\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(q_new, neighbors)\n\n            # Additional smoothing rewire step for more gradual improvement\n            neighbors_smooth = self._get_vertices_within_radius(root_verts, q_new.position, self._rewire_smooth_radius)\n            self._attempt_smooth_rewire(q_new, neighbors_smooth)\n\n            self._graph.root_vertices.append(q_new)\n\n            # Try to connect to goal if close enough\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= max_dist:\n                goal_line = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.root_vertices.append(goal_vertex)\n\n                    # Update best goal vertex and cost\n                    if goal_vertex.cost < best_goal_cost:\n                        best_goal_cost = goal_vertex.cost\n                        best_goal_vertex = goal_vertex\n                        # Extract vertices from current best path to assist guided sampling\n                        raw_path = self._extract_path(best_goal_vertex)\n                        best_path_vertices = raw_path\n                        path_found = True\n                        no_improve_count = 0  # reset counter on improvement\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            # Early stop if cost no meaningful improvement for patience iterations\n            if path_found and no_improve_count >= self._early_stop_patience:\n                break\n\n            self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            raw_path = self._extract_path(best_goal_vertex)\n            # Perform iterative shortcutting for final improved smoothness\n            smoothed_path = self._shortcut_path(raw_path)\n            smoothed_path = self._iterative_shortcut(smoothed_path)\n\n            # Animate movement along smoothed path\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Enhanced Smoothing\n\n    Key Improvements:\n    - Goal-biased adaptive sampling with a gradually increasing probability to sample the goal directly.\n    - Adaptive step size that decreases dynamically based on distance to goal, environment complexity, and iteration progress.\n    - Heuristic guided vertex expansion using A*-style cost combining path cost and Euclidean distance.\n    - Rewiring with neighbor pruning strategy to reduce graph complexity and focus rewiring on beneficial neighbors only.\n    - Early stopping if goal is connected or 10 seconds runtime exceeded.\n    - Aggressive shortcut smoothing with repeated attempts to reduce redundant waypoints and smooth sharp turns.\n    - Path pruning heuristics during smoothing to enhance smoothness and shorten paths.\n    - Use of a cleared cache of invalid connections to avoid redundant collision checks improving performance.\n    - Dynamic adjustment of sampling region radius shrinking over time to focus exploration near goal once search progresses.\n    - More robust connection checks using multiple intermediate points to reduce collision misses.\n    \"\"\"\n\n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _max_runtime_seconds: float\n    _invalid_connections_cache: set\n    _adaptive_sample_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 18.0\n        self._max_dist_min = 2.5\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._invalid_connections_cache = set()\n        self._adaptive_sample_radius = max(self._get_grid().size.x, self._get_grid().size.y) / 2.0\n        self._init_displays()\n\n    def _get_random_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Goal biased sampling with shrinking sample radius around goal:\n        - Probability to sample goal increases linearly.\n        - Sampling region shrinks exponentially focusing around goal later.\n        \"\"\"\n        prob_goal_sample = min(0.2 + 0.8 * (iteration / max_iterations), 0.97)\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n\n        # Dynamic shrinking radius to sample around goal, min 5 units radius\n        shrink_factor = ((max_iterations - iteration) / max_iterations) ** 2\n        radius = max(5.0, self._adaptive_sample_radius * shrink_factor)\n\n        goal_pos = self._goal_vertex.position\n        for _ in range(50):  # sample multiple times to find valid sample\n            sample_x = random.randint(max(0, goal_pos.x - int(radius)), min(self._get_grid().size.x - 1, goal_pos.x + int(radius)))\n            sample_y = random.randint(max(0, goal_pos.y - int(radius)), min(self._get_grid().size.y - 1, goal_pos.y + int(radius)))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform random sample if above fails\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_cost\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"\n        Collision check between points with caching to avoid redundant checks.\n        Uses multiple intermediate checks to avoid missed collisions.\n        \"\"\"\n        key = (p1.x, p1.y, p2.x, p2.y)\n        if key in self._invalid_connections_cache:\n            return False\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            self._invalid_connections_cache.add(key)\n            return False\n        return True\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        \"\"\"\n        Extract the path and aggressively smooth it by repeated shortcut attempts,\n        pruning waypoints that cause sharp turns or redundant detours.\n        \"\"\"\n\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            changed = True\n            smoothed_path = list(path_points)\n            while changed:\n                changed = False\n                new_path = [smoothed_path[0]]\n                i = 0\n                while i < len(smoothed_path) - 1:\n                    j = len(smoothed_path) - 1\n                    found_shortcut = False\n                    while j > i + 1:\n                        p_i = smoothed_path[i].position\n                        p_j = smoothed_path[j].position\n                        if self._can_connect(p_i, p_j):\n                            new_path.append(smoothed_path[j])\n                            i = j\n                            found_shortcut = True\n                            changed = True\n                            break\n                        j -= 1\n                    if not found_shortcut:\n                        new_path.append(smoothed_path[i+1])\n                        i += 1\n                smoothed_path = new_path\n            return smoothed_path\n\n        def prune_sharp_turns(path_points: List[Vertex], angle_threshold_degree: float = 60) -> List[Vertex]:\n            # Prune vertices that create sharp turns > threshold angle to smooth path further\n            if len(path_points) < 3:\n                return path_points\n            pruned_path = [path_points[0]]\n            for i in range(1, len(path_points)-1):\n                p_prev = path_points[i-1].position.to_tensor()\n                p_curr = path_points[i].position.to_tensor()\n                p_next = path_points[i+1].position.to_tensor()\n                v1 = (p_curr - p_prev)\n                v2 = (p_next - p_curr)\n                if torch.norm(v1) == 0 or torch.norm(v2) == 0:\n                    pruned_path.append(path_points[i])\n                    continue\n                v1_norm = v1 / torch.norm(v1)\n                v2_norm = v2 / torch.norm(v2)\n                cos_angle = torch.clamp(torch.dot(v1_norm, v2_norm), -1.0, 1.0)\n                angle = math.degrees(math.acos(cos_angle))\n                if angle < angle_threshold_degree:\n                    pruned_path.append(path_points[i])\n            pruned_path.append(path_points[-1])\n            return pruned_path\n\n        # Apply iterative shortcut smoothing + pruning\n        path = try_shortcut(path)\n        path = prune_sharp_turns(path)\n        path = try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 7000\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                return  # Failed to find path within time\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue  # skip if sampled point is identical to existing vertex\n\n            # Adaptive step size based on distance and iteration progress\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            iteration_factor = max(0.1, (1.0 - iteration / max_iterations))\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal * 0.4 * iteration_factor))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision-free connection with caching\n            if not self._can_connect(q_nearest.position, q_new.position):\n                continue\n\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 28.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent based on cost + heuristic (A* style)\n            q_min = q_nearest\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            c_min = q_nearest.cost + dist_qnearest_qnew\n\n            for q_near in neighbors:\n                dist_qnear_qnew = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_qnear_qnew\n                if cost_through_neighbor < c_min and self._can_connect(q_near.position, q_new.position):\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors only if cost beneficial and connection collision free\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_qnew_qnear = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_qnew_qnear\n                if cost_through_new < q_near.cost and self._can_connect(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Try linking goal if close enough and collision-free\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_dist * 1.1 and self._can_connect(q_new.position, self._goal_vertex.position):\n                self._goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, self._goal_vertex)\n                self._extract_and_smooth_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT that incorporates goal-biased sampling, adaptive step size,\n    rewiring (inspired by RRT*) for path optimization, and path shortcutting. Sampling is biased towards the\n    goal with a probability to speed convergence. The step size max_dist adapts based on proximity to obstacles\n    to allow safer expansion. The rewiring step improves path quality by attempting to reduce vertex costs and\n    thus smooth the path as the tree grows. After reaching the goal, a shortcutting process attempts to simplify\n    the path under obstacle constraints. Early stopping if a solution is found or if over 10 seconds elapsed.\n    This improves path quality, success rate, and reduces iterations needed compared to basic RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # enable rewiring\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive step size: smaller when close to obstacles, larger in open space.\n        Check adjacent points in 8 directions; if many obstacles nearby, reduce max_dist.\n        \"\"\"\n        grid = self._get_grid()\n        # directions: 8-neighbors\n        directions = [Point(dx, dy) for dx in [-1,0,1] for dy in [-1,0,1] if not (dx == 0 and dy == 0)]\n        obstacle_count = 0\n        for d in directions:\n            neighbor = Point(pos.x + d.x, pos.y + d.y)\n            if not grid.is_agent_valid_pos(neighbor):\n                obstacle_count += 1\n        # More adjacent obstacles -> smaller max_dist, minimal 3, maximal 15\n        max_dist = 15 - 2 * obstacle_count\n        if max_dist < 3:\n            max_dist = 3\n        return max_dist\n\n    def _get_goal_biased_sample(self, goal_bias: float = 0.2) -> Point:\n        \"\"\"\n        With a probability goal_bias, sample the goal directly to bias tree expansion.\n        Otherwise, sample randomly in the grid.\n        \"\"\"\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Get vertices near q_new within a given radius. Used for rewiring.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new_pos: Point) -> (Vertex, float):\n        \"\"\"\n        Choose the best parent for q_new among q_near_list that yields minimum cost path,\n        Also check line validity before connecting.\n        Returns (parent_vertex, cost)\n        \"\"\"\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float('inf')\n        for q_near in q_near_list:\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new_pos)\n            if new_cost < best_cost:\n                best_cost = new_cost\n                best_parent = q_near\n        return best_parent, best_cost\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to connect nearby vertices through q_new if that decreases their cost.\n        \"\"\"\n        grid = self._get_grid()\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + grid.get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # remove old edges: find old parents and remove connection\n                for old_parent in list(q_near.parents):\n                    self._graph.remove_edge(old_parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut the path by connecting non-adjacent vertices if the path is free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n\n        grid = self._get_grid()\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from q_new to start and shortcut path.\n        Move the agent along the path stepwise with key frames.\n        \"\"\"\n        path: List[Vertex] = [q_new]\n        # Trace parents to start\n        current = q_new\n        while len(current.parents) != 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        path.reverse()  # start -> goal order\n\n        # Shortcut path for smoothness\n        path = self._shortcut_path(path)\n\n        # Animate agent movement along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_total_iterations = 10000\n        goal_reached = False\n\n        for iteration in range(max_total_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached, stop planning\n                break\n\n            # Goal biased sampling\n            q_sample: Point = self._get_goal_biased_sample(goal_bias=0.2)\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max distance step size\n            adaptive_max_dist: float = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            # Check line validity from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near vertices around q_new for rewiring (RRT* style)\n            radius = adaptive_max_dist * 2.0\n            near_vertices = self._get_near_vertices(q_new, radius)\n\n            # Choose best parent for q_new from near vertices + q_near\n            candidates = near_vertices + [q_near]\n            parent, cost = self._choose_parent(candidates, q_new.position)\n            if parent is None:\n                continue  # no valid parent found\n\n            # Set q_new cost and add edge to graph\n            q_new.cost = cost\n            self._graph.add_edge(parent, q_new)\n\n            # Rewiring neighbors with q_new for possible better paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal reached (within radius)\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect final goal vertex properly\n                goal_vertex = Vertex(grid.goal.position)\n                # Check if path from q_new to goal is valid\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    goal_reached = True\n                else:\n                    self._extract_path(q_new)\n                    goal_reached = True\n                break\n\n            self.key_frame()\n\n        if not goal_reached:\n            # Could optionally implement fallback or reporting here\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm builds upon the RRT* framework with several enhancements to improve clearance, \n    path quality, and planning efficiency. It incorporates:\n    - Clearance-guided sampling to avoid proximity to obstacles, by rejecting samples within a clearance threshold.\n    - Adaptive step size adjustment that scales with clearance and distance to goal to balance exploration and fine control.\n    - Heuristic cost-to-go incorporation in rewiring and parent selection to bias exploration towards promising nodes.\n    - Early stopping when a sufficiently good path is found below a cost threshold.\n    - Aggressive shortcut smoothing applied iteratively to refine the final path for smoothness.\n    - Timeout handling to ensure timely termination.\n    The algorithm maintains rewiring to gradually optimize path costs and uses goal biasing for goal-directed growth.\n    Overall, it aims to produce smoother, shorter, and safer paths with higher success rates and fewer iterations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0        # maximum step size for extension\n        self._goal_sample_rate = 0.2      # probability of sampling the goal to bias growth\n        self._iterations_limit = 10000    # max iterations\n        self._rewire_radius = 20.0        # radius to attempt rewiring for optimization\n        self._clearance_threshold = 3.0   # minimum clearance distance from obstacles to accept a sample\n        self._early_stop_cost_threshold = 1.5 * self._get_distance(self._get_grid().agent.position, self._get_grid().goal.position)  # acceptable cost to stop early\n\n    def _is_sample_clear(self, sample: Point) -> bool:\n        \"\"\"\n        Check if a sample point is sufficiently far from all obstacles by a clearance threshold.\n        \"\"\"\n        for obstacle in self._get_grid().obstacles:\n            dist = self._get_distance(sample, obstacle.position) - obstacle.radius\n            if dist < self._clearance_threshold:\n                return False\n        return True\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"\n        Returns minimum clearance distance from point to any obstacle.\n        \"\"\"\n        min_clearance = float(\"inf\")\n        for obstacle in self._get_grid().obstacles:\n            dist = self._get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_clearance:\n                min_clearance = dist\n        return min_clearance\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling with probability goal_sample_rate and clearance rejection\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample) and self._is_sample_clear(sample):\n                return sample\n\n    def _heuristic_cost_to_go(self, point: Point) -> float:\n        \"\"\"\n        Heuristic estimate of cost-to-go from point to goal: Euclidean distance + clearance penalty\n        \"\"\"\n        dist = self._get_distance(point, self._get_grid().goal.position)\n        clearance = self._get_clearance(point)\n        clearance_penalty = 0.0\n        if clearance < self._clearance_threshold:\n            clearance_penalty = (self._clearance_threshold - clearance) * 10.0  # Penalize low clearance strongly\n        return dist + clearance_penalty\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, vertices: List[Vertex]) -> Vertex:\n        # Enhanced parent selection with heuristic bias and clearance validity\n        cost_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position) + self._heuristic_cost_to_go(q_new.position)\n        best_parent = q_near\n\n        for v in vertices:\n            if v == q_near:\n                continue\n            cost_to_new = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position) + self._heuristic_cost_to_go(q_new.position)\n            if cost_to_new < cost_min:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line) and self._is_sample_clear(q_new.position):\n                    cost_min = cost_to_new\n                    best_parent = v\n        q_new.cost = cost_min - self._heuristic_cost_to_go(q_new.position)  # store real cost without heuristic\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if cost improves considering clearance and heuristic\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position) + self._heuristic_cost_to_go(v.position)\n            if cost_through_new < v.cost + self._heuristic_cost_to_go(v.position):\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line) and self._is_sample_clear(v.position):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new - self._heuristic_cost_to_go(v.position)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n\n        # Adjust max_dist based on clearance at q_near and distance to goal for adaptive step size\n        clearance = max(self._clearance_threshold, self._get_clearance(q_near.position))\n        dist_to_goal = self._get_distance(q_near.position, self._get_grid().goal.position)\n        scale = min(1.0, clearance / (2.0 * self._clearance_threshold))  # more clearance -> longer steps\n        scale *= min(1.0, dist_to_goal / (5 * self._max_dist_base))  # near goal -> smaller steps\n\n        adaptive_max_dist = max(1.0, max_dist * scale)\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + adaptive_max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Iterative shortcut smoothing for improved path quality\n        if len(path) < 3:\n            return path\n        smoothed_path = path[:]\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            new_path = [smoothed_path[0]]\n            while i < len(smoothed_path) - 1:\n                j = len(smoothed_path) - 1\n                while j > i + 1:\n                    line = self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line):\n                        new_path.append(smoothed_path[j])\n                        i = j\n                        improved = True\n                        break\n                    j -= 1\n                else:\n                    new_path.append(smoothed_path[i + 1])\n                    i += 1\n            smoothed_path = new_path\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_goal_vertex: Vertex = None\n        best_goal_cost = float(\"inf\")\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached: treat as no path found and break\n                break\n\n            q_sample = self._get_random_sample()\n            root_verts = self._graph.root_vertices\n\n            q_near = self._get_nearest_vertex(root_verts, q_sample)\n            dist_to_goal = self._get_distance(q_near.position, goal_vertex.position)\n            max_dist = min(self._max_dist_base, dist_to_goal * 1.2)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line) or not self._is_sample_clear(q_new.position):\n                continue\n\n            neighbors = self._get_vertices_within_radius(root_verts, q_new.position, self._rewire_radius)\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(q_new, neighbors)\n            self._graph.root_vertices.append(q_new)\n\n            # Check connection to goal with clearance consideration\n            if self._get_distance(q_new.position, goal_vertex.position) <= max_dist:\n                goal_line = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line) and self._is_sample_clear(goal_vertex.position):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.root_vertices.append(goal_vertex)\n                    path_found = True\n                    best_goal_vertex = goal_vertex\n                    best_goal_cost = goal_vertex.cost\n\n                    # Early stopping if path cost is sufficiently good\n                    if best_goal_cost <= self._early_stop_cost_threshold:\n                        break\n\n            self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            raw_path = self._extract_path(best_goal_vertex)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning Algorithm inspired by RRT* with enhanced collision clearance.\n    Key improvements:\n    - Clearance-aware adaptive step size: max step size dynamically reduced near obstacles,\n      promoting safer expansions and fewer collisions.\n    - Clearance-biased sampling: samples near known safe regions more frequently for robust exploration.\n    - Heuristic-guided vertex expansion combining path cost + Euclidean + clearance penalty.\n    - Rewiring vertices for path optimality (like RRT*), prioritizing clearance.\n    - Early stopping after 10 seconds or upon goal connection.\n    - Post-path extraction shortcut smoothing.\n    This algorithm improves robustness, success rate, and path quality by integrating clearance awareness \n    into sampling, expansion, and cost evaluation steps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._clearance_safety_margin = 2.0  # Clearance margin in grid units\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"\n        Estimate clearance (distance) from obstacles at the given point.\n        Returns a clearance value >=0, higher means more free space.\n        \"\"\"\n        grid = self._get_grid()\n        # Check clearance in a radius around point; minimal manhattan distance to obstacle tiles\n        clearance_radius = int(self._clearance_safety_margin)\n        size = grid.size\n        min_dist = float('inf')\n        for dx in range(-clearance_radius, clearance_radius + 1):\n            for dy in range(-clearance_radius, clearance_radius + 1):\n                if self._dimension == 2:\n                    nx, ny = point.x + dx, point.y + dy\n                    if not (0 <= nx < size[0] and 0 <= ny < size[1]):\n                        continue\n                    neighbor = Point(nx, ny)\n                    if neighbor in {obstacle.position for obstacle in grid.obstacles}:\n                        dist = abs(dx) + abs(dy)\n                        if dist < min_dist:\n                            min_dist = dist\n                else:\n                    # For n-dimensional, simply check points offset within radius cube\n                    coords = list(point)\n                    valid = True\n                    dist = 0\n                    for i in range(self._dimension):\n                        coord = point[i] + (dx if i == 0 else dy if i == 1 else 0)\n                        if coord < 0 or coord >= size[i]:\n                            valid = False\n                            break\n                        dist += abs(dx) if i == 0 else abs(dy) if i == 1 else 0\n                    if not valid:\n                        continue\n                    # Check obstacle presence at this coordinate; fallback skip for >2D\n                    # Only implemented for 2D clearly, fallback max clearance for >2D\n                    return 5.0\n        if min_dist == float('inf'):\n            return 5.0  # max clearance if no nearby obstacle found\n        return min_dist\n\n    def _sample_near_safe_region(self) -> Point:\n        \"\"\"\n        Sample points with bias toward known vertices with high clearance.\n        Tries to sample around safe vertices to improve clearance in path.\n        \"\"\"\n        safe_vertices = [v for v in self._graph.root_vertices[0].children.union({self._start_vertex}) if self._get_clearance(v.position) > self._clearance_safety_margin]\n        grid = self._get_grid()\n        if not safe_vertices or random.random() < 0.2:\n            # Fall back to uniform random sampling or goal sampling\n            return self._get_random_sample(0, 1)\n        # Pick a safe vertex randomly and sample in vicinity (Gaussian)\n        base_vertex = random.choice(safe_vertices)\n        sigma = max(1.0, self._max_dist_initial / 4)\n        coords = []\n        for i in range(self._dimension):\n            val = base_vertex.position[i] + int(random.gauss(0, sigma))\n            val = max(0, min(grid.size[i] - 1, val))\n            coords.append(val)\n        sample = Point(*coords)\n        if grid.is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback uniform sampling if invalid\n            return self._get_random_sample(0, 1)\n\n    def _cost_function(self, from_vertex: Vertex, to_point: Point) -> float:\n        \"\"\"\n        Heuristic cost = current cost + Euclidean distance + penalty for low clearance (inverse clearance)\n        Encourages paths with higher clearance.\n        \"\"\"\n        euclidean_dist = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        clearance_val = self._get_clearance(to_point)\n        if clearance_val <= 0:\n            clearance_penalty = 50.0  # large penalty for zero clearance\n        else:\n            clearance_penalty = 1.0 / clearance_val\n        return from_vertex.cost + euclidean_dist + clearance_penalty\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 7000  # Slightly less iterations due to clearance overhead\n        iteration: int = 0\n        grid = self._get_grid()\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Failed to find path in time\n                return\n\n            # Mix clearance-biased sampling and goal biased sampling\n            prob_goal_sample = min(0.25 + 0.7 * (iteration / max_iterations), 0.95)\n            if random.random() < prob_goal_sample:\n                q_sample = self._goal_vertex.position\n            else:\n                q_sample = self._sample_near_safe_region()\n\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size based on distance + clearance near q_nearest (smaller near obstacles)\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n            clearance_nearest = self._get_clearance(q_nearest.position)\n            clearance_factor = min(1.0, clearance_nearest / (self._clearance_safety_margin + 1e-5))\n            max_dist = max(self._max_dist_min,\n                           min(self._max_dist_initial,\n                               dist_to_goal / 2.0 * clearance_factor))\n\n            # Compute direction vector and create new vertex at limited distance\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist = torch.norm(dir_vec).item()\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                q_new_tensor = q_nearest.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(q_new_tensor)\n\n            # Check collision-free path from q_nearest to q_new_pos\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Compute neighbor radius for rewiring similarly to RRT*\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            neighbors = self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n            # Choose best parent based on improved cost function (clearance-aware)\n            q_min = q_nearest\n            c_min = self._cost_function(q_nearest, q_new.position)\n\n            for q_near in neighbors:\n                cost_through_neighbor = self._cost_function(q_near, q_new.position)\n                line_seq_check = grid.get_line_sequence(q_near.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better cost via q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_check):\n                    continue\n                cost_through_new = self._cost_function(q_new, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal proximity and connect if possible\n            dist_to_goal_new = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n            if dist_to_goal_new <= max_dist:\n                line_seq_goal = grid.get_line_sequence(q_new.position, self._goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal_new\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired algorithm with goal biasing, adaptive max step size, and rewiring for path optimization.\n    - Uses goal-biased sampling to improve convergence speed.\n    - Adapts max_dist according to distance to the goal for efficient exploration.\n    - Implements rewiring step on nearby vertices to optimize path cost (RRT* style).\n    - Early stops if path found or time exceeds 10 seconds.\n    - Extracts and smooths path with shortcut attempts after completion.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable removal for rewiring\n        self._init_displays()\n        self._max_dist_base = 15.0              # base max step length\n        self._goal_sample_rate = 0.15           # 15% goal biased samples\n        self._rewire_radius = 25.0               # radius for rewiring neighbors\n\n    # Reuse _get_random_sample but add goal biasing\n    def _get_random_sample_goal_biased(self, goal_bias_rate: float) -> Point:\n        if random.random() < goal_bias_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = math.inf\n        for q_near in q_near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = q_near\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_vertices: List[Vertex]) -> None:\n        for q_near in q_near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old parent edge(s) if edges are removable\n                parents_to_remove = list(q_near.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, q_near)\n                    q_near.cost = math.inf\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Backtrack from q_new to root start\n        path: List[Vertex] = [q_new]\n        current = q_new\n        while len(current.parents) != 0:\n            current = min(current.parents, key=lambda v: v.cost)\n            path.append(current)\n        path.reverse()\n\n        # Try shortcut smoothing: iteratively try skipping intermediate points\n        def try_shortcut(path_list: List[Vertex]) -> List[Vertex]:\n            if len(path_list) < 3:\n                return path_list\n            i = 0\n            while i < len(path_list) - 2:\n                j = i + 2\n                while j < len(path_list):\n                    line_seq = self._get_grid().get_line_sequence(path_list[i].position, path_list[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # Shortcut found, remove intermediate vertices\n                        del path_list[i+1:j]\n                        j = i + 2\n                    else:\n                        j += 1\n                i += 1\n            return path_list\n\n        path = try_shortcut(path)\n\n        # Add connection to goal if not exact\n        goal_pos = self._get_grid().goal.position\n        if path[-1].position != goal_pos:\n            goal_v = Vertex(goal_pos)\n            self._graph.add_edge(path[-1], goal_v)\n            path.append(goal_v)\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        dist = self._get_grid().get_distance(current_pos, goal_pos)\n        # Reduce max_dist as agent gets closer to goal, min 3, max self._max_dist_base\n        return max(3.0, min(self._max_dist_base, dist / 2))\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        goal_pos: Point = self._get_grid().goal.position\n\n        # Initialize the start vertex cost to 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        max_iterations = 8000\n\n        for i in range(max_iterations):\n            # Stop if taking too long (>10 seconds)\n            if time.time() - start_time > 10:\n                # Failed to find path within time limit\n                break\n\n            q_sample: Point = self._get_random_sample_goal_biased(self._goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position, goal_pos)\n            dir = q_sample.to_tensor() - q_near.position.to_tensor()\n            if torch.norm(dir) <= 1e-6:\n                continue\n\n            dir_normalized = dir / torch.norm(dir)\n            q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            q_new = Vertex(q_new_pos)\n            q_new.cost = math.inf  # initialize cost before choosing parent\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Choose parent with lowest cost from near vertices\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                # If no valid parent found in radius, connect to nearest if collision-free\n                parent_vertex = q_near\n                q_new.cost = parent_vertex.cost + self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire nearby neighbors to q_new if this improves cost\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm combining RRT* with goal biasing and adaptive step size.\n    The algorithm dynamically adjusts the step size based on distance to goal for efficient exploration.\n    It incorporates rewiring of vertices within a radius to optimize path cost (RRT* style).\n    The sampling is goal-biased to improve convergence speed.\n    Early stopping is enforced if the search exceeds 10 seconds.\n    Path extraction includes simple shortcut smoothing to improve path quality.\n    The algorithm aims to improve planning efficiency, path smoothness, robustness, and success rate while reducing memory overhead by avoiding redundant expansions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow removing edges for rewiring in RRT*\n        self._start_time = None\n        self._max_time_sec = 10\n        self._goal_bias = 0.2  # 20% probability to sample goal directly\n        self._max_step = 15.0\n        self._min_step = 5.0\n        self._rewire_radius = 20.0\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_goal_vertex: Vertex) -> None:\n        # Extract path by backtracking parents\n        path: List[Vertex] = [q_goal_vertex]\n        current = q_goal_vertex\n        while len(current.parents) != 0:\n            # pick parent with minimum cost (in case of multiple parents)\n            min_cost_parent = None\n            min_cost = math.inf\n            for parent in current.parents:\n                if parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_cost_parent = parent\n            current = min_cost_parent\n            path.append(current)\n        path.reverse()\n\n        # Simple path shortcut smoothing\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            last = smoothed_path[-1]\n            # Check line of sight from last smoothed path vertex to current path vertex\n            line_seq = self._get_grid().get_line_sequence(last.position, path[i].position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                # Can't connect directly, append the previous vertex before this unreachable one\n                smoothed_path.append(path[i-1])\n            # else continue to check next vertices (skip intermediate)\n        # Make sure last vertex is the goal\n        if smoothed_path[-1] != path[-1]:\n            smoothed_path.append(path[-1])\n\n        # Animate the path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], point)\n\n    def _get_vertices_in_radius(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, radius)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for _ in range(iterations):\n            if time.time() - self._start_time > self._max_time_sec:\n                # Timeout - route not found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on distance to goal (smaller step near goal)\n            dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = self._max_step * (dist_to_goal / self._get_grid().size.width)\n            max_dist = max(self._min_step, min(max_dist, self._max_step))\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost from q_near to q_new\n            cost_to_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            # Initialize q_new with infinite cost; cost will be updated in rewiring step\n            q_new.cost = float(\"inf\")\n\n            # Find neighbors for rewiring within radius\n            neighbors = self._get_vertices_in_radius(q_new.position, self._rewire_radius)\n\n            # Choose parent with minimum cost + cost from parent to q_new\n            min_cost = cost_to_new\n            min_parent = q_near\n\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue  # already evaluated\n                # Check if line is valid from neighbor to q_new\n                line_seq_n = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = neighbor\n\n            # Assign min cost and add edge to parent\n            q_new.cost = min_cost\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire neighbors if q_new offers a cheaper path to them\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                line_seq_n = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old edges from parents\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    # Add new edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if q_new is in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect last vertex to goal vertex and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                # validate connection to goal vertex\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm incorporating:\n    - Goal-biased adaptive sampling with dynamic probability shaping for more efficient goal convergence\n    - Adaptive step size that shrinks near crowded or goal regions, enabling precise expansions\n    - Heuristic-driven vertex expansion combining path cost + Euclidean distance (A*-style)\n    - Efficient rewiring for path optimality (RRT* inspired)\n    - Neighborhood radius dynamically adjusted with tree growth and dimension\n    - Early stopping on successful goal connection or 10 seconds timeout\n    - Path shortcut smoothing via collision-free direct-connect attempts on extracted path\n    - Memory-efficient management by limiting neighbors, pruning costly branches, and reducing redundant expansions\n    - Robustness: Checks for valid samples and connections before graph updates\n    - Clear and concise vertex and edge management ensuring minimal graph bloat\n    \"\"\"\n    \n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # reduced iterations for efficiency while maintaining thoroughness\n        iteration: int = 0\n        timeout_sec: float = 10.0\n        self._start_time = time.perf_counter()\n        last_goal_connect_iter: int = -1\n\n        # Precompute constants for radius calculation\n        dim = self._dimension\n        lambda_rrt_star = self._lambda_rrt_star\n        max_dist_initial = self._max_dist_initial\n        max_dist_min = self._max_dist_min\n        goal_pos = self._goal_vertex.position\n        start_vertex = self._start_vertex\n        graph = self._graph\n        grid = self._get_grid()\n\n        def adaptive_sampling_prob(iter_i: int, max_iter: int) -> float:\n            # Non-linear goal biasing, starts low and grows faster closer to max_iter\n            base_prob = 0.15\n            growth_factor = 0.9\n            progress_ratio = iter_i / max_iter\n            return min(base_prob + growth_factor * (progress_ratio ** 2), 0.98)\n\n        def compute_radius(cardinality: float) -> float:\n            # Adaptive radius shrinking with graph size, capped max radius\n            if cardinality <= 1.0:\n                return 30.0\n            log_card = math.log(cardinality)\n            rad = lambda_rrt_star * ((log_card / cardinality) ** (1.0 / dim))\n            return min(rad, 30.0)\n\n        def heuristic_cost(from_vertex: Vertex, to_point: Point) -> float:\n            # Cost = accumulated cost + Euclidean dist to point\n            return from_vertex.cost + torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor()).item()\n\n        def can_connect_valid(p1: Point, p2: Point) -> bool:\n            line_seq = grid.get_line_sequence(p1, p2)\n            return grid.is_valid_line_sequence(line_seq)\n\n        def shortcut_path(path_vertices: List[Vertex]) -> List[Vertex]:\n            # Attempt shortcuts in path by direct connection check\n            if len(path_vertices) < 3:\n                return path_vertices\n            smoothed = [path_vertices[0]]\n            i = 0\n            while i < len(path_vertices) - 1:\n                j = len(path_vertices) - 1\n                connected = False\n                while j > i + 1:\n                    if can_connect_valid(path_vertices[i].position, path_vertices[j].position):\n                        smoothed.append(path_vertices[j])\n                        i = j\n                        connected = True\n                        break\n                    j -= 1\n                if not connected:\n                    smoothed.append(path_vertices[i + 1])\n                    i += 1\n            return smoothed\n\n        def extract_and_smooth_path(connection_vertex: Vertex) -> None:\n            # Extract path by traversing parents up to start\n            path: List[Vertex] = []\n            curr = connection_vertex\n            while curr is not None:\n                path.append(curr)\n                if len(curr.parents) == 0:\n                    break\n                curr = next(iter(curr.parents))\n            path.reverse()\n\n            smooth_path = shortcut_path(path)\n            for v in smooth_path:\n                self.move_agent(v.position)\n                if hasattr(grid, \"publish_wp\"):\n                    grid.publish_wp(grid.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            # Early stop on timeout\n            if (time.perf_counter() - self._start_time) > timeout_sec:\n                return\n\n            # Goal-biased adaptive sampling\n            goal_sample_prob = adaptive_sampling_prob(iteration, max_iterations)\n            if random.random() < goal_sample_prob:\n                q_sample = goal_pos\n            else:\n                # Uniform random sampling with validity check\n                while True:\n                    coords = [random.randint(0, grid.size[i] - 1) for i in range(dim)]\n                    sample_point = Point(*coords)\n                    if grid.is_agent_valid_pos(sample_point):\n                        q_sample = sample_point\n                        break\n\n            # Find nearest vertex to sample\n            q_nearest = graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Compute dynamic step size: shrinks near goal and when locally dense\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - goal_pos.to_tensor()).item()\n            max_dist = max(max_dist_min, min(max_dist_initial, dist_to_goal / 2.0))\n\n            # Generate new vertex toward q_sample but limited by max_dist\n            direction = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_sample = torch.norm(direction).item()\n            if dist_sample <= max_dist:\n                q_new_pos = q_sample\n            else:\n                norm_dir = direction / dist_sample\n                new_pos_tensor = q_nearest.position.to_tensor() + norm_dir * max_dist\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check connection collision free from nearest to new\n            if not can_connect_valid(q_nearest.position, q_new_pos):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = float(\"inf\")\n\n            # Compute radius for neighborhood search based on current graph size\n            cardinality = max(1, float(graph.size))\n            radius = compute_radius(cardinality)\n\n            neighbors = graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent from neighbors based on minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            for q_near in neighbors:\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                new_cost = q_near.cost + dist_neighbor_to_new\n                if new_cost < c_min and can_connect_valid(q_near.position, q_new.position):\n                    q_min = q_near\n                    c_min = new_cost\n\n            q_new.cost = c_min\n            graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if beneficial via new vertex\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_via_new = q_new.cost + dist_new_to_near\n                if cost_via_new < q_near.cost and can_connect_valid(q_new.position, q_near.position):\n                    # Remove old parent edge(s)\n                    parents = list(q_near.parents)\n                    for p in parents:\n                        graph.remove_edge(p, q_near)\n                    q_near.cost = cost_via_new\n                    graph.add_edge(q_new, q_near)\n\n            # If close enough to goal, attempt connection and finish if valid\n            goal_dist = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            if goal_dist <= max_dist and can_connect_valid(q_new.position, goal_pos):\n                self._goal_vertex.cost = q_new.cost + goal_dist\n                graph.add_edge(q_new, self._goal_vertex)\n                extract_and_smooth_path(q_new)\n                return\n\n            # Key frame for visualization/animation\n            self.key_frame()\n\n        # If path not found within max iterations or timeout\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Bidirectional Heuristic Search with Adaptive Sampling and \n    Progressive Path Refinement on a discrete grid. It maintains two expanding forests from start and goal \n    simultaneously, attempting to connect them efficiently by prioritizing vertices with lowest combined cost \n    (cost-to-come + heuristic-to-goal/start). \n\n    Key features:\n    - Bidirectional growth from start and goal to reduce search space and planning time.\n    - Priority expansion based on heuristic cost (similar to A*), focusing growth towards the other tree.\n    - Adaptive samples biased around tree frontiers with exploration radius shrinking over iterations.\n    - Attempt connections between the two trees within a dynamic radius for early path discovery.\n    - Progressive path extraction and smoothing on early connect, ensuring shorter, higher quality paths.\n    - Early stopping on first successful connection or timeout (>10 seconds).\n    - Dynamic step sizing based on local density to avoid overshooting in narrow passages.\n    - Maintains a CyclicGraph allowing multiple parentage for richer rewiring possibilities.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_runtime_seconds: float\n    _start_time: float\n    _dimension: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _heuristic(self, v1: Vertex, v2: Vertex) -> float:\n        delta = v1.position.to_tensor() - v2.position.to_tensor()\n        return float(torch.norm(delta))\n\n    def _get_new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample_around_vertex(self, center: Point, radius: int) -> Point:\n        grid_size = self._get_grid().size\n        attempts = 0\n        while True:\n            attempts += 1\n            if attempts > 1000:\n                # Fallback to uniform random in grid if radius sampling fails repeatedly\n                rand_coords = [random.randint(0, grid_size[i] - 1) for i in range(self._dimension)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # Sample coords bounded to radius ball around center\n            coords = []\n            for i in range(self._dimension):\n                low = max(center[i] - radius, 0)\n                high = min(center[i] + radius, grid_size[i] - 1)\n                coord = random.randint(low, high)\n                coords.append(coord)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_connect(self, vertex_from: Vertex, vertex_to: Vertex, max_dist: float) -> Vertex or None:\n        # Attempt direct connection if within max_dist and line valid\n        dist = self._heuristic(vertex_from, vertex_to)\n        if dist > max_dist:\n            return None\n        line_seq = self._get_grid().get_line_sequence(vertex_from.position, vertex_to.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        # Return a new vertex at target to connect\n        new_vertex = Vertex(vertex_to.position, store_connectivity=True)\n        new_vertex.cost = vertex_from.cost + dist\n        self._graph.add_edge(vertex_from, new_vertex)\n        return new_vertex\n\n    def _extract_bidirectional_path(self, vertex_from_start: Vertex, vertex_from_goal: Vertex) -> None:\n        # Extract path from start tree vertex (up to root)\n        path_start = []\n        current = vertex_from_start\n        while current is not None:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with smallest cost\n            current = min(current.parents, key=lambda p: p.cost)\n        path_start.reverse()\n\n        # Extract path from goal tree vertex (up to root)\n        path_goal = []\n        current = vertex_from_goal\n        while current is not None:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n\n        # Concatenate paths (goal tree reversed, exclude duplicated connecting vertex)\n        full_path = path_start + path_goal[1:]\n\n        # Shortcut path smoothing by connecting non-adjacent vertices directly\n        def shortcut_path(path_vertices: List[Vertex]) -> List[Vertex]:\n            smoothed = [path_vertices[0]]\n            i = 0\n            while i < len(path_vertices) - 1:\n                j = len(path_vertices) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_vertices[i].position, path_vertices[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed.append(path_vertices[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed.append(path_vertices[i+1])\n                    i += 1\n            return smoothed\n\n        smoothed_path = shortcut_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 5000\n        iteration = 0\n        radius_initial = 30\n        radius_min = 5\n        step_initial = 10.0\n        step_min = 2.0\n\n        # Separate root lists for bidirectional exploration\n        start_roots = [self._start_vertex]\n        goal_roots = [self._goal_vertex]\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout: fail gracefully\n                return\n\n            # Determine adaptive radius and step for sampling and expansion (shrinks over time)\n            radius = max(radius_min, int(radius_initial * (1 - iteration / max_iterations)))\n            step = max(step_min, step_initial * (1 - iteration / max_iterations))\n\n            # Alternate sampling sides: odd iter from start tree, even iter from goal tree\n            if iteration % 2 == 1:\n                # Sample around frontier of start tree\n                q_frontier_candidates = start_roots\n                q_sample_base = random.choice(q_frontier_candidates).position\n                q_sample = self._get_random_sample_around_vertex(q_sample_base, radius)\n                # Find nearest vertex in start tree\n                q_nearest = self._graph.get_nearest_vertex(start_roots, q_sample)\n                q_new = self._get_new_vertex_towards(q_nearest, q_sample, step)\n\n                # Check line validity\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                    continue\n\n                # Assign cost and add to graph\n                dist = self._heuristic(q_nearest, q_new)\n                q_new.cost = q_nearest.cost + dist\n                self._graph.add_edge(q_nearest, q_new)\n                self._graph.root_vertices.append(q_new)  # expand roots\n\n                # Try to connect to goal tree within radius\n                neighbors_goal = self._graph.get_vertices_within_radius(goal_roots, q_new.position, radius)\n                connected = False\n                for q_goal_near in neighbors_goal:\n                    q_connect = self._try_connect(q_new, q_goal_near, step)\n                    if q_connect:\n                        self._extract_bidirectional_path(q_connect, q_goal_near)\n                        connected = True\n                        break\n                if connected:\n                    return\n            else:\n                # Sample around frontier of goal tree\n                q_frontier_candidates = goal_roots\n                q_sample_base = random.choice(q_frontier_candidates).position\n                q_sample = self._get_random_sample_around_vertex(q_sample_base, radius)\n                # Find nearest vertex in goal tree\n                q_nearest = self._graph.get_nearest_vertex(goal_roots, q_sample)\n                q_new = self._get_new_vertex_towards(q_nearest, q_sample, step)\n\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                    continue\n\n                dist = self._heuristic(q_nearest, q_new)\n                q_new.cost = q_nearest.cost + dist\n                self._graph.add_edge(q_nearest, q_new)\n                self._graph.root_vertices.append(q_new)  # expand roots\n\n                # Try to connect to start tree within radius\n                neighbors_start = self._graph.get_vertices_within_radius(start_roots, q_new.position, radius)\n                connected = False\n                for q_start_near in neighbors_start:\n                    q_connect = self._try_connect(q_new, q_start_near, step)\n                    if q_connect:\n                        self._extract_bidirectional_path(q_start_near, q_connect)\n                        connected = True\n                        break\n                if connected:\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm introduces a hybrid search strategy combining bidirectional heuristic sampling \n    and iterative deepening with adaptive pruning to improve efficiency and path quality.\n    \n    Key features:\n    - Bidirectional trees grown simultaneously from start and goal using Forest structure\n    - Heuristic-guided sampling biased towards the gap between the frontiers of both trees\n    - Adaptive max_dist step size that dynamically adjusts based on local clearance and tree density\n    - Iterative deepening with dynamic pruning of less promising vertices to focus computation\n    - Early stopping upon connection of the two trees with heuristic checks\n    - Local shortcut smoothing during path extraction improves finalized path quality\n    - Enforced 10-second max runtime to guarantee responsiveness\n    \n    This approach balances exploration between start and goal, aggressively prunes search space, \n    and adaptively refines path to provide faster convergence with smoother and more reliable paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    _max_dist_max: float\n    _max_dist_min: float\n    _dimension: int\n\n    _start_time: float\n    _max_runtime_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_max = 20.0\n        self._max_dist_min = 2.5\n        self._dimension = self._get_grid().size.n_dim\n\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n    def _bidirectional_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Generates a heuristic-biased sample point between the edges of start and goal trees.\n        Probability to sample directly on the middle between nearest frontier vertices improves path bridging.\n        \"\"\"\n        # Probability increase linearly with iterations to bias samples closer between closest start and goal vertices\n        sample_prob_goal = min(0.1 + 0.9 * (iteration / max_iterations), 0.9)\n\n        if random.random() < sample_prob_goal:\n            # Sample midpoint between nearest vertices in each tree to encourage connection\n            start_near = self._graph.get_nearest_vertex([self._start_vertex], self._goal_vertex.position)\n            goal_near = self._graph.get_nearest_vertex([self._goal_vertex], self._start_vertex.position)\n            midpoint_coords = (\n                (start_near.position.to_tensor() + goal_near.position.to_tensor()) / 2.0\n            )\n            sample_point = Point.from_tensor(midpoint_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Else random valid sample anywhere\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._dimension)]\n            sample_point = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _adaptive_max_dist(self, vertex: Vertex) -> float:\n        \"\"\"\n        Dynamically computes max_dist dependent on local obstacle clearance and number of nearby vertices.\n        Smaller step size near obstacles or crowded regions. Larger in open spaces.\n        \"\"\"\n        base = self._max_dist_max\n        clearance_factor = 1.0\n        nearby_factor = 1.0\n\n        # Estimate clearance from obstacles by checking line sequences in multiple random directions\n        directions = [\n            Point(1, 0),\n            Point(-1, 0),\n            Point(0, 1),\n            Point(0, -1),\n        ]\n        max_check_dist = 5\n        clearances = []\n        for d in directions:\n            check_point = vertex.position\n            count_clear = 0\n            for step in range(max_check_dist):\n                check_point = Point(check_point.x + d.x, check_point.y + d.y)\n                if not self._get_grid().is_agent_valid_pos(check_point):\n                    break\n                count_clear += 1\n            clearances.append(count_clear)\n        clearance_factor = min(clearances) / max_check_dist  # 0 (no clearance) to 1 (full clearance)\n\n        # Number of nearby vertices within radius affects step size\n        nearby_verts = self._graph.get_vertices_within_radius([self._start_vertex], vertex.position, radius=5)\n        nearby_count = len(nearby_verts)\n        # More vertices nearby, smaller step (crowded area)\n        nearby_factor = 1.0 / (1 + 0.2 * nearby_count)\n\n        dist = base * clearance_factor * nearby_factor\n        # Clamp to min/max limits\n        dist = max(self._max_dist_min, min(self._max_dist_max, dist))\n        return dist\n\n    def _extract_bidirectional_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Reconstruct path by walking parents backward from meet_vertex_start in start tree,\n        then parents backward from meet_vertex_goal in goal tree (edges reversed),\n        then concatenating and smoothing.\n        \"\"\"\n        path_start = []\n        v = meet_vertex_start\n        while v is not None:\n            path_start.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        path_goal = []\n        v = meet_vertex_goal\n        while v is not None:\n            path_goal.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n\n        # Combine paths and remove duplicate meet point\n        full_path = path_start + path_goal[1:]\n\n        # Shortcut smoothing\n        smoothed_path = [full_path[0]]\n        idx = 0\n        while idx < len(full_path) - 1:\n            next_idx = len(full_path) - 1\n            # Try shortcut from idx to farthest possible next_idx\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(full_path[idx].position, full_path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            smoothed_path.append(full_path[next_idx])\n            idx = next_idx\n\n        # Animate path following\n        for vert in smoothed_path:\n            self.move_agent(vert.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_forest(self, forest_side: List[Vertex], max_cost: float) -> None:\n        \"\"\"\n        Prunes vertices in the given forest (start or goal root vertices) whose cost exceeds max_cost by a margin.\n        This limits search space and keeps cost frontier tight.\n        \"\"\"\n        to_remove = []\n        margin = 5.0  # Allow some slack\n\n        def prune_fn(vertex: Vertex) -> bool:\n            if vertex.cost > max_cost + margin:\n                to_remove.append(vertex)\n                return False\n            return True\n\n        self._graph.walk_dfs_subset_of_vertices(forest_side, prune_fn)\n        for vertex in to_remove:\n            # Remove edges to parents and from parents\n            for parent in list(vertex.parents):\n                self._graph.remove_edge(parent, vertex)\n            for child in list(vertex.children):\n                self._graph.remove_edge(vertex, child)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 7000\n        iteration = 0\n\n        # Each tree: root vertices lists - for tracking pruning\n        start_roots = [self._start_vertex]\n        goal_roots = [self._goal_vertex]\n\n        # Initialize costs for root vertices of goal tree to 0 likewise start\n        self._goal_vertex.cost = 0.0\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            # Check elapsed time for early stopping\n            elapsed_time = time.perf_counter() - self._start_time\n            if elapsed_time > self._max_runtime_seconds:\n                return\n\n            # Alternate growth: odd iterations grow start tree, even grow goal tree\n            grow_start_tree = (iteration % 2) == 1\n\n            # Select which tree to grow\n            if grow_start_tree:\n                current_root = self._start_vertex\n                opposite_root = self._goal_vertex\n                root_list = start_roots\n                opposite_roots = goal_roots\n            else:\n                current_root = self._goal_vertex\n                opposite_root = self._start_vertex\n                root_list = goal_roots\n                opposite_roots = start_roots\n\n            # Sample biased near gap or random validation sampling\n            q_sample = self._bidirectional_sample(iteration, max_iterations)\n\n            # Nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex(root_list, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist == 0:\n                continue\n            dir_normalized = dir_vec / dist\n            if dist <= max_dist:\n                q_new_pos_tensor = q_sample.to_tensor()\n            else:\n                q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            # Validate position\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check collision line from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Compute cost to q_new\n            dist_qnear_qnew = torch.norm(q_new_pos_tensor - q_near.position.to_tensor())\n            q_new.cost = q_near.cost + dist_qnear_qnew\n\n            # Add q_new and edge to graph under correct root set\n            self._graph.add_edge(q_near, q_new)\n            root_list.append(q_new)\n\n            # Attempt to connect q_new to opposite tree vertices within radius\n            radius_connect = max_dist * 1.5\n            opposite_nearby = self._graph.get_vertices_within_radius(opposite_roots, q_new.position, radius_connect)\n\n            # Find if any vertex in opposite tree can connect to q_new safely\n            connection_found = False\n            meeting_vertex_opposite = None\n\n            for v_opposite in opposite_nearby:\n                line_conn = self._get_grid().get_line_sequence(q_new.position, v_opposite.position)\n                if self._get_grid().is_valid_line_sequence(line_conn):\n                    connection_found = True\n                    meeting_vertex_opposite = v_opposite\n                    break\n\n            if connection_found:\n                # Link the two vertices by edges in both directions for extraction\n                if grow_start_tree:\n                    self._graph.add_edge(q_new, meeting_vertex_opposite)\n                else:\n                    self._graph.add_edge(meeting_vertex_opposite, q_new)\n\n                # Extract full bidirectional path and smooth it\n                if grow_start_tree:\n                    self._extract_bidirectional_path(q_new, meeting_vertex_opposite)\n                else:\n                    self._extract_bidirectional_path(meeting_vertex_opposite, q_new)\n                return\n\n            # Prune both trees periodically every 500 iterations to control search space\n            if iteration % 500 == 0:\n                max_cost_start = min(v.cost for v in start_roots) + 30.0\n                max_cost_goal = min(v.cost for v in goal_roots) + 30.0\n                self._prune_forest(start_roots, max_cost_start)\n                self._prune_forest(goal_roots, max_cost_goal)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Advanced Dual-Tree Bi-directional RRT* with Informative Sampling and Path Optimization",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Advanced Dual-Tree Bi-directional RRT* with Informative Sampling and Path Optimization}\n\n    This algorithm runs two connected RRT* trees simultaneously: one rooted at the start and one at the goal.\n    Key innovations:\n    - Bi-directional growth: grow start-tree and goal-tree in tandem, attempt to connect both to find quicker paths.\n    - Informative sampling: samples focused dynamically within an ellipsoidal informed subset when a solution is found, \n      concentrating search efforts in promising regions.\n    - Adaptive max step size depending on progress and sampling region size.\n    - Rewiring for path optimality in both trees.\n    - Early stopping after a valid connection found and path smoothing.\n    - Uses a CyclicGraph to allow cyclic connections between the two trees and rewiring.\n    - Incorporates heuristic cost to guide tree expansion to reduce unnecessary exploration.\n    - Limits runtime to 10 seconds to avoid excessive planning time.\n    This approach improves efficiency by focusing sampling space, robustly connects start and goal, \n    and generates high quality smooth paths faster than conventional RRT* variants.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = CyclicGraph(self._services, self._start_vertex, self._goal_vertex, [])\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 30.0\n        self._solution_found = False\n        self._best_connection_cost = float(\"inf\")\n        self._best_connection_vertex_start = None\n        self._best_connection_vertex_goal = None\n        self._init_displays()\n\n    def _sample_in_ellipsoid(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample inside an ellipsoid defined by start and goal as foci and sum distance <= c_best.\n        If no solution found, sample uniformly in full space.\n        \"\"\"\n        if c_best == float(\"inf\"):\n            # No solution yet, sample uniformly valid in whole space\n            while True:\n                coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._dimension)]\n                p = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n        else:\n            # Ellipsoid sampling\n            start_np = start.to_tensor().numpy()\n            goal_np = goal.to_tensor().numpy()\n            center = (start_np + goal_np) / 2.0\n            c_min = np.linalg.norm(start_np - goal_np)\n            r1 = c_best / 2.0\n            r2 = math.sqrt(r1 ** 2 - (c_min / 2.0) ** 2) if c_min / 2.0 < r1 else 0.0\n            # Sample uniformly from unit ball\n            while True:\n                # Sample random point inside unit ball in n-dim\n                direction = np.random.normal(0, 1, self._dimension)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1.0 / self._dimension)\n                sample = direction * radius\n                # Stretch and shift sample into ellipsoid\n                # Align principal axis with start to goal vector\n                if self._dimension == 2:\n                    cos_theta = (goal_np[0] - start_np[0]) / c_min if c_min > 0 else 1.0\n                    sin_theta = (goal_np[1] - start_np[1]) / c_min if c_min > 0 else 0.0\n                    # Rotation matrix for 2D\n                    rot = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n                    stretch = np.diag([r1, r2])\n                    ellipsoid_point = rot.dot(stretch).dot(sample) + center\n                    coords = [int(round(x)) for x in ellipsoid_point]\n                else:\n                    # For higher dim, do approximate spherical stretch along primary axis\n                    # Use an axis aligned ellipsoid (a simplification)\n                    coords = []\n                    for i in range(self._dimension):\n                        r = r1 if i == 0 else r2\n                        coords.append(int(round(center[i] + r * sample[i])))\n                p = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n    def _reconstruct_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> List[Vertex]:\n        \"\"\"\n        Reconstruct full path from start to goal through connection vertices.\n        \"\"\"\n        path_start = []\n        current = connection_vertex_start\n        while current is not None:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        path_goal = []\n        current = connection_vertex_goal\n        while current is not None:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n\n        # Full path: start_tree path + reversed goal_tree path (excluding duplicate connection vertex)\n        full_path = path_start + path_goal[1:]\n        return full_path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Shortcut smoothing: attempt to connect non-adjacent path vertices directly.\n        \"\"\"\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Cost + Euclidean distance heuristic (A*-style)\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_cost\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float, root_vertices: List[Vertex]) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], p: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, p)\n\n    def _try_rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            cost_through_new = q_new.cost + dist_new_to_near\n            if cost_through_new < q_near.cost:\n                # Remove existing parent edge\n                q_near_parent = None\n                for parent in q_near.parents:\n                    q_near_parent = parent\n                    break\n                if q_near_parent is not None:\n                    self._graph.remove_edge(q_near_parent, q_near)\n                # Add edge from new parent q_new\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _grow_tree(self, root_vertices: List[Vertex], other_root_vertices: List[Vertex], q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Attempt to grow a tree rooted at root_vertices towards q_sample.\n        Return the new vertex if added, else None.\n        \"\"\"\n        q_near = self._get_nearest_vertex(root_vertices, q_sample)\n        if q_near.position == q_sample:\n            return None\n\n        q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Radius for neighbor search for rewiring; depends on size (cardinality) of tree\n        card_v = max(1.0, float(len(root_vertices)))\n        radius = min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / self._dimension)), 25.0)\n\n        neighbors = self._get_vertices_within_radius(q_new, radius, root_vertices)\n\n        q_min = q_near\n        c_min = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n        for q_near_cand in neighbors:\n            dist_neighbor_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_neighbor = q_near_cand.cost + dist_neighbor_to_new\n            line_seq_check = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                q_min = q_near_cand\n                c_min = cost_through_neighbor\n\n        q_new.cost = c_min\n        self._graph.add_edge(q_min, q_new)\n        root_vertices.append(q_new)\n\n        self._try_rewire(q_new, neighbors)\n\n        # Attempt to connect q_new to other tree vertices (attempt bridging)\n        radius_connect = max_dist * 1.5\n        neighbors_other = self._get_vertices_within_radius(q_new, radius_connect, other_root_vertices)\n        for q_other in neighbors_other:\n            line_seq_connect = self._get_grid().get_line_sequence(q_new.position, q_other.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                continue\n            dist_connect = torch.norm(q_new.position.to_tensor() - q_other.position.to_tensor())\n            potential_cost = q_new.cost + dist_connect + q_other.cost\n            if potential_cost < self._best_connection_cost:\n                # Connect trees bidirectionally\n                self._graph.add_edge(q_new, q_other)\n                self._best_connection_vertex_start = q_new if root_vertices[0] == self._start_vertex else q_other\n                self._best_connection_vertex_goal = q_other if root_vertices[0] == self._start_vertex else q_new\n                self._best_connection_cost = potential_cost\n                self._solution_found = True\n\n        return q_new\n\n    def _find_path_internal(self) -> None:\n        iter_limit = 6000\n        iter_count = 0\n\n        # Maintain lists of start tree and goal tree vertices separately for efficient management\n        start_tree_vertices = [self._start_vertex]\n        goal_tree_vertices = [self._goal_vertex]\n\n        max_dist = self._max_dist_initial\n        c_best = float(\"inf\")\n\n        while iter_count < iter_limit:\n            iter_count += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout with no solution\n                return\n\n            # Alternate tree growth (start=even iterations, goal=odd)\n            grow_start_tree = (iter_count % 2 == 0)\n\n            # Use informative sampling inside ellipsoid if solution found\n            if self._solution_found:\n                sample_point = self._sample_in_ellipsoid(\n                    self._start_vertex.position,\n                    self._goal_vertex.position,\n                    c_best\n                )\n            else:\n                # Uniform sampling anywhere valid\n                while True:\n                    coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._dimension)]\n                    sample_point = Point(*coords)\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        break\n\n            # Adaptive max_dist scales with c_best or falls back to initial max_dist\n            if self._solution_found and c_best < float(\"inf\"):\n                max_dist = max(self._max_dist_min, c_best / 4.0)\n            else:\n                max_dist = self._max_dist_initial\n\n            if grow_start_tree:\n                q_new = self._grow_tree(start_tree_vertices, goal_tree_vertices, sample_point, max_dist)\n            else:\n                q_new = self._grow_tree(goal_tree_vertices, start_tree_vertices, sample_point, max_dist)\n\n            # If solution found, reconstruct and smooth path, then finish\n            if self._solution_found:\n                # Update c_best with best connection cost\n                c_best = self._best_connection_cost\n\n                full_path = self._reconstruct_path(self._best_connection_vertex_start, self._best_connection_vertex_goal)\n                full_path = self._shortcut_path(full_path)\n\n                for vertex in full_path:\n                    self.move_agent(vertex.position)\n                    grid = self._get_grid()\n                    if hasattr(grid, \"publish_wp\"):\n                        grid.publish_wp(grid.agent.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This path planning algorithm uses a hybrid informed tree search approach inspired by \n    RRT*, Informed RRT*, and A* principles, but differing in structure by employing \n    dynamic informed sampling within a shrinking elliptical subset of the state space to \n    focus exploration efficiently towards the goal.\n    \n    Key features:\n    - Informed sampling inside an ellipsoid defined by the current best path cost and start-goal positions\n    - Dynamic shrinking of ellipsoid region as better paths are found to concentrate sampling\n    - Heuristic-guided vertex expansion using cost-so-far + Euclidean cost-to-go (A*-style)\n    - Rewiring to improve path optimality (like RRT*)\n    - Adaptive max step size reducing near goal and as cost improves\n    - Early stopping when path found or after 10 seconds runtime\n    - Shortcut smoothing on extracted path to improve quality\n    - Uses Forest graph as backbone data structure\n    \n    This design strives to improve planning efficiency by guiding sampling adaptively, \n    improving path quality with rewiring and smoothing, and increasing success rates with goal bias and dynamic region focusing.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _max_runtime_seconds: float\n    _best_cost: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._best_cost = float('inf')  # Store best path cost found so far\n        self._init_displays()\n\n    def _sample_in_ellipse(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Samples uniformly within an elliptical informed subset to guide toward better paths.\n        Ellipse defined by start, goal, and current best path cost.\n        Falls back to uniform sampling if no path found yet.\n        \"\"\"\n        start_np = self._start_vertex.position.to_numpy()\n        goal_np = self._goal_vertex.position.to_numpy()\n        dist_start_goal = np.linalg.norm(goal_np - start_np)\n        if self._best_cost == float('inf'):\n            # No path found yet: uniform random sampling with small goal bias\n            prob_goal_sample = min(0.05 + 0.9 * (iteration / max_iterations), 0.95)\n            if random.random() < prob_goal_sample:\n                return self._goal_vertex.position\n            while True:\n                rand_coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside ellipse informed by current best path cost\n            c_best = self._best_cost\n            c_min = dist_start_goal\n            if c_best < c_min:\n                c_best = c_min + 1e-6  # avoid degenerate ellipse\n\n            # Ellipse parameters\n            center = (start_np + goal_np) / 2.0\n            a1 = (goal_np - start_np) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis using SVD rotation:\n            U, _, _ = np.linalg.svd(np.atleast_2d(a1).T)\n            C = U  # rotation matrix\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            radii = np.array([r1] + [r2]*(self._dimension-1))\n\n            # Sample random point in unit ball\n            while True:\n                direction = np.random.randn(self._dimension)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir == 0:\n                    continue\n                direction /= norm_dir\n                radius_sample = random.random() ** (1.0 / self._dimension)\n                point_ball = radius_sample * direction\n\n                sample_ellipse = center + np.dot(C, radii * point_ball)\n                # Round and clamp to grid limits\n                sample_coords = np.clip(np.round(sample_ellipse).astype(int), 0, np.array(self._get_grid().size) - 1)\n                sample_point = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_cost\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        # Shortcut path smoothing by attempting to connect non-adjacent points directly if collision free\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i+1])\n                    i += 1\n            return smoothed_path\n\n        path = try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 6000\n        iteration = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout: no path found within time limit\n                return\n\n            q_sample = self._sample_in_ellipse(iteration, max_iterations)\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            # Adaptive step size: smaller near goal or as best cost improves (focused refinement)\n            progress_factor = 1.0 if self._best_cost == float('inf') else (self._best_cost / (self._best_cost + 1e-6))\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal * progress_factor * 0.7))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost + heuristic to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in neighbors:\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices through q_new if it improves cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove one existing parent edge (if any)\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if path to goal can be improved / connected\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    proposed_cost = q_new.cost + dist_to_goal\n                    if proposed_cost < self._best_cost:\n                        self._best_cost = proposed_cost\n                        self._goal_vertex.cost = proposed_cost\n                        self._graph.add_edge(q_new, self._goal_vertex)\n                        self._extract_and_smooth_path(q_new)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Bidirectional Heuristic-Guided Sampling with Dynamic Corridor Narrowing",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Adaptive Bidirectional Heuristic-Guided Sampling with Dynamic Corridor Narrowing}\n\n    This algorithm combines bidirectional search with goal-biased and frontier-biased sampling \n    to efficiently explore sparse and cluttered environments. It grows two trees simultaneously \n    \u2014 one rooted at the start (agent) and one at the goal \u2014 and attempts to connect them dynamically \n    when their branches come close. Sampling is adaptively focused on promising regions: near the \n    goal, near the tree frontiers, and in dynamic \"corridors\" that narrow as paths improve.\n\n    Key ideas:\n    - Bidirectional vertex expansion to speed up convergence.\n    - Dynamic corridor narrowing: reduces exploration area adaptively based on best current path cost.\n    - Heuristic priority in selecting vertices for connection attempts.\n    - Intermediate rechecking and smoothing steps on found paths.\n    - Adaptive max step distance reducing near goal or corridor borders.\n    - Early stopping after max 10 seconds runtime.\n    - Utilizes Forest graph structure, and existing utilities from provided framework.\n    \"\"\"\n\n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_dist_initial: float\n    _max_dist_min: float\n    _dimension: int\n    _start_time: float\n    _max_runtime_seconds: float\n    _best_path_cost: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 20.0\n        self._max_dist_min = 2.5\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._best_path_cost = float('inf')\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n    def _heuristic(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Euclidean distance heuristic\n        return torch.norm(from_vertex.position.to_tensor() - to_vertex.position.to_tensor()).item()\n\n    def _adaptive_max_dist(self, from_vertex: Vertex) -> float:\n        # Dynamically reduce max step with proximity to goal and best path cost (corridor narrowing)\n        dist_to_goal = self._heuristic(from_vertex, self._goal_vertex)\n        max_step = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 3.0))\n        # Further narrow if a solution was found and cost is better than estimated corridor size\n        if self._best_path_cost < float('inf'):\n            # Narrow corridor radius proportional to best_path_cost to force refinement\n            corridor_radius = (self._best_path_cost - from_vertex.cost) / 2.5\n            corridor_radius = max(corridor_radius, self._max_dist_min)\n            max_step = min(max_step, corridor_radius)\n        return max_step\n\n    def _sample_near_vertex(self, vertex: Vertex, radius: float) -> Point:\n        # Sample random point within a ball of radius around vertex position\n        base_point = vertex.position\n        for _ in range(20):  # try limited times to sample a valid position\n            offset_coords = []\n            for d in range(self._dimension):\n                offset = random.uniform(-radius, radius)\n                coord = base_point[d] + offset\n                coord = min(max(0, coord), self._get_grid().size[d] - 1)\n                offset_coords.append(int(round(coord)))\n            candidate = Point(*offset_coords)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n        return base_point  # fallback to vertex position if no valid sample found near\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        # Attempt to connect two vertices if collision free, add edge, update costs if better\n        line_seq = self._get_grid().get_line_sequence(v_from.position, v_to.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return False\n        dist = self._heuristic(v_from, v_to)\n        cost_through = v_from.cost + dist\n        if cost_through < v_to.cost or v_to.cost == 0.0:\n            # If v_to already in graph and cheaper path found, rewire\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            v_to.cost = cost_through\n            self._graph.add_edge(v_from, v_to)\n            return True\n        elif v_to.cost == float('inf'):\n            # v_to new vertex, assign cost and add edge\n            v_to.cost = cost_through\n            self._graph.add_edge(v_from, v_to)\n            return True\n        return False\n\n    def _extract_path_bidirectional(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> List[Vertex]:\n        # Extracts and merges paths from start to meet_vertex and goal to meet_vertex (from goal side)\n        path_start = []\n        current = meet_vertex_start\n        while current is not None:\n            path_start.append(current)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        path_goal = []\n        current = meet_vertex_goal\n        while current is not None:\n            path_goal.append(current)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n\n        # Remove duplicate meet vertex and join paths together\n        if path_goal and path_goal[0].position == path_start[-1].position:\n            path_goal.pop(0)\n        full_path = path_start + path_goal\n\n        return full_path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: remove unnecessary intermediate waypoints if direct connection is collision free\n        n = len(path)\n        if n <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found; advance by one\n                if i + 1 < n:\n                    smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _move_agent_along_path(self, path: List[Vertex]) -> None:\n        # Move agent along the given vertex path, issuing key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 6000\n        iteration = 0\n\n        # Initialize vertex sets for bidirectional trees\n        start_vertices = [self._start_vertex]\n        goal_vertices = [self._goal_vertex]\n\n        # Assign initial costs\n        self._start_vertex.cost = 0.0\n        self._goal_vertex.cost = float('inf')  # Only updated on connection attempts\n\n        # Mapping vertex positions to vertices for quick lookup\n        start_pos_map = {self._start_vertex.position: self._start_vertex}\n        goal_pos_map = {self._goal_vertex.position: self._goal_vertex}\n\n        best_meeting_vertices = None  # (start_vertex, goal_vertex)\n        best_path_found_cost = float('inf')\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Time limit exceeded \u2014 fail gracefully\n                return\n\n            # Alternate expansions between start and goal trees\n            expand_from_start = (iteration % 2 == 1)\n\n            if expand_from_start:\n                # Sample near frontier of start tree with some goal bias\n                if random.random() < 0.3:\n                    sample = self._goal_vertex.position\n                else:\n                    # Pick a frontier vertex weighted by inverse cost to goal (heuristic)\n                    frontier_vertex = min(start_vertices, key=lambda v: v.cost + self._heuristic(v, self._goal_vertex))\n                    max_dist = self._adaptive_max_dist(frontier_vertex)\n                    sample = self._sample_near_vertex(frontier_vertex, max_dist)\n                tree_to_expand = start_vertices\n                other_tree = goal_vertices\n                tree_pos_map = start_pos_map\n                other_pos_map = goal_pos_map\n                root_vertex = self._start_vertex\n                other_root_vertex = self._goal_vertex\n            else:\n                # Expand from goal side similarly but biased near start\n                if random.random() < 0.3:\n                    sample = self._start_vertex.position\n                else:\n                    frontier_vertex = min(goal_vertices, key=lambda v: v.cost + self._heuristic(v, self._start_vertex))\n                    max_dist = self._adaptive_max_dist(frontier_vertex)\n                    sample = self._sample_near_vertex(frontier_vertex, max_dist)\n                tree_to_expand = goal_vertices\n                other_tree = start_vertices\n                tree_pos_map = goal_pos_map\n                other_pos_map = start_pos_map\n                root_vertex = self._goal_vertex\n                other_root_vertex = self._start_vertex\n\n            # Find nearest vertex in tree to sample\n            q_near = min(tree_to_expand, key=lambda v: torch.norm(v.position.to_tensor() - sample.to_tensor()).item())\n\n            # Determine adaptive max distance and new vertex\n            max_dist = self._adaptive_max_dist(q_near)\n            dir_vec = sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-6:\n                continue  # skip if sample equals nearest vertex\n\n            if dist <= max_dist:\n                q_new_pos = sample\n            else:\n                dir_normalized = dir_vec / dist\n                q_new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(q_new_tensor)\n\n            # Skip if invalid position\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = float('inf')\n\n            # Tentative cost update from q_near\n            tentative_cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = tentative_cost\n\n            # Add q_new to tree\n            tree_to_expand.append(q_new)\n            tree_pos_map[q_new.position] = q_new\n            self._graph.add_edge(q_near, q_new)\n\n            # Try to connect q_new in this tree to nearest vertex in opposite tree\n            q_connect_candidates = []\n            connection_radius = max(5.0, max_dist)\n            for v_other in other_tree:\n                if torch.norm(q_new.position.to_tensor() - v_other.position.to_tensor()).item() <= connection_radius:\n                    q_connect_candidates.append(v_other)\n\n            connected = False\n            for v_other in q_connect_candidates:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                # Check combined cost for potential path via connection\n                cost_through = q_new.cost + torch.norm(q_new.position.to_tensor() - v_other.position.to_tensor()).item() + v_other.cost\n                if cost_through < best_path_found_cost:\n                    # Connect the trees by adding edge\n                    # Add edge direction depends on which tree expanding\n                    if expand_from_start:\n                        success = self._connect_vertices(q_new, v_other)\n                    else:\n                        success = self._connect_vertices(v_other, q_new)\n                    if success:\n                        best_path_found_cost = cost_through\n                        best_meeting_vertices = (q_new if expand_from_start else v_other,\n                                                v_other if expand_from_start else q_new)\n                        self._best_path_cost = best_path_found_cost\n                        connected = True\n\n            if connected and best_meeting_vertices is not None:\n                # Extract path and smooth it\n                path_vertices = self._extract_path_bidirectional(best_meeting_vertices[0], best_meeting_vertices[1])\n                path_vertices = self._shortcut_path(path_vertices)\n                self._move_agent_along_path(path_vertices)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid A*-influenced Rapidly-exploring Random Graph (RRG)\n    with adaptive heuristic-guided sampling and informed rewiring to improve planning efficiency,\n    path quality, and robustness. It constructs a cyclic graph where vertices represent states\n    and edges represent feasible paths. Sampling is biased heuristically toward the goal's funnel\n    region using a dynamically shrinking informed ellipse region to accelerate convergence.\n    The algorithm dynamically adjusts extension step size based on local obstacle density and\n    heuristic cost-to-go estimate, improving exploration in open areas and refinement near the goal.\n    Rewiring ensures continuously improved subpaths, while early stopping triggers when a sufficiently\n    low-cost path is found. Finally, a bi-directional search connection phase attempts to connect the\n    start and goal trees to boost success rate. The path is extracted and shortcut-smoothed for quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize cyclic graph with start and goal vertices for bi-directional search\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Use CyclicGraph to allow cyclic edges (for rewiring)\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # enable rewiring/removing edges\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0         # base max extension step size\n        self._informed_sample_rate = 0.8   # probability of sampling inside informed ellipse\n        self._expand_radius = 15.0          # radius for neighborhood rewiring\n        self._iterations_limit = 8000       # iteration limit\n        self._goal_connection_dist = 7.0    # max dist to attempt connecting trees\n        self._early_stop_cost_ratio = 1.05 # early stop if path cost within 5% of heuristic dist\n\n    # Helper: Euclidean distance\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    # Helper: Returns heuristic (Euclidean) estimated cost-to-go from p to goal\n    def _heuristic_cost(self, p: Point) -> float:\n        return self._get_distance(p, self._graph.root_vertex_goal.position)\n\n    # Helper: Samples heuristically within an informed ellipse between start and goal\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n        c_min = self._get_distance(start, goal)\n        if c_min < 1e-6:\n            return goal\n\n        # Find current best path cost for ellipse size\n        best_path_cost = min((v.cost for v in self._graph.root_vertices if hasattr(v, \"cost\") and v.cost < float(\"inf\")), default=float(\"inf\"))\n        c_best = best_path_cost if best_path_cost < float(\"inf\") else float(\"inf\")\n\n        if c_best == float(\"inf\"):\n            # No known path, sample uniformly\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside ellipse defined by start, goal, and c_best (in 2D)\n            center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n            a1 = (goal.x - start.x) / c_min\n            a2 = (goal.y - start.y) / c_min\n            rotation = np.array([[a1, -a2],[a2, a1]])\n\n            # Sample random point in unit circle\n            while True:\n                r1 = np.sqrt(np.random.rand())\n                r2 = 2 * np.pi * np.random.rand()\n                x_ball = np.array([r1 * np.cos(r2), r1 * np.sin(r2)])\n\n                # Scale to ellipse axes lengths: a = c_best/2, b = sqrt(c_best^2 - c_min^2)/2\n                a = c_best / 2.0\n                b = np.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n\n                local_sample = np.array([a * x_ball[0], b * x_ball[1]])\n                rotated = rotation @ local_sample\n                sample_point = Point(int(center.x + rotated[0]), int(center.y + rotated[1]))\n                if (0 <= sample_point.x < self._get_grid().size.x and\n                    0 <= sample_point.y < self._get_grid().size.y and\n                    self._get_grid().is_agent_valid_pos(sample_point)):\n                    return sample_point\n\n    # Helper: Adaptive step size based on heuristic and local obstacle density around q_near\n    def _adaptive_step_size(self, q_near: Vertex) -> float:\n        base = self._max_dist_base\n        # Estimate obstacle density in neighborhood by counting invalid neighbors\n        neighbors = self._get_grid().get_next_positions(q_near.position)\n        invalid_neighbors = 0\n        for n_pos in neighbors:\n            if not self._get_grid().is_agent_valid_pos(n_pos):\n                invalid_neighbors += 1\n        density = invalid_neighbors / max(len(neighbors), 1)\n\n        # Smaller steps near obstacles or near goal, larger steps in open space\n        dist_to_goal = self._heuristic_cost(q_near.position)\n        step = base * (1.0 - 0.7 * density) * min(1.0, dist_to_goal / 30.0)\n        return max(2.0, step)\n\n    # Helper: Get neighbors for rewiring (within radius)\n    def _get_neighbors_for_rewire(self, q_new: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._expand_radius)\n\n    # Helper: Choose best parent minimizing cost + checking collision\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        best_parent = None\n        min_cost = float(\"inf\")\n        for v in neighbors:\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    min_cost = cost\n                    best_parent = v\n        if best_parent is None:\n            # Fallback: connect to nearest neighbor ignoring others (safe fallback)\n            best_parent = neighbors[0] if neighbors else self._graph.root_vertex_start\n            min_cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n        q_new.cost = min_cost\n        return best_parent\n\n    # Helper: Rewire neighbors if cheaper via q_new\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    # Remove old edges from parents; add q_new as parent\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    # Helper: Attempt to connect start and goal trees for bi-directional search\n    def _try_connect_trees(self, q_new: Vertex) -> Optional[Vertex]:\n        # Connect q_new from one tree to closest vertex in opposite tree if in range and valid\n        start_tree = [self._graph.root_vertex_start]\n        goal_tree = [self._graph.root_vertex_goal]\n\n        # If q_new belongs to start tree, try connecting to goal tree\n        # else try connecting to start tree\n        # Detect which tree q_new is in by proximity to roots\n        dist_start = self._get_distance(q_new.position, self._graph.root_vertex_start.position)\n        dist_goal = self._get_distance(q_new.position, self._graph.root_vertex_goal.position)\n        if dist_start < dist_goal:\n            other_tree_vertices = [v for v in self._graph.root_vertices if self._get_distance(v.position, self._graph.root_vertex_goal.position) < dist_start + 10.0]\n        else:\n            other_tree_vertices = [v for v in self._graph.root_vertices if self._get_distance(v.position, self._graph.root_vertex_start.position) < dist_goal + 10.0]\n\n        if not other_tree_vertices:\n            return None\n\n        nearest_opposite = self._graph.get_nearest_vertex(other_tree_vertices, q_new.position)\n        dist = self._get_distance(q_new.position, nearest_opposite.position)\n        if dist <= self._goal_connection_dist:\n            line = self._get_grid().get_line_sequence(q_new.position, nearest_opposite.position)\n            if self._get_grid().is_valid_line_sequence(line):\n                # Connect edges both ways to form cycle (bi-directional)\n                self._graph.add_edge(q_new, nearest_opposite)\n                self._graph.add_edge(nearest_opposite, q_new)\n                # Estimate combined cost path\n                combined_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, nearest_opposite.position) + nearest_opposite.cost\n                return (q_new, nearest_opposite, combined_cost)\n        return None\n\n    # Helper: Extract path when start and goal are connected via connection edge\n    def _extract_best_path(self, connect_pair: Tuple[Vertex, Vertex, float]) -> List[Vertex]:\n        q_start, q_goal, _ = connect_pair\n\n        # Extract path from start vertex to q_start\n        path_start = []\n        cur = q_start\n        while True:\n            path_start.append(cur)\n            if len(cur.parents) == 0:\n                break\n            # Choose parent with minimal cost\n            min_p = min(cur.parents, key=lambda p: p.cost + self._get_grid().get_movement_cost(p.position, cur.position))\n            cur = min_p\n        path_start.reverse()\n\n        # Extract path from q_goal to goal by following parents\n        path_goal = []\n        cur = q_goal\n        while True:\n            path_goal.append(cur)\n            if len(cur.parents) == 0:\n                break\n            min_p = min(cur.parents, key=lambda p: p.cost + self._get_grid().get_movement_cost(p.position, cur.position))\n            cur = min_p\n\n        # Combine paths with connection edge (no overlap)\n        path_goal = path_goal[1:]  # avoid duplicating q_goal\n        full_path = path_start + path_goal\n        return full_path\n\n    # Helper: Shortcut path smoothing\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = float(\"inf\")\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_path_cost = float(\"inf\")\n        best_connection = None  # stores tuple (q_start, q_goal, combined_cost)\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached\n                break\n\n            # Sample point: heuristic informed vs uniform\n            if np.random.rand() < self._informed_sample_rate:\n                q_sample = self._informed_sample()\n            else:\n                # Uniform random sample\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    q_sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(q_sample):\n                        break\n\n            # Get nearest vertex in entire graph\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size\n            max_dist = self._adaptive_step_size(q_near)\n\n            # Generate q_new toward sample with max_dist\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            q_new = Vertex(q_new_pos)\n\n            # Check valid edge\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            # Get neighbors for rewiring\n            neighbors = self._get_neighbors_for_rewire(q_new)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent\n            best_parent = self._choose_parent(neighbors, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for cost improvement\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to graph root vertices for future expansions\n            self._graph.root_vertices.append(q_new)\n\n            # Attempt to connect start and goal trees to boost success\n            connect_result = self._try_connect_trees(q_new)\n            if connect_result is not None:\n                _, _, combined_cost = connect_result\n                if combined_cost < best_path_cost:\n                    best_path_cost = combined_cost\n                    best_connection = connect_result\n                    path_found = True\n                    # Early stopping if path cost close to heuristic minimum\n                    if best_path_cost <= self._early_stop_cost_ratio * self._get_distance(start_vertex.position, goal_vertex.position):\n                        break\n\n            self.key_frame()\n\n        if path_found and best_connection is not None:\n            # Extract and smooth final best path\n            raw_path = self._extract_best_path(best_connection)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Enhanced Goal-Biased Sampling, \n    Adaptive Dynamic Step Sizing, Heuristic-Guided Expansion, and Efficient Rewiring.\n    \n    Enhancements over baseline:\n    - Dynamic goal bias that increases adaptively with progress but also accounts for current tree coverage\n    - Adaptive step size adjusted by both distance to goal and local obstacle density to improve sampling efficiency\n    - Heuristic cost that combines current path cost, Euclidean distance to goal, and estimated obstacle density\n    - Efficient rewiring prioritizing minimal cost neighbors with early pruning of suboptimal edges\n    - Path extraction with robust shortcut smoothing using multi-pass refinement to improve path quality\n    - Early stopping if goal connected or total runtime exceeds 10 seconds for practical run-time limits\n    - Use of batch candidate sampling around goal area periodically to accelerate connection attempts near goal\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n        # Additional members for enhanced algorithm\n        self._sample_batch_size = 5\n        self._goal_sample_base_prob = 0.2\n        self._goal_sample_max_prob = 0.95\n        self._rewire_radius_factor = 1.5\n        self._obstacle_density_check_radius = 5.0\n\n    def _get_obstacle_density(self, point: Point, radius: float) -> float:\n        \"\"\"\n        Estimate local obstacle density around a point within a given radius.\n        Used to adapt step size and cost heuristics.\n        \"\"\"\n        grid = self._get_grid()\n        total_points_checked = 0\n        obstacle_points = 0\n        # Calculate points sampled in radius cube/sphere (grid based)\n        xmin = max(0, point[0] - int(radius))\n        xmax = min(grid.size[0] - 1, point[0] + int(radius))\n        ymin = max(0, point[1] - int(radius)) if self._dimension > 1 else 0\n        ymax = min(grid.size[1] - 1, point[1] + int(radius)) if self._dimension > 1 else 0\n\n        # For 2D support (grid.n_dim assumed 2 or more)\n        for x in range(xmin, xmax+1):\n            for y in range(ymin, ymax+1):\n                candidate = Point(x, y)\n                total_points_checked += 1\n                if not grid.is_agent_valid_pos(candidate):\n                    obstacle_points += 1\n        if total_points_checked == 0:\n            return 0.0\n        return obstacle_points / total_points_checked\n\n    def _get_random_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Enhanced goal-biased sampling:\n        - Increases goal sample probability dynamically based on iteration progress and tree size.\n        - Occasionally performs batch sampling near goal area to increase connection chances.\n        \"\"\"\n        grid = self._get_grid()\n        prob_goal_sample_dynamic = min(\n            self._goal_sample_base_prob + 0.8 * (iteration / max_iterations) + 0.1 * (self._graph.size / 100.0),\n            self._goal_sample_max_prob)\n        # Occasionally attempt batch samples near goal\n        if iteration % 20 == 0:\n            # Sample within radius around goal to encourage tree growth near goal\n            for _ in range(self._sample_batch_size):\n                sample_offset = [random.randint(-5,5) for _ in range(self._dimension)]\n                sample_point_coords = [max(0, min(grid.size[d]-1, self._goal_vertex.position[d] + sample_offset[d])) for d in range(self._dimension)]\n                sample_point = Point(*sample_point_coords)\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n        # Otherwise do normal goal-biased sampling with dynamic probability\n        if random.random() < prob_goal_sample_dynamic:\n            return self._goal_vertex.position\n        while True:\n            rand_coords = [random.randint(0, grid.size[i]-1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        When extending, adaptively reduce step size based on obstacle density and distance to goal\n        for more careful expansions near obstacle clusters and goal.\n        \"\"\"\n        grid = self._get_grid()\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist == 0:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        # Calculate obstacle density near q_near and q_sample midpoint\n        midpoint = Point.from_tensor((q_near.position.to_tensor() + q_sample.to_tensor()) / 2)\n        obstacle_density = self._get_obstacle_density(midpoint, self._obstacle_density_check_radius)\n        # Reduce max_dist proportionally to obstacle density and closeness to goal\n        dist_to_goal = torch.norm(q_near.position.to_tensor() - self._goal_vertex.position.to_tensor())\n        dist_factor = max(dist_to_goal / 10.0, 0.1)\n        adjusted_max_dist = max(self._max_dist_min,\n                               min(self._max_dist_initial, max_dist * dist_factor * (1.0 - obstacle_density * 0.7)))\n        # Clip adjusted max_dist to be no larger than actual distance to sample to not overshoot\n        step_dist = min(adjusted_max_dist, dist)\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        \"\"\"\n        Enhanced heuristic combining path cost, Euclidean distance to goal and local obstacle density penalty\n        to guide the tree growth preferentially toward easier, lower-cost regions.\n        \"\"\"\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        obstacle_density = self._get_obstacle_density(from_vertex.position, self._obstacle_density_check_radius)\n        obstacle_penalty = obstacle_density * 10.0  # Weight obstacle density penalty higher\n        return from_vertex.cost + dist_cost + obstacle_penalty\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        \"\"\"\n        Multi-pass shortcut smoothing to ensure smoothest possible path with valid collision checks.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Extract raw path\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path_points[i].position, path_points[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i+1])\n                    i += 1\n            return smoothed_path\n\n        # Multi-pass smoothing for improved path refinement\n        for _ in range(3):\n            path = try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            if hasattr(grid, \"publish_wp\"):  # For ROS integration\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # Slightly reduced for performance gains but offset by improvements\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                return  # Timeout fallback\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Use adaptive step size influenced by distance and local environment\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)) * self._rewire_radius_factor, 30.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Select parent minimizing heuristic cost\n            q_min = q_nearest\n            c_min = self._heuristic_cost(q_nearest, q_new.position)\n\n            for q_near in neighbors:\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check):\n                    heuristic = cost_through_neighbor + torch.norm(q_near.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                    if heuristic < c_min:\n                        q_min = q_near\n                        c_min = heuristic\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Efficient rewiring prioritizing neighbors with better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge (assuming single parent)\n                    q_near_parent = next(iter(q_near.parents), None)\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Goal-Biased Adaptive Sampling,\n    Heuristic-Guided Vertex Expansion, Dynamic Step Sizing, and Enhanced Rewiring with Lazy Collision Checks.\n\n    Key Improvements:\n    - Goal-biased adaptive sampling probability increasing faster (exponentially) for quicker exploitation.\n    - Dynamic step size adapting smoothly by a logistic decay based on distance to goal.\n    - Heuristic cost includes movement cost + Euclidean to goal (A* style) for better expansion quality.\n    - Lazy collision checking during rewiring to reduce expensive line validations.\n    - Early stopping on goal connection or 10 seconds timeout.\n    - Post path extraction shortcut smoothing and local smoothing via random shortcut attempts.\n    - Uses Forest graph with vertices and edges, maintaining consistency.\n\n    This algorithm improves planning efficiency, success rate, and produces smoother, shorter paths\n    compared to basic RRT* implementations by balancing exploration and exploitation effectively.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n        self._max_iterations = 8000\n\n    def _goal_biased_sample(self, iteration: int, max_iterations: int) -> Point:\n        # Exponential growth in goal sample probability for faster goal biasing\n        exp_factor = 5.0\n        prob_goal_sample = min(0.2 + 0.75 * (1 - math.exp(-exp_factor * (iteration / max_iterations))), 0.99)\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_step_size(self, dist_to_goal: float) -> float:\n        # Smooth logistic decay of step size from max_dist_initial to min over distance to goal\n        midpoint = 20.0\n        steepness = 0.2\n        scale = (1 / (1 + math.exp(steepness * (dist_to_goal - midpoint))))\n        step = self._max_dist_min + (self._max_dist_initial - self._max_dist_min) * scale\n        return max(self._max_dist_min, min(self._max_dist_initial, step))\n\n    def _heuristic_total_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # A*-style cost: cost-so-far + euclidean distance heuristic\n        cost_so_far = from_vertex.cost\n        heuristic = float(torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor()))\n        return cost_so_far + heuristic\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i + 1])\n                    i += 1\n            return smoothed_path\n\n        def local_random_shortcut(path_points: List[Vertex], attempts: int = 10) -> List[Vertex]:\n            path_len = len(path_points)\n            for _ in range(attempts):\n                if path_len < 3:\n                    break\n                i = random.randint(0, path_len - 3)\n                j = random.randint(i + 2, path_len - 1)\n                if j >= path_len or i >= j:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    path_points = path_points[:i + 1] + path_points[j:]\n                    path_len = len(path_points)\n            return path_points\n\n        path = try_shortcut(path)\n        path = local_random_shortcut(path, attempts=20)  # Further smooth path by random shortcuts\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout failure\n                return\n\n            q_sample = self._goal_biased_sample(iteration, self._max_iterations)\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            dist_to_goal = float(torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor()))\n            max_dist = self._adaptive_step_size(dist_to_goal)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + float(torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()))\n\n            # Choose best parent leveraging heuristic cost to goal + cost from parent\n            for q_near in neighbors:\n                dist_neighbor_to_new = float(torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()))\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                # Prefer candidates with better heuristic total cost\n                if cost_through_neighbor >= c_min:\n                    continue\n                # Lazy collision check only for chosen best parent candidate\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check):\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors - Lazy collision checks only for those that improve costs\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_new_to_near = float(torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()))\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new >= q_near.cost:\n                    continue\n                # Collision check for rewiring edge\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n\n                # Remove existing parent edge\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent is not None:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n            # Connect to goal if feasible\n            dist_goal_check = float(torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor()))\n            if dist_goal_check <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_goal_check\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm combining:\n    - Goal-biased adaptive sampling with dynamic goal attraction factor to balance exploration/exploitation\n    - Heuristic-guided vertex expansion using combined cost and Euclidean heuristic (A*-style)\n    - Adaptive step size scaled by distance to goal and local density of vertices for finer control near goal/obstacles\n    - RRT*-style rewiring to optimize path cost and topology dynamically\n    - Dynamic neighbor radius shrinking with growing graph size to optimize runtime and precision\n    - Early stopping on goal connection or runtime > 10 seconds\n    - Path extraction with improved shortcut smoothing (tries multi-step shortcuts)\n    - Use of vertex priority queue during rewiring to reduce redundant checks\n    Overall: enhances efficiency, success rate, and smoothness of path compared to basic RRT* or SPRM techniques.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variables for adaptive parameters\n        self._goal_sample_initial_prob = 0.3\n        self._goal_sample_final_prob = 0.9\n        self._adaptive_step_factor = 0.4\n        self._rewire_batch_size = 15\n        self._max_runtime_seconds = 10.0  # enforce 10 seconds max runtime\n        self._lambda_rrt_star = 50.0\n        self._max_dist_initial = 20.0\n        self._max_dist_min = 2.5\n\n    def _get_random_sample(self, iteration: int, max_iterations: int) -> Point:\n        # Adaptive goal biased sampling: probability increases non-linearly (sigmoid-like)\n        progress_ratio = iteration / max_iterations\n        prob_goal_sample = (self._goal_sample_initial_prob +\n                            (self._goal_sample_final_prob - self._goal_sample_initial_prob) *\n                            (math.tanh(5 * (progress_ratio - 0.5)) * 0.5 + 0.5))\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n        # Otherwise uniform random valid sample\n        dimension = self._dimension\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_step_size(self, dist_to_goal: float, num_vertices: int) -> float:\n        # Step size shrinks as graph grows and agent approaches goal, with minimum bound\n        scale_factor = max(0.1, 1.0 - (num_vertices / 5000.0))\n        dist_factor = max(self._max_dist_min, dist_to_goal * self._adaptive_step_factor)\n        step_size = max(self._max_dist_min, min(self._max_dist_initial * scale_factor, dist_factor))\n        return step_size\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # A*-style combined cost + euclidean heuristic (cost-to-come + est. cost-to-go)\n        dist_to_goal = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_to_goal\n\n    def _choose_best_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Select the best parent from neighbors that provides lowest cost-to-come through\n        q_new's position, respecting collision-free connection.\n        \"\"\"\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free edge\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through = q_near.cost + dist\n            if cost_through < c_min:\n                c_min = cost_through\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire_vertices(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        Attempt to rewire neighbors to q_new if it improves their cost.\n        Use a priority-based approach to rewire limited batch size neighbors.\n        \"\"\"\n        dist_mat = []\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            cost_through = q_new.cost + dist\n            if cost_through < q_near.cost:\n                dist_mat.append((cost_through - q_near.cost, q_near, cost_through))\n\n        # Sort neighbors by cost improvement descending to rewire biggest gains first\n        dist_mat.sort(key=lambda x: x[0])\n\n        rewire_count = min(self._rewire_batch_size, len(dist_mat))\n        for i in range(rewire_count):\n            _, q_near, cost_through = dist_mat[i]\n            # Remove existing parent edge\n            q_near_parents = list(q_near.parents)\n            for p in q_near_parents:\n                self._graph.remove_edge(p, q_near)\n            # Add edge from q_new\n            q_near.cost = cost_through\n            self._graph.add_edge(q_new, q_near)\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n\n        # Extract raw path from start to goal\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        def try_multi_step_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            # Shortcut smoothing attempts multi-step shortcuts to reduce path length further\n            smoothed_path = [path_points[0]]\n            i = 0\n            n = len(path_points)\n            while i < n - 1:\n                # Try farthest feasible shortcut jump\n                j = n - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i + 1])\n                    i += 1\n            return smoothed_path\n\n        path = try_multi_step_shortcut(path)\n\n        # Move agent along smoothed path with key frames and ROS integration\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):  # ROS map integration\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        iteration: int = 0\n        grid = self._get_grid()\n        start_time = time.perf_counter()\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed_time = time.perf_counter() - start_time\n            if elapsed_time > self._max_runtime_seconds:\n                # Timeout: failed to find path in given time\n                return\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Compute adaptive max step size based on distance to goal & graph size\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            max_dist = self._adaptive_step_size(dist_to_goal, self._graph.size)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            # Verify collision-free path for extension\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius shrinks with graph growth and dimension for neighbor search\n            card_v = max(2.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), 20.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            if not neighbors:\n                # Always include q_nearest if neighbors empty to connect tree\n                neighbors = [q_nearest]\n\n            # Select the best parent vertex from neighbors\n            q_min, c_min = self._choose_best_parent(neighbors, q_new)\n            if q_min is None:\n                # Fallback to nearest vertex as parent\n                q_min = q_nearest\n                c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors with improved rewire batching by cost improvement\n            self._rewire_vertices(neighbors, q_new)\n\n            # Check if can connect to goal with collision-free edge\n            dist_goal_new = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_goal_new <= max_dist:\n                line_seq_goal = grid.get_line_sequence(q_new.position, self._goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_goal_new\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    An improved path planning algorithm inspired by RRT* with enhancements:\n    - Goal-biased adaptive sampling with increasing probability to sample the goal.\n    - Heuristic-guided vertex expansion combining path cost and Euclidean distance.\n    - Adaptive dynamic step sizing that reduces near obstacles and goal for finer control.\n    - Rewiring vertices for path optimality like RRT*.\n    - Use of collision-cost-aware adaptive step size to avoid obstacle-rich areas.\n    - Early stopping if goal connected or runtime exceeds 10 seconds.\n    - Enhanced shortcut smoothing with multiple attempts.\n    - Prioritized neighbor rewiring based on heuristics.\n    - Incorporates a small local search near new vertices to find better parents.\n    \n    This approach improves planning efficiency, path quality, robustness, and success rate,\n    balancing exploration and exploitation in complex environments.\n    \"\"\"\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        iteration: int = 0\n        grid: Map = self._get_grid()\n        start = self._start_vertex.position\n        goal = self._goal_vertex.position\n        dimension = self._dimension\n        directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,1), (1,-1), (-1,-1)]\n\n        def collision_cost_between(frm: Point, to: Point) -> float:\n            # Simple cost: 0 if line collision-free; large penalty if obstacles pass close\n            line_seq = grid.get_line_sequence(frm, to)\n            if not grid.is_valid_line_sequence(line_seq):\n                return float('inf')\n            return 0.0  # Could be extended with clearance cost if needed\n\n        def heuristic_cost(vertex: Vertex) -> float:\n            # f = g + h, g = cost to come, h = euclidean distance to goal\n            return vertex.cost + grid.get_distance(vertex.position, goal)\n\n        def adapt_step_size(q_near: Vertex, q_sample: Point) -> float:\n            dist_to_goal = grid.get_distance(q_near.position, goal)\n            # Reduce step size near obstacles by checking local neighbors for freespace\n            radius_clearance = 3.0\n            clearance_vertices = self._get_vertices_within_radius(q_near, radius_clearance)\n            obstacle_factor = 1.0\n            # If many neighbors nearby, possibly a cluttered area => reduce step size\n            if len(clearance_vertices) > 8:\n                obstacle_factor = 0.4\n            base_size = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 3))\n            return base_size * obstacle_factor\n\n        def local_parent_search(q_new: Vertex, neighbors: List[Vertex]) -> Tuple[Vertex, float]:\n            # Find the best parent candidate around q_new with minimal cost + collision\n            q_min = None\n            c_min = float('inf')\n            for q_near in neighbors:\n                dist_neighbor_to_new = grid.get_distance(q_near.position, q_new.position)\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                if cost_through_neighbor >= c_min:\n                    continue\n                # Validate collision-free connection\n                line_seq_check = grid.get_line_sequence(q_near.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n            return (q_min, c_min)\n\n        def rewire_neighbors(q_new: Vertex, neighbors: List[Vertex]) -> None:\n            # Attempt to rewire neighbors through q_new for lower cost paths\n            for q_near in neighbors:\n                if q_near == q_new:\n                    continue\n                line_seq_check = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = grid.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + 1e-4 < q_near.cost:  # small epsilon for numerical stability\n                    # Remove old parent edge(s)\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    # Add new parent edge\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n        def smooth_path(path: List[Vertex]) -> List[Vertex]:\n            # Multiple passes of shortcut smoothing with different start points for better results\n            def try_shortcuts(path_pts: List[Vertex]) -> List[Vertex]:\n                smoothed_path = [path_pts[0]]\n                i = 0\n                n = len(path_pts)\n                while i < n - 1:\n                    j = n - 1\n                    connected = False\n                    while j > i + 1:\n                        line_seq = grid.get_line_sequence(path_pts[i].position, path_pts[j].position)\n                        if grid.is_valid_line_sequence(line_seq):\n                            smoothed_path.append(path_pts[j])\n                            i = j\n                            connected = True\n                            break\n                        j -= 1\n                    if not connected:\n                        smoothed_path.append(path_pts[i+1])\n                        i += 1\n                return smoothed_path\n\n            # Iterate smoothing multiple times for more improvement\n            for _ in range(3):\n                path = try_shortcuts(path)\n            return path\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Timeout: fail gracefully\n                return\n\n            # Goal biased sampling with stronger bias as iteration progresses\n            prob_goal_sample = min(0.15 + 0.85 * (iteration / max_iterations), 0.98)\n            if random.random() < prob_goal_sample:\n                q_sample = goal\n            else:\n                while True:\n                    rand_coords = [random.randint(0, grid.size[i] - 1) for i in range(dimension)]\n                    q_sample_candidate = Point(*rand_coords)\n                    if grid.is_agent_valid_pos(q_sample_candidate):\n                        q_sample = q_sample_candidate\n                        break\n\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                # Skip if sample exactly on vertex\n                self.key_frame()\n                continue\n\n            max_dist = adapt_step_size(q_nearest, q_sample)\n            \n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                q_new_pos = Point.from_tensor(q_nearest.position.to_tensor() + max_dist * dir_normalized)\n\n            q_new = Vertex(q_new_pos)\n\n            # Collision check\n            line_sequence = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                self.key_frame()\n                continue\n\n            # Neighbor radius adapts based on tree size and dimension, capped\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = max(1.0, math.log(card_v))\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), 35.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            if q_nearest not in neighbors:\n                neighbors.append(q_nearest)\n\n            q_min, c_min = local_parent_search(q_new, neighbors)\n            if q_min is None:\n                # Fallback to nearest vertex if no better parent found\n                q_min = q_nearest\n                dist_to_new = grid.get_distance(q_min.position, q_new.position)\n                c_min = q_min.cost + dist_to_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for path improvement\n            rewire_neighbors(q_new, neighbors)\n\n            # Try connecting goal if close enough\n            dist_to_goal = grid.get_distance(q_new.position, goal)\n            if dist_to_goal <= max_dist * 1.2:\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    # Extract path and smooth before returning\n                    # Build path back to root\n                    path: List[Vertex] = [self._goal_vertex]\n                    current = q_new\n                    while current is not None:\n                        path.append(current)\n                        if len(current.parents) == 0:\n                            break\n                        current = next(iter(current.parents))\n                    path.reverse()\n                    path = smooth_path(path)\n\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        # Publish waypoint if available (ROS integration)\n                        if hasattr(grid, \"publish_wp\"):\n                            grid.publish_wp(grid.agent.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with Goal-Biased Adaptive Sampling,\n    Heuristic-Guided Vertex Expansion, Dynamic Step Sizing, and Cost-aware Sampling Region.\n    \n    Key Improvements:\n    - Adaptive Goal Biasing: Probability to sample the goal increases non-linearly faster than linear.\n    - Cost-Guided Sampling Region: Samples are preferentially drawn closer to the region around \n      current best path cost to enhance exploitation around promising areas.\n    - Heuristic-Guided Vertex Expansion: Extend vertices guided by combined cost-to-come and \n      heuristic estimated cost-to-go, encouraging rapid focused growth.\n    - Dynamic Step Size: Step size adapts dynamically based on both iteration and distance to goal,\n      shrinking near goal and as tree grows to promote finer expansions.\n    - Rewiring optimized by heuristic cost to enhance path optimality.\n    - Early stopping when goal connected or time exceeds 10 seconds.\n    - Shortcut smoothing with bidirectional shortcut attempts for path quality.\n    \n    This approach achieves reduced planning time, higher success rates, improved path smoothness,\n    and shorter paths by strategic sampling and cost-aware graph rewiring.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Existing initialization kept as-is\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 2.5\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n        # Additional internal state\n        self._best_goal_cost = float('inf')\n        self._best_connection_vertex = None\n\n    def _biased_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Adaptive goal bias with cost-region informed sampling:\n        - Probability to sample goal increases with iteration^1.5 to focus iteration end.\n        - For non-goal samples, we encourage sampling near current best-cost-informed ellipse/funnel.\n        - Fallback to uniform random sample if no best cost yet or fallback condition.\n        \"\"\"\n        prob_goal_sample = min(0.1 + 0.9 * ((iteration / max_iterations) ** 1.5), 0.98)\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n\n        grid = self._get_grid()\n        # If no best path cost found yet, uniform random valid sample\n        if self._best_goal_cost == float('inf'):\n            while True:\n                rand_coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Try cost-informed sampling region: Ellipse between start and goal with major axis = best cost\n        # We approximate ellipse by sampling along a region around line start-goal with some Gaussian noise,\n        # radius proportional to best cost and shrinking with iteration.\n        start_pos = self._start_vertex.position\n        goal_pos = self._goal_vertex.position\n\n        # Vector from start to goal, distance between them\n        start_to_goal_vec = torch.tensor(goal_pos.to_list()) - torch.tensor(start_pos.to_list())\n        dist_start_goal = torch.norm(start_to_goal_vec).item()\n        major_axis = min(self._best_goal_cost, max(dist_start_goal, 1e-3))  # Avoid zero\n\n        # Minor axis proportional to sqrt of max_dist_initial scaled and shrinks with iteration\n        minor_axis_base = self._max_dist_initial / 2.0\n        decay_factor = max(0.05, 1 - (iteration / max_iterations))  # shrinks from 1 to 0.05\n        minor_axis = minor_axis_base * decay_factor\n\n        # Sampling ellipse parameterization:\n        # Sample random angle and distance within ellipse region\n        angle = random.uniform(0, 2 * math.pi)\n        # Distance along major axis sampled uniformly from 0 to 1\n        r_major = random.uniform(0, 1)\n        r_minor = random.uniform(0, 1)\n\n        # Rotate and translate sample to grid\n        center_vec = (torch.tensor(start_pos.to_list()) + torch.tensor(goal_pos.to_list())) / 2\n        direction_vec = start_to_goal_vec / dist_start_goal\n        # Orthogonal vector in 2D plane; higher dims approximate by ignoring minor axis direction bias\n        if self._dimension == 2:\n            ortho_vec = torch.tensor([-direction_vec[1], direction_vec[0]])\n            pos_sample = center_vec + \\\n                         direction_vec * (r_major * major_axis / 2) * math.cos(angle) + \\\n                         ortho_vec * (r_minor * minor_axis) * math.sin(angle)\n            pos_sample_int = [int(round(x)) for x in pos_sample.tolist()]\n        else:\n            # Higher dim fallback: sample near line along start->goal with noise perpendicular\n            base_pos = center_vec + direction_vec * (r_major * major_axis / 2) * math.cos(angle)\n            noise_vec = torch.randn(self._dimension)\n            noise_vec -= torch.dot(noise_vec, direction_vec) * direction_vec  # orthogonalize\n            noise_vec /= (torch.norm(noise_vec) + 1e-9)\n            pos_sample = base_pos + noise_vec * (r_minor * math.sin(angle))\n            pos_sample_int = [int(round(x)) for x in pos_sample.tolist()]\n\n        sample_point = Point(*pos_sample_int)\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        # fallback uniform random valid if cost-informed sample invalid\n        while True:\n            rand_coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Override to use Euclidean cost + path cost with slight weighting to heuristic closer to goal\n        dist_to_goal = torch.norm(to_point.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n        # Weighted sum of cost so far + heuristic cost\n        alpha = 0.7  # emphasis for path cost vs heuristic\n        return alpha * from_vertex.cost + (1 - alpha) * dist_to_goal\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Enhanced to snap to sample if close enough or make a step with stochastic perturbation to explore\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return Vertex(q_near.position)  # No movement\n\n        dir_normalized = dir_vec / dist\n\n        # Dynamic step size adapted by iteration and distance to goal\n        dist_to_goal = torch.norm(q_near.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n        iteration_progress = max(min((time.perf_counter() - self._start_time) / self._max_runtime_seconds, 1), 0)\n        dynamic_scale = max(self._max_dist_min,\n                            min(self._max_dist_initial,\n                                dist_to_goal / (2.0 + 5 * iteration_progress)))\n        step_len = min(dynamic_scale, dist)\n\n        # Add small random deviation orthogonal to direction for exploration improvement\n        if self._dimension == 2 and step_len > self._max_dist_min:\n            ortho_vec = torch.tensor([-dir_normalized[1], dir_normalized[0]])\n            deviation = (random.random() - 0.5) * (step_len * 0.25)  # up to 25% step size deviation\n            step = dir_normalized * step_len + ortho_vec * deviation\n        else:\n            step = dir_normalized * step_len\n\n        q_new_coord = q_near.position.to_tensor() + step\n        q_new_point = Point.from_tensor(q_new_coord)\n        return Vertex(q_new_point)\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        # Extract path: from goal backward to start, picking first parent at each step\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        visited_set = set()\n        while current is not None and current not in visited_set:\n            path.append(current)\n            visited_set.add(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        # Bidirectional shortcut smoothing to enhance path quality:\n        def try_shortcut_bidirectional(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed = []\n            i = 0\n            n = len(path_points)\n            while i < n:\n                smoothed.append(path_points[i])\n                # Attempt to find furthest reachable point ahead that can connect directly\n                j = n - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n            return smoothed\n\n        path = try_shortcut_bidirectional(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # Fewer max iterations due to improved efficiency\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Fail early if max runtime exceeded\n                return\n\n            q_sample = self._biased_sample(iteration, max_iterations)\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size (dynamic) as influenced by iteration and goal distance\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / (2 + iteration / max_iterations * 5)))\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for rewiring using heuristic cost shape - radius reduced over time\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius_base = self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension))\n            radius_decay = max(5.0, radius_base * (1 - iteration / max_iterations))\n            radius = min(radius_decay, 30.0)\n\n            neighbors = self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n            # Select best parent with heuristic cost guidance\n            q_min = q_nearest\n            cost_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n\n            for q_near in neighbors:\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost_through_neighbor = q_near.cost + dist_to_new\n                # Heuristic cost combining path cost + dist to goal used to compare\n                heuristic_c = cost_through_neighbor + torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n                heuristic_min = cost_min + torch.norm(q_min.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n\n                if heuristic_c < heuristic_min:\n                    q_min = q_near\n                    cost_min = cost_through_neighbor\n\n            q_new.cost = cost_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors if better route found via q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge (there may be multiple, remove one)\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    # Add new edge and update cost\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            dist_new_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n\n            # If new vertex close enough to goal and valid line join, connect goal and update best\n            if dist_new_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_to_goal = q_new.cost + dist_new_to_goal\n                    if cost_to_goal < self._best_goal_cost:\n                        self._best_goal_cost = cost_to_goal\n                        self._best_connection_vertex = q_new\n                        self._goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, self._goal_vertex)\n                        self._extract_and_smooth_path(q_new)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
