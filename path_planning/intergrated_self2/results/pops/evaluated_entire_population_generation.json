Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0078,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm is an improved sample-based planner inspired by the RRT* concept combined with heuristic-guided sampling \n    and adaptive rewiring for path optimization. It performs goal-biased sampling to increase the chance to reach the goal \n    more quickly, uses a dynamic step size decreasing as the tree grows to better refine paths near obstacles or goal, and \n    incorporates rewiring by trying to connect new vertices to neighbors with lower cost to generate smoother, shorter paths.\n\n    Notable features:\n    - Goal biasing with a configurable probability to sample towards the goal.\n    - Adaptive max step distance that shrinks as the number of vertices increases.\n    - Rewiring vertices within a fixed radius to improve path quality.\n    - Early stopping if a valid path is found.\n    - Time cutoff (10 seconds) to avoid long computations.\n    - Shortcutting the final path by checking line-of-sight between non-adjacent vertices to smooth the trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring\n        self._init_displays()\n\n        # Parameters\n        self.goal_sample_rate = 0.2     # 20% samples towards goal (goal bias)\n        self.init_max_dist = 15.0       # initial maximum extension step size\n        self.min_max_dist = 2.0         # minimum step size when refined\n        self.rewire_radius = 20.0       # radius to consider neighbors for rewiring\n        self.time_limit = 10.0          # seconds to stop planning if no solution\n\n    # Helper: Adaptive max distance based on number of vertices (shrinks as tree grows)\n    def _compute_max_dist(self) -> float:\n        n_vertices = self._graph.size\n        max_dist = max(self.init_max_dist * (0.99 ** n_vertices), self.min_max_dist)\n        return max_dist\n\n    # Helper: Sample a random point in the environment not colliding with obstacles\n    def _get_random_sample(self) -> Point:\n        grid = self._get_grid()\n        # Generate a random point within grid size until valid for agent\n        size = grid.size\n        while True:\n            rand_x = np.random.randint(0, size.width)\n            rand_y = np.random.randint(0, size.height)\n            sample = Point(rand_x, rand_y)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    # Helper: Sample point with goal biasing\n    def _get_biased_sample(self) -> Point:\n        if np.random.rand() < self.goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    # Helper: Find best parent vertex for q_new from neighbors considering cost + movement cost\n    def _choose_parent(self, neighbors, q_near: Vertex, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = q_near\n        for vertex in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost = vertex.cost + self._get_grid().get_distance(vertex.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        q_new.cost = min_cost\n        return best_parent\n\n    # Helper: Rewire neighbors to potentially lower cost via q_new\n    def _rewire(self, neighbors, q_new: Vertex) -> None:\n        for vertex in neighbors:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_distance(q_new.position, vertex.position)\n            if potential_cost < vertex.cost:\n                # Remove old parent edges, add new edge from q_new to vertex\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = potential_cost\n\n    # Helper: Shortcut the path for smoothing by skipping intermediate vertices if line of sight exists\n    def _shortcut_path(self, path) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[idx].position, path[j].position)):\n                    next_idx = j\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    # Helper: Extract and animate path from tree root to goal, includes shortcutting\n    def _extract_and_animate_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while len(current.parents) != 0:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            max_dist = self._compute_max_dist()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vector)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vector / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            q_new = Vertex(q_new_pos)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self.rewire_radius)\n            if len(neighbors) == 0:\n                neighbors = [q_near]\n\n            best_parent = self._choose_parent(neighbors, q_near, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(neighbors, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position) or self._get_grid().is_goal_reached(q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                else:\n                    goal_vertex.cost = float('inf')\n                self._graph.root_vertex_goal = goal_vertex\n\n                self._extract_and_animate_path(goal_vertex)\n                return\n\n            self.key_frame()",
     "objective": 3937.725,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.68,
          "average_distance": 11.29,
          "average_smoothness": 0.33,
          "average_clearance": 2.11,
          "average_time": 0.2096,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 44.31,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -16.85,
          "average_distance_improvement": -16.87,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 5.5,
          "average_time_improvement": -2587.18,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.629999999999999,
          "average_memory_improvement": -19.05
     }
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired planner that combines:\n     - Adaptive goal-biased sampling with dynamic probability adjustment to focus\n       exploration progressively towards the goal while still sampling widely.\n     - Heuristic-guided nearest neighbor search that uses both Euclidean distance and \n       path cost to select the best parent candidate, improving tree quality.\n     - Rewiring of nearby vertices with a radius that scales adaptively with the graph size\n       to reduce path cost dynamically (RRT* style).\n     - Adaptive max_dist step size that reduces when near obstacles or goal area for fine \n       path refinement and increases in free space for faster exploration.\n     - Early stopping if a path is found within a target cost threshold.\n     - Path shortcutting smoothing to improve path quality after extraction.\n     - Maximum 10 seconds total allowed runtime to avoid long planning delays.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n\n        self._goal_bias = 0.2  # starting probability to sample goal directly\n        self._max_dist = 15.0  # initial max extension distance\n        self._rewire_radius_constant = 30.0  # constant to scale rewiring radius\n        self._iterations = 8000  # max iterations\n        self._timeout = 10.0  # max allowed seconds to find path\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With probability self._goal_bias sample the goal point directly, else uniform random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        # Uniform random sampling over valid positions\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Direction and distance vector\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / dist\n        # Adaptive max_dist: smaller steps near obstacles or goal\n        # Check if q_near close to goal or obstacles, reduce max_dist in those cases\n        reduce_factor = 1.0\n        if self._get_grid().is_agent_in_goal_radius(agent_pos=q_near.position):\n            reduce_factor = 0.3\n        else:\n            # Check distance to nearest obstacle (estimate by grid sampling radius)\n            # To avoid expensive computing, just check neighbours near q_near\n            neighbors = self._get_grid().get_next_positions(q_near.position)\n            obstacle_near = any(not self._get_grid().is_agent_valid_pos(p) for p in neighbors)\n            if obstacle_near:\n                reduce_factor = 0.5\n        \n        adaptive_dist = max_dist * reduce_factor\n        q_new_pos_tensor = q_near.position.to_tensor() + adaptive_dist * dir_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        # Cost function: path cost + movement cost\n        # Includes from_v.cost + cost from from_v to to_v\n        c = from_v.cost + self._get_grid().get_movement_cost(from_v.position, to_v.position)\n        return c\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Among q_near_list, choose parent minimizing total cost to reach q_new\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in q_near_list:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            c = self._cost(q_near, q_new)\n            if c < best_cost:\n                best_cost = c\n                best_parent = q_near\n        \n        if best_parent is None:\n            # fallback: nearest by Euclidean distance\n            best_parent = q_near_list[0]\n            best_cost = self._cost(best_parent, q_new)\n\n        q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]):\n        # Attempt to rewire neighbors to q_new if it improves their cost via q_new\n        for q_near in q_near_list:\n            if q_near is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Remove old parent edge(s) and add new edge q_new->q_near\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = potential_cost\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace back from q_last to root_vertex_start\n        path: List[Vertex] = [q_last]\n        current = q_last\n        while len(current.parents) > 0:\n            # pick parent with lowest cost for robustness\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Path shortcutting / smoothing\n        path = self._shortcut_path(path)\n\n        # Animate path movement & key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut between non-consecutive vertices if line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n        last_best_cost = float('inf')\n        best_goal_vertex = None\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Adaptive goal bias - ramps up as iterations progress\n            self._goal_bias = min(0.7, 0.2 + 0.5 * (i / self._iterations))\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            # Validate line from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within adaptive radius for choosing parent & rewiring\n            radius = min(self._rewire_radius_constant * math.sqrt(math.log(max(1, self._graph.size)) / max(1, self._graph.size)), self._max_dist * 5)\n            neighbor_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if len(neighbor_vertices) == 0:\n                neighbor_vertices = [q_nearest]\n\n            # Choose best parent using cost heuristic\n            best_parent = self._choose_parent(neighbor_vertices, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if improvement possible\n            self._rewire(q_new, neighbor_vertices)\n\n            # If close enough to goal, try direct connection\n            goal_pos = self._get_grid().goal.position\n            if Map.get_distance(q_new.position, goal_pos) <= self._max_dist * 1.5:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Check if this new path is best so far\n                    if goal_vertex.cost < last_best_cost:\n                        last_best_cost = goal_vertex.cost\n                        best_goal_vertex = goal_vertex\n\n            # Early stop if very good path found\n            if best_goal_vertex is not None and last_best_cost < self._max_dist * 20:\n                break\n\n            # Periodically add key_frame for visualization\n            if i % 100 == 0:\n                self.key_frame()\n\n        # Extract and animate path if found\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": 559.375,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 11.43,
          "average_distance": 12.41,
          "average_smoothness": 0.34,
          "average_clearance": 2.17,
          "average_time": 0.0361,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 36.41,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -25.05,
          "average_distance_improvement": -28.47,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 8.5,
          "average_time_improvement": -362.82,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 2.75,
          "average_memory_improvement": 2.18
     }
}
{
     "algorithm": "This algorithm is an improved informed RRT* variant with goal bias and adaptive step sizes.\n    It incorporates heuristic guidance using an admissible cost-to-go estimate (Euclidean distance)\n    to guide sampling toward the goal region and speed convergence.\n    Key features:\n    - Goal-biased sampling with probability 0.2 to bias exploration near goal.\n    - Adaptive max step size based on local obstacle density to allow larger steps in open spaces and smaller in cluttered areas.\n    - Heuristic-driven rewiring for better path quality.\n    - Shortcut smoothing step is performed on the final extracted path to remove unnecessary waypoints.\n    - Early stopping if path is found or if planning exceeds 10 seconds.\n    - Uses Forest graph structure and Vertex helper functions per framework conventions.\n    This balances efficiency, robustness, and path quality improvements over classic RRT* and RRT-Connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._goal_bias_prob = 0.2\n        self._max_dist_base = 15\n        self._max_iterations = 5000\n        self._dimension = len(self._get_grid().size)\n        self._init_displays()\n\n    def _heuristic(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(p1, p2)\n\n    def _sample_informed(self) -> Point:\n        \"\"\"\n        Sample with goal biasing:\n        With a probability of self._goal_bias_prob, sample near the goal position with a small Gaussian perturbation.\n        Otherwise, sample uniformly valid random position.\n        \"\"\"\n        grid_size = self._get_grid().size\n        if np.random.rand() < self._goal_bias_prob:\n            goal_pos = self._get_grid().goal.position\n            # Perturb around goal with Gaussian noise scaled by 3 (tunable)\n            perturb = np.random.normal(scale=3.0, size=self._dimension)\n            sample_coords = np.array(goal_pos) + perturb\n            sample_coords = np.clip(sample_coords, [0]*self._dimension, np.array([grid_size.width, grid_size.height]) - 1).astype(int)\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Uniform random sampling fallback loop\n        for _ in range(10):\n            rand_coords = np.random.randint(0, [grid_size.width, grid_size.height], self._dimension)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # If 10 attempts fail, return goal position (last resort)\n        return self._get_grid().goal.position\n\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        \"\"\"\n        Adapt max step size according to local obstacle density:\n        Check neighbors in radius=8 around vertex position.\n        More obstacles nearby => smaller max_dist, fewer => larger max_dist.\n        Result clipped between 5 and self._max_dist_base.\n        \"\"\"\n        check_radius = 8\n        grid = self._get_grid()\n        pos = near_vertex.position\n        obstacle_count = 0\n        total_checked = 0\n\n        # Use width and height instead of x and y\n        max_x = grid.size.width\n        max_y = grid.size.height\n\n        # Generate points around in a square area; more efficient than querying obstacles directly\n        for dx in range(-check_radius, check_radius + 1):\n            for dy in range(-check_radius, check_radius + 1):\n                candidate = Point(pos.x + dx, pos.y + dy)\n                if 0 <= candidate.x < max_x and 0 <= candidate.y < max_y:\n                    total_checked += 1\n                    if not grid.is_agent_valid_pos(candidate):\n                        obstacle_count += 1\n        density = obstacle_count / total_checked if total_checked > 0 else 0.0\n\n        # Inverse proportional to density: more dense = smaller max step\n        max_dist = self._max_dist_base * (1.0 - 0.7 * density)\n        return max(5.0, min(max_dist, self._max_dist_base))\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_goal: Vertex) -> List[Point]:\n        \"\"\"\n        Extract path by backtracking parents from goal vertex to start.\n        Also perform shortcut smoothing to improve path.\n        \"\"\"\n        path_vertices: List[Vertex] = [q_goal]\n        while len(path_vertices[-1].parents) != 0:\n            parent = next(iter(path_vertices[-1].parents))\n            path_vertices.append(parent)\n        path_vertices.reverse()\n\n        path_points = [v.position for v in path_vertices]\n\n        # Shortcut smoothing: Try shortcuts by skipping intermediate vertices if line is collision free.\n        def shortcut_path(points: List[Point]) -> List[Point]:\n            if len(points) <= 2:\n                return points\n            smoothed = [points[0]]\n            i = 0\n            while i < len(points) - 1:\n                j = len(points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(smoothed[-1], points[j])\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                smoothed.append(points[j])\n                i = j\n            return smoothed\n\n        smoothed_path = shortcut_path(path_points)\n        return smoothed_path\n\n    def _move_agent_along_path(self, path_points: List[Point]) -> None:\n        for p in path_points:\n            self.move_agent(p)\n            # ROS-specific waypoint publishing if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # The main planning function #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_radius_const = 40.0\n        lambda_rrt_star = 40.0\n        for i in range(self._max_iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:   # timeout after 10 seconds\n                break\n\n            q_sample: Point = self._sample_informed()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_nearest)\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), max_radius_const)\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimal cost + heuristic + movement cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position) + self._heuristic(q_new.position, self._get_grid().goal.position)\n\n            for q_near in neighbors:\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_to_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position) + self._heuristic(q_new.position, self._get_grid().goal.position)\n                if cost_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_to_new\n\n            edge_cost = self._get_grid().get_distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + edge_cost\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if going through q_new is cheaper\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                    # Add edge from q_new\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # If close enough to goal, add goal vertex and extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    path_points = self._extract_path(goal_vertex)\n                    self._move_agent_along_path(path_points)\n                    break\n\n            self.key_frame()",
     "objective": 35027.02,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.0,
          "average_steps": 9.59,
          "average_distance": 10.12,
          "average_smoothness": 0.34,
          "average_clearance": 2.02,
          "average_time": 1.8228,
          "average_distance_from_goal": 0.3,
          "average_original_distance_from_goal": 8.42,
          "average memory": 112.21,
          "goal_found_perc_improvement": -1.37,
          "average_steps_improvement": -4.47,
          "average_distance_improvement": -4.44,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 2.02,
          "average_time_improvement": -22973.42,
          "average_distance_from_goal_improvement": -50.0,
          "average_path_deviation": 0.4299999999999997,
          "average_memory_improvement": -201.48
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0074,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired planning method with goal biasing and dynamic shortcutting.\n    It balances exploration and exploitation by sampling points with a goal bias probability and uses a rewiring procedure\n    to optimize the path incrementally for lower cost and smoother connection. Adaptive step size scaling is used based\n    on distance to goal to speed up exploration in open spaces and fine movements near the goal.\n    The algorithm includes early stopping when a high-quality path is found or after a time budget (10 seconds).\n    Once a path is found, a shortcut smoothing step is applied to reduce unnecessary bends in the path.\n    This algorithm aims to improve efficiency, path quality and robustness over baseline RRT and RRT-Connect implementations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Parameters\n        self._max_dist_base = 15.0   # maximum step size for extension\n        self._goal_sample_rate = 0.2 # probability of sampling the goal to bias growth\n        self._iterations_limit = 10000  # max iterations\n        self._rewire_radius = 20.0    # radius to attempt rewiring for optimization\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling with probability goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, vertices: List[Vertex]) -> Vertex:\n        # Choose parent among nearby vertices that minimizes cost to q_new (RRT* rewiring parent selection)\n        cost_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n\n        for v in vertices:\n            if v == q_near:\n                continue\n            cost_to_new = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost_to_new < cost_min:\n                line = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    cost_min = cost_to_new\n                    best_parent = v\n\n        q_new.cost = cost_min\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if cost improves (RRT* rewiring)\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    # Remove old edge(s) to v from parents and add q_new as parent\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _extract_path(self, end_vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [end_vertex]\n        current = end_vertex\n        while len(current.parents) != 0:\n            # Choose parent with minimum cost leading to current\n            min_parent = None\n            min_cost = float(\"inf\")\n            for p in current.parents:\n                cost = p.cost + self._get_grid().get_movement_cost(p.position, current.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            current = min_parent\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: repeatedly try to directly connect non-adjacent points\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next point\n                smoothed_path.append(path[i + 1])\n                i += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialize start vertex cost and root vertices\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        path_found = False\n        best_goal_vertex: Vertex = None\n        best_goal_cost = float(\"inf\")\n\n        for iteration in range(self._iterations_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout limit reached: treat as no path found\n                break\n\n            q_sample = self._get_random_sample()\n            root_verts = self._graph.root_vertices\n\n            # Nearest vertex to sample\n            q_near = self._get_nearest_vertex(root_verts, q_sample)\n            # Adaptive max step size based on distance to goal (closer -> smaller)\n            dist_to_goal = self._get_distance(q_near.position, goal_vertex.position)\n            max_dist = min(self._max_dist_base, dist_to_goal * 1.2)\n\n            # New vertex toward sample relative to max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check validity of edge q_near->q_new\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            # Find nearby vertices for possible better parent and rewiring (RRT* neighborhood)\n            neighbors = self._get_vertices_within_radius(root_verts, q_new.position, self._rewire_radius)\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n\n            # Add new vertex and edge with best_parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better cost paths through q_new\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to root vertices for sampling & rewiring\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new is close enough to goal to connect\n            if self._get_distance(q_new.position, goal_vertex.position) <= max_dist:\n                # Attempt connect q_new to goal vertex if valid line\n                goal_line = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line):\n                    # Connect goal vertex\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.root_vertices.append(goal_vertex)\n                    path_found = True\n                    best_goal_vertex = goal_vertex\n                    best_goal_cost = goal_vertex.cost\n                    break\n\n            self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            # Extract and shortcut path\n            raw_path = self._extract_path(best_goal_vertex)\n            smoothed_path = self._shortcut_path(raw_path)\n\n            # Animate movement along smoothed path\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": 3822.335,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 11.08,
          "average_distance": 11.8,
          "average_smoothness": 0.34,
          "average_clearance": 2.14,
          "average_time": 0.1855,
          "average_distance_from_goal": 0.25,
          "average_original_distance_from_goal": 8.42,
          "average memory": 50.26,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -21.49,
          "average_distance_improvement": -22.53,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 6.47,
          "average_time_improvement": -2441.1,
          "average_distance_from_goal_improvement": -25.0,
          "average_path_deviation": 2.17,
          "average_memory_improvement": -35.03
     }
}
{
     "algorithm": "Improved Path Planning Algorithm inspired by RRT* with Goal-Biased Adaptive Sampling, \n    Heuristic-Guided Vertex Expansion, and Dynamic Step Sizing. \n\n    Key features:\n    - Goal-biased sampling (sampling towards the goal with increasing probability as the tree grows)\n    - Adaptive step size that decreases based on distance to goal, promoting finer movements near goal\n    - Heuristic cost function combining path cost + Euclidean distance to goal (A*-style)\n    - Rewiring vertices for path optimality (like RRT*)\n    - Early stopping if goal is connected or 10 seconds runtime exceeded\n    - Shortcut smoothing on extracted path to enhance path quality\n    - Uses a Forest graph with vertices and edges, consistent with prior algorithms\n    \n    This approach balances exploration and exploitation, reduces planning time, improves success rate\n    and produces smoother, shorter paths than basic RRT* or SPRM variants.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _max_runtime_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_runtime_seconds = 10.0\n        self._start_time = time.perf_counter()\n        self._init_displays()\n\n    def _get_random_sample(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Goal biased sampling:\n        - Probability to sample directly the goal increases linearly with iteration progress\n        \"\"\"\n        prob_goal_sample = min(0.2 + 0.8 * (iteration / max_iterations), 0.95)\n        if random.random() < prob_goal_sample:\n            return self._goal_vertex.position\n        while True:\n            rand_coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        dist_cost = torch.norm(from_vertex.position.to_tensor() - to_point.to_tensor())\n        return from_vertex.cost + dist_cost\n\n    def _extract_and_smooth_path(self, connection_vertex: Vertex) -> None:\n        path: List[Vertex] = [self._goal_vertex]\n        current = connection_vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            parents_list = list(current.parents)\n            current = parents_list[0]\n        path.reverse()\n\n        # Shortcut path smoothing by attempting to connect non-adjacent points directly if collision free\n        def try_shortcut(path_points: List[Vertex]) -> List[Vertex]:\n            smoothed_path = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path_points[i].position, path_points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed_path.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed_path.append(path_points[i+1])\n                    i += 1\n            return smoothed_path\n\n        path = try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):  # For ROS map integration\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        iteration: int = 0\n\n        while iteration < max_iterations:\n            iteration += 1\n            # Check elapsed time for early stopping\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_runtime_seconds:\n                # Failed to find path in time\n                return\n\n            q_sample = self._get_random_sample(iteration, max_iterations)\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size decreases near goal to allow finer connection attempts\n            dist_to_goal = torch.norm(q_nearest.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision-free path from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute radius for neighbor search for rewiring\n            card_v = max(1.0, float(self._graph.size))\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            # Choose best parent based on cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in neighbors:\n                # Cost from neighbor to new vertex\n                dist_neighbor_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_neighbor = q_near.cost + dist_neighbor_to_new\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check) and cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better via q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge\n                    q_near_parent = None\n                    for parent in q_near.parents:\n                        q_near_parent = parent\n                        break\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n                    # Add edge from new parent q_new\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal proximity and link if possible\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_and_smooth_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": 5558.53,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 10.05,
          "average_distance": 10.63,
          "average_smoothness": 0.33,
          "average_clearance": 2.07,
          "average_time": 0.2748,
          "average_distance_from_goal": 0.28,
          "average_original_distance_from_goal": 8.42,
          "average memory": 46.0,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -10.08,
          "average_distance_improvement": -10.27,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 2.99,
          "average_time_improvement": -3613.51,
          "average_distance_from_goal_improvement": -40.0,
          "average_path_deviation": 0.9900000000000002,
          "average_memory_improvement": -23.59
     }
}
