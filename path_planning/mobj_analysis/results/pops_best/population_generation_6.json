{
     "operator": "time_expert",
     "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
     "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -25.46582,
     "time_improvement": 54.0,
     "length_improvement": 15.0,
     "smoothness_improvement": 1244.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.019983816146850585,
               "num_nodes_avg": 96.8,
               "path_length_avg": 170.2199533723818,
               "smoothness_avg": 0.03191661323621712,
               "success_improvement": 0.0,
               "time_improvement": 15.716301131147329,
               "length_improvement": 6.6997462488276955,
               "smoothness_improvement": 399.5643051817539,
               "objective_score": 8.052661115018507
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.05431396961212158,
               "num_nodes_avg": 257.2,
               "path_length_avg": 236.52350437862407,
               "smoothness_avg": 0.08310278940495856,
               "success_improvement": 0.0,
               "time_improvement": 77.35540855616505,
               "length_improvement": 21.04164628681887,
               "smoothness_improvement": 2038.2946279093733,
               "objective_score": 37.606424963760155
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.03142735958099365,
               "num_nodes_avg": 216.0,
               "path_length_avg": 125.86434766351888,
               "smoothness_avg": 0.10952251178835211,
               "success_improvement": 0.0,
               "time_improvement": 69.97134180929318,
               "length_improvement": 16.406893298066827,
               "smoothness_improvement": 1293.1182658369369,
               "objective_score": 30.738372531586002
          }
     ],
     "success_rate": 1.0
}