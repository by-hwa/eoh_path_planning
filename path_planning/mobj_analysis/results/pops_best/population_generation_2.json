{
     "operator": "m3",
     "algorithm_description": "This algorithm presents an enhanced bidirectional RRT with goal biasing and simplified structure to improve efficiency and path quality. It grows two trees simultaneously\u2014from start and goal\u2014and attempts to connect them, alternating expansion in each iteration. Goal biasing increases convergence speed toward the goal. The approach includes collision checks for nodes and edges, pruning redundant exploration, and incremental connection attempts to improve robustness and success rate. Path extraction merges the two trees into a smooth, feasible path.",
     "planning_mechanism": "The planner alternates growing start and goal trees by steering towards samples, employs goal biasing to guide exploration, performs collision-free extension checks, and attempts to connect the two trees incrementally. Upon connecting, it extracts a final path by tracing parents from both trees, ensuring a feasible, smooth solution with reduced search overhead.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for itr in range(self.max_iter):\n            # Alternate start and goal tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try connecting trees\n                near_connect = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_connect = math.dist(new_pos, near_connect.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, near_connect.position, obstacles, is_3d):\n                        conn_node = Node(near_connect.position, parent=new_node, cost=new_node.cost + dist_connect)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Reconstruct path\n                        path = self._extract_path(conn_node, near_connect)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        # Extract path from node_a up to root start tree\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        # Extract path from node_b up to root goal tree\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        # Since node_b belongs to opposite tree, append its reversed path (excluding first duplicate node)\n        return path_a + path_b[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -24.73192,
     "time_improvement": 85.0,
     "length_improvement": -6.0,
     "smoothness_improvement": 64.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.0071019411087036135,
               "num_nodes_avg": 114.7,
               "path_length_avg": 183.5187018824448,
               "smoothness_avg": 0.010997871352320374,
               "success_improvement": 0.0,
               "time_improvement": 71.70916792508382,
               "length_improvement": -0.5895085416933348,
               "smoothness_improvement": 72.14056892370422,
               "objective_score": 21.755551513805
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.011534762382507325,
               "num_nodes_avg": 259.9,
               "path_length_avg": 309.6814971266057,
               "smoothness_avg": 0.0064039069277323805,
               "success_improvement": 0.0,
               "time_improvement": 93.00682632435114,
               "length_improvement": -3.3805974285229334,
               "smoothness_improvement": 64.77713779827361,
               "objective_score": 27.549814100592123
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.004734683036804199,
               "num_nodes_avg": 190.4,
               "path_length_avg": 169.66580872434636,
               "smoothness_avg": 0.01221306295668852,
               "success_improvement": 0.0,
               "time_improvement": 90.50144735658925,
               "length_improvement": -12.68395153709525,
               "smoothness_improvement": 55.34925933454292,
               "objective_score": 24.89039019623044
          }
     ],
     "success_rate": 1.0
}