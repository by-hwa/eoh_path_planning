{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional RRT* with Sampling Bias and Localized Lazy Collision Checking to improve planning efficiency, path quality, robustness, and smoothness. It dynamically adjusts the sampling domain using heuristic-guided informed sampling biased towards promising regions, interleaves tree growth from start and goal, employs KD-tree for efficient neighbor queries, and performs lazy collision checks during rewiring to reduce expensive computations. Additionally, a post-processing shortcut smoothing using smart edge checking is applied to enhance path smoothness and shorten final path length.",
     "planning_mechanism": "The planner grows two trees from start and goal positions alternately, samples points adaptively biased towards the current best path region, extends one tree toward sampled points, rewires neighbors using efficient KD-tree-based radius search with lazy collision checking, and attempts to connect the two trees. Upon connection, it extracts and shortcuts the combined path while validating collision-free edges. It leverages pruning of nodes not capable of improving current best path and maintains balanced tree growth for robustness and reduced search time.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity or lazy checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 shortcut_iter: int = 150, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius)*math.sqrt(math.log(n_nodes + 1) / (n_nodes))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges and nodes\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b)\n            key_rev = (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # KDTree for neighbor search (simple linear search)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling biased towards best found path corridor with heuristic weights\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with retries for obstacle free\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-5:  # avoid zero vector\n                    x_ball = x_ball / norm_x * random.uniform(0,1) ** (1.0/dim)  # uniform in ball\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Shortcut smoothing on path using lazy collision checks\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n\n        nodes_start = [root_start]\n        nodes_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Balanced tree growth flag\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Select which tree to grow based on sizes for balance\n            if len(nodes_start) <= len(nodes_goal):\n                tree_a_nodes, tree_b_nodes = nodes_start, nodes_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a_nodes, tree_b_nodes = nodes_goal, nodes_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a_nodes])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = radius(iteration, len(nodes_all))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: first minimal cost parent selection (do edge check lazily)\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # Check connectivity lazily now\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a_nodes.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost paths if possible\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, c_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b_nodes])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            if dist(new_node.position, nearest_b.position) <= self.step_size and \\\n               not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Connect directly\n                cost_connection = new_node.cost + dist(new_node.position, nearest_b.position)\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_connection)\n                new_node.children.append(connect_node)\n                tree_a_nodes.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                # Extract full path\n                if growing_from_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                # Shortcut smoothing for improved path quality\n                smoothed_path = shortcut_path(merged_path)\n\n                c_candidate = connect_node.cost + (nearest_b.cost if growing_from_start else new_node.cost)\n                if c_candidate < c_best:\n                    c_best = c_candidate\n                    best_path = smoothed_path\n                    success_state = True\n\n                extracted_path = best_path\n                break\n\n            # Else do incremental connection attempt with limited steps from nearest_b toward new_node\n            dist_to_newnode = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_to_newnode / self.step_size))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos) or is_edge_colliding_cached(last_node_b.position, next_pos):\n                    break\n                cost_next = last_node_b.cost + dist(last_node_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_node_b, cost=cost_next)\n                last_node_b.children.append(new_node_b)\n                tree_b_nodes.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                near_b = kdtree_b.radius_search(next_pos, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    # Connect finally\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b_nodes.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if cost_conn < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n                        success_state = True\n\n                    extracted_path = best_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -24.30002,
     "time_improvement": 43.0,
     "length_improvement": 18.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.016922187805175782,
               "num_nodes_avg": 73.5,
               "path_length_avg": 154.23200362778806,
               "smoothness_avg": 0.04002093790061885,
               "success_improvement": 0.0,
               "time_improvement": 32.784829785863906,
               "length_improvement": 15.46299484911554,
               "smoothness_improvement": 526.4145850023286,
               "objective_score": 15.560120830593922
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.045720887184143064,
               "num_nodes_avg": 212.9,
               "path_length_avg": 237.2164084286152,
               "smoothness_avg": 0.10522668171555331,
               "success_improvement": 0.0,
               "time_improvement": 72.29510884836787,
               "length_improvement": 20.81033497079458,
               "smoothness_improvement": 2607.558312256502,
               "objective_score": 38.88839120995179
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.03875234127044678,
               "num_nodes_avg": 157.1,
               "path_length_avg": 123.32472678199296,
               "smoothness_avg": 0.1265137676603671,
               "success_improvement": 0.0,
               "time_improvement": 24.288718052866827,
               "length_improvement": 18.093588563825442,
               "smoothness_improvement": 1509.245786364919,
               "objective_score": 18.45156206044973
          }
     ],
     "smoothness_improvement": 1548.0,
     "success_rate": 1.0
}