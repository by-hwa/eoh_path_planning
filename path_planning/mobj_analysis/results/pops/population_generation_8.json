[
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling. It grows two trees alternately from start and goal, dynamically rewiring neighbors to optimize path cost and smoothness. Rigorous collision checks for nodes and edges ensure path validity. The algorithm enforces a 30-second runtime limit, returns the best feasible path found so far, and applies path smoothing for improved quality and shorter lengths.",
          "planning_mechanism": "The planner alternately samples points biased towards the opposite tree\u2019s root, extends the current tree incrementally with step-size limits, rewires neighbors within an adaptive radius to minimize cost, and attempts incremental connections to the other tree. On successful connection or timeout, it reconstructs and smooths the combined path. Nodes and edges are tracked for roadmap analysis.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Update parent and cost, then propagate cost updates recursively to children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            # Goal-biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return tree_to_root_pos  # fallback\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                # Shortcut path\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Combine with no duplicated connect node\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=100)\n                    success_state = True\n\n                # Early termination when found a connection\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early stop but found best path, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=100)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.71144,
          "time_improvement": 64.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1391.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01094198226928711,
                    "num_nodes_avg": 71.9,
                    "path_length_avg": 159.3879990283421,
                    "smoothness_avg": 0.03611968111442979,
                    "success_improvement": 0.0,
                    "time_improvement": 53.851119734292496,
                    "length_improvement": 12.636912068096395,
                    "smoothness_improvement": 465.3514445837642,
                    "objective_score": 21.009475556825848
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055727267265319826,
                    "num_nodes_avg": 295.1,
                    "path_length_avg": 229.22588968501387,
                    "smoothness_avg": 0.0851665813883569,
                    "success_improvement": 0.0,
                    "time_improvement": 76.76617620629713,
                    "length_improvement": 23.477800121738362,
                    "smoothness_improvement": 2091.3974821314937,
                    "objective_score": 38.18240029689428
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04135787487030029,
                    "num_nodes_avg": 235.5,
                    "path_length_avg": 122.57216148158086,
                    "smoothness_avg": 0.13488954490947164,
                    "success_improvement": 0.0,
                    "time_improvement": 60.482792556160256,
                    "length_improvement": 18.593406603050504,
                    "smoothness_improvement": 1615.7850547379617,
                    "objective_score": 29.942444361147988
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased and informed sampling, adaptive neighbor radius, incremental extend-and-rewire expansions, and progressive tree connection attempts. It dynamically rewires nodes to optimize path cost while respecting map boundaries and obstacles, applies multiple passes of path smoothing, and enforces a strict time limit of 30 seconds to ensure timely responses.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled points generated with a bias towards the goal and an ellipsoidal informed region after an initial solution is found. Each extension attempts to connect to the opposite tree incrementally. Adaptive neighbor radius ensures locally appropriate rewiring for cost optimization. On connection, best paths from both trees are combined, smoothed, and returned. The process halts if time runs out, returning the best available path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Cost from root\n        self.children: List[Node] = []        # List of child nodes\n        self.valid = True                     # For collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                           # Tuple[int, ...]\n        start_pos = map.start                       # Tuple[float, ...]\n        goal_pos = map.goal                         # Tuple[float, ...]\n        obstacles = map.obstacles                   # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning parameter\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors for potentially better paths\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n\n        iter_cnt = 0\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplication of connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Apply smoothing and return early\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or iteration limit, return best path found (if any)\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.07081,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1580.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01549065113067627,
                    "num_nodes_avg": 67.1,
                    "path_length_avg": 160.82071621613,
                    "smoothness_avg": 0.04018716215495074,
                    "success_improvement": 0.0,
                    "time_improvement": 34.666663985190205,
                    "length_improvement": 11.851617074613193,
                    "smoothness_improvement": 529.0163555443684,
                    "objective_score": 15.415404388201543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04627766609191895,
                    "num_nodes_avg": 218.8,
                    "path_length_avg": 234.7337667638325,
                    "smoothness_avg": 0.10335063168007959,
                    "success_improvement": 0.0,
                    "time_improvement": 80.70590588186646,
                    "length_improvement": 21.639112217377225,
                    "smoothness_improvement": 2559.2861935795413,
                    "objective_score": 41.33602517593309
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.049237298965454104,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 125.59843408327171,
                    "smoothness_avg": 0.13770665612117666,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95404893761946,
                    "length_improvement": 16.583500436623012,
                    "smoothness_improvement": 1651.6185014133298,
                    "objective_score": 27.46100727567709
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius, incremental extend-and-rewire expansions, and continuous path optimization. It employs goal bias and ellipsoidal informed sampling after the first solution to focus search, ensures collision-free node and edge placement, and manages trees with parent-child relationships for efficient rewiring and cost updates. It enforces a strict 30-second time limit, returning the best smoothed path found if time expires.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending towards sampled points drawn either uniformly or from an informed ellipsoidal region after an initial solution is found. Each extension rewires nearby nodes within an adaptive radius for cost optimization. Incremental connection attempts are made between trees to merge paths early. Efficient collision checks prevent invalid expansions. Path smoothing refines the solution before returning. The process halts upon time expiration or success, delivering an optimized, smooth, and low-cost path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []  # Child nodes list\n        self.valid = True               # For collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...] (W,H) or (W,H,D)\n        start_pos = map.start                  # Tuple[float, ...]\n        goal_pos = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles (rectangular)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning constant\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees from start and goal\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n        iteration = 0\n        success_state = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iteration += 1\n\n            # Sample point for tree extension\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            # Extend the chosen tree\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicate connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # After max iterations or timeout, return best found path if any\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.52708,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1634.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01539454460144043,
                    "num_nodes_avg": 62.4,
                    "path_length_avg": 162.07334389473203,
                    "smoothness_avg": 0.038528230647502874,
                    "success_improvement": 0.0,
                    "time_improvement": 35.07200267075055,
                    "length_improvement": 11.16503199481564,
                    "smoothness_improvement": 503.05047502538207,
                    "objective_score": 15.269859575315202
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.060103225708007815,
                    "num_nodes_avg": 246.0,
                    "path_length_avg": 235.23042013392615,
                    "smoothness_avg": 0.11139777289001798,
                    "success_improvement": 0.0,
                    "time_improvement": 74.94175070734124,
                    "length_improvement": 21.473315027065336,
                    "smoothness_improvement": 2766.3449330327885,
                    "objective_score": 40.60891288277938
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0526397705078125,
                    "num_nodes_avg": 220.7,
                    "path_length_avg": 123.26986202793978,
                    "smoothness_avg": 0.13625179478905936,
                    "success_improvement": 0.0,
                    "time_improvement": 49.70300728756376,
                    "length_improvement": 18.13002712108873,
                    "smoothness_improvement": 1633.1127726554907,
                    "objective_score": 26.702471473764327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.46582,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1244.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019983816146850585,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 170.2199533723818,
                    "smoothness_avg": 0.03191661323621712,
                    "success_improvement": 0.0,
                    "time_improvement": 15.716301131147329,
                    "length_improvement": 6.6997462488276955,
                    "smoothness_improvement": 399.5643051817539,
                    "objective_score": 8.052661115018507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05431396961212158,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 236.52350437862407,
                    "smoothness_avg": 0.08310278940495856,
                    "success_improvement": 0.0,
                    "time_improvement": 77.35540855616505,
                    "length_improvement": 21.04164628681887,
                    "smoothness_improvement": 2038.2946279093733,
                    "objective_score": 37.606424963760155
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03142735958099365,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 125.86434766351888,
                    "smoothness_avg": 0.10952251178835211,
                    "success_improvement": 0.0,
                    "time_improvement": 69.97134180929318,
                    "length_improvement": 16.406893298066827,
                    "smoothness_improvement": 1293.1182658369369,
                    "objective_score": 30.738372531586002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation uses a bidirectional RRT* algorithm that simultaneously grows two trees from the start and goal positions, respectively. The planner incrementally extends each tree by sampling points with a goal bias, steering toward samples by a fixed step size, and choosing minimum cost parents from nearby neighbors while enforcing collision-free constraints. It dynamically rewires neighbors to optimize path costs. The algorithm attempts to connect the two trees at each iteration, returning the shortest found path upon connection or when the 30-second time limit expires. Finally, path smoothing via random shortcutting reduces unnecessary waypoints, improving path length and smoothness.",
          "planning_mechanism": "The planner alternately grows two search trees bidirectionally from start and goal, performing nearest neighbor queries and neighborhood rewiring for cost optimization. New nodes are added if collision-free, and trees are connected when possible to find paths faster. Rewiring and adaptive neighbor radius enhance path quality. The planning process respects map bounds and obstacles, employing collision checks on nodes and edges. Early termination occurs if a valid path is found or when time limits expire, ensuring efficiency and practical usability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # float\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_constant: float = 30.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        edges = []\n        connection_found = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        start_time = time.time()\n\n        def swap_trees():\n            nonlocal start_tree, goal_tree\n            start_tree, goal_tree = goal_tree, start_tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            dims = len(bounds)\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    yield goal_position\n                else:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        yield point\n\n        sample_iterator = sample_free()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            sample = next(sample_iterator)\n\n            # Extend start_tree towards sample\n            nearest_start = self._nearest(start_tree, sample)\n            new_pos_start = self._steer(nearest_start.position, sample)\n\n            if not self._in_bounds(new_pos_start, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_start, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d):\n                continue\n\n            # Find neighbors in start_tree for rewiring\n            neighbor_radius_start = self._adaptive_radius(len(start_tree))\n            neighbors_start = self._near_nodes(start_tree, new_pos_start, neighbor_radius_start)\n\n            # Choose best parent in start_tree\n            min_cost_start = nearest_start.cost + dist(nearest_start.position, new_pos_start)\n            best_parent_start = nearest_start\n            for neighbor in neighbors_start:\n                cost = neighbor.cost + dist(neighbor.position, new_pos_start)\n                if cost < min_cost_start and not self._is_edge_in_obstacle(neighbor.position, new_pos_start, obstacles, is_3d):\n                    min_cost_start = cost\n                    best_parent_start = neighbor\n\n            new_start_node = Node(new_pos_start)\n            best_parent_start.add_child(new_start_node)\n            new_start_node.cost = min_cost_start\n            start_tree.append(new_start_node)\n            edges.append((best_parent_start, new_start_node))\n\n            # Rewire neighbors in start_tree through new_start_node\n            for neighbor in neighbors_start:\n                if neighbor is best_parent_start:\n                    continue\n                new_cost = new_start_node.cost + dist(new_start_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_start_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_start_node, new_cost)\n                    edges.append((new_start_node, neighbor))\n\n            # Extend goal_tree towards new_start_node.position to attempt connection\n            nearest_goal = self._nearest(goal_tree, new_start_node.position)\n            new_pos_goal = self._steer(nearest_goal.position, new_start_node.position)\n\n            if not self._in_bounds(new_pos_goal, bounds):\n                pass  # don't connect if out of bounds\n            elif self._is_in_obstacle(new_pos_goal, obstacles, is_3d):\n                pass  # skip if in obstacle\n            elif self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d):\n                pass  # skip if edge collides\n            else:\n                neighbor_radius_goal = self._adaptive_radius(len(goal_tree))\n                neighbors_goal = self._near_nodes(goal_tree, new_pos_goal, neighbor_radius_goal)\n\n                min_cost_goal = nearest_goal.cost + dist(nearest_goal.position, new_pos_goal)\n                best_parent_goal = nearest_goal\n                for neighbor in neighbors_goal:\n                    cost = neighbor.cost + dist(neighbor.position, new_pos_goal)\n                    if cost < min_cost_goal and not self._is_edge_in_obstacle(neighbor.position, new_pos_goal, obstacles, is_3d):\n                        min_cost_goal = cost\n                        best_parent_goal = neighbor\n\n                new_goal_node = Node(new_pos_goal)\n                best_parent_goal.add_child(new_goal_node)\n                new_goal_node.cost = min_cost_goal\n                goal_tree.append(new_goal_node)\n                edges.append((best_parent_goal, new_goal_node))\n\n                # Rewire neighbors in goal_tree through new_goal_node\n                for neighbor in neighbors_goal:\n                    if neighbor is best_parent_goal:\n                        continue\n                    new_cost = new_goal_node.cost + dist(new_goal_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_goal_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_goal_node, new_cost)\n                        edges.append((new_goal_node, neighbor))\n\n                # Check if we can connect new_start_node and new_goal_node\n                if dist(new_start_node.position, new_goal_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_start_node.position, new_goal_node.position, obstacles, is_3d):\n                        cost_to_connect = new_start_node.cost + dist(new_start_node.position, new_goal_node.position) + new_goal_node.cost\n                        if cost_to_connect < best_cost:\n                            best_cost = cost_to_connect\n                            best_start_node = new_start_node\n                            best_goal_node = new_goal_node\n                            connection_found = True\n\n            if connection_found:\n                break\n\n            # Swap trees for balanced growth\n            swap_trees()\n\n        success_state = connection_found\n        extracted_path = []\n\n        if success_state and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            path_goal.reverse()  # reverse to goal root\n            # Concatenate paths avoiding duplication of connection point\n            full_path = path_start + path_goal[1:]\n            extracted_path = self._path_smoothing(full_path, obstacles, is_3d)\n        else:\n            # If no connection found, return best path among both trees' closest nodes to goal\n            # Find closest node in start_tree to goal and in goal_tree to start, pick shorter path\n            def best_approx_path(tree, target_pos):\n                best_node = min(tree, key=lambda n: dist(n.position, target_pos))\n                return best_node.path_from_root(), best_node.cost, best_node\n\n            start_path, start_cost, _ = best_approx_path(start_tree, goal_position)\n            goal_path, goal_cost, _ = best_approx_path(goal_tree, start_position)\n\n            # Pick the path with smaller heuristic cost to goal or start respectively\n            if start_cost + dist(start_path[-1], goal_position) < goal_cost + dist(goal_path[-1], start_position):\n                approx_path = start_path\n            else:\n                approx_path = goal_path[::-1]\n\n            extracted_path = self._path_smoothing(approx_path, obstacles, is_3d)\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree,\n            edges=edges\n        )\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _adaptive_radius(self, n_nodes):\n        # Algorithm adapts neighbor radius proportional to (log n / n)^{1/d} with constant scaling\n        if n_nodes <= 1:\n            return self.neighbor_radius_constant\n        dim = len(bounds) if hasattr(self, 'bounds') else 2  # fallback dim=2\n        gamma_rrt_star = self.neighbor_radius_constant\n        radius = min(gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim), self.step_size * 50)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_iterations=150):\n        if len(path) < 3:\n            return path[:]\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path",
          "objective": -25.04421,
          "time_improvement": 46.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1597.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024372053146362305,
                    "num_nodes_avg": 113.8,
                    "path_length_avg": 159.5915861709516,
                    "smoothness_avg": 0.04184470687683983,
                    "success_improvement": 0.0,
                    "time_improvement": -2.79151755143659,
                    "length_improvement": 12.52532272918742,
                    "smoothness_improvement": 554.9605298579069,
                    "objective_score": 4.442411929696042
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04618837833404541,
                    "num_nodes_avg": 284.8,
                    "path_length_avg": 242.9965020999087,
                    "smoothness_avg": 0.1070723847689884,
                    "success_improvement": 0.0,
                    "time_improvement": 80.74313175234548,
                    "length_improvement": 18.880773332545168,
                    "smoothness_improvement": 2655.0495812275612,
                    "objective_score": 41.27434209835048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041561317443847653,
                    "num_nodes_avg": 236.3,
                    "path_length_avg": 124.76782145766249,
                    "smoothness_avg": 0.13211293366663907,
                    "success_improvement": 0.0,
                    "time_improvement": 60.288404367526496,
                    "length_improvement": 17.135153793029748,
                    "smoothness_improvement": 1580.4667646772543,
                    "objective_score": 29.415885892250166
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed and goal-biased sampling, adaptive neighborhood rewiring, incremental tree connection, and time-bounded execution. It balances fast convergence and path quality by dynamically rewiring nodes for cost optimization, alternating expansions from start and goal, and smoothing the resulting path for improved smoothness and shorter length while respecting obstacle constraints and map boundaries.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, alternately sampling points biased toward the goal or informed ellipsoidal region after a first solution. Each extension steers within a step size, checks collisions for nodes and edges, rewires neighbors to reduce costs, and attempts incremental connection between trees. When a connection is established or time limit is reached, it extracts, smooths, and returns the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            # RRT* radius scaling for dimension dim\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def clamp_to_bounds(pos):\n            return tuple(\n                max(0.0, min(bounds[d], pos[d])) for d in range(dim)\n            )\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                # fallback to identity if direction is aligned with x-axis\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta*cos_theta)\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        # Connect the new_node to opposite tree incrementally with rewiring\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    # Time limit reached \u2014 extract best path found so far\n                    if best_path:\n                        extracted_path_final = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path_final, all_nodes, edges)\n                    else:\n                        return PlannerResult(False, [], all_nodes, edges)\n\n                iter_count += 1\n                sample = None\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start_tree:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_goal)\n                    if connect_node:\n                        # Build path\n                        path_s = new_node.path_from_root()\n                        path_g = connect_node.path_from_root()\n\n                        # Avoid duplicate node position overlap in merged path\n                        if path_g and path_g[0] == new_node.position:\n                            path_g = path_g[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        # Update edges for all new nodes (maintain consistent edges)\n                        # Clear and re-build edges\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_start)\n                    if connect_node:\n                        path_g = new_node.path_from_root()\n                        path_s = connect_node.path_from_root()\n                        if path_s and path_s[0] == new_node.position:\n                            path_s = path_s[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                grow_start_tree = not grow_start_tree\n            break  # exit outer while if max_iter reached\n\n        # No complete connection found, try best path extraction\n        if best_path:\n            extracted_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            success_state = False\n            extracted_path = []\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.40163,
          "time_improvement": 45.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1453.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02057945728302002,
                    "num_nodes_avg": 65.5,
                    "path_length_avg": 156.83014571172365,
                    "smoothness_avg": 0.03866421328032622,
                    "success_improvement": 0.0,
                    "time_improvement": 13.204126390052256,
                    "length_improvement": 14.038912002714524,
                    "smoothness_improvement": 505.1788985200809,
                    "objective_score": 9.294914810158986
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04782705307006836,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 235.04300669404265,
                    "smoothness_avg": 0.09978280006234666,
                    "success_improvement": 0.0,
                    "time_improvement": 80.05993514249408,
                    "length_improvement": 21.535879027695216,
                    "smoothness_improvement": 2467.483316250031,
                    "objective_score": 40.66257292953742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059801268577575686,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 124.49733655203302,
                    "smoothness_avg": 0.1167675547851698,
                    "success_improvement": 0.0,
                    "time_improvement": 42.86023778552829,
                    "length_improvement": 17.314796988241735,
                    "smoothness_improvement": 1385.2746779830118,
                    "objective_score": 23.247404123221894
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* approach with adaptive neighbor radius, goal-biased sampling, and incremental extend-and-rewire steps to efficiently grow two trees from start and goal towards each other. It performs rigorous collision and edge checks, dynamically rewires nodes to optimize path cost, and applies path smoothing for better quality. The planning process enforces a strict 30-second runtime limit, returning the best feasible path found at timeout or successful connection.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the opposite tree root. New nodes are added with step size limits, parents chosen from neighbors within an adaptive radius to minimize cost, and rewiring performed to improve the tree structure. Incremental connections from one tree to the other attempt efficient merges. On successful connection or timeout, the combined path is extracted and smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= r_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            to_remove = []\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            to_remove.append((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            for e in to_remove:\n                edges.remove(e)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined, max_iters=100)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined, max_iters=100)\n            success_state = True\n\n        return type('PlannerResult', (), {})() if False else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.38696,
          "time_improvement": 44.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018783712387084962,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 153.71064836573322,
                    "smoothness_avg": 0.04239088328876562,
                    "success_improvement": 0.0,
                    "time_improvement": 20.77785609923607,
                    "length_improvement": 15.748757929650598,
                    "smoothness_improvement": 563.5093767456073,
                    "objective_score": 12.200655299428979
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05699787139892578,
                    "num_nodes_avg": 298.5,
                    "path_length_avg": 243.06794856753677,
                    "smoothness_avg": 0.10890286053066733,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23643566812932,
                    "length_improvement": 18.856922445178366,
                    "smoothness_improvement": 2702.14904101396,
                    "objective_score": 40.15306039454427
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06685750484466553,
                    "num_nodes_avg": 274.5,
                    "path_length_avg": 123.54875955604457,
                    "smoothness_avg": 0.1082207456314781,
                    "success_improvement": 0.0,
                    "time_improvement": 36.11804532003545,
                    "length_improvement": 17.944796662594666,
                    "smoothness_improvement": 1276.5598964078824,
                    "objective_score": 20.80717241056898
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a time-limited bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius tuning. It combines goal-biased sampling with ellipsoidal informed sampling to focus exploration progressively, uses rewiring within a dynamically chosen neighbor radius to optimize path cost locally, and alternates growth between two trees starting from start and goal positions. Collision-free nodes and edges are guaranteed for safe and feasible path expansion. The algorithm stops early either upon a successful connection or exceeding the 30-second execution limit, returning the best found path with smoothing applied for improved smoothness and quality.",
          "planning_mechanism": "The planner grows two RRT* trees from start and goal alternately, sampling with a bias towards the goal and inside an ellipsoidal informed subset after the first feasible solution to accelerate convergence. Each extension steers toward a sampled point, rewires neighbors to optimize cost, and attempts incremental connection to the opposite tree with rewiring. Paths are merged on successful connection, smoothed for smoothness, and returned immediately. Execution time is tracked and enforced with early termination, returning the best feasible path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0     # Enforced 30 sec time limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=resolution)\n\n        # Unit ball sample for uniform direction sampling in nD\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        informed_sampling_enabled = False\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct rotation matrix to align x-axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Use Householder transform to rotate direction to x-axis\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    # Compute rotation matrix R that aligns x-axis with \"direction\"\n                    # Approach: compute orthonormal basis with \"direction\" as first vector\n                    ux, uy, uz = direction\n                    # Construct an arbitrary orthogonal basis:\n                    if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                        # direction close to z-axis:\n                        vx_, vy_, vz_ = 1,0,0\n                    else:\n                        vx_, vy_, vz_ = -uy, ux, 0\n                    norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                    vx_ /= norm_v_\n                    vy_ /= norm_v_\n                    vz_ /= norm_v_\n                    wx = uy * vz_ - uz * vy_\n                    wy = uz * vx_ - ux * vz_\n                    wz = ux * vy_ - uy * vx_\n\n                    R = [\n                        [ux, vx_, wx],\n                        [uy, vy_, wy],\n                        [uz, vz_, wz]\n                    ]\n\n            # Radii of prolate hyperspheroid\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        # Adaptive neighbor radius for rewiring (following RRT* theory)\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return 50.0  # large initial radius\n            gamma_rrt = 30.0\n            return max(5.0, min(30.0, gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp(next_pos)\n\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # time limit exceeded: return best path so far\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_goal)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    # Make sure to remove duplicate connecting node\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    # Refresh edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_start)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached - return best path if any\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.98338,
          "time_improvement": 49.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1290.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02227151393890381,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 176.73650863221073,
                    "smoothness_avg": 0.04163013462817498,
                    "success_improvement": 0.0,
                    "time_improvement": 6.067711973228136,
                    "length_improvement": 3.1279190494893707,
                    "smoothness_improvement": 551.6020082152062,
                    "objective_score": 5.203907442942346
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04452013969421387,
                    "num_nodes_avg": 216.7,
                    "path_length_avg": 234.6283220155596,
                    "smoothness_avg": 0.08281404133923359,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43865415108714,
                    "length_improvement": 21.674312709409516,
                    "smoothness_improvement": 2030.8649322014446,
                    "objective_score": 38.92078344821527
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04296309947967529,
                    "num_nodes_avg": 221.2,
                    "path_length_avg": 122.72804706569131,
                    "smoothness_avg": 0.1091637086355884,
                    "success_improvement": 0.0,
                    "time_improvement": 58.94900983445225,
                    "length_improvement": 18.489874820558175,
                    "smoothness_improvement": 1288.5543162178765,
                    "objective_score": 27.825449495536688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner with incremental rewiring, goal-biased sampling, collision checking for nodes and edges, adaptive neighbor radius, and early termination on time limit or successful connection. It balances exploration and exploitation to efficiently find lower-cost, smoother paths in 2D or 3D bounded spaces with obstacles.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions alternately, sampling nodes biased toward the goal and informed by an adaptive ellipsoidal region after an initial path is found. It extends each tree by steering towards sampled points, rewires neighbors to optimize path costs, attempts incremental connection between trees, performs collision checks for nodes and edges, applies shortcut smoothing to the final path, and terminates within a 30-second time budget, returning the best discovered path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # alternate growth\n        success_state = False\n        extracted_path = []\n        best_connection = None\n        best_cost = float('inf')\n        c_best = math.dist(start_pos, goal_pos)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n        use_informed_sampling = False\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_pos, goal_pos)])\n            M = np.outer(a1, np.array([1.0] + [0] * (dim - 1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1 / dim)\n            r_vec = r * z_unit\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_best ** 2, 0)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2] * (dim - 1))\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback if no free sample found\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.96468,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1343.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020919609069824218,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 162.1552476112867,
                    "smoothness_avg": 0.036750846642726535,
                    "success_improvement": 0.0,
                    "time_improvement": 11.769502964875004,
                    "length_improvement": 11.12013926992458,
                    "smoothness_improvement": 475.23055569949014,
                    "objective_score": 8.131031521944868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05067124366760254,
                    "num_nodes_avg": 285.6,
                    "path_length_avg": 236.9991428088577,
                    "smoothness_avg": 0.09505745680222014,
                    "success_improvement": 0.0,
                    "time_improvement": 78.87413461033807,
                    "length_improvement": 20.882864488313764,
                    "smoothness_improvement": 2345.896830639797,
                    "objective_score": 39.56829743396317
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05418672561645508,
                    "num_nodes_avg": 285.8,
                    "path_length_avg": 122.85691426491363,
                    "smoothness_avg": 0.10293133869600272,
                    "success_improvement": 0.0,
                    "time_improvement": 48.22490073285691,
                    "length_improvement": 18.404287362831315,
                    "smoothness_improvement": 1209.279030612043,
                    "objective_score": 24.194722845483554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius and informed sampling after a first solution is found. It alternates growing two trees from start and goal, incrementally extending and rewiring nodes to minimize path cost, while maintaining strict collision checks and clamping positions within bounds. The planner applies path smoothing on the extracted path, and enforces a 30-second runtime limit to ensure timely return of the best found path.",
          "planning_mechanism": "The planner grows two trees alternatively, sampling points with goal bias and later focused informed sampling inside an ellipsoidal subset defined by the best path cost. Each iteration extends one tree towards the sample with a step-size constrained steer, rewires locally to improve costs, then incrementally attempts to connect the other tree. Upon successful connection or timeout, the best path is extracted, smoothed, and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=8.0, neighbor_radius_max=30.0,\n                 max_planning_time=30.0, smoothing_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import time\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def propagate_costs(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-10 < child.cost:\n                    child.cost = new_cost\n                    propagate_costs(child)\n\n        self._propagate_costs = propagate_costs\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    propagate_costs(nbr)\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr_node = connect_node\n\n        def path_smooth(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i+2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        iter_count = 0\n        grow_start = True\n        success_state = False\n        extracted_path = []\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = try_connect(new_node, other_tree)\n\n            if connect_node:\n                path_s = new_node.path_from_root()\n                path_g = connect_node.path_from_root()\n                if path_g and path_g[0] == new_node.position:\n                    path_g = path_g[1:]\n                combined = path_s + path_g[::-1]\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined\n                    informed_enabled = True\n\n                # Update all_nodes and edges\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for child in node.children:\n                        if collision_free_edge(node.position, child.position):\n                            edges.append((node, child))\n\n                extracted_path = path_smooth(best_path, self.smoothing_trials)\n                success_state = True\n                # Early exit on first valid path found\n                break\n\n            grow_start = not grow_start\n\n        if not success_state and best_path:\n            extracted_path = path_smooth(best_path, self.smoothing_trials)\n            success_state = True\n        elif not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.619,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1329.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02542247772216797,
                    "num_nodes_avg": 66.4,
                    "path_length_avg": 158.04188338762918,
                    "smoothness_avg": 0.04257911968298753,
                    "success_improvement": 0.0,
                    "time_improvement": -7.221785923656363,
                    "length_improvement": 13.374739381338483,
                    "smoothness_improvement": 566.4556850770527,
                    "objective_score": 3.340690524556052
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04310841560363769,
                    "num_nodes_avg": 240.3,
                    "path_length_avg": 237.46317982130995,
                    "smoothness_avg": 0.08844010205024158,
                    "success_improvement": 0.0,
                    "time_improvement": 82.02723045090121,
                    "length_improvement": 20.727955576992372,
                    "smoothness_improvement": 2175.6275265834156,
                    "objective_score": 39.631897883585914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05217833518981933,
                    "num_nodes_avg": 248.4,
                    "path_length_avg": 123.3226961463844,
                    "smoothness_avg": 0.10569638778892007,
                    "success_improvement": 0.0,
                    "time_improvement": 50.14390603393877,
                    "length_improvement": 18.094937215308175,
                    "smoothness_improvement": 1244.450250979258,
                    "objective_score": 24.884410508139553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* algorithm combining goal-biased and informed ellipsoidal sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and rigorous collision checks. It alternates growth between start and goal trees, dynamically rewires nodes for optimal path cost, and performs path smoothing on solutions. The planner enforces bounds and obstacle constraints in 2D/3D, and respects a strict 30-second runtime limit, returning the best feasible path when timed out.",
          "planning_mechanism": "The planner grows two trees bidirectionally with adaptive and informed sampling to efficiently explore promising regions. New nodes are connected with collision-free edges and rewired locally for cost optimization. Incremental attempts connect the trees as soon as possible. Once a connection is found or time expires, the path is extracted and smoothed via collision-safe shortcuts, yielding a high-quality, smooth path with minimized length, ensuring robustness and speed.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 25.0\n            r = gamma * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def collision_node_free(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            # Use finer resolution for collision checking for robustness\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_enabled = False\n\n        def clamp_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            # Return rotation matrix that aligns x-axis to direction vector in 2D or 3D\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                # Compute axis k (cross with x-axis)\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            # fallback to goal\n            return goal_position\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if len(tree) == 0:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Node or None:\n            if len(other_tree) == 0:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_position, None, 0.0)]\n        tree_goal: List[Node] = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n        edges.clear()\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found so far\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            # Sampling\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            # Extend appropriate tree\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # Avoid duplicate nodes at connection\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    # Refresh edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_iterations)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.61736,
          "time_improvement": 41.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1456.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01728057861328125,
                    "num_nodes_avg": 68.6,
                    "path_length_avg": 167.34606457465054,
                    "smoothness_avg": 0.039486046191842615,
                    "success_improvement": 0.0,
                    "time_improvement": 27.117469785626007,
                    "length_improvement": 8.274970238546423,
                    "smoothness_improvement": 518.0423682240439,
                    "objective_score": 12.380446824517307
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03963184356689453,
                    "num_nodes_avg": 232.2,
                    "path_length_avg": 237.28845906535452,
                    "smoothness_avg": 0.09407634338894924,
                    "success_improvement": 0.0,
                    "time_improvement": 83.47668358348058,
                    "length_improvement": 20.78628239438841,
                    "smoothness_improvement": 2320.6520758489087,
                    "objective_score": 40.8035219331664
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09072043895721435,
                    "num_nodes_avg": 302.7,
                    "path_length_avg": 127.75138773269472,
                    "smoothness_avg": 0.1280235503232115,
                    "success_improvement": 0.0,
                    "time_improvement": 13.317151403180654,
                    "length_improvement": 15.153611135312167,
                    "smoothness_improvement": 1528.4501103957357,
                    "objective_score": 14.668118199995309
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighbor radius and rewiring that grows two trees from start and goal simultaneously. It incrementally samples nodes biased toward the goals, extends both trees using step-limited steering, and attempts connection between trees with continuous collision checking. Rewiring optimizes node costs locally. A 30-second time limit enforces timely termination, and post-connection path smoothing improves path quality by shortcutting unnecessary waypoints. The algorithm balances exploration and exploitation to reduce planning time and path length while maintaining robustness and success rate.",
          "planning_mechanism": "The planner alternates growing trees from start and goal, samples with goal bias, extends toward sampled points if collision-free, rewires nearby nodes to optimize costs, attempts connection between trees each iteration, and stops either when a path is found or the 30-second limit expires. Extracted paths are smoothed before returning to improve smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Accumulated path cost from root\n        self.children: List[Node] = []            # Children nodes\n        self.valid = True                         # Validity flag (collision-free)\n\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node:'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node:'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent:'Node', new_cost:float):\n        # Remove from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and update cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, \n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)  # Clamp between 0 and 1\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Data containers\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(towards_goal:bool) -> Tuple[float, ...]:\n            if towards_goal and random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            # Based on RRT* theory: radius shrinks as nodes increase, bounded by min and max radius\n            gamma = self.neighbor_radius_max  # max radius\n            # log term ensures connectivity with probabilistic guarantees\n            rad = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return max(rad, self.neighbor_radius_min)\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= r_sq]\n\n        def add_node(tree: List[Node], pos: Tuple[float, ...], parent_node: Node, cost: float) -> Node:\n            new_node = Node(pos, parent_node, cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            # Edge already removed possibly\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Update parent and cost recursively\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(nodes)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree: List[Node], new_node: Node) -> Node:\n            nearest_node = nearest(tree, new_node.position)\n            dist = math.dist(nearest_node.position, new_node.position)\n            if dist <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_node.position, new_node.position, obstacles, is_3d) and not self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                    return nearest_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations=100) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            p = path[:]\n            for _ in range(iterations):\n                if len(p) <= 2:\n                    break\n                i = random.randint(0, len(p) - 2)\n                j = random.randint(i + 1, len(p) - 1)\n                if j == i + 1:\n                    continue\n                if not self._is_edge_in_obstacle(p[i], p[j], obstacles, is_3d):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        start_time = time.time()\n        # Alternate growing trees: True means grow tree_start, False means grow tree_goal\n        grow_start_tree = True\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached, return best found path if any\n                if best_path:\n                    extracted_path = path_smoothing(best_path)\n                    success_state = True\n                break\n\n            if grow_start_tree:\n                sample_point = sample_free(towards_goal=True)\n                new_node_start = try_extend(tree_start, sample_point)\n                if new_node_start is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node_goal = try_connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    # Connect goal tree to start tree at new_node_start.position\n                    n_nodes_goal = len(nodes)\n                    radius_goal = adaptive_neighbor_radius(n_nodes_goal)\n                    neighbors_goal = near_nodes(tree_goal, new_node_start.position, radius_goal)\n\n                    # Choose best parent in goal tree for connection point\n                    min_cost_goal = connect_node_goal.cost + math.dist(connect_node_goal.position, new_node_start.position)\n                    best_parent_goal = connect_node_goal\n                    for neighbor in neighbors_goal:\n                        cost_through = neighbor.cost + math.dist(neighbor.position, new_node_start.position)\n                        if cost_through < min_cost_goal and not self._is_edge_in_obstacle(neighbor.position, new_node_start.position, obstacles, is_3d):\n                            min_cost_goal = cost_through\n                            best_parent_goal = neighbor\n\n                    new_node_goal = add_node(tree_goal, new_node_start.position, best_parent_goal, min_cost_goal)\n                    rewire(tree_goal, new_node_goal, neighbors_goal)\n\n                    # Extract path from start root -> new_node_start\n                    path_start = new_node_start.path_from_root()\n                    # Extract path from goal root -> new_node_goal\n                    path_goal = new_node_goal.path_from_root()\n\n                    connected_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                    cost_path = new_node_start.cost + new_node_goal.cost\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = connected_path\n                        extracted_path = path_smoothing(best_path)\n                        success_state = True\n                    break\n\n            else:\n                # Grow goal tree toward start goal with reversed bias\n                sample_point = sample_free(towards_goal=False)\n                new_node_goal = try_extend(tree_goal, sample_point)\n                if new_node_goal is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node_start = try_connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    n_nodes_start = len(nodes)\n                    radius_start = adaptive_neighbor_radius(n_nodes_start)\n                    neighbors_start = near_nodes(tree_start, new_node_goal.position, radius_start)\n\n                    min_cost_start = connect_node_start.cost + math.dist(connect_node_start.position, new_node_goal.position)\n                    best_parent_start = connect_node_start\n                    for neighbor in neighbors_start:\n                        cost_through = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                        if cost_through < min_cost_start and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                            min_cost_start = cost_through\n                            best_parent_start = neighbor\n\n                    new_node_start = add_node(tree_start, new_node_goal.position, best_parent_start, min_cost_start)\n                    rewire(tree_start, new_node_start, neighbors_start)\n\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n\n                    connected_path = path_start + path_goal[::-1][1:]\n\n                    cost_path = new_node_start.cost + new_node_goal.cost\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = connected_path\n                        extracted_path = path_smoothing(best_path)\n                        success_state = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        # If no connection found but nodes exist, try to approximate best path between closest pair\n        if not success_state and nodes:\n            # Find minimal-cost bridge between tree_start and tree_goal\n            min_bridge_cost = math.inf\n            bridge_nodes = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    dist = math.dist(ns.position, ng.position)\n                    if dist <= self.step_size * 2:  # heuristic connection attempt distance\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d):\n                            cost_bridge = ns.cost + dist + ng.cost\n                            if cost_bridge < min_bridge_cost:\n                                min_bridge_cost = cost_bridge\n                                bridge_nodes = (ns, ng)\n            if bridge_nodes:\n                ns, ng = bridge_nodes\n                path_start = ns.path_from_root()\n                path_goal = ng.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                extracted_path = path_smoothing(combined_path)\n                success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.49643,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1374.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03155448436737061,
                    "num_nodes_avg": 132.1,
                    "path_length_avg": 165.4504062373288,
                    "smoothness_avg": 0.0434797382446403,
                    "success_improvement": 0.0,
                    "time_improvement": -33.084123614724135,
                    "length_improvement": 9.314010611861088,
                    "smoothness_improvement": 580.5523212914276,
                    "objective_score": -5.159673355587885
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04292302131652832,
                    "num_nodes_avg": 251.6,
                    "path_length_avg": 231.90063815813036,
                    "smoothness_avg": 0.08227857184034407,
                    "success_improvement": 0.0,
                    "time_improvement": 82.10452507542588,
                    "length_improvement": 22.58489209304601,
                    "smoothness_improvement": 2017.0869163119266,
                    "objective_score": 39.2337705227966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02547919750213623,
                    "num_nodes_avg": 175.1,
                    "path_length_avg": 127.2492309717258,
                    "smoothness_avg": 0.1276946223645137,
                    "success_improvement": 0.0,
                    "time_improvement": 75.65477587153477,
                    "length_improvement": 15.487119745812356,
                    "smoothness_improvement": 1524.2661710400362,
                    "objective_score": 33.41518756582308
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal biasing, adaptive rewiring, and incremental tree connections to improve planning efficiency, path quality, and robustness. It grows two search trees simultaneously from start and goal points, dynamically rewires nodes to reduce path costs, biases sampling toward the goal to accelerate convergence, and enforces a maximum planning time. It terminates early upon finding a feasible path or time expiration, returning the best solution found.",
          "planning_mechanism": "The planner alternates growing and rewiring two trees from start and goal by sampling points (biased toward goal), extending nodes stepwise with collision checks, rewiring neighbors for cost reduction, and incrementally connecting the trees. If trees connect, the resultant low-cost path is extracted by merging paths from both trees. Within a 30-second limit, the algorithm balances exploration and exploitation to find smooth, short, and feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # Tuple of nodes in start and goal trees\n\n        def sample_free():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_thru_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            target = new_node.position\n            current_node = nearest(tree, target)\n\n            while True:\n                dist = math.dist(current_node.position, target)\n                if dist <= self.step_size:\n                    new_pos = target\n                else:\n                    new_pos = steer(current_node.position, target)\n\n                if (\n                    not within_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                for neighbor in neighbors:\n                    cost_thru_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node_goal, cost_thru_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # Avoid duplicate middle node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded, return best path found (if any)\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n\n                tree_start, tree_goal = tree_goal, tree_start\n\n                # Optional early break to reduce planning time on success\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.99894,
          "time_improvement": 59.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 276.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013381409645080566,
                    "num_nodes_avg": 76.5,
                    "path_length_avg": 166.83413501227932,
                    "smoothness_avg": 0.019463577249412372,
                    "success_improvement": 0.0,
                    "time_improvement": 43.56259621891708,
                    "length_improvement": 8.555566943725118,
                    "smoothness_improvement": 204.64724978778887,
                    "objective_score": 15.803128503359092
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052031731605529784,
                    "num_nodes_avg": 274.1,
                    "path_length_avg": 246.89388693282086,
                    "smoothness_avg": 0.015621323729922434,
                    "success_improvement": 0.0,
                    "time_improvement": 78.30691969788298,
                    "length_improvement": 17.57971409531666,
                    "smoothness_improvement": 301.94791115559445,
                    "objective_score": 28.5177582842062
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04690549373626709,
                    "num_nodes_avg": 239.1,
                    "path_length_avg": 124.15395131017871,
                    "smoothness_avg": 0.033219353543958816,
                    "success_improvement": 0.0,
                    "time_improvement": 55.18207519016236,
                    "length_improvement": 17.542857115633282,
                    "smoothness_improvement": 322.5477250815371,
                    "objective_score": 21.67593260558305
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive neighbor radius and dynamic rewiring to minimize path length while reducing planning time. It uses goal-biased sampling, rigorous node and edge collision checking, and incremental steering. The planner alternates growth between two trees (start and goal) to efficiently find a feasible path. Early termination occurs upon connection or after 30 seconds, returning the best path found. Post-processing applies path smoothing through shortcutting to enhance path smoothness and quality.",
          "planning_mechanism": "The planner grows two trees from start and goal with goal-biased sampling, connecting and rewiring nodes within an adaptive radius to optimize costs. It performs collision checks to ensure validity of expansions and edges. Alternating tree growth and early termination reduce search time. After path extraction, shortcutting smooths the path, removing unnecessary nodes for shorter, feasible routes.",
          "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, max_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # heuristic factor per dimension\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            for _ in range(20):  # Rejection sampling to avoid obstacles\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos if tree_toggle else start_pos\n\n        def nearest(tree, point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, point))\n            return nearest_node\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, position) ** 2) <= r_sq]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(other_tree, from_node):\n            nearest_node = nearest(other_tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        def path_shortcut(path: list, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        best_cost = float('inf')\n        best_connection = None  # (path_start, path_goal_reversed)\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            rand_point = sample_free(grow_start)\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            parent_node = new_node.parent\n            if parent_node:\n                edges.append((parent_node, new_node))\n\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position, best_parent_other, min_cost)\n                other_tree.append(connecting_node_other)\n                edges.append((best_parent_other, connecting_node_other))\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                joined_path = path_start + path_goal[::-1][1:]\n                total_cost = new_node.cost + connecting_node_other.cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n                    final_path = joined_path\n                    success = True\n                    # Early termination on first valid connection with improved cost\n                    break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        if not success and best_connection:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=100)\n\n        # Rebuild node and edge collections consistently for output\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n\n        def collect_nodes_and_edges(node: Node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n    \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.40382,
          "time_improvement": 37.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1385.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02850348949432373,
                    "num_nodes_avg": 119.3,
                    "path_length_avg": 166.63069161371672,
                    "smoothness_avg": 0.04110201384851541,
                    "success_improvement": 0.0,
                    "time_improvement": -20.216254372901542,
                    "length_improvement": 8.667077494244227,
                    "smoothness_improvement": 543.3357711809051,
                    "objective_score": -1.6147819571170916
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0411912202835083,
                    "num_nodes_avg": 247.4,
                    "path_length_avg": 236.20123759928438,
                    "smoothness_avg": 0.0911022068289662,
                    "success_improvement": 0.0,
                    "time_improvement": 82.82654792028157,
                    "length_improvement": 21.149228213697384,
                    "smoothness_improvement": 2244.125399976569,
                    "objective_score": 40.29843701870679
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05265343189239502,
                    "num_nodes_avg": 250.2,
                    "path_length_avg": 122.08508005860313,
                    "smoothness_avg": 0.11536932958306656,
                    "success_improvement": 0.0,
                    "time_improvement": 49.68995391453116,
                    "length_improvement": 18.916902891867394,
                    "smoothness_improvement": 1367.4893566185074,
                    "objective_score": 25.527813535825363
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* variant with adaptive neighbor rewiring, goal-biased and informed sampling, incremental connection attempts, and path smoothing. It alternates growing trees from start and goal while dynamically rewiring nearby nodes to optimize path costs, uses collision checks to ensure validity, and enforces a maximum planning time to return the best solution found efficiently.",
          "planning_mechanism": "The planner samples points biased towards the goal and within informed ellipsoids after a solution is found, extends trees by steering towards samples within a step size limit, rewires neighbors to minimize costs, attempts incremental connection with rewiring between both trees, and performs path smoothing to reduce unnecessary waypoints before returning the optimized path or a failure state if timed out.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost update recursively to children\n        for c in self.children:\n            dist = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=10.0, neighbor_radius_max=30.0,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            # 3D approximate rotation matrix aligning x-axis to direction\n            vx, vy, vz = direction\n            kx, ky, kz = -vy, vx, 0.0\n            norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n            if norm_k < 1e-12:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            kx /= norm_k; ky /= norm_k; kz /= norm_k\n            cos_theta = vx\n            sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n            K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n            I = [[1,0,0],[0,1,0],[0,0,1]]\n\n            def mat_add(A,B):\n                return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n            def mat_scale(A,s):\n                return [[A[i][j]*s for j in range(3)] for i in range(3)]\n            def mat_mul(A,B):\n                return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n            K2 = mat_mul(K,K)\n            R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n            return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_planning_time:\n                # Time limit exceeded\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Rebuild edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations done, return best found if any\n        if best_path:\n            best_path = path_smoothing(best_path)\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.77895,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1414.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020661187171936036,
                    "num_nodes_avg": 84.3,
                    "path_length_avg": 160.61427250673296,
                    "smoothness_avg": 0.03845975354123328,
                    "success_improvement": 0.0,
                    "time_improvement": 12.85942259096992,
                    "length_improvement": 11.964772143043625,
                    "smoothness_improvement": 501.9786596118466,
                    "objective_score": 8.760674503958933
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05249233245849609,
                    "num_nodes_avg": 240.6,
                    "path_length_avg": 235.3262802393561,
                    "smoothness_avg": 0.09443823991870184,
                    "success_improvement": 0.0,
                    "time_improvement": 78.11488589500335,
                    "length_improvement": 21.441314164692674,
                    "smoothness_improvement": 2329.963934222978,
                    "objective_score": 39.37254827255443
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09164626598358154,
                    "num_nodes_avg": 282.2,
                    "path_length_avg": 124.80294443268312,
                    "smoothness_avg": 0.11873500820805918,
                    "success_improvement": 0.0,
                    "time_improvement": 12.432529096720257,
                    "length_improvement": 17.111826785397387,
                    "smoothness_improvement": 1410.3005402998594,
                    "objective_score": 14.203626787594851
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner utilizing dynamic informed sampling, adaptive neighbor radius, incremental rewiring, and path smoothing with integrated time-budget enforcement. It balances exploration and exploitation by growing two trees from start and goal, progressively refining paths considering collision constraints to generate shorter, smoother, and feasible paths efficiently.",
          "planning_mechanism": "The planner grows bidirectional RRT* trees alternately with goal biasing and informed ellipsoidal sampling after initial solution discovery. It incrementally extends and rewires near neighbors using an adaptive radius based on node count and dimensionality, performs meticulous collision checking on nodes and edges, and attempts incremental connection. If connected, it extracts and smooths the path. The planner enforces a 30-second time limit, returning the best path found, ensuring practical usability and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # From root to this node\n        self.children = []              # List of children nodes\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update descendants cost recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate tree growth\n        success_state = False\n        extracted_path = []\n        best_connection = None\n        best_cost = float('inf')\n        c_best = math.dist(start_pos, goal_pos)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n        use_informed_sampling = False\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n            # Unit vector along start-goal\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_pos, goal_pos)])\n            M = np.outer(a1, np.array([1.0] + [0] * (dim - 1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n\n            while True:\n                z = np.random.normal(0,1,dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1/dim)\n            r_vec = r * z_unit\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_best ** 2, 0)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2] * (dim - 1))\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.35749,
          "time_improvement": 29.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1588.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028732967376708985,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 162.02270475755276,
                    "smoothness_avg": 0.04115715604890256,
                    "success_improvement": 0.0,
                    "time_improvement": -21.184099783102077,
                    "length_improvement": 11.19278810833208,
                    "smoothness_improvement": 544.1988663601688,
                    "objective_score": -1.3956779814633626
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049467158317565915,
                    "num_nodes_avg": 268.6,
                    "path_length_avg": 231.62486987469825,
                    "smoothness_avg": 0.1131365462742473,
                    "success_improvement": 0.0,
                    "time_improvement": 79.37614212350282,
                    "length_improvement": 22.676951483605585,
                    "smoothness_improvement": 2811.084824596856,
                    "objective_score": 42.403657056756245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07304623126983642,
                    "num_nodes_avg": 341.5,
                    "path_length_avg": 120.79068484586617,
                    "smoothness_avg": 0.1186759904436205,
                    "success_improvement": 0.0,
                    "time_improvement": 30.20475343249037,
                    "length_improvement": 19.776578559690794,
                    "smoothness_improvement": 1409.5498386924373,
                    "objective_score": 20.064490935147457
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with dynamic rewiring, goal-biased and informed ellipsoidal sampling, adaptive neighborhood radius, and comprehensive collision checking for nodes and edges. It grows two trees from start and goal positions alternately, performs incremental extension, rewires local neighborhoods to optimize path costs, and attempts incremental connection with rewiring. The planner enforces a strict 30-second time limit, returning the best path found so far to ensure planning efficiency, path quality, smoothness, and robustness.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal positions using a combination of goal-biased and ellipsoidal informed sampling to focus the search. Each new node is extended cautiously with collision checks and rewiring to nearby nodes to reduce overall cost. The opposing tree incrementally connects to newly added nodes with additional rewiring, continuously improving path quality. The process terminates on success or time expiry, providing robust, low-cost, and smooth paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5,\n                 max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size              # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Constants for informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)*0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            temp_node = Node(new_pos)\n            neighbors = near_nodes(tree, temp_node)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos)\n                candidate_node.cost = cost_to_next\n\n                neighbors = near_nodes(tree_connect, candidate_node)\n\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n\n                min_parent.add_child(candidate_node)\n                candidate_node.parent = min_parent\n                candidate_node.cost = min_cost\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n\n                last_node = candidate_node\n\n            return None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # For both trees alternately\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n\n                # Sampling: goal bias + informed sampling when path found\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Build combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    # Compute path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node subtree\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return on first found path to maximize speed\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no connection found return best partial path by checking nearby nodes between trees\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.16994,
          "time_improvement": 68.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007612085342407227,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 184.4913298419197,
                    "smoothness_avg": 0.010519350526551577,
                    "success_improvement": 0.0,
                    "time_improvement": 67.89528566271517,
                    "length_improvement": -1.1226213385578332,
                    "smoothness_improvement": 64.65067887581763,
                    "objective_score": 20.46731482548207
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0381946325302124,
                    "num_nodes_avg": 201.0,
                    "path_length_avg": 307.68127601525805,
                    "smoothness_avg": 0.006362886119035033,
                    "success_improvement": 0.0,
                    "time_improvement": 84.07588590613632,
                    "length_improvement": -2.7128660483826366,
                    "smoothness_improvement": 63.72164284439662,
                    "objective_score": 24.99880077638635
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04949972629547119,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 158.73835880469125,
                    "smoothness_avg": 0.012861891384057036,
                    "success_improvement": 0.0,
                    "time_improvement": 52.703301159312666,
                    "length_improvement": -5.42645960970871,
                    "smoothness_improvement": 63.60230903913767,
                    "objective_score": 15.043709971047745
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* with adaptive neighbor radius and goal-biased sampling, combining local rewiring, incremental tree connection, and post-solution path smoothing within a 30-second time limit. It manages nodes with robust parent-child relationships and performs rigorous node and edge collision checks to ensure feasible, high-quality, and smooth paths efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the opposite tree's root to encourage connection. Each expansion steers toward sampled points respecting a step size and performs adaptive-rewiring using a dynamically computed neighbor radius based on the current tree size and dimension. Incremental connect attempts progressively link trees while rewiring optimizes path costs. Upon connection, the combined path is smoothed via shortcutting. The process halts early if 30 seconds elapse, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n        # Recursively update cost of descendants\n        for child in self.children:\n            child_cost = self.cost + math.dist(self.position, child.position)\n            child.update_parent(self, child_cost)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree: List[Node] = [Node(start_pos)]\n        goal_tree: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_free_point(p):\n            return within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def sample_free(tree_indicator: bool):\n            # tree_indicator=True means sampling for start_tree toward goal, else vice versa\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 30.0  # tuning param, can be adjusted\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not is_free_point(new_pos) or not is_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr_node = nearest\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not is_free_point(new_pos) or not is_free_edge(curr_node.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path: List[Tuple[float, ...]], iterations: int = 100) -> List[Tuple[float, ...]]:\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) - 1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                if is_free_edge(p1, p2):\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_indicator=True)\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicated node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined_path, iterations=100)\n                    success = True\n                    # Optional: stop early on first solution, comment next line to keep searching\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.0713,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1531.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024182724952697753,
                    "num_nodes_avg": 103.1,
                    "path_length_avg": 156.2190449823175,
                    "smoothness_avg": 0.040275037558805106,
                    "success_improvement": 0.0,
                    "time_improvement": -1.9930073797584058,
                    "length_improvement": 14.37386599601276,
                    "smoothness_improvement": 530.3917964391828,
                    "objective_score": 4.928829967470945
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06206269264221191,
                    "num_nodes_avg": 370.0,
                    "path_length_avg": 235.10600365298006,
                    "smoothness_avg": 0.1031911715268196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.1248093478783,
                    "length_improvement": 21.514848829534984,
                    "smoothness_improvement": 2555.183168981656,
                    "objective_score": 39.316328415178766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08631713390350342,
                    "num_nodes_avg": 359.6,
                    "path_length_avg": 126.64040269645093,
                    "smoothness_avg": 0.12630717040516848,
                    "success_improvement": 0.0,
                    "time_improvement": 17.52448361721952,
                    "length_improvement": 15.891474496962882,
                    "smoothness_improvement": 1506.6178845282157,
                    "objective_score": 15.96872940719951
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner incorporating goal-biased and informed sampling, adaptive neighbor radius, dynamic rewiring with recursive cost updates, and progressive incremental tree connections. It enforces strict 30-second planning time limit, applies path smoothing, and ensures collision-free, boundary-respecting expansions, balancing planning efficiency and path quality.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions, sampling points with goal bias and informed ellipsoidal sampling after initial solution discovery. Nodes are connected with rewiring of neighbors for cost optimization and incremental attempts link opposing trees. The best path found is combined, smoothed, and returned either on success or upon reaching the time budget, ensuring efficient and robust route planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Path cost from root\n        self.children = []                   # List[Node]\n        self.valid = True                    # Collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children for consistent cost tree\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_r = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_r = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_r, y_r)\n                else:\n                    x_r = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_r = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_r = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_r, y_r, z_r)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent for new node to minimize cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to possibly lower cost routes via new node\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 150) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or iteration limit reached; return best found path if any\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.94609,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1498.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025188755989074708,
                    "num_nodes_avg": 66.2,
                    "path_length_avg": 157.89328902934858,
                    "smoothness_avg": 0.042858784246731806,
                    "success_improvement": 0.0,
                    "time_improvement": -6.236041658077569,
                    "length_improvement": 13.45618630374037,
                    "smoothness_improvement": 570.8330428009708,
                    "objective_score": 3.674589977329658
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05411760807037354,
                    "num_nodes_avg": 229.2,
                    "path_length_avg": 237.40725040109592,
                    "smoothness_avg": 0.10389042997477224,
                    "success_improvement": 0.0,
                    "time_improvement": 77.43727565076189,
                    "length_improvement": 20.746626427298914,
                    "smoothness_improvement": 2573.1755925029793,
                    "objective_score": 40.24638594320325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08452324867248535,
                    "num_nodes_avg": 263.3,
                    "path_length_avg": 124.96527655293502,
                    "smoothness_avg": 0.11391471514756088,
                    "success_improvement": 0.0,
                    "time_improvement": 19.238530459009446,
                    "length_improvement": 17.004013520550973,
                    "smoothness_improvement": 1348.9867683673442,
                    "objective_score": 15.91729568364975
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal biasing, incremental extend-and-rewire, and path smoothing to efficiently find feasible, short, and smooth paths within a 30-second time limit. <The planner simultaneously grows two trees from start and goal positions, sampling points biased toward goals, extending nodes stepwise while avoiding obstacles, rewiring neighbors to minimize path cost, and incrementally connecting the trees. Upon successful connection or timeout, it returns the shortest smoothed path found, balancing exploration and exploitation for robustness and quality.>",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, sampling points biased toward goals, extending nodes stepwise while avoiding obstacles, rewiring neighbors to minimize path cost, and incrementally connecting the trees. Upon successful connection or timeout, it returns the shortest smoothed path found, balancing exploration and exploitation for robustness and quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update costs of children\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 25.0, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternating tree\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_a is start_tree else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n\n        def neighbor_radius(num_nodes):\n            if num_nodes == 0:\n                return self.neighbor_radius_max\n            gamma = 2 * (1 + 1/dimension) ** (1/dimension) * \\\n                ((math.pi ** (dimension/2)) / math.gamma(dimension/2 + 1)) ** (1/dimension)\n            r = gamma * (math.log(num_nodes + 1) / (num_nodes + 1)) ** (1/dimension)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, point))\n            new_pos = steer(nearest_node.position, point)\n            if (not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_incremental_connect(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                r = neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def merge_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            path_b.reverse()\n            return path_a + path_b[1:]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                candidate_path = merge_paths(new_node_a, new_node_b)\n                candidate_path = path_smoothing(candidate_path)\n\n                cost = 0.0\n                for idx in range(1, len(candidate_path)):\n                    cost += math.dist(candidate_path[idx-1], candidate_path[idx])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = candidate_path\n                    success = True\n                # Early stop upon finding a better path\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout with no full path found, attempt to return partial best path\n        if not success and best_path == []:\n            # Try closest node to goal in start tree\n            closest_to_goal = min(start_tree, key=lambda n: math.dist(n.position, goal_pos))\n            if math.dist(closest_to_goal.position, goal_pos) <= self.step_size:\n                best_path = closest_to_goal.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.84906,
          "time_improvement": 25.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1736.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03349788188934326,
                    "num_nodes_avg": 113.9,
                    "path_length_avg": 159.0457139542737,
                    "smoothness_avg": 0.04433123827313681,
                    "success_improvement": 0.0,
                    "time_improvement": -41.28059271355697,
                    "length_improvement": 12.824523941047373,
                    "smoothness_improvement": 593.8801457993051,
                    "objective_score": -6.84987229686109
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0513988733291626,
                    "num_nodes_avg": 293.0,
                    "path_length_avg": 234.4364991384319,
                    "smoothness_avg": 0.12602951180228042,
                    "success_improvement": 0.0,
                    "time_improvement": 78.57077110135297,
                    "length_improvement": 21.73834870711012,
                    "smoothness_improvement": 3142.8301140608573,
                    "objective_score": 43.6330516421322
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06520779132843017,
                    "num_nodes_avg": 311.8,
                    "path_length_avg": 119.67342714951776,
                    "smoothness_avg": 0.12345947495706663,
                    "success_improvement": 0.0,
                    "time_improvement": 37.69433693193338,
                    "length_improvement": 20.518607923511016,
                    "smoothness_improvement": 1470.3954086233734,
                    "objective_score": 22.763999707399083
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* growth with informed ellipsoidal sampling, adaptive neighbor radius rewiring, dynamic incremental connection between trees, and robust obstacle and edge collision checks. It balances exploration and exploitation by focusing samples in promising regions, efficiently rewires locally for cost optimization, and enforces strict time limits to guarantee timely results. Path smoothing via shortcutting follows path extraction to improve smoothness and remove unnecessary waypoints.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal, sampling with goal bias and informed ellipsoidal regions once a connection is found. Each extension involves steering with limited step size, collision and edge checks, then rewiring neighbors within an adaptive radius based on current node count. Incremental incremental connection attempts bridge the two trees efficiently. The algorithm terminates successfully when start and goal trees connect or when the 30-second time limit is reached, returning the best path found after smoothing.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Trees alternate growth each iteration\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_connection_nodes = None\n        best_cost = math.inf\n\n        start_time = time.perf_counter()\n\n        # Precompute start-goal dist and initialize sampling ellipse params\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2.0 for s, g in zip(start_position, goal_position))\n        use_informed_sampling = False\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _ellipsoidal_sample(c_max: float) -> Tuple[float, ...]:\n            # Implements informed sampling inside an ellipse between start and goal\n            # Reference: Informed RRT* sampling (Gammell, 2014)\n            if c_max == math.inf:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)], dtype=float)\n            # Build orthonormal basis matrix C via a rotation matrix:\n            # Create identity and replace first dim with a1\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))  # rank-1 matrix\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, Vt)\n\n            # Sample in unit n-ball \n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:  # avoid division by zero\n                    break\n            z_unit = z / norm_z\n\n            # Sample radius with probability ~ r^{dim-1} to fill ball uniformly\n            r = random.random() ** (1/dim)\n            r *= z_unit\n\n            # Lengths of the ellipse axes\n            r1 = c_max / 2.0\n            r2 = math.sqrt(c_max**2 - c_best**2) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                # For 3D, use r2 for axes 2 and 3\n                L = np.diag([r1, r2, r2])\n            else:\n                # fallback: use r2 for other axes\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = np.dot(C, np.dot(L, r))\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):  # Max 100 attempts\n                if use_informed_sampling and best_cost < math.inf:\n                    sample = _ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                    return sample\n            # fallback to uniform sample ignoring obstacle if no free found (very unlikely)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    # If direct connection between new_node and target_pos is collision-free, return new_node\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iterations: int=120) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iterations):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time exceeded: break and return best path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate, sample towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Update informed sampling usage and parameters\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2.0 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n\n                    # Extract and smooth path early for faster return on success\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Make sure no duplicate point at connection\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.54166,
          "time_improvement": 27.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1572.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030754804611206055,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 155.39801050614182,
                    "smoothness_avg": 0.0472465218485357,
                    "success_improvement": 0.0,
                    "time_improvement": -29.71139604033075,
                    "length_improvement": 14.82388800252849,
                    "smoothness_improvement": 639.5106643939071,
                    "objective_score": -2.7510878896239914
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06528630256652831,
                    "num_nodes_avg": 280.8,
                    "path_length_avg": 237.27958937981202,
                    "smoothness_avg": 0.11296131328131831,
                    "success_improvement": 0.0,
                    "time_improvement": 72.78082123152922,
                    "length_improvement": 20.789243350722238,
                    "smoothness_improvement": 2806.57595347357,
                    "objective_score": 40.02497480697106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06531059741973877,
                    "num_nodes_avg": 312.0,
                    "path_length_avg": 122.54529492889571,
                    "smoothness_avg": 0.10770517113827668,
                    "success_improvement": 0.0,
                    "time_improvement": 37.596106313230834,
                    "length_improvement": 18.611250088096217,
                    "smoothness_improvement": 1270.001826910111,
                    "objective_score": 21.351091046139047
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive neighbor radius based on tree size, incremental extend-and-rewire steps, and a post-processing path smoothing step. It rigorously checks collisions for nodes and edges, manages explicit parent-child relationships with clean rewiring, and enforces a maximum time limit to ensure responsiveness while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from the start and goal positions, extending each alternately towards goal-biased random samples. For each new node, it selects the best parent within an adaptive neighbor radius minimizing cost and rewires neighbors if cheaper paths are found. Incremental connect attempts between trees are performed carefully to gradually and safely link the two trees. Upon a successful connection, extracted paths are smoothed to improve smoothness and reduce length. Time-limiting ensures that the planning process halts within 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling goal, False for goal_tree sampling start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            # Volume of ball in R^d: For 2D \u03c0r^2, 3D (4/3)\u03c0r^3; Using heuristic R ~ gamma * (log(n)/n)^(1/d)\n            gamma = 25.0  # tuning parameter\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not valid_node(new_pos): \n                return None\n            if not valid_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path, iterations=50):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) -1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                # Check collision-free shortcut\n                if valid_edge(p1, p2):\n                    # Remove intermediate nodes\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Time exceeded: return best found\n                break\n\n            sample = sample_free(tree_indicator=True)  # tree_a grows towards goal_pos\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Found connection\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate connect node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success = True\n\n                # Attempt smoothing\n                smoothed_path = path_smoothing(best_path, iterations=100)\n                best_path = smoothed_path\n\n                # Stop on first found improved solution\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.40207,
          "time_improvement": 31.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1263.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019640398025512696,
                    "num_nodes_avg": 93.8,
                    "path_length_avg": 153.83644111358143,
                    "smoothness_avg": 0.029869960489300924,
                    "success_improvement": 0.0,
                    "time_improvement": 17.164700641643794,
                    "length_improvement": 15.679808931241347,
                    "smoothness_improvement": 367.52974531494084,
                    "objective_score": 10.123020705316112
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11281363964080811,
                    "num_nodes_avg": 504.4,
                    "path_length_avg": 238.70686820192523,
                    "smoothness_avg": 0.08618445945156529,
                    "success_improvement": 0.0,
                    "time_improvement": 52.965714028974354,
                    "length_improvement": 20.312776597957804,
                    "smoothness_improvement": 2117.588217845781,
                    "objective_score": 30.54021061751277
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0793837308883667,
                    "num_nodes_avg": 407.3,
                    "path_length_avg": 122.15175915589433,
                    "smoothness_avg": 0.11043538889563216,
                    "success_improvement": 0.0,
                    "time_improvement": 24.14930962919764,
                    "length_improvement": 18.87261781036399,
                    "smoothness_improvement": 1304.7299952599603,
                    "objective_score": 17.54296642713189
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a time-limited, bidirectional RRT* planner with adaptive neighbor radius, goal-biased sampling, incremental extension and rewiring, and early termination upon successful connection. It grows two trees alternately from start and goal, rewiring locally to optimize path cost, while performing rigorous collision checking on nodes and edges in both 2D and 3D environments. The adaptive radius scales with node count to balance exploration vs exploitation, and time budget guarantees timely return with the best path found.",
          "planning_mechanism": "The planner samples points biased toward the goal, incrementally extends the nearest nodes in alternating trees, rewires neighbor nodes to reduce path costs, and tries to connect the two trees incrementally. It maintains and updates the best path found so far, stops early if a path is found or the time budget is exceeded, and returns the best feasible path with graph details.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children if exists\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update children cost\n        for child in self.children:\n            child.update_parent(self, new_cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, \n                 goal_sample_rate: float=0.15, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import time\n        import random\n        import math\n\n        start_time = time.perf_counter()\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            # Adaptive neighbor radius based on node count and dimension (from RRT* literature)\n            gamma = 50.0  # tunable constant\n            unit_ball_volume = 3.14159 if dim == 2 else 4.18879  # approx vol of unit ball (circle/sphere)\n            r = min(self.step_size * 5, gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim))\n            return max(r, self.step_size)  # radius at least step_size\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def valid_new_node(parent_node, new_pos):\n            if (not self._within_bounds(new_pos, bounds) or \n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d)):\n                return False\n            return True\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_new_node(nearest_node, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost = neighbor.cost + edge_dist\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve paths\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except (ValueError, AttributeError):\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally grow tree towards new_node.position, rewiring neighbors\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if not valid_new_node(current_node, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    edge_dist = math.dist(neighbor.position, new_pos)\n                    cost = neighbor.cost + edge_dist\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_tree_node = Node(new_pos)\n                best_parent.add_child(new_tree_node)\n                new_tree_node.cost = min_cost\n                tree.append(new_tree_node)\n                nodes.append(new_tree_node)\n                edges.append((best_parent, new_tree_node))\n\n                # Rewire neighbors if beneficial\n                for neighbor in neighbors:\n                    cost_through_new = new_tree_node.cost + math.dist(new_tree_node.position, neighbor.position)\n                    if (cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_tree_node.position, neighbor.position, obstacles, is_3d)):\n                        neighbor.update_parent(new_tree_node, cost_through_new)\n                        edges.append((new_tree_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n\n                if new_tree_node.position == target_pos:\n                    return new_tree_node\n                current_node = new_tree_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        # Initialization\n        nodes = []\n        edges = []\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success_state = False\n        extracted_path = []\n\n        # Alternate growth mode flag (True: extend start, False: extend goal)\n        extend_start_tree = True\n\n        for i in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded: return best path found so far\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd = sample_free()\n            if extend_start_tree:\n                new_node = try_extend_and_rewire(tree_start, rnd)\n                if new_node is None:\n                    extend_start_tree = not extend_start_tree\n                    continue\n                connect_node = try_connect_and_rewire(tree_goal, new_node)\n            else:\n                new_node = try_extend_and_rewire(tree_goal, rnd)\n                if new_node is None:\n                    extend_start_tree = not extend_start_tree\n                    continue\n                connect_node = try_connect_and_rewire(tree_start, new_node)\n\n            if connect_node:\n                total_cost = new_node.cost + connect_node.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node, connect_node)\n                    extracted_path = merge_paths(new_node, connect_node)\n                    success_state = True\n                    # Early stop on found path to reduce search time\n                    break\n\n            extend_start_tree = not extend_start_tree  # Swap the trees to balance growth\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -19.29129,
          "time_improvement": 52.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 249.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017214751243591307,
                    "num_nodes_avg": 85.4,
                    "path_length_avg": 162.45403846964155,
                    "smoothness_avg": 0.025295390961639026,
                    "success_improvement": 0.0,
                    "time_improvement": 27.395103154723543,
                    "length_improvement": 10.956367265816162,
                    "smoothness_improvement": 295.9277983703062,
                    "objective_score": 11.889443391431826
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05150196552276611,
                    "num_nodes_avg": 308.1,
                    "path_length_avg": 263.26314823528526,
                    "smoothness_avg": 0.011204579401821988,
                    "success_improvement": 0.0,
                    "time_improvement": 78.5277898826744,
                    "length_improvement": 12.115183509491798,
                    "smoothness_improvement": 188.30189834121762,
                    "objective_score": 26.922883158406766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052243614196777345,
                    "num_nodes_avg": 282.3,
                    "path_length_avg": 130.0660806664245,
                    "smoothness_avg": 0.028519530529673744,
                    "success_improvement": 0.0,
                    "time_improvement": 50.08153232475334,
                    "length_improvement": 13.616302302561847,
                    "smoothness_improvement": 262.76632324468045,
                    "objective_score": 19.061551774161774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* trees with adaptive neighbor radius rewiring, goal-biased and informed ellipsoidal sampling after initial solution, incremental connection attempts with rewiring, robust collision checking in 2D/3D, and path smoothing via shortcutting. It enforces a 30-second max planning time and dynamically improves path cost and smoothness while efficiently exploring the configuration space.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples biased towards the goal or informed ellipse after a first solution is found, extends trees with step size limits while rewiring neighbors for cost optimization, attempts incremental connections between trees with rewiring, performs comprehensive obstacle checks, and applies shortcut path smoothing before returning the best path found or terminating if time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []\n        self.valid = True                  # Validity flag for collision\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' cost\n        for c in self.children:\n            dist_c = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist_c)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate growth\n        success_state = False\n        extracted_path = []\n        best_connection_nodes = None\n        best_cost = float('inf')\n\n        start_time = time.perf_counter()\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n        use_informed_sampling = False\n        rng = random.Random()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 30.0\n            r = gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)])\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1/dim)\n            r_vec = r * z_unit\n\n            r1 = c_max/2.0\n            r2 = math.sqrt(max(c_max**2 - c_best**2, 0))/2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback uniform sample ignoring obstacle if needed (unlikely)\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos)/self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=120):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            # Goal bias sampling\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = (new_node_a.cost + new_node_b.cost + \n                                math.dist(new_node_a.position, new_node_b.position))\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no final success but a best connection was found, return it\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.1736,
          "time_improvement": 29.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1460.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021906590461730956,
                    "num_nodes_avg": 94.3,
                    "path_length_avg": 164.82019876529642,
                    "smoothness_avg": 0.04242478953845123,
                    "success_improvement": 0.0,
                    "time_improvement": 7.606812425023407,
                    "length_improvement": 9.659437313558474,
                    "smoothness_improvement": 564.0400831817867,
                    "objective_score": 7.034131606127651
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055688667297363284,
                    "num_nodes_avg": 275.4,
                    "path_length_avg": 233.536148522463,
                    "smoothness_avg": 0.09844953476103444,
                    "success_improvement": 0.0,
                    "time_improvement": 76.78226931292077,
                    "length_improvement": 22.038911657876113,
                    "smoothness_improvement": 2433.177439735087,
                    "objective_score": 39.60835032412689
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10334131717681885,
                    "num_nodes_avg": 371.2,
                    "path_length_avg": 123.52674639577147,
                    "smoothness_avg": 0.11649523857042132,
                    "success_improvement": 0.0,
                    "time_improvement": 1.2579761120995374,
                    "length_improvement": 17.959416755494015,
                    "smoothness_improvement": 1381.8108358317033,
                    "objective_score": 10.87833036388718
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive rewiring, goal biasing, and incremental connection to rapidly find collision-free, lower cost, and smooth paths. It effectively balances exploration and exploitation by growing start and goal trees simultaneously with goal-directed sampling, local rewiring to optimize tree costs, and precise collision checks. A time budget is enforced to guarantee timely returns.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions toward randomly sampled points biased toward the goal. It incrementally extends trees within a step size, rewires neighbors within a fixed radius to minimize costs, and attempts to connect the trees. Collision checks prevent invalid nodes and edges. The best path found so far is returned if a time budget is exceeded, ensuring both efficiency and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -18.94623,
          "time_improvement": 50.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 271.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017641496658325196,
                    "num_nodes_avg": 84.5,
                    "path_length_avg": 170.50120424036766,
                    "smoothness_avg": 0.019952942408527338,
                    "success_improvement": 0.0,
                    "time_improvement": 25.59526263553606,
                    "length_improvement": 6.545588191379452,
                    "smoothness_improvement": 212.30687720138977,
                    "objective_score": 10.049230814943657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04605059623718262,
                    "num_nodes_avg": 254.1,
                    "path_length_avg": 248.84054005866628,
                    "smoothness_avg": 0.015314310037129148,
                    "success_improvement": 0.0,
                    "time_improvement": 80.80057589266545,
                    "length_improvement": 16.92986525060597,
                    "smoothness_improvement": 294.04822770699855,
                    "objective_score": 29.09638695645582
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06053769588470459,
                    "num_nodes_avg": 277.0,
                    "path_length_avg": 124.08694361494807,
                    "smoothness_avg": 0.03189665894955138,
                    "success_improvement": 0.0,
                    "time_improvement": 42.15658580257741,
                    "length_improvement": 17.587360436241912,
                    "smoothness_improvement": 305.72314747183384,
                    "objective_score": 17.693063565380776
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation is an optimized bidirectional RRT* planner with adaptive rewiring, goal biasing, and time-budget enforcement to minimize planning time while maintaining path quality and robustness. It grows two trees from start and goal simultaneously, incrementally extends and rewires nodes, performs efficient collision checks, and halts early upon connection or timeout.",
          "planning_mechanism": "The planner alternates extending two trees grown from start and goal positions respectively toward randomly sampled, goal-biased points. It uses rewiring within a neighborhood radius to locally optimize the path cost. At each iteration, it attempts to connect the trees, terminating early once a collision-free linkage is found or the time limit expires, returning the best path discovered.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=12.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Initialize two trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        extracted_path = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...]) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node or None:\n            current_node = nearest(tree, target_node.position)\n            while True:\n                dist = math.dist(current_node.position, target_node.position)\n                if dist <= self.step_size:\n                    new_pos = target_node.position\n                else:\n                    new_pos = steer(current_node.position, target_node.position)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node.position == target_node.position:\n                    return new_node\n                current_node = new_node\n\n        def merge_paths(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # avoid duplicate joining node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success = True\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early termination on success for reduced planning time\n                break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -18.76002,
          "time_improvement": 53.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 179.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019108223915100097,
                    "num_nodes_avg": 98.8,
                    "path_length_avg": 176.1973261808077,
                    "smoothness_avg": 0.016264515390411786,
                    "success_improvement": 0.0,
                    "time_improvement": 19.409196995003406,
                    "length_improvement": 3.4234534949960658,
                    "smoothness_improvement": 154.5749848204143,
                    "objective_score": 7.280324721602305
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04307892322540283,
                    "num_nodes_avg": 286.6,
                    "path_length_avg": 252.26151991778178,
                    "smoothness_avg": 0.011662148021780783,
                    "success_improvement": 0.0,
                    "time_improvement": 82.03952641933448,
                    "length_improvement": 15.78784370618765,
                    "smoothness_improvement": 200.07546850611288,
                    "objective_score": 28.76980400956844
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04527461528778076,
                    "num_nodes_avg": 224.4,
                    "path_length_avg": 133.24569451252,
                    "smoothness_avg": 0.022121184403052812,
                    "success_improvement": 0.0,
                    "time_improvement": 56.74037000503455,
                    "length_improvement": 11.50455418292619,
                    "smoothness_improvement": 181.3798327908465,
                    "objective_score": 20.229921002049835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* variant with informed sampling, adaptive rewiring, and goal biasing to efficiently explore and connect the search space while ensuring collision-free expansions and edge validations. It balances exploration and exploitation with incremental tree growth from both start and goal, dynamically rewiring to optimize path cost, and returns the best path found within a 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly and switching to ellipsoidal informed sampling after a first solution is found. Each extension steers towards samples within a step size limit, performs collision checks on nodes and edges, rewires neighbors adaptively for cost improvements, and attempts incremental connections between trees. Upon connection or timeout, it returns the best valid path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates down the subtree\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=10.0, neighbor_radius_max=30.0, max_time_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf:\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Rotation matrix (2D and 3D)\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                # 3D rotation matrix around axis v\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    k = tuple(ki / k_norm for ki in k)\n                    cos_t = vx\n                    sin_t = k_norm\n                    Kx, Ky, Kz = k\n                    K = [[0,-Kz,Ky],[Kz,0,-Kx],[-Ky,Kx,0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    def mat_add(A,B):\n                        return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_scale(A,s):\n                        return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                    K2 = mat_mul(K,K)\n                    R = mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n            # Ellipsoid radii\n            a1 = c_best / 2.0\n            a_minor = math.sqrt(max(c_best**2 - (c_min**2), 0.0)) / 2.0\n            radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                # Sample unit n-ball\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm_vec for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [r * unit_vec[i] * radii[i] for i in range(dim)]\n\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*ball_sample[0] + R[0][1]*ball_sample[1]\n                    y_rot = R[1][0]*ball_sample[0] + R[1][1]*ball_sample[1]\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot)\n                else:\n                    x_rot = sum(R[0][j]*ball_sample[j] for j in range(dim))\n                    y_rot = sum(R[1][j]*ball_sample[j] for j in range(dim))\n                    z_rot = sum(R[2][j]*ball_sample[j] for j in range(dim))\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot, center[2] + z_rot)\n\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if not self._is_in_obstacle(clamped, obstacles, is_3d):\n                    return clamped\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = math.inf\n        best_path = []\n\n        grow_start_tree = True\n        use_informed = False\n\n        start_time = time.perf_counter()\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            dist_curr = math.dist(nearest_node.position, from_node.position)\n            if dist_curr <= self.step_size and collision_free_edge(nearest_node.position, from_node.position) and collision_free_node(from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    if best_path:\n                        return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n\n                if use_informed:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_uniform()\n\n                if grow_start_tree:\n                    new_node = extend(start_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(goal_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(goal_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(goal_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        goal_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(goal_tree, connecting_node, neighbors)\n\n                        # Extract combined path\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            # Return early on first feasible path found\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(goal_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(start_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(start_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(start_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        start_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(start_tree, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n\n                grow_start_tree = not grow_start_tree\n\n            break\n\n        if best_path:\n            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.70121,
          "time_improvement": 50.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 209.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020652365684509278,
                    "num_nodes_avg": 101.9,
                    "path_length_avg": 161.09272527755476,
                    "smoothness_avg": 0.020914734892580944,
                    "success_improvement": 0.0,
                    "time_improvement": 12.896628076868538,
                    "length_improvement": 11.702524597786873,
                    "smoothness_improvement": 227.36101814263648,
                    "objective_score": 7.3462984333311185
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05064387321472168,
                    "num_nodes_avg": 297.6,
                    "path_length_avg": 251.50120631194395,
                    "smoothness_avg": 0.01163127030182631,
                    "success_improvement": 0.0,
                    "time_improvement": 78.88554590521389,
                    "length_improvement": 16.04165827223005,
                    "smoothness_improvement": 199.28096253136158,
                    "objective_score": 27.870400238666985
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04441468715667725,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 130.89357935919415,
                    "smoothness_avg": 0.02366342243242298,
                    "success_improvement": 0.0,
                    "time_improvement": 57.56202630266056,
                    "length_improvement": 13.066717072077614,
                    "smoothness_improvement": 200.99698668826508,
                    "objective_score": 20.886936238655014
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.654359830512174,
          "time_improvement": 54.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020609617233276367,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 17.306726487427596,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 6.787323209480537
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03164470195770264,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 80.42008291490608,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.76431560419259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01710929870605469,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.63515364948351,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 21.411440677863403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed sampling, goal biasing, adaptive neighbor radius, incremental connection, and efficient rewiring to optimize planning time, path quality, and smoothness. It employs ellipsoidal informed sampling after an initial solution to focus exploration, maintains robust collision checks for both nodes and edges, and applies path smoothing to the final path. Alternating tree expansions from start and goal with early termination within 30 seconds ensures timely results without sacrificing solution optimality.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias and informed ellipsoidal distributions after a first solution. For each sampled point, it extends the closest node in the active tree toward it, rewiring neighbors adaptively to minimize cost while respecting collision constraints. Upon extending, it incrementally tries to connect the opposite tree toward the new node with rewiring for cost improvement. Once a connection is made or the time limit is reached, the planner extracts the combined path, applies smoothing, and returns the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # Child nodes list\n        self.valid = True                 # Validity flag for collision checks\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    # Propagate cost changes downwards\n                    self._propagate_costs(nbr)\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr_node = connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Cost propagation after rewiring for cost consistency\n        def _propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    c.cost = new_cost\n                    _propagate_costs(c)\n\n        self._propagate_costs = _propagate_costs\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample = None\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect_trees(new_node, other_tree)\n\n            if connect_node:\n                path_s = new_node.path_from_root()\n                path_g = connect_node.path_from_root()\n                # Remove duplicate overlap\n                if path_g and path_g[0] == new_node.position:\n                    path_g = path_g[1:]\n                combined_path = path_s + path_g[::-1]\n\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling_enabled = True\n\n                # Update edges\n                edges.clear()\n                all_nodes = tree_start + tree_goal\n                for node in all_nodes:\n                    for child in node.children:\n                        # Confirm edge validity before adding\n                        if collision_free_edge(node.position, child.position):\n                            edges.append((node, child))\n\n                extracted_path = path_smoothing(best_path, self.smoothing_trials)\n                success_state = True\n                # Early termination on first connection for faster result\n                break\n\n            grow_start_tree = not grow_start_tree\n\n        if not success_state and best_path:\n            extracted_path = path_smoothing(best_path, self.smoothing_trials)\n            success_state = True\n\n        # If no path found, return empty path with failure\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.47087,
          "time_improvement": 25.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1581.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035898375511169436,
                    "num_nodes_avg": 105.7,
                    "path_length_avg": 165.43919266575992,
                    "smoothness_avg": 0.04547452672691564,
                    "success_improvement": 0.0,
                    "time_improvement": -51.404909314142024,
                    "length_improvement": 9.3201569481284,
                    "smoothness_improvement": 611.775092791558,
                    "objective_score": -10.498565940659137
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06856350898742676,
                    "num_nodes_avg": 274.6,
                    "path_length_avg": 240.62702077192915,
                    "smoothness_avg": 0.10674203749060625,
                    "success_improvement": 0.0,
                    "time_improvement": 71.41448765274039,
                    "length_improvement": 19.671774401563216,
                    "smoothness_improvement": 2646.5495078152617,
                    "objective_score": 38.591448715211065
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0478440523147583,
                    "num_nodes_avg": 200.5,
                    "path_length_avg": 123.405226371156,
                    "smoothness_avg": 0.12462532690100234,
                    "success_improvement": 0.0,
                    "time_improvement": 54.28528796014279,
                    "length_improvement": 18.040124569681865,
                    "smoothness_improvement": 1485.2249592959965,
                    "objective_score": 27.31973609845919
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner uses a bidirectional RRT* approach with adaptive rewiring, goal-biased sampling, and incremental connection attempts between two trees grown from start and goal. It dynamically adjusts neighbor radius for efficient path optimization and applies robust collision checks to ensure feasibility. The algorithm enforces a 30-second time limit, returning the best path found within that interval. Path smoothing is applied post planning to improve path quality and smoothness.",
          "planning_mechanism": "The planner alternates expansions between two trees from start and goal positions, sampling points biased toward the opposite tree root. It extends each tree toward samples using a step size limit, rewires neighbors within an adaptive radius to minimize path cost, and incrementally attempts to connect the trees while avoiding collisions. Upon success or timeout, the best path is extracted and shortcut smoothing is applied before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            # Goal bias toward opposite tree root\n            if random.random() < self.goal_sample_rate:\n                if tree_from is start_tree:\n                    return goal_pos\n                else:\n                    return start_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            if tree_from is start_tree:\n                return goal_pos\n            else:\n                return start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            node_near = nearest(tree, node.position)\n            dist_to = math.dist(node_near.position, node.position)\n            if dist_to <= self.step_size:\n                if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(node_near.position, node.position, obstacles, is_3d):\n                    return node_near\n            return None\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        import time\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    # Optional early break for speed:\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.44179,
          "time_improvement": 28.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1195.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0321617841720581,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 154.7988312384859,
                    "smoothness_avg": 0.03852361475420025,
                    "success_improvement": 0.0,
                    "time_improvement": -35.64546993042573,
                    "length_improvement": 15.152307653733788,
                    "smoothness_improvement": 502.97822627162316,
                    "objective_score": -5.148288317022846
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0475306510925293,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 232.3176880735701,
                    "smoothness_avg": 0.07877010053743526,
                    "success_improvement": 0.0,
                    "time_improvement": 80.18351111627115,
                    "length_improvement": 22.445668827155995,
                    "smoothness_improvement": 1926.8114226383475,
                    "objective_score": 38.17824421350428
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.061810421943664554,
                    "num_nodes_avg": 280.3,
                    "path_length_avg": 118.64183299869458,
                    "smoothness_avg": 0.09862513818512744,
                    "success_improvement": 0.0,
                    "time_improvement": 40.94050350026311,
                    "length_improvement": 21.203743639253076,
                    "smoothness_improvement": 1154.504477964368,
                    "objective_score": 22.29542216775139
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner is a bidirectional RRT* variant that grows two trees from start and goal positions. It employs goal-biased and informed samplings to focus exploration, uses an adaptive neighbor radius for efficient rewiring, and incrementally connects the two trees. It also performs collision checks on nodes and edges, rewires nearby nodes to optimize path cost, and applies path smoothing on the best path found. Planning is time-limited to 30 seconds, returning the best feasible path discovered.",
          "planning_mechanism": "The planner alternates expansions from the two trees towards sampled points, rewiring nearby nodes for cost improvements. After each expansion, it incrementally tries to connect the newly added node to the other tree, rewiring as needed. Sampling is goal-biased initially, then informed by the current best path cost to limit the search space. Once a connection between trees is made or the time limit is reached, the algorithm extracts, smooths, and returns the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D/3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = [] # Child nodes\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                    # Environment bounds (tuple)\n        start_pos = map.start                # Start position (tuple)\n        goal_pos = map.goal                  # Goal position (tuple)\n        obstacles = map.obstacles            # Obstacle list\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def is_valid_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_valid_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def clamp_to_bounds(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta * cos_theta)\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_valid_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if is_valid_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and is_valid_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not is_valid_node(new_pos) or not is_valid_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and is_valid_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n\n                if not is_valid_node(next_pos) or not is_valid_edge(curr.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    tentative = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative < min_cost and is_valid_edge(nbr.position, next_pos):\n                        min_cost = tentative\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if is_valid_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    return None\n                curr = new_connect_node\n\n        def path_smooth(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_valid_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # time limit exceeded: return best found\n                if best_path:\n                    final_path = path_smooth(best_path)\n                    return PlannerResult(True, final_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n\n                    final_path = path_smooth(combined_path)\n                    return PlannerResult(True, final_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n\n                    final_path = path_smooth(combined_path)\n                    return PlannerResult(True, final_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached, return best found path if any\n        if best_path:\n            final_path = path_smooth(best_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.11735,
          "time_improvement": 25.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1461.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03285539150238037,
                    "num_nodes_avg": 101.1,
                    "path_length_avg": 166.7486358081921,
                    "smoothness_avg": 0.03593353363548005,
                    "success_improvement": 0.0,
                    "time_improvement": -38.57082667573006,
                    "length_improvement": 8.602430412306914,
                    "smoothness_improvement": 462.43783231248034,
                    "objective_score": -7.538572758695234
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04608297348022461,
                    "num_nodes_avg": 221.6,
                    "path_length_avg": 236.61854026094048,
                    "smoothness_avg": 0.09746371733560524,
                    "success_improvement": 0.0,
                    "time_improvement": 80.78707716580014,
                    "length_improvement": 21.009920573845452,
                    "smoothness_improvement": 2407.8116473232035,
                    "objective_score": 40.47716550112515
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.070013427734375,
                    "num_nodes_avg": 277.2,
                    "path_length_avg": 121.02876962702206,
                    "smoothness_avg": 0.12671448206394503,
                    "success_improvement": 0.0,
                    "time_improvement": 33.10257946497118,
                    "length_improvement": 19.618453984426026,
                    "smoothness_improvement": 1511.7988587632342,
                    "objective_score": 21.41345893019273
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a time-bounded bidirectional RRT* planner with goal-biased sampling, adaptive neighbor radius rewiring, and path smoothing via shortcutting. It incrementally grows two trees from start and goal, attempts connections at each extension, optimizes paths through rewiring, and enforces strict collision checking and bounds constraints for robustness and efficiency. Upon reaching a connection or time limit, it extracts and smooths the best path found.",
          "planning_mechanism": "The planner alternates growth of two RRT* trees from start and goal positions, using adaptive sampling biased toward the goal. For each new node, it selects the best parent among neighbors to minimize path cost and rewires neighbors to improve path quality. It attempts to connect the two trees repeatedly, and if successful or upon timeout, it extracts and smooths the combined path. Collision checks and bounds enforcement ensure safety and feasibility throughout the process.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n):\n            if n == 0:\n                return self.step_size * 5.0\n            gamma = 2 * (1.5 ** (1 / dim))\n            r = min(self.step_size * 5.0, gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            # tree_toggle True: sample goal biased towards goal; False: towards start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            radius_sq = radius * radius\n            for n in tree:\n                dx = sum((pos[d] - n.position[d]) ** 2 for d in range(dim))\n                if dx <= radius_sq:\n                    result.append(n)\n            return result\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        def path_shortcut(path, max_attempts=75):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n        final_path = []\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - time_start) > self.max_time:\n                break  # time limit exceeded\n\n            rand_point = sample_free(grow_start)\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            edges.append((new_node.parent, new_node))\n\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                min_cost_other = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-9 < min_cost_other and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost_other = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost_other\n                other_tree.append(connecting_node_other)\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                combined_path = path_start + path_goal[::-1][1:]\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                final_path = combined_path\n                success = True\n                break\n\n            nodes.append(new_node)\n            grow_start = not grow_start\n\n        # If no success but have partial best connection\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = len(final_path) > 1\n\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        edges.clear()\n        all_nodes = []\n        seen = set()\n\n        def collect_nodes_edges(node):\n            if node in seen:\n                return\n            seen.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_edges(c)\n\n        for n in tree_start:\n            collect_nodes_edges(n)\n        for n in tree_goal:\n            collect_nodes_edges(n)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -17.38251,
          "time_improvement": 24.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1408.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026909017562866212,
                    "num_nodes_avg": 120.1,
                    "path_length_avg": 167.1397068312923,
                    "smoothness_avg": 0.034221032257095704,
                    "success_improvement": 0.0,
                    "time_improvement": -13.491413074409975,
                    "length_improvement": 8.38807818762877,
                    "smoothness_improvement": 435.63346698450147,
                    "objective_score": -0.1916409498747309
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0745931625366211,
                    "num_nodes_avg": 284.2,
                    "path_length_avg": 237.67604063407308,
                    "smoothness_avg": 0.09023415703269165,
                    "success_improvement": 0.0,
                    "time_improvement": 68.90060324796465,
                    "length_improvement": 20.65689651083326,
                    "smoothness_improvement": 2221.7898534874284,
                    "objective_score": 35.91050954399319
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08596856594085693,
                    "num_nodes_avg": 300.0,
                    "path_length_avg": 126.16355373265787,
                    "smoothness_avg": 0.13097175723059273,
                    "success_improvement": 0.0,
                    "time_improvement": 17.857538265974437,
                    "length_improvement": 16.208174873606655,
                    "smoothness_improvement": 1565.9510846436274,
                    "objective_score": 16.4286518777318
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation improves the bidirectional RRT* planner by incorporating adaptive rewiring, enhanced goal biasing, and optimized incremental connection strategies. It leverages spatial hashing for efficient nearest neighbor queries to reduce planning time, dynamically adjusts sampling bias based on progress, and limits neighborhood searches to reduce computation. Collision checks are carefully applied, and a strict 30-second time budget ensures timely planning termination. The planner balances exploration and exploitation to find lower-cost, smoother, and valid paths rapidly.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately using goal-biased sampling and spatially efficient nearest-neighbor queries. Each extension steers toward sampled points within step size, rewires neighbors for cost improvement, and incrementally attempts connecting the opposite tree. Strict collision checks ensure validity. The process continues until a time limit or max iteration count is reached, then returns the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=12.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        from collections import defaultdict\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Spatial hashing grid for efficient neighbor search\n        cell_size = self.neighbor_radius\n        def grid_key(pos):\n            return tuple(int(p // cell_size) for p in pos)\n\n        grid_nodes_start = defaultdict(list)\n        grid_nodes_goal = defaultdict(list)\n\n        def insert_node_to_grid(grid, node):\n            k = grid_key(node.position)\n            grid[k].append(node)\n\n        def nearby_nodes_grid(grid, pos):\n            base = grid_key(pos)\n            neighbors = []\n            # Search neighbors in adjacent cells only\n            for dx in (-1,0,1):\n                for dy in (-1,0,1):\n                    for dz in ([0] if dimension==2 else (-1,0,1)):\n                        if dimension ==2 and dz!=0:\n                            continue\n                        neighbor_cell = tuple(base[d]+(dx if d==0 else dy if d==1 else dz) for d in range(dimension))\n                        neighbors.extend(grid.get(neighbor_cell, []))\n            return neighbors\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n\n        for n in tree_start: insert_node_to_grid(grid_nodes_start, n)\n        for n in tree_goal: insert_node_to_grid(grid_nodes_goal, n)\n\n        def sample_free():\n            # Adaptive goal biasing: slightly increase goal bias if already found a better path\n            rate = self.goal_sample_rate if not success_state else min(0.4, self.goal_sample_rate + 0.1)\n            if random.random() < rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Use spatial hashing grid for efficient search\n            grid_tree = grid_nodes_start if tree is tree_start else grid_nodes_goal\n            candidates = nearby_nodes_grid(grid_tree, point)\n            if not candidates:\n                return min(tree, key=lambda n: math.dist(n.position, point))\n            return min(candidates, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            grid_tree = grid_nodes_start if tree is tree_start else grid_nodes_goal\n            neighbors = []\n            candidates = nearby_nodes_grid(grid_tree, pos)\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            neighbors = [n for n in candidates if (self._dist_sq(n.position, pos) <= radius_sq)]\n            return neighbors\n\n        def try_extend_and_rewire(tree, grid_tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            insert_node_to_grid(grid_tree, new_node)\n\n            # Rewire neighbors if beneficial\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def try_connect_and_rewire(tree, grid_tree, new_node):\n            # Incrementally extend tree toward new_node.position with rewiring\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if not self._within_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                insert_node_to_grid(grid_tree, new_node_goal)\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                            neighbor.update_parent(new_node_goal, cost_through_new)\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, grid_nodes_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, grid_nodes_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=tree_start+tree_goal,\n            edges=self._extract_edges(tree_start+tree_goal)\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((a-b)**2 for a,b in zip(p1,p2))\n\n    def _extract_edges(self, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return edges\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -16.78989,
          "time_improvement": 44.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 190.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017108941078186037,
                    "num_nodes_avg": 83.8,
                    "path_length_avg": 162.78675012856405,
                    "smoothness_avg": 0.01651510601193109,
                    "success_improvement": 0.0,
                    "time_improvement": 27.84136787477236,
                    "length_improvement": 10.774002733407121,
                    "smoothness_improvement": 158.4972722134357,
                    "objective_score": 11.299697270180308
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06019690036773682,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 261.2897492478698,
                    "smoothness_avg": 0.011521411010039959,
                    "success_improvement": 0.0,
                    "time_improvement": 74.90269584883335,
                    "length_improvement": 12.773960892631509,
                    "smoothness_improvement": 196.4542038252493,
                    "objective_score": 26.007871952302555
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0747917652130127,
                    "num_nodes_avg": 307.6,
                    "path_length_avg": 124.76360771496066,
                    "smoothness_avg": 0.024739827262098366,
                    "success_improvement": 0.0,
                    "time_improvement": 28.53690596331842,
                    "length_improvement": 17.13795236029544,
                    "smoothness_improvement": 214.68877666979614,
                    "objective_score": 13.062106144403595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is a bidirectional informed RRT* algorithm with adaptive rewiring and goal-biased sampling to improve sample efficiency, path quality, and smoothness. It incorporates dynamic rewiring, collision-aware node and edge validation, and a strict 30-second execution limit to balance exploration and exploitation effectively while ensuring timely responses in both 2D and 3D spaces.",
          "planning_mechanism": "The planning mechanism grows two alternating trees from start and goal, initially exploring the space with uniform samples and switching to ellipsoidal informed sampling after a first solution is found. Each extension steers incrementally towards samples within step size limits, performs collision checks, connects optimally through neighbor-based rewiring, and attempts incremental tree connections. The algorithm maintains the best path cost and immediately returns the best valid path once time expires or a satisfactory path is achieved.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # Collision status\n\n        if parent:\n            self.parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost update to children\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=15.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.neighbor_radius\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[0, -Kz, Ky], [Kz, 0, -Kx], [-Ky, Kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-8:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <= 1.0 and norm_sq > 1e-10:\n                        norm = math.sqrt(norm_sq)\n                        return tuple(x / norm for x in pt)\n\n            while True:\n                n = dim\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n                sample_point = clamp_to_bounds(sample_point)\n                if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d_curr = dist(nearest_node.position, from_node.position)\n            if d_curr <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    # Time limit reached - return best path found so far\n                    if best_path_nodes:\n                        return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_goal, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_goal.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_goal, connecting_node, neighbors)\n\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_start, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_start.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_start, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n\n                grow_start = not grow_start\n\n            break\n\n        # If max iterations reached without success but path found\n        if best_path_nodes:\n            return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.68936,
          "time_improvement": 42.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 303.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02621774673461914,
                    "num_nodes_avg": 120.1,
                    "path_length_avg": 163.78975475831936,
                    "smoothness_avg": 0.02379259944851252,
                    "success_improvement": 0.0,
                    "time_improvement": -10.57591075510042,
                    "length_improvement": 10.224240002212797,
                    "smoothness_improvement": 272.4058478258737,
                    "objective_score": 0.23410401304180173
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05165274143218994,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 243.7262208895383,
                    "smoothness_avg": 0.01676442716657435,
                    "success_improvement": 0.0,
                    "time_improvement": 78.46492835933412,
                    "length_improvement": 18.637172196776035,
                    "smoothness_improvement": 331.36078592477384,
                    "objective_score": 28.923716876779313
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.045268702507019046,
                    "num_nodes_avg": 241.1,
                    "path_length_avg": 132.82977863188572,
                    "smoothness_avg": 0.03192310547714889,
                    "success_improvement": 0.0,
                    "time_improvement": 56.74601963245528,
                    "length_improvement": 11.780785707057527,
                    "smoothness_improvement": 306.0595453507945,
                    "objective_score": 20.91026075790206
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
          "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.50088,
          "time_improvement": 36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and post-processing path smoothing. It rigorously verifies collisions for nodes and edges, manages parent-child relations with clean rewiring, adapts neighbor radius dynamically for balanced exploration and exploitation, and enforces a 30-second time limit to ensure timely results while optimizing path quality, length, and smoothness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions toward goal-biased random samples. For each new node, it selects the best parent within an adaptive radius minimizing cost and rewires neighbors if cheaper connections are found. It tries to incrementally connect the two trees safely. Upon successful connection, the combined path is smoothed to improve navigation. Planning stops on success or timeout, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=25.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def _within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling towards goal, False for goal_tree sampling towards start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if _within_bounds(p) and not _is_in_obstacle(p):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and not _is_edge_in_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not _within_bounds(new_pos) or _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not _within_bounds(new_pos) or _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr_node.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) <= 2:\n                return path[:]\n            p = path[:]\n            for _ in range(iterations):\n                if len(p) <= 2:\n                    break\n                i = random.randint(0, len(p) - 2)\n                j = random.randint(i + 1, len(p) - 1)\n                if j == i + 1:\n                    continue\n                if not _is_edge_in_obstacle(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break  # timeout\n\n            sample = sample_free(tree_indicator=True)\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined_path, iterations=100)\n                    success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout but no path, try extracting best known path\n        if not success and best_path:\n            best_path = path_smoothing(best_path, iterations=100)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -16.43934,
          "time_improvement": 23.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1203.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0278092622756958,
                    "num_nodes_avg": 140.2,
                    "path_length_avg": 160.76337289480648,
                    "smoothness_avg": 0.03216259970288559,
                    "success_improvement": 0.0,
                    "time_improvement": -17.28828318804759,
                    "length_improvement": 11.883047857693684,
                    "smoothness_improvement": 403.4145275532775,
                    "objective_score": -0.7928027471091523
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12574188709259032,
                    "num_nodes_avg": 529.1,
                    "path_length_avg": 236.14255269432087,
                    "smoothness_avg": 0.07820490793912455,
                    "success_improvement": 0.0,
                    "time_improvement": 47.57566642757288,
                    "length_improvement": 21.16881892412554,
                    "smoothness_improvement": 1912.268609992039,
                    "objective_score": 28.067806763057163
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06304893493652344,
                    "num_nodes_avg": 365.2,
                    "path_length_avg": 123.13467120808863,
                    "smoothness_avg": 0.10962216477618048,
                    "success_improvement": 0.0,
                    "time_improvement": 39.75711158241963,
                    "length_improvement": 18.219814426538804,
                    "smoothness_improvement": 1294.3858444864957,
                    "objective_score": 22.04302558246613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal-biased and informed sampling, adaptive neighborhood rewiring, and incremental tree connections optimizing for path cost, smoothness, and robustness within a 30-second planning window. It grows two trees from start and goal, alternately extending the trees with rewiring to reduce costs, and attempts incremental connections. The algorithm terminates early on time limit or upon finding an improved path, returning the best feasible path with smoothed segments and obstacle-aware constraints.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal. It samples new points with a bias towards the goal and within an informed ellipsoidal region after a solution is found. Each extension steers towards the sample limiting step size, adds rewired nodes to minimize cost, and attempts incremental connection to the opposite tree. Path smoothing is applied on the best path found. The search respects map boundaries and performs node and edge collision checks. The process is bounded by a 30-second time limit, enforcing early termination with the best result available.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Post max iterations: return best path if any\n        if best_path:\n            extracted = path_smoothing(best_path)\n            success_state = True\n        else:\n            extracted = []\n            success_state = False\n\n        return PlannerResult(success_state, extracted, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.16879,
          "time_improvement": 19.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1429.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02265455722808838,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 162.79462990355435,
                    "smoothness_avg": 0.04384992409220446,
                    "success_improvement": 0.0,
                    "time_improvement": 4.452189442289757,
                    "length_improvement": 10.76968370387191,
                    "smoothness_improvement": 586.346533677241,
                    "objective_score": 6.421326241847515
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049032163619995114,
                    "num_nodes_avg": 219.0,
                    "path_length_avg": 233.27017502674235,
                    "smoothness_avg": 0.0889054816827217,
                    "success_improvement": 0.0,
                    "time_improvement": 79.55750020277911,
                    "length_improvement": 22.127701266370266,
                    "smoothness_improvement": 2187.6020797265296,
                    "objective_score": 39.23080071274043
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13197367191314696,
                    "num_nodes_avg": 374.4,
                    "path_length_avg": 127.09207572420584,
                    "smoothness_avg": 0.1268240467271708,
                    "success_improvement": 0.0,
                    "time_improvement": -26.10007130376542,
                    "length_improvement": 15.5914947782864,
                    "smoothness_improvement": 1513.1925131922435,
                    "objective_score": 2.854240130488871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive rewiring, goal-biased sampling, and incremental connection. It grows two trees from start and goal alternately, sampling points biased towards the opposite tree root to improve exploration efficiency. Rewiring is applied dynamically during node insertions and tree connections to optimize path cost and smoothness. Comprehensive collision checks on nodes and edges ensure path feasibility. The planner enforces a 30-second time limit, returning the best path found within that interval with shortcut smoothing for path quality.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling points biased towards the opposite tree\u2019s root. It tries to extend each tree toward the sample by limited step size, rewires neighbors within an adaptive radius to minimize cost, and incrementally attempts connections between trees while enforcing collision checks. If successful or on timeout, extracts and smooths the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            if random.random() < self.goal_sample_rate:\n                return tree_to[0].position\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to[0].position\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early termination on successful connection\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.01025,
          "time_improvement": 19.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0349745512008667,
                    "num_nodes_avg": 99.6,
                    "path_length_avg": 161.61541596370688,
                    "smoothness_avg": 0.038164240443188946,
                    "success_improvement": 0.0,
                    "time_improvement": -47.50858994225105,
                    "length_improvement": 11.41602955014295,
                    "smoothness_improvement": 497.35323791048927,
                    "objective_score": -9.482604883094279
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06216433048248291,
                    "num_nodes_avg": 302.6,
                    "path_length_avg": 235.87082513264122,
                    "smoothness_avg": 0.0877666970169375,
                    "success_improvement": 0.0,
                    "time_improvement": 74.0824344784919,
                    "length_improvement": 21.25952940545841,
                    "smoothness_improvement": 2158.3003300424616,
                    "objective_score": 37.26813787485156
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07126703262329101,
                    "num_nodes_avg": 339.7,
                    "path_length_avg": 123.54013070238454,
                    "smoothness_avg": 0.11924109929446303,
                    "success_improvement": 0.0,
                    "time_improvement": 31.904767328751372,
                    "length_improvement": 17.9505275363338,
                    "smoothness_improvement": 1416.737981563158,
                    "objective_score": 20.24522561370796
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* with incremental rewiring, adaptive neighbor radius, and goal-biased sampling to efficiently explore the space. It grows two trees simultaneously from start and goal, alternating expansion and performing rewiring for path cost optimization. A time limit ensures prompt termination, returning the best path found so far. Path smoothing via shortcutting improves path quality and smoothness post planning. The Node class manages parent-child relationships and supports clean rewiring.",
          "planning_mechanism": "The planner alternates growth between two trees, samples points with goal bias, extends and rewires each tree toward samples using an adaptive neighbor radius, and incrementally attempts connection between trees with rewiring. Collision and bounds checks ensure safety. Upon successful connection or time expiration, the best path is extracted and smoothed by shortcutting unnecessary waypoints to deliver a robust, smooth, and cost-efficient solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time limit reached: return best found path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    smoothed_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    extracted_path = smoothed_path\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    success_state = True\n                    # Early termination can be left off for more improvement, here break for efficiency\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If not success but have best path found within iterations\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1]\n            extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int, dim: int) -> float:\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        gamma_rrt_star = 50.0\n        radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n        radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n        return radius\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d: bool) -> Tuple[float, ...]:\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          sample: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes, dims)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                       tree: List[Node],\n                                       target_pos: Tuple[float, ...],\n                                       obstacles,\n                                       is_3d: bool,\n                                       nodes: List[Node],\n                                       edges: List[Tuple[Node, Node]],\n                                       bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        dist_total = math.dist(curr_node.position, target_pos)\n        max_steps = int(dist_total / self.step_size) + 2\n\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes, dims)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int=100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.71302,
          "time_improvement": 15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029410433769226075,
                    "num_nodes_avg": 93.7,
                    "path_length_avg": 151.35150865706538,
                    "smoothness_avg": 0.03576982037913053,
                    "success_improvement": 0.0,
                    "time_improvement": -24.04138054474865,
                    "length_improvement": 17.04183978693237,
                    "smoothness_improvement": 459.8753643415842,
                    "objective_score": -1.5046693843302004
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08552870750427247,
                    "num_nodes_avg": 391.9,
                    "path_length_avg": 234.64078700173286,
                    "smoothness_avg": 0.10682658825679274,
                    "success_improvement": 0.0,
                    "time_improvement": 64.34135357837532,
                    "length_improvement": 21.670151538240148,
                    "smoothness_improvement": 2648.7250599286954,
                    "objective_score": 36.880061680804104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09911580085754394,
                    "num_nodes_avg": 413.0,
                    "path_length_avg": 119.99349451886602,
                    "smoothness_avg": 0.10399153638493046,
                    "success_improvement": 0.0,
                    "time_improvement": 5.295432230668823,
                    "length_improvement": 20.30603441676022,
                    "smoothness_improvement": 1222.7646669595508,
                    "objective_score": 11.763659887350446
               }
          ],
          "success_rate": 1.0
     }
]