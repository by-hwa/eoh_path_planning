[
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with dynamic rewiring, goal-biased and informed ellipsoidal sampling, adaptive neighborhood radius, and comprehensive collision checking for nodes and edges. It grows two trees from start and goal positions alternately, performs incremental extension, rewires local neighborhoods to optimize path costs, and attempts incremental connection with rewiring. The planner enforces a strict 30-second time limit, returning the best path found so far to ensure planning efficiency, path quality, smoothness, and robustness.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal positions using a combination of goal-biased and ellipsoidal informed sampling to focus the search. Each new node is extended cautiously with collision checks and rewiring to nearby nodes to reduce overall cost. The opposing tree incrementally connects to newly added nodes with additional rewiring, continuously improving path quality. The process terminates on success or time expiry, providing robust, low-cost, and smooth paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5,\n                 max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size              # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Constants for informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)*0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            temp_node = Node(new_pos)\n            neighbors = near_nodes(tree, temp_node)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos)\n                candidate_node.cost = cost_to_next\n\n                neighbors = near_nodes(tree_connect, candidate_node)\n\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n\n                min_parent.add_child(candidate_node)\n                candidate_node.parent = min_parent\n                candidate_node.cost = min_cost\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n\n                last_node = candidate_node\n\n            return None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # For both trees alternately\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n\n                # Sampling: goal bias + informed sampling when path found\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Build combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    # Compute path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node subtree\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return on first found path to maximize speed\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no connection found return best partial path by checking nearby nodes between trees\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.16994,
          "time_improvement": 68.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007612085342407227,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 184.4913298419197,
                    "smoothness_avg": 0.010519350526551577,
                    "success_improvement": 0.0,
                    "time_improvement": 67.89528566271517,
                    "length_improvement": -1.1226213385578332,
                    "smoothness_improvement": 64.65067887581763,
                    "objective_score": 20.46731482548207
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0381946325302124,
                    "num_nodes_avg": 201.0,
                    "path_length_avg": 307.68127601525805,
                    "smoothness_avg": 0.006362886119035033,
                    "success_improvement": 0.0,
                    "time_improvement": 84.07588590613632,
                    "length_improvement": -2.7128660483826366,
                    "smoothness_improvement": 63.72164284439662,
                    "objective_score": 24.99880077638635
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04949972629547119,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 158.73835880469125,
                    "smoothness_avg": 0.012861891384057036,
                    "success_improvement": 0.0,
                    "time_improvement": 52.703301159312666,
                    "length_improvement": -5.42645960970871,
                    "smoothness_improvement": 63.60230903913767,
                    "objective_score": 15.043709971047745
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.654359830512174,
          "time_improvement": 54.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020609617233276367,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 17.306726487427596,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 6.787323209480537
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03164470195770264,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 80.42008291490608,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.76431560419259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01710929870605469,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.63515364948351,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 21.411440677863403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
          "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.50088,
          "time_improvement": 36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* with incremental rewiring, adaptive neighbor radius, and goal-biased sampling to efficiently explore the space. It grows two trees simultaneously from start and goal, alternating expansion and performing rewiring for path cost optimization. A time limit ensures prompt termination, returning the best path found so far. Path smoothing via shortcutting improves path quality and smoothness post planning. The Node class manages parent-child relationships and supports clean rewiring.",
          "planning_mechanism": "The planner alternates growth between two trees, samples points with goal bias, extends and rewires each tree toward samples using an adaptive neighbor radius, and incrementally attempts connection between trees with rewiring. Collision and bounds checks ensure safety. Upon successful connection or time expiration, the best path is extracted and smoothed by shortcutting unnecessary waypoints to deliver a robust, smooth, and cost-efficient solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time limit reached: return best found path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    smoothed_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    extracted_path = smoothed_path\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    success_state = True\n                    # Early termination can be left off for more improvement, here break for efficiency\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If not success but have best path found within iterations\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1]\n            extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int, dim: int) -> float:\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        gamma_rrt_star = 50.0\n        radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n        radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n        return radius\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d: bool) -> Tuple[float, ...]:\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          sample: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes, dims)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                       tree: List[Node],\n                                       target_pos: Tuple[float, ...],\n                                       obstacles,\n                                       is_3d: bool,\n                                       nodes: List[Node],\n                                       edges: List[Tuple[Node, Node]],\n                                       bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        dist_total = math.dist(curr_node.position, target_pos)\n        max_steps = int(dist_total / self.step_size) + 2\n\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes, dims)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int=100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.71302,
          "time_improvement": 15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029410433769226075,
                    "num_nodes_avg": 93.7,
                    "path_length_avg": 151.35150865706538,
                    "smoothness_avg": 0.03576982037913053,
                    "success_improvement": 0.0,
                    "time_improvement": -24.04138054474865,
                    "length_improvement": 17.04183978693237,
                    "smoothness_improvement": 459.8753643415842,
                    "objective_score": -1.5046693843302004
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08552870750427247,
                    "num_nodes_avg": 391.9,
                    "path_length_avg": 234.64078700173286,
                    "smoothness_avg": 0.10682658825679274,
                    "success_improvement": 0.0,
                    "time_improvement": 64.34135357837532,
                    "length_improvement": 21.670151538240148,
                    "smoothness_improvement": 2648.7250599286954,
                    "objective_score": 36.880061680804104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09911580085754394,
                    "num_nodes_avg": 413.0,
                    "path_length_avg": 119.99349451886602,
                    "smoothness_avg": 0.10399153638493046,
                    "success_improvement": 0.0,
                    "time_improvement": 5.295432230668823,
                    "length_improvement": 20.30603441676022,
                    "smoothness_improvement": 1222.7646669595508,
                    "objective_score": 11.763659887350446
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.974939814675388,
          "time_improvement": 44.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012398910522460938,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 50.2510654377263,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 14.8169556563946
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027178692817687988,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 83.18339188143196,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 25.336085485098604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05079307556152344,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": -2.020326334253888,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": -1.2282216974670441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional growth and rewiring strategies of bidirectional RRT* with goal-biased sampling and dynamic incremental connection attempts. It features two trees grown from start and goal that alternate expansions. Each expansion uses neighborhood rewiring to reduce path cost, and after each new node is added, an incremental connection attempt with rewiring is made to join the two trees as early as possible. Collision checks ensure validity of nodes and edges, and careful cost-based parent selection with children management maintains tree consistency and path quality. The planner terminates early upon finding a valid connecting path, outputting an optimized, smooth, and low-cost route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased random sampling. Each iteration extends one tree by steering towards a sampled point with step size limits and rewiring neighbors within a radius to minimize path cost. Then, it attempts an incremental connection from the other tree to the newly added node with rewiring to further optimize cost and connect paths. Collision checks ensure nodes and edges are valid, preventing invalid expansions. This bidirectional, rewiring-based approach accelerates convergence, improves path quality and smoothness, and reduces planning time by rapidly discovering a valid optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost of descendants\n        for child in self.children:\n            dist = self._distance(child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def is_collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    prev_parent = neighbor.parent\n                    if prev_parent:\n                        if (prev_parent, neighbor) in edges:\n                            edges.remove((prev_parent, neighbor))\n                        prev_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample):\n            # Find nearest node\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, connect_node):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, connect_node.position))\n            dist = math.dist(nearest_node.position, connect_node.position)\n            if dist > self.step_size:\n                return None\n\n            if not is_collision_free_node(connect_node.position):\n                return None\n            if not is_collision_free_edge(nearest_node.position, connect_node.position):\n                return None\n\n            neighbors = near_nodes(tree, connect_node.position)\n\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, connect_node.position)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, connect_node.position):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(connect_node.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        success_state = False\n        final_path = []\n\n        # Alternate tree starts with start tree\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                final_path = path_a + path_b[1:]  # avoid duplicate connection node\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -12.01814,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 316.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027533936500549316,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 160.569386712611,
                    "smoothness_avg": 0.02450451608453697,
                    "success_improvement": 0.0,
                    "time_improvement": -10.476158588791257,
                    "length_improvement": 11.989374758062796,
                    "smoothness_improvement": 283.54888913137535,
                    "objective_score": 0.672771820632059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052264285087585446,
                    "num_nodes_avg": 325.9,
                    "path_length_avg": 240.06426952247952,
                    "smoothness_avg": 0.017266584034611274,
                    "success_improvement": 0.0,
                    "time_improvement": 67.66187370339429,
                    "length_improvement": 19.8596369665261,
                    "smoothness_improvement": 344.28164382833637,
                    "objective_score": 25.99189772346519
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042936849594116214,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.98176033662389,
                    "smoothness_avg": 0.03298287097098217,
                    "success_improvement": 0.0,
                    "time_improvement": 13.759280001647332,
                    "length_improvement": 18.321370546532442,
                    "smoothness_improvement": 319.53968420860195,
                    "objective_score": 9.389756530843698
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified yet effective bidirectional RRT* inspired planner using dual trees growing simultaneously from start and goal with goal bias sampling and rewiring. The Node class supports parent updates and child management to maintain tree consistency. Goal bias accelerates convergence, rewiring improves path quality by locally optimizing connections, and collision checking ensures safe expansions. The planner alternates tree expansions, attempts incremental connection with rewiring, and merges paths upon successful connection, balancing exploration and exploitation for efficient, robust pathfinding.",
          "planning_mechanism": "The planner initializes two trees from start and goal points. At each iteration, it samples a point biased towards the goal, extends one tree towards the sample with rewiring to optimize costs, then incrementally attempts to connect the other tree back with rewiring. Collision and edge checks guarantee validity. Upon connection, paths are concatenated to produce the final solution. This alternation and rewiring enable fast convergence to high-quality, smooth paths with reduced computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For collision/status checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n\n        # Find optimal parent among neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor == nearest:\n                continue\n            candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = candidate_cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors through new_node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        current = nearest\n\n        while True:\n            new_pos = self._steer(current.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = current.cost + math.dist(current.position, new_pos)\n            best_parent = current\n            for neighbor in neighbors:\n                if neighbor == current:\n                    continue\n                candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.84193,
          "time_improvement": 18.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01887509822845459,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 151.17482827913645,
                    "smoothness_avg": 0.02102342809722014,
                    "success_improvement": 0.0,
                    "time_improvement": 24.26624702849299,
                    "length_improvement": 17.138681101754965,
                    "smoothness_improvement": 229.06230282631154,
                    "objective_score": 11.85292184303045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07972452640533448,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 235.8839930063653,
                    "smoothness_avg": 0.01930007836028916,
                    "success_improvement": 0.0,
                    "time_improvement": 50.67105960576548,
                    "length_improvement": 21.25513359019308,
                    "smoothness_improvement": 396.60491749478894,
                    "objective_score": 21.435369187242205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06023519039154053,
                    "num_nodes_avg": 310.7,
                    "path_length_avg": 122.75329360888414,
                    "smoothness_avg": 0.03676825833269663,
                    "success_improvement": 0.0,
                    "time_improvement": -20.985266448523078,
                    "length_improvement": 18.4731072686807,
                    "smoothness_improvement": 367.68953204137927,
                    "objective_score": -0.7625108206138871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm is a bidirectional RRT* inspired planner with enhanced efficiency through goal-biased random sampling, dynamic local rewiring during tree expansions, and incremental connection attempts between start and goal trees. It incorporates efficient nearest neighbor querying, adaptive steering with step size limits, and rigorous collision checking for node positions and edges. The rewiring optimizes cost and path quality while alternating tree expansions accelerates convergence. This leads to faster planning times, improved path smoothness, and higher success rates.",
          "planning_mechanism": "The planner grows two trees simultaneously, sampling mostly towards the goal to improve search focus. On each iteration, one tree is extended toward a sampled point with rewiring of nearby nodes to minimize cost. Then it attempts connecting the other tree to the newly added node via rewiring to form a continuous path. Collision checks ensure validity at every step. By alternating expansions and rewiring, the method quickly converges to a collision-free, optimized path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Efficient nearest search: linear for simplicity, can be optimized with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Re-assign parent\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, connect_to_node):\n            nearest_node = nearest(tree, connect_to_node.position)\n            dist = math.dist(nearest_node.position, connect_to_node.position)\n            if dist > self.step_size:\n                return None\n            if self._is_in_obstacle(connect_to_node.position, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, connect_to_node.position, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, connect_to_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, connect_to_node.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, connect_to_node.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(connect_to_node.position, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Alternate tree expansion each iteration to balance growth\n        start_tree = tree_start\n        goal_tree = tree_goal\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = try_extend(start_tree, sample)\n            if new_node_start is None:\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            new_node_goal = try_connect(goal_tree, new_node_start)\n            if new_node_goal:\n                # Paths connecting start_tree root to new_node_start, and goal_tree root to new_node_goal\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path_goal.reverse()\n                extracted_path = path_start + path_goal[1:]  # Avoid duplicating connecting node\n                success_state = True\n                break\n\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -10.74705,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 218.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021436524391174317,
                    "num_nodes_avg": 147.8,
                    "path_length_avg": 161.4200586584748,
                    "smoothness_avg": 0.018596289666266766,
                    "success_improvement": 0.0,
                    "time_improvement": 13.988874486413575,
                    "length_improvement": 11.523107984775253,
                    "smoothness_improvement": 191.07231576642934,
                    "objective_score": 7.45664552171127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06319136619567871,
                    "num_nodes_avg": 366.1,
                    "path_length_avg": 251.15246650705654,
                    "smoothness_avg": 0.0131187349704594,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90082591838002,
                    "length_improvement": 16.15807765702018,
                    "smoothness_improvement": 237.55449983278646,
                    "objective_score": 22.689635806081974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05267148017883301,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 130.14155852635278,
                    "smoothness_avg": 0.025465211964407646,
                    "success_improvement": 0.0,
                    "time_improvement": -5.793192023664093,
                    "length_improvement": 13.566173501866952,
                    "smoothness_improvement": 223.915616540841,
                    "objective_score": 2.094855175978368
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighbor radius, incremental connection attempts, goal bias sampling, rewiring for path cost optimization, and path smoothing. It enforces collision-free node and edge checks, bounds clamping, and stops planning once a time limit is reached to ensure practical execution time.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansion with goal-biased sampling. It extends one tree towards samples, rewires neighbors to minimize path costs, then incrementally connects the other tree to the new node with rewiring. When connected, paths are merged and smoothed. Execution halts if time exceeds 30 seconds, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update costs of descendants for consistency\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.time()\n\n        # Utility functions\n        def _random():\n            import random\n            return random.random()\n\n        def sample_free(goal_bias_for_start=True):\n            # Goal biasing for alternating trees\n            if _random() < self.goal_sample_rate:\n                return goal_position if goal_bias_for_start else start_position\n            while True:\n                sample = tuple(_random() * bounds[d] for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def try_extend_and_rewire(tree, point):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improvement possible\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                if time.time() - start_time > self.time_limit_sec:\n                    return None\n                curr_node = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) < 3:\n                    break\n                i = int(_random() * (len(path) - 2))\n                j = i + 2 + int(_random() * (len(path) - i - 2))\n                if j >= len(path):\n                    j = len(path) - 1\n                if j <= i + 1:\n                    attempts += 1\n                    continue\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    del path[i + 1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break  # Time limit exceeded\n\n            sample = sample_free(goal_bias_for_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge and smooth final path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # avoid duplicate node\n                extracted_path = path_smoothing(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.42336,
          "time_improvement": 2.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1407.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04564192295074463,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 164.0663458293772,
                    "smoothness_avg": 0.037275524225553885,
                    "success_improvement": 0.0,
                    "time_improvement": -92.49927348747131,
                    "length_improvement": 10.072636053299995,
                    "smoothness_improvement": 483.4428992263453,
                    "objective_score": -23.318040339449666
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06323657035827637,
                    "num_nodes_avg": 276.4,
                    "path_length_avg": 241.39358297851035,
                    "smoothness_avg": 0.09835034963146143,
                    "success_improvement": 0.0,
                    "time_improvement": 73.63539600771674,
                    "length_improvement": 19.415873872736682,
                    "smoothness_improvement": 2430.6253349110125,
                    "objective_score": 38.12692025141742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08017446994781494,
                    "num_nodes_avg": 365.3,
                    "path_length_avg": 128.70032423974,
                    "smoothness_avg": 0.11066732728565867,
                    "success_improvement": 0.0,
                    "time_improvement": 23.393763084696577,
                    "length_improvement": 14.523372690833355,
                    "smoothness_improvement": 1307.6802344611865,
                    "objective_score": 16.461204635881575
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner integrating adaptive informed sampling with goal bias, rewiring for path cost optimization, and incremental connection of trees. It balances exploration and exploitation by focusing samples within an ellipsoidal informed region when a solution is found, uses fixed-radius rewiring to improve solution quality dynamically, and performs collision-aware incremental connections to swiftly merge two trees. Post-processing smoothing via random shortcutting further refines the path for length and smoothness improvements.",
          "planning_mechanism": "The planner alternates growing start and goal trees with rewiring of neighbors to minimize path costs. It samples with goal bias and informed ellipsoidal sampling towards the goal to accelerate convergence. When trees approach, an incremental rewiring-enhanced connection is performed to join them. After a valid path is found, path smoothing is applied to reduce detours and shorten the path. The structure maintains robust parent-child relations and ensures strict collision checks for nodes and edges throughout the process.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float) -> None:\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 7000,\n        step_size: float = 4.0,\n        goal_sample_rate: float = 0.15,\n        neighbor_radius: float = 20.0,\n        smoothing_iters: int = 50,\n        collision_resolution: float = 0.5,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        # Trees and data structures\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Variables for informed sampling\n        c_best = math.inf\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2.0 for s, g in zip(start_position, goal_position))\n        # Rotation matrix from unit vector along x axis to vector from start to goal\n        def rotation_to_goal():\n            \"\"\"Calculate rotation matrix to align x-axis with vector from start to goal in dimension D.\"\"\"\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1 = a1 / np.linalg.norm(a1)\n            Id = np.eye(dimension)\n            if dimension == 2:\n                # 2D rotation matrix\n                angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            else:\n                # For 3D, use Householder transformation\n                e1 = np.zeros(dimension)\n                e1[0] = 1.0\n                v = a1 - e1\n                if np.linalg.norm(v) < 1e-10:\n                    return Id\n                v = v / np.linalg.norm(v)\n                H = Id - 2.0 * np.outer(v, v)\n                return H\n\n        rotation_matrix = rotation_to_goal()\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid defined by current best cost c_best\n            if c_best == math.inf:\n                return uniform_sample()\n            r1 = c_best/2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            while True:\n                # Sample unit ball in dimension\n                if dimension == 2:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    unit_ball = np.array([x, y])\n                else:\n                    # Sample 3D unit ball via rejection\n                    while True:\n                        px = random.uniform(-1,1)\n                        py = random.uniform(-1,1)\n                        pz = random.uniform(-1,1)\n                        if px*px+py*py+pz*pz <= 1:\n                            unit_ball = np.array([px, py, pz])\n                            break\n                L = np.diag([r1] + [r2]*(dimension-1))\n                sample_local = L @ unit_ball\n\n                # Rotate and translate sample\n                sample_world = rotation_matrix @ sample_local + np.array(x_center)\n\n                point = tuple(np.clip(sample_world, [0]*dimension, bounds))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def uniform_sample():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def sample():\n            # Goal bias applied along with informed sampling when c_best is finite\n            if c_best < math.inf:\n                p_goal = random.random()\n                if p_goal < self.goal_sample_rate:\n                    return goal_position\n                if random.random() < 0.5:\n                    return informed_sample()\n                return uniform_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                not collision_free_edge(nearest_node.position, new_pos)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent by cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(curr_node.position, new_pos)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_final_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate node position at connection\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n\n                p1 = new_path[i]\n                p2 = new_path[j]\n\n                if collision_free_edge(p1, p2):\n                    # Shortcut by removing intermediate points\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                extracted_path = extract_final_path(new_node_a, new_node_b)\n                # Update c_best and informed sampling parameters\n                c_best = sum(math.dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1))\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -8.07632,
          "time_improvement": -4.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1103.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03546233177185058,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 160.4244848049874,
                    "smoothness_avg": 0.035022633560391106,
                    "success_improvement": 0.0,
                    "time_improvement": -42.28776145674394,
                    "length_improvement": 12.068797789748949,
                    "smoothness_improvement": 448.1802680861655,
                    "objective_score": -8.031667538642562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08922274112701416,
                    "num_nodes_avg": 355.5,
                    "path_length_avg": 229.67382658668322,
                    "smoothness_avg": 0.06373306979660538,
                    "success_improvement": 0.0,
                    "time_improvement": 44.79411195887387,
                    "length_improvement": 23.3282658908123,
                    "smoothness_improvement": 1539.897790941334,
                    "objective_score": 25.803375720531292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05740001201629639,
                    "num_nodes_avg": 222.1,
                    "path_length_avg": 117.09146594625352,
                    "smoothness_avg": 0.11160099977024449,
                    "success_improvement": 0.0,
                    "time_improvement": -15.29067481648307,
                    "length_improvement": 22.233423614938765,
                    "smoothness_improvement": 1319.556479548584,
                    "objective_score": 6.457264675785753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified, goal-biased bidirectional RRT* algorithm with incremental rewiring to optimize path cost and improve planning efficiency. Two trees grow from start and goal positions alternating expansions, where each new node connects through the lowest-cost parent within a fixed neighbor radius. Rewiring of nearby nodes reduces path costs dynamically. Collision checks on nodes and edges ensure feasibility and robustness. Once the two trees connect, their root paths are combined to form a smooth, optimized route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling points biased towards each opposite root to accelerate convergence. Each extension involves cost-based parent selection and rewiring of neighbors to refine path quality. After every extension, an incremental connection attempt with rewiring is made to join trees earlier and improve path smoothness. Collision and boundary checks maintain reliability and avoid invalid expansions, resulting in improved success rates and reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free(tree_from, tree_to_root):\n            if random.random() < self.goal_sample_rate:\n                # bias sample towards opposing tree root\n                return tree_to_root.position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample_point = sample_free(tree_a[0], tree_b[0])\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.54897,
          "time_improvement": 10.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 237.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024068188667297364,
                    "num_nodes_avg": 118.1,
                    "path_length_avg": 162.16088273051918,
                    "smoothness_avg": 0.018111696645408973,
                    "success_improvement": 0.0,
                    "time_improvement": 3.4296811100641387,
                    "length_improvement": 11.117050571779089,
                    "smoothness_improvement": 183.48738267941727,
                    "objective_score": 4.169751360772146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07468876838684083,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 243.3674034244215,
                    "smoothness_avg": 0.013951704330297302,
                    "success_improvement": 0.0,
                    "time_improvement": 53.78689632922378,
                    "length_improvement": 18.756955794620104,
                    "smoothness_improvement": 258.98740142499486,
                    "objective_score": 21.18239706481613
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06368763446807861,
                    "num_nodes_avg": 330.2,
                    "path_length_avg": 117.95792484222511,
                    "smoothness_avg": 0.02891657606089635,
                    "success_improvement": 0.0,
                    "time_improvement": -27.91966582177128,
                    "length_improvement": 21.657962872573307,
                    "smoothness_improvement": 267.81671309497943,
                    "objective_score": -2.7052236065418245
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal-biased sampling and dynamic rewiring to efficiently find optimized, collision-free paths in 2D or 3D spaces. It grows two trees from start and goal simultaneously, attempts incremental connections between them, rewires neighbors to improve path cost locally, and applies path smoothing upon success. The search respects map bounds and obstacle constraints, enforcing robust collision checks for nodes and edges. A hard 30-second time limit ensures planning terminates timely, returning the best path found so far.",
          "planning_mechanism": "The planner alternately extends start and goal trees towards sampled points, biased towards the opposite tree's root, using fixed incremental steps. It dynamically adjusts neighbor radius to find candidate nodes for rewiring that reduce path cost. After extending a tree, it incrementally tries connecting the other tree towards the new node with rewiring for lower-cost connections. Collision checks verify node placement and edges before accepting expansions. Once both trees connect, paths from each root to the connecting nodes merge and smooth to yield a refined final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(towards_goal_root):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if towards_goal_root else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-6 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point, nodes: List[Node], edges: List[Tuple[Node, Node]]):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, new_node.position)\n\n            while True:\n                new_pos = steer(curr_node.position, new_node.position)\n                if (not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos)):\n                    return None\n\n                n_radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, new_pos, n_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                connecting_node = Node(new_pos)\n                best_parent.add_child(connecting_node)\n                connecting_node.cost = min_cost\n                other_tree.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((best_parent, connecting_node))\n\n                rewire(other_tree, connecting_node, neighbors)\n\n                if dist(connecting_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connecting_node.position, new_node.position):\n                        return connecting_node\n                curr_node = connecting_node\n\n        def smooth_path(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return collision_free_edge(p1, p2)\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # Time limit exceeded - return best found path so far or empty\n                break\n\n            sample = goal_pos if (random.random() < self.goal_sample_rate) else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            n_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + dist(nbr.position, new_pos)\n                if c + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                full_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(full_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Alternate expansion\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.18931,
          "time_improvement": 43.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1321.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02274925708770752,
                    "num_nodes_avg": 67.6,
                    "path_length_avg": 158.81110092018804,
                    "smoothness_avg": 0.029083964568429703,
                    "success_improvement": 0.0,
                    "time_improvement": 4.052783523399731,
                    "length_improvement": 12.953119062711158,
                    "smoothness_improvement": 355.22720233584545,
                    "objective_score": 5.582594881241379
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.05949478149414063,
                    "num_nodes_avg": 260.7,
                    "path_length_avg": 240.88951929148098,
                    "smoothness_avg": 0.08831224278064696,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 75.19542339482445,
                    "length_improvement": 19.58414484013586,
                    "smoothness_improvement": 2172.3376154834364,
                    "objective_score": -12.662855936108306
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05254848003387451,
                    "num_nodes_avg": 237.1,
                    "path_length_avg": 123.92381622280504,
                    "smoothness_avg": 0.12062919505308514,
                    "success_improvement": 0.0,
                    "time_improvement": 49.7902348012493,
                    "length_improvement": 17.695701882811633,
                    "smoothness_improvement": 1434.3944571542602,
                    "objective_score": 25.648183102708416
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation is a bidirectional RRT*-inspired planner with advanced rewiring and informed incremental connection to minimize path length efficiently. It uses goal bias sampling, adaptive neighbor radius, and robust collision/edge checks to ensure path validity. The planner alternates expansion between two trees growing from start and goal, rewires nodes locally for optimal path cost, and incrementally attempts connection with rewiring optimizations. A time check enforces a 30-second cap to ensure timely results. After successful connection, the path is extracted and smoothed by shortcutting unnecessary waypoints, enhancing path smoothness and reducing length.",
          "planning_mechanism": "The planner samples points with goal bias, extends the active tree toward samples, rewires neighbors by cost within an adaptive radius, then incrementally connects the other tree to the new node while also rewiring. This bidirectional growth reduces search space and improves convergence. Collision checks prevent invalid expansions. Upon connection, the combined path is extracted and smoothed by iterative shortcutting to minimize length and sharp turns, producing a high-quality feasible path efficiently within time constraints.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, \n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree  # alternate growing trees\n        start_time = time.time()\n        last_best_cost = math.inf\n        best_connection_nodes = None\n\n        for iter_count in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time exceeded: break and return best path so far if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if (math.isclose(self.goal_sample_rate, 0.0) == False) and (math.isclose(self.goal_sample_rate, 1.0) == False):\n                if math.isclose(self.goal_sample_rate, 0.0):\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_position if tree_a is start_tree else start_position\n                    else:\n                        sample = self._sample_free(bounds, obstacles, is_3d)\n            else:\n                # goal_sample_rate=0 or 1 handled simply\n                sample = goal_position if tree_a is start_tree else start_position if self.goal_sample_rate==1 else self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < last_best_cost:\n                    last_best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Extract path now to allow early return\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int) -> float:\n        # RRT* theory: radius ~ gamma*(log(n)/n)^{1/d}\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        d = 2  # default dimension, adjusted in usage\n        # Let's keep dimension dynamic based on start node position length\n        # but fallback safely to 2D dimensional radius\n        return max(self.neighbor_radius_min, min(self.neighbor_radius_max, 50.0 * (math.log(n_nodes) / n_nodes)**(1/d)))\n\n    def _sample_free(self, bounds, obstacles, is_3d) -> Tuple[float, ...]:\n        import random\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          point: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes)\n\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if better cost available\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                      tree: List[Node],\n                                      target_pos: Tuple[float, ...],\n                                      obstacles,\n                                      is_3d: bool,\n                                      nodes: List[Node],\n                                      edges: List[Tuple[Node, Node]],\n                                      bounds: Tuple[int, ...]) -> Optional[Node]:\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n            if not self._in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int = 100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        import random\n        path = path[:]\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut possible: remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
          "objective": -6.11822,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1384.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02766132354736328,
                    "num_nodes_avg": 77.7,
                    "path_length_avg": 165.4971817884253,
                    "smoothness_avg": 0.04086364809249811,
                    "success_improvement": 0.0,
                    "time_improvement": -16.664337133991037,
                    "length_improvement": 9.288372191099048,
                    "smoothness_improvement": 539.6048294797105,
                    "objective_score": -0.44360255457894837
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04680578708648682,
                    "num_nodes_avg": 233.4,
                    "path_length_avg": 228.80053159602903,
                    "smoothness_avg": 0.09368330659549666,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 80.48572156758588,
                    "length_improvement": 23.619796895095245,
                    "smoothness_improvement": 2310.5389560604144,
                    "objective_score": -9.577629370403105
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04047691822052002,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 124.4211581054195,
                    "smoothness_avg": 0.11014912999012824,
                    "success_improvement": 0.0,
                    "time_improvement": 61.324541480339064,
                    "length_improvement": 17.365391085254622,
                    "smoothness_improvement": 1301.088803111385,
                    "objective_score": 28.37588467670957
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with goal-biased informed sampling, dynamic rewiring, and incremental tree connection. It enforces rigorous collision checks on nodes and edges, manages parent-child relationships for efficient rewiring, and limits execution time to ensure timely response while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal toward randomly sampled points biased by a goal-oriented heuristic within map bounds and obstacles. For each new sampled point, it selects the best parent node minimizing path cost in a neighborhood and rewires neighbors if the new path is cheaper. The planner tries to incrementally connect the two trees with rewiring to form a full path. It terminates upon success or after 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]: spatial coordinate (2D or 3D)\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # List of child nodes\n        self.valid = True             # Node validity flag (e.g., collision free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, neighbor_radius: float=20.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def valid_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_free(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if valid_node(node.position) and edge_free(nearest_node.position, node.position):\n                    return nearest_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                # Time limit reached; return best found path so far.\n                break\n\n            sample = sample_free()\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not valid_node(new_pos):\n                    continue\n                if not edge_free(nearest_node.position, new_pos):\n                    continue\n\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_via_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_via_neighbor < min_cost and edge_free(neighbor.position, new_pos):\n                        min_cost = cost_via_neighbor\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost and edge_free(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = potential_cost\n                        edges.append((new_node, neighbor))\n\n                connect_node = try_connect(tree_b, new_node)\n                if connect_node:\n                    conn_neighbors = near_nodes(tree_b, new_node.position)\n                    min_conn_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_conn_parent = connect_node\n                    for neighbor in conn_neighbors:\n                        cost_try = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if cost_try < min_conn_cost and edge_free(neighbor.position, new_node.position):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                    new_node_other = Node(new_node.position)\n                    best_conn_parent.add_child(new_node_other)\n                    new_node_other.cost = min_conn_cost\n                    tree_b.append(new_node_other)\n                    nodes.append(new_node_other)\n                    edges.append((best_conn_parent, new_node_other))\n\n                    for neighbor in conn_neighbors:\n                        if neighbor is best_conn_parent:\n                            continue\n                        cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                        if cost_via_new < neighbor.cost and edge_free(new_node_other.position, neighbor.position):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_other.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    total_cost = new_node.cost + new_node_other.cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success = True\n\n                    # Stop immediately on first successful connection\n                    break\n\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -5.84492,
          "time_improvement": 1.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 428.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04308300018310547,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 163.1762654561707,
                    "smoothness_avg": 0.027824464800794584,
                    "success_improvement": 0.0,
                    "time_improvement": -81.70676647122058,
                    "length_improvement": 10.560503210080563,
                    "smoothness_improvement": 335.5132959248345,
                    "objective_score": -20.722362819725888
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07495694160461426,
                    "num_nodes_avg": 349.9,
                    "path_length_avg": 233.93850869422153,
                    "smoothness_avg": 0.02168014879726888,
                    "success_improvement": 0.0,
                    "time_improvement": 68.7489364037006,
                    "length_improvement": 21.90459225124772,
                    "smoothness_improvement": 457.84584413372045,
                    "objective_score": 27.294828592028328
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08740341663360596,
                    "num_nodes_avg": 319.6,
                    "path_length_avg": 123.78660059659566,
                    "smoothness_avg": 0.046524904337205866,
                    "success_improvement": 0.0,
                    "time_improvement": 16.486546824704362,
                    "length_improvement": 17.786833968233932,
                    "smoothness_improvement": 491.79334905804063,
                    "objective_score": 10.962297586348297
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT*-style path planner that grows two trees from start and goal positions simultaneously, employing goal-biased sampling, incremental tree expansion with cost-based rewiring, and frequent incremental connection attempts between the two trees. It ensures collision-free nodes and edges while dynamically optimizing path cost through rewiring in both trees. The algorithm promotes efficiency, robustness, and quality by balancing exploration and exploitation with structured incremental connections and rewiring to produce smooth, shorter paths.",
          "planning_mechanism": "The planner alternates growth between two trees using goal-biased random samples, extends and rewires one tree towards samples, then incrementally connects and rewires the opposite tree towards the newly added node. This frequent attempt to link the trees combined with rewiring optimizes path cost on the fly. Collision checking for nodes and edges ensures validity. Upon successful connection, paths are merged to output a smooth and optimized final route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update costs recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(child.position))\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._within_bounds(pos, bounds)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            \n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge paths from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.40105,
          "time_improvement": 0.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 291.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021263980865478517,
                    "num_nodes_avg": 90.2,
                    "path_length_avg": 155.46314810612068,
                    "smoothness_avg": 0.02029841917168108,
                    "success_improvement": 0.0,
                    "time_improvement": 14.681181810789734,
                    "length_improvement": 14.78818505180875,
                    "smoothness_improvement": 217.71433875954466,
                    "objective_score": 8.450563247396394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07615876197814941,
                    "num_nodes_avg": 383.7,
                    "path_length_avg": 238.22231704511987,
                    "smoothness_avg": 0.015554505787950446,
                    "success_improvement": 0.0,
                    "time_improvement": 52.87734904791542,
                    "length_improvement": 20.474533721131174,
                    "smoothness_improvement": 300.2286373816369,
                    "objective_score": 21.459254645509045
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08309917449951172,
                    "num_nodes_avg": 392.6,
                    "path_length_avg": 115.95748746207536,
                    "smoothness_avg": 0.035670171688152404,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90867420064964,
                    "length_improvement": 22.986558129877153,
                    "smoothness_improvement": 353.72195097510166,
                    "objective_score": -13.706680879343953
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* planner by integrating informed ellipsoidal goal-biased sampling to focus exploration on promising regions, dynamically adjusting neighbor radius based on the node count and dimension for efficient rewiring, and incremental rewiring to continuously improve path quality. A balance of exploration and exploitation is achieved by alternating tree growth, ensuring collision-free node and edge connections. The planner uses numpy for efficient linear algebra operations in sampling, employs adaptive step sizing, and terminates early upon finding a feasible low-cost path, thereby reducing planning time and improving path smoothness and quality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately, samples points biased towards the dynamically defined ellipsoidal informed subset around the current best path cost, extends trees towards sampled points with constrained steps, performs collision checks, rewires neighbors within an adaptive radius, attempts connection between trees at each iteration, and returns an optimized smooth path on success or after reaching iteration limits.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal bias\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of 2D or 3D boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        # Current best path and its cost, initialize with None and infinity\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        # Adaptive neighbor radius: \u03b3 * (log(n)/n)^(1/d), \u03b3 ~ 30 (tuned)\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        # Ellipsoidal informed sampling between start and goal constrained by current best cost\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):  # No solution found yet: uniform random sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoid parameters\n            c_min = dist(start, goal)\n            if best_cost < c_min:\n                # Numerics: clamp to c_min to avoid pathological ellipsoid\n                c_cost = c_min\n            else:\n                c_cost = best_cost\n\n            # Center of ellipsoid\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n\n            # Rotation matrix aligning x-axis to start-goal vector\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)  # start==goal rare case\n\n            e1 = a1 / norm_a1  # Unit vector from start to goal\n\n            # Construct basis via QR decomposition for dimension d\n            I = np.eye(dim)\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            # Ellipsoid radii\n            r1 = c_cost / 2.0\n            if c_cost * c_cost - c_min * c_min <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_cost * c_cost - c_min * c_min) / 2.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Sample uniformly from unit ball in dim-dimensions\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 0:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n\n            # Scale and transform sample to ellipsoid\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            # Final collision check for sample is omitted here (usually acceptable)\n            return sample_point\n\n        # Rewiring logic\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n                    # Update edges list: remove old edge\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        # Extension + rewiring for one tree towards a sampled point\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            # Choose best parent with min cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Attempt to connect two trees via the newly added node in tree_a by extending tree_b towards it incrementally,\n        # rewiring and choosing lower cost parents until connection or failure\n        def connect_and_rewire(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                # Direct check\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir == 0:\n                return None\n\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            # Choose best parent among neighbors\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_to, new_node, neighbors)\n\n            # Recursively attempt to connect further or reach the target\n            if dist(new_pos, current_pos) <= self.step_size:\n                # Final connection attempt\n                if collision_free_edge(new_pos, current_pos):\n                    final_connect = Node(current_pos)\n                    final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                    tree_to.append(final_connect)\n                    nodes.append(final_connect)\n                    edges.append((new_node, final_connect))\n                    rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                    return final_connect\n                return None\n\n            # Continue extending towards current_pos if possible\n            return connect_and_rewire(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    # Reconstruct full path from start to goal\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n\n            grow_start = not grow_start\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.28427,
          "time_improvement": 13.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 128.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028359365463256837,
                    "num_nodes_avg": 110.4,
                    "path_length_avg": 171.9092710773572,
                    "smoothness_avg": 0.017696900898962236,
                    "success_improvement": 0.0,
                    "time_improvement": -13.788079533551127,
                    "length_improvement": 5.773804445778623,
                    "smoothness_improvement": 176.99492850414552,
                    "objective_score": -2.0966883283888853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06134157180786133,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 289.6449868661758,
                    "smoothness_avg": 0.007427513234392058,
                    "success_improvement": 0.0,
                    "time_improvement": 62.04537203502058,
                    "length_improvement": 3.3081664153793446,
                    "smoothness_improvement": 91.11526534244898,
                    "objective_score": 19.730821220294285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05503737926483154,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 144.51516822016083,
                    "smoothness_avg": 0.016953867316359176,
                    "success_improvement": 0.0,
                    "time_improvement": -10.545213714792496,
                    "length_improvement": 4.019906340982156,
                    "smoothness_improvement": 115.65194085977592,
                    "objective_score": -1.7813231419424378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with incremental connect-and-rewire and informed ellipsoidal sampling to accelerate convergence, improve path quality, enhance rewiring efficiency, and maintain balanced tree growth. It enforces strict collision and boundary checks for nodes and edges, uses dynamic neighborhood radius for rewiring in both trees, and integrates best path tracking with a strict 30-second time budget.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling informed points within an ellipsoid defined by the current best path cost to concentrate search efforts. Each extension involves steering, collision checking, rewiring neighbors to optimize path costs, then incrementally connecting to the opposite tree with rewiring. When a connection is found, it extracts the combined path. If time expires, it returns the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        self.parent = new_parent\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time  # max planning time in seconds\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Ellipsoidal informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D uniform sampling inside unit sphere\n                    while True:\n                        unit_sample = np.random.uniform(-1,1,3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            neighbors = near_nodes(tree, Node(new_pos))\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    # Check if edge collision free before considering\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors via new node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            # Incrementally move from nearest node in tree_connect towards node_to_connect.position\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos, parent=last_node, cost=cost_to_next)\n                neighbors = near_nodes(tree_connect, candidate_node)\n                min_cost = cost_to_next\n                min_parent = last_node\n                # Choose best parent in neighborhood (rewiring)\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n                if min_parent != last_node:\n                    candidate_node.parent = min_parent\n                    candidate_node.cost = min_cost\n                    min_parent.add_child(candidate_node)\n                else:\n                    last_node.add_child(candidate_node)\n\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                # Check if we reached or close to target connection node\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n                last_node = candidate_node\n\n            return None\n\n        # Initialization of trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal  # Initialize alternating trees\n\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # Sampling with goal bias and informed sampling\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n                sample = None\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n\n                # Add edge for new_node\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                # Rewire edges after extension already handled in extend_and_rewire\n\n                # Attempt to connect the other tree incrementally with rewiring\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Extract combined path\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n\n                    # Calculate path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node to tree_other\n                    # already added in connect_trees by adding children relationship,\n                    # but edges list missing these newly formed edges; we add them now carefully\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return immediately on first successful path (can be adjusted to keep searching)\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            # Swap trees for next iteration expansion\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no connection found, attempt to connect any nodes from both trees for best partial path\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.08863,
          "time_improvement": 71.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011738967895507813,
                    "num_nodes_avg": 58.8,
                    "path_length_avg": 186.54654740845126,
                    "smoothness_avg": 0.010452942678314281,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 50.48975491640329,
                    "length_improvement": -2.2491186537801777,
                    "smoothness_improvement": 63.6112518439534,
                    "objective_score": -34.984840996615276
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033424091339111325,
                    "num_nodes_avg": 205.5,
                    "path_length_avg": 304.3219635036141,
                    "smoothness_avg": 0.0064799438269543454,
                    "success_improvement": 0.0,
                    "time_improvement": 86.06482092616773,
                    "length_improvement": -1.5914308395464922,
                    "smoothness_improvement": 66.73362198241959,
                    "objective_score": 25.834828219853115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02385706901550293,
                    "num_nodes_avg": 176.7,
                    "path_length_avg": 165.88087532861306,
                    "smoothness_avg": 0.012398411759637712,
                    "success_improvement": 0.0,
                    "time_improvement": 77.20471014905449,
                    "length_improvement": -10.170178994809635,
                    "smoothness_improvement": 57.706882427031125,
                    "objective_score": 21.415911657889577
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a bidirectional RRT* style planner with goal-biased sampling, incremental connection, and local rewiring to improve planning speed and path quality. It simultaneously grows two trees from start and goal positions, extends toward sampled points with bias toward the goal, and rewires paths locally to minimize costs while avoiding collisions in 2D or 3D space. The planner enforces node and edge collision checks, alternates tree expansions for balanced growth, and enforces a strict 30-second planning time limit, returning the best path found within this budget.",
          "planning_mechanism": "The planner samples nodes using goal biasing and extends trees alternately toward samples by a fixed step size within bounds. It locally rewires nearby nodes to reduce cost after each extension. On every iteration, the planner attempts to connect the two trees and, if successful, extracts and returns a smooth, optimized path. Collision checks ensure all nodes and edges remain valid. Time budget enforcement guarantees termination with the best known solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        self.parent = new_parent\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time = max_time  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            else:\n                ratio = self.step_size / d\n                return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def near_nodes(nodes, position):\n            radius = self.neighbor_radius\n            return [node for node in nodes if dist(node.position, position) <= radius]\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            if not within_bounds(to_pos):\n                return False\n            return True\n\n        # Attempt to extend tree towards point with rewiring\n        def extend_and_rewire(tree_nodes, point):\n            nearest_node = nearest(tree_nodes, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_nodes, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_nodes.append(new_node)\n\n            # Rewire neighbors if beneficial\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Update parent\n                    neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        # Try connecting one tree to a node added in another tree, with rewiring on connect side\n        def connect_and_rewire(connect_tree, node_to_connect):\n            nearest_node = nearest(connect_tree, node_to_connect.position)\n            if dist(nearest_node.position, node_to_connect.position) > self.step_size:\n                return None\n            if not collision_free(nearest_node.position, node_to_connect.position):\n                return None\n\n            neighbors = near_nodes(connect_tree, node_to_connect.position)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, node_to_connect.position)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, node_to_connect.position)\n                if cost < min_cost and collision_free(neighbor.position, node_to_connect.position):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(node_to_connect.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            connect_tree.append(new_node)\n\n            # Rewire neighbors in connect_tree\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        start_time = time.time()\n\n        # Initialize trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        # Alternate trees to grow for balanced bidirectional expansion\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time:\n                break\n\n            sample_point = sample_free()\n\n            # Extend tree_a towards sampled point\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Connected successful, extract path\n\n                # Build edges list from start tree\n                edges.clear()\n                for n in nodes:\n                    for c in n.children:\n                        edges.append((n, c))\n\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n\n                # Combine paths: start path + reversed goal path except duplicate connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                break\n\n            nodes = tree_start + tree_goal\n\n            # Swap trees for next iteration expansion\n            tree_a, tree_b = tree_b, tree_a\n\n        # On timeout or no success, try to find best path that connects trees if any (optional)\n        if not success_state:\n            # Check all pairs for potential connection to produce best path found so far\n            best_cost = float('inf')\n            best_connection = None\n            for n_start in tree_start:\n                for n_goal in tree_goal:\n                    if dist(n_start.position, n_goal.position) <= self.step_size and collision_free(n_start.position, n_goal.position):\n                        total_cost = n_start.cost + dist(n_start.position, n_goal.position) + n_goal.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (n_start, n_goal)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n\n            # Build edges list\n            edges.clear()\n            for n in nodes:\n                for c in n.children:\n                    edges.append((n, c))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -3.67201,
          "time_improvement": 0.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 224.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03826737403869629,
                    "num_nodes_avg": 134.9,
                    "path_length_avg": 169.84564253571372,
                    "smoothness_avg": 0.019400254248835798,
                    "success_improvement": 0.0,
                    "time_improvement": -61.39639227453224,
                    "length_improvement": 6.904911949740244,
                    "smoothness_improvement": 203.6561073206688,
                    "objective_score": -16.019654755808276
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07387025356292724,
                    "num_nodes_avg": 326.5,
                    "path_length_avg": 251.31283072739484,
                    "smoothness_avg": 0.012996142372631875,
                    "success_improvement": 0.0,
                    "time_improvement": 69.20199860678825,
                    "length_improvement": 16.104543464443104,
                    "smoothness_improvement": 234.40010399080512,
                    "objective_score": 25.15350879487912
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11241765022277832,
                    "num_nodes_avg": 363.6,
                    "path_length_avg": 128.46614711876808,
                    "smoothness_avg": 0.02626908746048357,
                    "success_improvement": 0.0,
                    "time_improvement": -7.414407005537998,
                    "length_improvement": 14.678901984266721,
                    "smoothness_improvement": 234.14085351500984,
                    "objective_score": 1.8821625627669942
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an improved bidirectional RRT* variant that integrates goal-biased sampling, adaptive neighborhood rewiring, incremental connection attempts between two alternating trees, and post-processing path smoothing for enhanced path quality and smoothness. It enforces strict collision checks and bounded sampling, adapts rewiring neighborhood size dynamically, and limits execution to 30 seconds to ensure practical planning times. The Node class manages parent-child relationships robustly to maintain tree consistency and supports cost-based rewiring for path optimization.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions using goal-biased sampling toward the opposing root, steering incrementally with a fixed step size. Each newly added node rewires its neighbors within an adaptively calculated radius to minimize path cost. After extending one tree, the planner incrementally connects the other tree to the new node, with rewiring for optimization. Collision checks ensure feasible nodes and edges. Upon successful connection, the combined path is extracted and smoothed via random shortcutting within collision constraints. If planning time exceeds 30 seconds, the best found solution is returned immediately.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost for descendants\n        for c in self.children:\n            dist = self._distance(c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0, goal_sample_rate: float = 0.2,\n                 neighbor_factor: float = 20.0, smoothing_iters: int = 50, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math, time\n\n        start_time = time.time()\n        MAX_TIME = 30.0  # max 30 seconds planning time enforced\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def sample_free(tree_from):\n            # Goal bias biased toward opposite tree root for directed sampling\n            if random.random() < self.goal_sample_rate:\n                return tree_from[0].position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            # Adaptive neighbor radius based on sample count, clamped min 5.0 and max neighbor_factor\n            n = max(len(tree), 1)\n            r = min(max(self.neighbor_factor * (math.log(n) / n) ** (1.0 / dimension), 5.0), self.neighbor_factor)\n            return [node for node in tree if math.dist(node.position, position) <= r]\n\n        def collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree_from, sample):\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_from, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                if collision_free_edge(neighbor.position, new_pos):\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost:\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_from, new_node, neighbors)\n            return new_node\n\n        def try_incremental_connect(tree_to, target_node):\n            nearest = min(tree_to, key=lambda n: math.dist(n.position, target_node.position))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree_to, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    if collision_free_edge(neighbor.position, new_pos):\n                        cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_to, new_node, neighbors)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    # Last connection edge\n                    final_dist = math.dist(new_node.position, target_node.position)\n                    if final_dist <= self.step_size and \\\n                        collision_free_node(target_node.position) and \\\n                        collision_free_edge(new_node.position, target_node.position):\n                        # Connect final node\n                        final_node = Node(target_node.position)\n                        min_cost_final = new_node.cost + final_dist\n                        final_best_parent = new_node\n                        for neighbor in neighbors:\n                            if neighbor != new_node and collision_free_edge(neighbor.position, target_node.position):\n                                c = neighbor.cost + math.dist(neighbor.position, target_node.position)\n                                if c < min_cost_final:\n                                    min_cost_final = c\n                                    final_best_parent = neighbor\n                        final_best_parent.add_child(final_node)\n                        final_node.cost = min_cost_final\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((final_best_parent, final_node))\n\n                        rewire(tree_to, final_node, neighbors)\n                        return final_node\n\n                    return None\n                curr_node = new_node\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            path_b.reverse()\n            return path_a + path_b[1:]  # avoid duplicated node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not collision_free_edge(path[i], path[j]):\n                    continue\n                # shortcut if collision free\n                del path[i + 1:j]\n            return path\n\n        tree_a, tree_b = tree_start, tree_goal\n        success = False\n        final_path = []\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > MAX_TIME:\n                break\n            # Sample biased toward root of other tree for better directed growth\n            sample = sample_free(tree_b if tree_a is tree_start else tree_a)\n\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a)\n            if new_node_b:\n                final_path = extract_path(new_node_a, new_node_b)\n                final_path = path_smoothing(final_path)\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success but still have nodes, extract best partial path via closest node to goal\n        if not success:\n            # Check closest node to goal in start tree\n            closest_node = min(tree_start, key=lambda n: math.dist(n.position, goal_pos))\n            if closest_node:\n                final_path = closest_node.path_from_root()\n                final_path = path_smoothing(final_path)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.06862,
          "time_improvement": -27.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 998.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06343424320220947,
                    "num_nodes_avg": 172.6,
                    "path_length_avg": 165.01787273572657,
                    "smoothness_avg": 0.023010741858143564,
                    "success_improvement": 0.0,
                    "time_improvement": -167.5401241054343,
                    "length_improvement": 9.551089078021201,
                    "smoothness_improvement": 260.1680787056673,
                    "objective_score": -47.05097902249771
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10997071266174316,
                    "num_nodes_avg": 415.3,
                    "path_length_avg": 249.15139230771564,
                    "smoothness_avg": 0.06530571321983464,
                    "success_improvement": 0.0,
                    "time_improvement": 54.15098773305682,
                    "length_improvement": 16.826093822487405,
                    "smoothness_improvement": 1580.3630389502953,
                    "objective_score": 27.512330279166
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07000374794006348,
                    "num_nodes_avg": 327.3,
                    "path_length_avg": 123.25143869798683,
                    "smoothness_avg": 0.0985977029059624,
                    "success_improvement": 0.0,
                    "time_improvement": 33.11182845179706,
                    "length_improvement": 18.14226301961878,
                    "smoothness_improvement": 1154.1555032384506,
                    "objective_score": 19.332778655655126
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring, and incremental tree connection. It incorporates ellipsoidal heuristic sampling focused around the current best path cost to bias exploration towards promising regions. The planner maintains two growing trees from start and goal states, performs collision-aware rewiring in both trees for path cost optimization, and incrementally connects the two trees with rewiring-enhanced procedures to ensure robustness and shorter paths. Post solution, path smoothing via random shortcutting enhances path smoothness and quality.",
          "planning_mechanism": "The planner samples states within the ellipsoidal informed subset guided by current best path cost or uniformly if no path exists, growing two trees bidirectionally with rewiring to minimize costs. It extends one tree toward sampled points and incrementally connects the other tree towards the new node, rewiring neighbors to reduce path cost. Once connected, the path is extracted and smoothed by repeatedly attempting collision-free shortcuts, reducing overall path length and improving smoothness while maintaining collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_radius_factor: float = 50.0,\n                 collision_check_resolution: float = 0.5, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.collision_check_resolution = collision_check_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_uniform_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def rot_matrix_ellipsoid(start, goal):\n            \"\"\"Compute rotation matrix aligning unit vector to vector from start to goal in dim-space.\"\"\"\n            import numpy as np\n            unit_x = np.zeros(dim)\n            unit_x[0] = 1.0\n            vec = np.array(goal) - np.array(start)\n            length = np.linalg.norm(vec)\n            if length == 0:\n                return np.eye(dim)\n            vec = vec / length\n            if dim == 2:\n                # 2D rotation matrix to align x-axis to vec\n                c = vec[0]\n                s = vec[1]\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                # 3D: compute axis-angle rotation matrix aligning x-axis to vec\n                v = np.cross(unit_x, vec)\n                s = np.linalg.norm(v)\n                c = np.dot(unit_x, vec)\n                if s == 0:\n                    return np.eye(3) if c > 0 else -np.eye(3)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                return R\n            else:\n                return np.eye(dim)\n\n        def informed_sample(start, goal, c_max):\n            import numpy as np\n            if c_max == float('inf'):\n                return sample_uniform_free()\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                return sample_uniform_free()\n\n            # Sample in unit n-ball\n            while True:\n                a = np.random.normal(0, 1, dim)\n                norm_a = np.linalg.norm(a)\n                sample_ball = a / norm_a * (random.random() ** (1 / dim))\n                # Scale ellipsoid radii\n                r1 = c_max / 2.0\n                if dim == 2:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2])\n                elif dim == 3:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2, r2])\n                else:\n                    # fallback uniform if higher dims\n                    return sample_uniform_free()\n                # Rotate and translate sample\n                R = rot_matrix_ellipsoid(np.array(start), np.array(goal))\n                pt = np.dot(R, L @ sample_ball) + (np.array(start) + np.array(goal)) / 2.0\n                pt_tuple = tuple(pt.tolist())\n                if within_bounds(pt_tuple) and not self._is_in_obstacle(pt_tuple, obstacles, is_3d):\n                    return pt_tuple\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def can_connect(n1, n2):\n            if self._is_in_obstacle(n2.position, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, self.collision_check_resolution):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n\n            radius = self._calc_neighbor_radius(len(tree))\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent for minimal cost connection\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                        min_cost = tentative_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if new_node offers lower cost path\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.remove_child(nb)\n                            except ValueError:\n                                pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]):\n            nearest_node = nearest(tree, target_pos)\n            current = nearest_node\n            radius = self._calc_neighbor_radius(len(tree))\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nb in neighbors:\n                    tentative_cost = nb.cost + dist(nb.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                            min_cost = tentative_cost\n                            best_parent = nb\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if path costs improve\n                for nb in neighbors:\n                    if nb == best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost < nb.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                    nb.parent.remove_child(nb)\n                                except ValueError:\n                                    pass\n                            nb.update_parent(new_node, new_cost)\n                            edges.append((new_node, nb))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current = new_node\n\n        def try_connect_trees(node_in_a: Node, tree_b: List[Node]):\n            # Attempt incremental connect from tree_b to node_in_a.position\n            return incremental_connect_and_rewire(tree_b, node_in_a.position)\n\n        def path_smooth(path: List[Tuple[float, ...]]):\n            # Random shortcutting path smoothing\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_check_resolution):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        tree_a = start_tree\n        tree_b = goal_tree\n\n        for iter_count in range(self.max_iter):\n            # Informed sampling using current best cost or uniform\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = informed_sample(start_pos, goal_pos, best_cost)\n\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect_trees(new_node_a, tree_b)\n            if new_node_b:\n                # Successfully connected trees\n                cost_path = new_node_a.cost + new_node_b.cost + dist(new_node_a.position, new_node_b.position)\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    # Extract path: start root \u2192 new_node_a + reversed(goal root \u2192 new_node_b)\n                    path_from_start = new_node_a.path_from_root()\n                    path_from_goal = new_node_b.path_from_root()\n                    # Ensure no duplicate node at connection point\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n                    extracted_path = path_smooth(combined_path)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _calc_neighbor_radius(self, n):\n        # According to Karaman and Frazzoli (RRT*) scaling for neighbor radius\n        # r_n = min{max_radius, gamma * (log(n)/n)^(1/d)}\n        if n <= 1:\n            return self.neighbor_radius_factor\n        gamma_rrt_star = self.neighbor_radius_factor\n        radius = gamma_rrt_star * (math.log(n) / n) ** (1 / 2.0)  # 2D/3D same formula for simplicity\n        radius = max(radius, self.step_size)\n        radius = min(radius, gamma_rrt_star)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.6295,
          "time_improvement": 15.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1412.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043416929244995114,
                    "num_nodes_avg": 83.9,
                    "path_length_avg": 164.18372191414562,
                    "smoothness_avg": 0.03720324769360068,
                    "success_improvement": 0.0,
                    "time_improvement": -74.2044970799114,
                    "length_improvement": 10.008300361295342,
                    "smoothness_improvement": 482.3116145502763,
                    "objective_score": -17.84813097896297
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050745177268981936,
                    "num_nodes_avg": 229.8,
                    "path_length_avg": 238.21428623172022,
                    "smoothness_avg": 0.08991796263875351,
                    "success_improvement": 0.0,
                    "time_improvement": 68.60181003685484,
                    "length_improvement": 20.47721463779812,
                    "smoothness_improvement": 2213.653943985784,
                    "objective_score": 35.74425565854499
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.024538660049438478,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 118.18445541862111,
                    "smoothness_avg": 0.1289315433122978,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 50.71292536683033,
                    "length_improvement": 21.507512049957953,
                    "smoothness_improvement": 1539.9997141958427,
                    "objective_score": -22.784621408980087
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner with goal-biased sampling and adaptive neighborhood rewiring that balances exploration and exploitation for efficient, smooth, and high-quality paths in 2D or 3D environments. It maintains two trees grown simultaneously from start and goal, incrementally connecting and rewiring while ensuring collision-free expansions and edges. The planner enforces map bounds and ends early on success or if a time limit (30 seconds) is reached.",
          "planning_mechanism": "The planner alternates growing two trees with goal biased sampling towards the opposite root. Expansion toward sampled points is done with fixed step size respecting bounds and collision constraints. Rewiring uses an adaptive neighborhood radius to optimize path cost. After each extension, incremental attempts to connect trees with rewiring are performed. Once connected, the combined path is smoothed to reduce unnecessary waypoints. The algorithm monitors elapsed time to enforce a maximum execution time and returns the best path found within that limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For obstacle validity etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 35.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if (not self._is_in_obstacle(pt, obstacles, is_3d)) and in_bounds(pt):\n                    return pt\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def can_connect_nodes(n1, n2):\n            if not in_bounds(n2):\n                return False\n            if self._is_in_obstacle(n2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(n1, n2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_connect_trees(connect_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, connect_node.position)\n            while True:\n                new_pos = steer(curr_node.position, connect_node.position)\n                if not can_connect_nodes(curr_node.position, new_pos):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    c = nbr.cost + math.dist(nbr.position, new_node.position)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                # Check if within step_size distance to target node\n                if math.dist(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path, max_trials=120):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = path[:]\n            for _ in range(max_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                if can_connect(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        success_state = False\n        extracted_path = []\n\n        t_start = time.perf_counter()\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                # Timeout - return best path found so far\n                break\n\n            # Goal biased sampling towards opposite tree root to encourage connection\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n\n            # Attempt incremental connection from opposite tree\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n            if connect_node:\n                # Merge and smooth path\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                # Avoid duplicate connection node in combined path\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = path_smoothing(extracted_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and extracted_path == []:\n            # Try to extract best path available if any\n            # Find node in either tree closest to goal\n            min_dist = float('inf')\n            best_node = None\n            for node in nodes:\n                d = math.dist(node.position, goal_pos)\n                if d < min_dist and node.valid:\n                    min_dist = d\n                    best_node = node\n            if best_node:\n                extracted_path = best_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.70638,
          "time_improvement": 14.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03560779094696045,
                    "num_nodes_avg": 113.8,
                    "path_length_avg": 154.15931074442005,
                    "smoothness_avg": 0.03315088554298353,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -50.17934049756807,
                    "length_improvement": 15.502838970381996,
                    "smoothness_improvement": 418.8833470478616,
                    "objective_score": -59.858817619954706
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08931412696838378,
                    "num_nodes_avg": 401.2,
                    "path_length_avg": 234.9609367619882,
                    "smoothness_avg": 0.10208437391955136,
                    "success_improvement": 0.0,
                    "time_improvement": 62.76313571250217,
                    "length_improvement": 21.56327633326701,
                    "smoothness_improvement": 2526.7044693525504,
                    "objective_score": 35.77511832716681
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07490887641906738,
                    "num_nodes_avg": 337.5,
                    "path_length_avg": 123.98655932353795,
                    "smoothness_avg": 0.11645098015995772,
                    "success_improvement": 0.0,
                    "time_improvement": 28.42500689117861,
                    "length_improvement": 17.654030902810234,
                    "smoothness_improvement": 1381.2478721174225,
                    "objective_score": 18.96454760850274
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of unidirectional and bidirectional RRT* algorithms by growing two trees simultaneously from start and goal, utilizing goal-biased sampling to accelerate convergence. It uses adaptive neighbor radius for rewiring to optimize path cost dynamically. Incremental extension steps and rewiring in both trees improve path quality and smoothness. Node parent-child updates support effective rewiring, and robust collision checks prevent invalid expansions. Once a connection is made between trees, the combined path is smoothed via a post-processing step to reduce unnecessary turns and shorten path lengths, ensuring robust, efficient, and high-quality path planning in 2D or 3D environments.",
          "planning_mechanism": "The planner alternates tree expansion between start and goal trees with goal-biased sampling towards the other tree\u2019s root, extending nodes incrementally with fixed step size. Adaptive neighborhood radius is used to find neighbors for rewiring to minimize cost dynamically during tree growth. After each extension, an incremental connection attempt is made from the opposite tree towards the new node with rewiring. Upon successful connection, the two trees' paths are merged and smoothed before returning the final optimized path. Collision checks ensure all nodes and edges are obstacle-free, and bounds are respected throughout the sampling and extension process.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 10.0,\n                 max_neighbor_radius: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 25.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_connect_trees(connect_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, connect_node.position)\n            while True:\n                new_pos = steer(curr_node.position, connect_node.position)\n                if (not in_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    c = nbr.cost + math.dist(nbr.position, new_node.position)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, connect_node.position) <= self.step_size:\n                    # Check direct connection without obstacle\n                    if (not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = path[:]\n\n            for _ in range(max_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                if can_connect(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        success_state = False\n        final_node_a = None\n        final_node_b = None\n\n        for _ in range(self.max_iter):\n            # Sample with bias towards opposite tree's root to focus growth\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            # Extend tree_a towards sample with rewiring\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n\n            # Try connecting tree_b incrementally to new_node\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n            if connect_node:\n                # Merge paths from both trees at connection nodes\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                # Remove duplicate connection point at start of path_b\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = path_smoothing(extracted_path)\n                success_state = True\n                final_node_a = new_node\n                final_node_b = connect_node\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.30597,
          "time_improvement": -43.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1370.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05125737190246582,
                    "num_nodes_avg": 114.6,
                    "path_length_avg": 157.05829791223314,
                    "smoothness_avg": 0.028447812996236242,
                    "success_improvement": 0.0,
                    "time_improvement": -105.66320210074187,
                    "length_improvement": 13.913858166312298,
                    "smoothness_improvement": 345.27004880576834,
                    "objective_score": -27.18983875293126
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09705915451049804,
                    "num_nodes_avg": 435.7,
                    "path_length_avg": 233.61929174719415,
                    "smoothness_avg": 0.10187133667784667,
                    "success_improvement": 0.0,
                    "time_improvement": 39.94539116832186,
                    "length_improvement": 22.011156056315826,
                    "smoothness_improvement": 2521.2228676789655,
                    "objective_score": 28.99196290015455
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0812455415725708,
                    "num_nodes_avg": 400.2,
                    "path_length_avg": 120.27345826984924,
                    "smoothness_avg": 0.10552908652875204,
                    "success_improvement": 0.0,
                    "time_improvement": -63.18556363843585,
                    "length_improvement": 20.12009582379838,
                    "smoothness_improvement": 1242.3221912988151,
                    "objective_score": -8.720038970277002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased sampling, adaptive neighbor radius rewiring, incremental tree connection, and comprehensive obstacle checks in 2D/3D. It grows two trees from start and goal alternately, rewires locally for lower-cost paths, and applies path smoothing on success. It enforces map bounds and robust collision checks, ensuring valid expansions within a strict 30-second time budget, returning the best found solution.",
          "planning_mechanism": "The planner alternates growing two trees from the start and goal positions, sampling points biased toward the goal to focus exploration. It attempts incremental connections between the trees after each extension with rewiring to optimize path cost locally. Collision checks prevent invalid nodes and edges. A dynamically adjusted neighbor radius allows efficient rewiring. Upon connecting the trees, the planner extracts and smooths the path and forces termination when the time limit is reached, returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent                # Parent Node or None\n        self.cost = cost                   # Cost from root to this node\n        self.children = []                 # List of child nodes\n        self.valid = True                  # Validity for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 25.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> \"PlannerResult\":\n        import time\n        import math\n        import random\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(towards_goal_root):\n            # Goal bias towards goal root when growing start tree, and vice versa\n            bias_pos = goal_pos if towards_goal_root else start_pos\n            if random.random() < self.goal_sample_rate:\n                return bias_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-8 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point, all_nodes, edges):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree, all_nodes, edges):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(curr_node.position, new_node.position)\n                if (not collision_free_node(new_pos)) or (not collision_free_edge(curr_node.position, new_pos)):\n                    return None\n\n                n_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, n_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                connecting_node = Node(new_pos)\n                best_parent.add_child(connecting_node)\n                connecting_node.cost = min_cost\n                other_tree.append(connecting_node)\n                all_nodes.append(connecting_node)\n                edges.append((best_parent, connecting_node))\n\n                rewire(other_tree, connecting_node, neighbors)\n\n                if dist(connecting_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connecting_node.position, new_node.position):\n                        return connecting_node\n\n                curr_node = connecting_node\n\n        def smooth_path(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return collision_free_edge(p1, p2)\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free(towards_goal_root=(tree_a is start_tree))\n\n            new_node = extend(tree_a, sample, all_nodes, edges)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connecting_node = try_connect_trees(new_node, tree_b, all_nodes, edges)\n            if connecting_node is not None:\n                path_a = new_node.path_from_root()\n                path_b = connecting_node.path_from_root()\n\n                # Avoid duplicating connecting node position\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                full_path = path_a + path_b[::-1]\n\n                extracted_path = smooth_path(full_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # alternate expansions\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.89742,
          "time_improvement": 11.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1545.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04950911998748779,
                    "num_nodes_avg": 113.1,
                    "path_length_avg": 176.74975566060044,
                    "smoothness_avg": 0.03039674379771622,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -108.80955517322171,
                    "length_improvement": 3.1206581433163705,
                    "smoothness_improvement": 375.77504801990364,
                    "objective_score": -80.13985968320371
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0702526330947876,
                    "num_nodes_avg": 255.0,
                    "path_length_avg": 240.21012094519773,
                    "smoothness_avg": 0.10264086063231954,
                    "success_improvement": 0.0,
                    "time_improvement": 70.7102576805569,
                    "length_improvement": 19.81094756352233,
                    "smoothness_improvement": 2541.0232732932536,
                    "objective_score": 37.880383183337806
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02869412899017334,
                    "num_nodes_avg": 141.0,
                    "path_length_avg": 126.41866795529886,
                    "smoothness_avg": 0.14284006493974544,
                    "success_improvement": 0.0,
                    "time_improvement": 72.58292764604172,
                    "length_improvement": 16.038740154162355,
                    "smoothness_improvement": 1716.9150826767002,
                    "objective_score": 33.56720173802849
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines the strengths of bidirectional RRT* with goal-biased and informed sampling, adaptive rewiring via neighbor radius, efficient incremental connection and rewiring, and post-processing path smoothing. It incorporates collision and edge checking to ensure safety and leverages a single unified tree per iteration by alternating expansion between two trees for fast convergence and path quality improvement. It enforces time constraints to balance speed and solution optimality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately; for each iteration, it samples intelligently with goal bias and local informed sampling, extends one tree towards the sample using step-size limited steering, rewires nearby nodes to optimize cost, then incrementally attempts connection and rewiring from the other tree towards the newly added node. If a valid connection is made, the path is extracted and refined with shortcut smoothing within the execution time limit. The planner terminates either upon success or when the time limit expires, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.2, neighbor_radius_factor: float=20.0, smoothing_iter: int=50, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.smoothing_iter = smoothing_iter\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        success_state = False\n\n        start_time = time.time()\n\n        # Precompute maximum radius for neighbor searching (adaptive)\n        # A simple radius clamped to neighbor_radius_factor:\n        def neighbor_radius(n_nodes):\n            r = self.neighbor_radius_factor * (math.log(n_nodes + 1) / (n_nodes + 1))**(1.0/dim)\n            return min(r, self.neighbor_radius_factor)\n\n        # Alternate expansion trees: tree_a expands each iteration, tree_b tries to connect\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # Time exceeded - stop and return best found path so far\n                break\n\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a towards sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds, neighbor_radius)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Incrementally try to connect and rewire tree_b towards new_node_a.position\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds, neighbor_radius)\n            if new_node_b:\n                # Connection successful - extract path joining roots via these connecting nodes\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                candidate_path = path_a + path_b[::-1]\n\n                # Update best path and success flag\n                if (not best_path) or (self._path_length(candidate_path) < self._path_length(best_path)):\n                    best_path = candidate_path\n                success_state = True\n\n                # Attempt path smoothing within remaining time budget\n                time_left = self.time_limit_sec - (time.time() - start_time)\n                self._post_smooth_path(best_path, obstacles, is_3d, time_left)\n\n                # Can break early on success if desired or continue for better path until time out:\n                # Here return immediately to reduce planning time.\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Swap expansion trees each iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success, attempt to return best found path if any\n        if best_path:\n            time_left = max(0.0, self.time_limit_sec - (time.time() - start_time))\n            self._post_smooth_path(best_path, obstacles, is_3d, time_left)\n            return PlannerResult(True, best_path, nodes, edges)\n        # No path found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _path_length(self, path):\n        length = 0.0\n        for i in range(len(path)-1):\n            length += math.dist(path[i], path[i+1])\n        return length\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds, neighbor_radius_func):\n        dim = len(bounds)\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        # Clamp within bounds\n        new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n\n        radius = neighbor_radius_func(len(tree))\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                continue\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds, neighbor_radius_func):\n        dim = len(bounds)\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            # Clamp within bounds\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n\n            radius = neighbor_radius_func(len(tree))\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _post_smooth_path(self, path, obstacles, is_3d, time_budget_sec):\n        if len(path) < 3 or time_budget_sec <= 0:\n            return\n\n        start_time = time.time()\n        path_pts = path[:]\n\n        def check_segment(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        for _ in range(self.smoothing_iter):\n            if time.time() - start_time > time_budget_sec:\n                break\n\n            if len(path_pts) < 3:\n                break\n\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i+2, len(path_pts) - 1)\n\n            p_i = path_pts[i]\n            p_j = path_pts[j]\n\n            if check_segment(p_i, p_j):\n                # Shortcut is collision-free: remove intermediate points\n                del path_pts[i+1:j]\n\n        # Update original list in place\n        path.clear()\n        path.extend(path_pts)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.31977,
          "time_improvement": 18.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 836.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.034394049644470216,
                    "num_nodes_avg": 89.5,
                    "path_length_avg": 153.79127280230273,
                    "smoothness_avg": 0.02197335694220786,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -45.0602678593874,
                    "length_improvement": 15.704566398390895,
                    "smoothness_improvement": 243.93075205387262,
                    "objective_score": -59.15751331786868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0800093173980713,
                    "num_nodes_avg": 358.4,
                    "path_length_avg": 239.33035388936665,
                    "smoothness_avg": 0.04861846941764689,
                    "success_improvement": 0.0,
                    "time_improvement": 66.64249884296626,
                    "length_improvement": 20.104639129449392,
                    "smoothness_improvement": 1150.988236584119,
                    "objective_score": 29.76861866170035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06975092887878417,
                    "num_nodes_avg": 280.7,
                    "path_length_avg": 121.57578404337112,
                    "smoothness_avg": 0.09548067700690545,
                    "success_improvement": 0.0,
                    "time_improvement": 33.35339558554516,
                    "length_improvement": 19.255153055114366,
                    "smoothness_improvement": 1114.5071638773652,
                    "objective_score": 19.429585106073247
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines goal-biased informed sampling with bidirectional RRT* style growth and dynamic rewiring. It maintains two trees grown from start and goal positions respectively, alternating expansions and incremental connect-and-rewire steps to efficiently explore the space. The sampling is guided by an ellipsoidal informed region after the first solution, focusing search and improving convergence speed. The planner uses adaptive neighbor radius recalculated per iteration for rewiring to optimize path cost continuously. Path smoothing is performed at the end to enhance smoothness and reduce unnecessary waypoints. Robust collision and edge validity checks ensure feasible expansions within bounds.",
          "planning_mechanism": "The planner alternates expansions of start and goal trees by sampling informed points biased toward the current best path. Each expansion attempts to connect the opposite tree via incremental steps and performs rewiring on neighborhood nodes to optimize the tree costs. Once a path is found, it extracts and smooths the path before returning. The informed sampler shrinks the ellipsoidal sampling domain as better returns are found, focusing effort on promising regions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float,...] (2D/3D)\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Path cost from root\n        self.children = []\n        self.valid = True                     # Validity flag (collision-free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, neighbor_factor: float = 2.5,\n                 goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix from unit vector a1 to x-axis (for informed sampling)\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])\n                R = eye + vx + (vx @ vx) * ((1 - c)/(s_**2))\n                return R\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)/2 for s,g in zip(start_pos, goal_pos))\n        rotation = _rotation_matrix() if np else None\n\n        def informed_sample():\n            if np is None or c_best == float('inf'):\n                # fallback uniform sampling inside bounds\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            else:\n                r2 = 0.0\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D sampling inside unit ball\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Initialize trees and data\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        edges = []\n        path_found = False\n        best_goal_node = None\n\n        def nearest_node(tree, pos):\n            return min(tree, key=lambda n: dist(n.position, pos))\n\n        def get_near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def try_connect(tree_from, tree_to, new_node, radius):\n            # Incremental connect and rewire from new_node towards nearest in tree_to within radius\n            # Returns connected goal node if success else None\n            connected_goal_node = None\n            nearest_in_to = nearest_node(tree_to, new_node.position)\n            direction = tuple(nearest_in_to.position[d] - new_node.position[d] for d in range(dim))\n            dist_to_nearest = dist(new_node.position, nearest_in_to.position)\n            steps = max(1, int(dist_to_nearest / self.step_size))\n\n            last_node = new_node\n            for i in range(1, steps + 1):\n                interm_pos = tuple(new_node.position[d] + direction[d]* i/steps for d in range(dim))\n                if not within_bounds(interm_pos):\n                    return None\n                if self._is_in_obstacle(interm_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, interm_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, interm_pos)\n                interm_node = Node(interm_pos, parent=last_node, cost=new_cost)\n                last_node.add_child(interm_node)\n                tree_from.append(interm_node)\n                edges.append((last_node, interm_node))\n\n                # Rewire near nodes around interm_node\n                neighbor_radius = min(self.step_size,\n                                      self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n                near_nodes = get_near_nodes(tree_from, interm_node.position, neighbor_radius)\n                for near in near_nodes:\n                    if near == interm_node.parent:\n                        continue\n                    if self._is_edge_in_obstacle(interm_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        continue\n                    cost_through_interm = interm_node.cost + dist(interm_node.position, near.position)\n                    if cost_through_interm < near.cost:\n                        near.update_parent(interm_node, cost_through_interm)\n\n                last_node = interm_node\n\n            # Final connection to nearest_in_to node\n            if (self._is_edge_in_obstacle(last_node.position, nearest_in_to.position, obstacles, is_3d, self.collision_resolution)\n                    or self._is_in_obstacle(nearest_in_to.position, obstacles, is_3d)):\n                return None\n            cost_connect = last_node.cost + dist(last_node.position, nearest_in_to.position)\n            connect_node = Node(nearest_in_to.position, parent=last_node, cost=cost_connect)\n            last_node.add_child(connect_node)\n            tree_from.append(connect_node)\n            edges.append((last_node, connect_node))\n\n            # Rewire near nodes in tree_from around connect_node\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n            near_nodes = get_near_nodes(tree_from, connect_node.position, neighbor_radius)\n            for near in near_nodes:\n                if near == connect_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(connect_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_connect = connect_node.cost + dist(connect_node.position, near.position)\n                if cost_through_connect < near.cost:\n                    near.update_parent(connect_node, cost_through_connect)\n\n            return connect_node\n\n        # Main loop alternating expansions of start and goal trees\n        for it in range(self.max_iter):\n            # Alternate trees\n            if it % 2 == 0:\n                tree_from = start_tree\n                tree_to = goal_tree\n            else:\n                tree_from = goal_tree\n                tree_to = start_tree\n\n            # Sample point\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_from is start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            # Nearest node in tree_from\n            nearest = nearest_node(tree_from, sample)\n\n            # Steer towards sample\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Dynamic neighbor radius for rewiring\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n\n            # Find neighbors to possibly rewire\n            near_nodes = get_near_nodes(tree_from, new_node.position, neighbor_radius)\n\n            # Choose best parent among near nodes (including current)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in near_nodes:\n                if self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_near = near.cost + dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if shorter through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    try:\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                    except (ValueError, AttributeError):\n                        pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect tree_from's new_node to tree_to\n            connect_node = try_connect(tree_from, tree_to, new_node, neighbor_radius)\n            if connect_node is not None:\n                # Path found, extract full path\n                if tree_from is start_tree:\n                    path_start = connect_node.path_from_root()\n                    # Corresponding node in tree_to has same position as connect_node.parent or connect_node itself at connection point\n                    # Find corresponding node in tree_to for path merging\n                    counterpart = nearest_node(tree_to, connect_node.position)\n                    path_goal = counterpart.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + counterpart.cost\n                else:\n                    path_start = nearest_node(tree_to, connect_node.position).path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + nearest_node(tree_to, connect_node.position).cost\n\n                # Update best solution\n                if cost_path < c_best:\n                    c_best = cost_path\n                    best_goal_node = connect_node if tree_from is start_tree else nearest_node(tree_to, connect_node.position)\n                    extracted_path = full_path\n                    path_found = True\n                    center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                    # update rotation for informed sampling to bias future samples\n                    rotation = _rotation_matrix() if np else None\n\n                # Optional early stop to allow better rewiring in remaining iterations or break immediately\n                # Here break on first found path for planning efficiency\n                break\n\n        # If found path, apply simple path smoothing by shortcuts along path\n        def path_smoothing(path, iterations=30):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if path_found:\n            extracted_path = path_smoothing(extracted_path, iterations=40)\n\n        # Combine all nodes from both trees and edges\n        all_nodes = start_tree + [n for n in goal_tree if n not in start_tree]\n\n        return PlannerResult(\n            success=path_found,\n            path=extracted_path if path_found else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.56739,
          "time_improvement": -32.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 729.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015814971923828126,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 164.28036986617082,
                    "smoothness_avg": 0.023170487001020087,
                    "success_improvement": 0.0,
                    "time_improvement": 36.54458575876863,
                    "length_improvement": 9.955326087305531,
                    "smoothness_improvement": 262.66843708381487,
                    "objective_score": 14.26778313051077
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10339927673339844,
                    "num_nodes_avg": 621.6,
                    "path_length_avg": 246.6354463547729,
                    "smoothness_avg": 0.038038996749436046,
                    "success_improvement": 0.0,
                    "time_improvement": 36.02248907874998,
                    "length_improvement": 17.66598899906865,
                    "smoothness_improvement": 878.7707847448972,
                    "objective_score": 18.73379844716321
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13381729125976563,
                    "num_nodes_avg": 728.5,
                    "path_length_avg": 137.74339529427704,
                    "smoothness_avg": 0.09003650182892373,
                    "success_improvement": 0.0,
                    "time_improvement": -168.77844219043237,
                    "length_improvement": 8.51739548117924,
                    "smoothness_improvement": 1045.257657460649,
                    "objective_score": -43.70376527359062
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner employs bidirectional RRT* with adaptive rewiring and goal biasing strategies. It grows two trees from start and goal positions alternately, samples points with bias toward the goal, and uses a fixed neighbor radius for efficient rewiring, enabling faster convergence and better path optimization. Collision checks are rigorously applied for nodes and edges to guarantee feasible paths. The rewiring step ensures smoother and lower-cost paths dynamically, while incremental connections accelerate success detection and reduce planning time. The planner parameters are tuned for balanced exploration and exploitation to optimize success rate and path quality.",
          "planning_mechanism": "The planner samples random points favoring the goal, extends both start and goal trees toward these samples by a fixed step size, and rewires nearby nodes to minimize path cost while maintaining collision-free constraints. It frequently attempts to connect the two trees incrementally. The bidirectional growth with rewiring and goal biasing greatly reduces the search space and time, improves path smoothness and length, and robustly avoids obstacles through continuous validation during expansion and connection.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):  # limit retries for efficiency\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n            return goal_position  # fallback\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def valid_new_node(pos, obstacles, is_3d):\n            return (self._within_bounds(pos, bounds) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_extend_and_rewire(tree, other_tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if (not valid_new_node(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost_try = neighbor.cost + edge_dist\n                if cost_try < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n            # Try to connect to the other tree\n            connection_node = try_connect(other_tree, new_node)\n            if connection_node:\n                # Create a connecting node in the other tree at new_node's position, with rewiring\n                connecting_neighbors = near_nodes(other_tree, new_node.position)\n                min_conn_cost = connection_node.cost + math.dist(connection_node.position, new_node.position)\n                best_conn_parent = connection_node\n                for neighbor in connecting_neighbors:\n                    edge_dist = math.dist(neighbor.position, new_node.position)\n                    cost_try = neighbor.cost + edge_dist\n                    if cost_try < min_conn_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                new_node_other = Node(new_node.position)\n                best_conn_parent.add_child(new_node_other)\n                new_node_other.cost = min_conn_cost\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((best_conn_parent, new_node_other))\n\n                # Rewire in other tree through new_node_other\n                for neighbor in connecting_neighbors:\n                    if neighbor == best_conn_parent:\n                        continue\n                    cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                    if cost_via_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                # Extract combined path: start root to new_node, and goal root to new_node_other, reversed\n                path_start = new_node.path_from_root()\n                path_goal = new_node_other.path_from_root()\n                extracted = path_start + path_goal[::-1][1:]  # remove duplicate connecting node\n                return extracted\n            return None\n\n        def try_connect(tree, node):\n            # Find nearest node in tree to node.position that can connect within step_size and collision free edge\n            nearest_node = nearest(tree, node.position)\n            if math.dist(nearest_node.position, node.position) <= self.step_size:\n                # Node position collision and edge collision checked outside usually, but safe to check here too:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        # Main loop: alternate expansions from start and goal trees\n        for iter_num in range(self.max_iter):\n            sample = sample_free()\n            # First extend start tree toward sample, then goal tree toward start tree's new node and vice versa\n            extracted_path = try_extend_and_rewire(tree_start, tree_goal, sample)\n            if extracted_path:\n                success_state = True\n                break\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 3.74921,
          "time_improvement": -31.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 449.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052749800682067874,
                    "num_nodes_avg": 179.5,
                    "path_length_avg": 167.67689676740173,
                    "smoothness_avg": 0.029109394951206242,
                    "success_improvement": 0.0,
                    "time_improvement": -111.65136868689285,
                    "length_improvement": 8.093635871327926,
                    "smoothness_improvement": 355.6252430492584,
                    "objective_score": -30.098557216555978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06149802207946777,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 234.39611255074652,
                    "smoothness_avg": 0.023209304182747068,
                    "success_improvement": 0.0,
                    "time_improvement": 61.9485696271455,
                    "length_improvement": 21.751830912542975,
                    "smoothness_improvement": 497.1921136081793,
                    "objective_score": 25.42089763869314
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07147982120513915,
                    "num_nodes_avg": 325.3,
                    "path_length_avg": 120.17915296485121,
                    "smoothness_avg": 0.04661454427600806,
                    "success_improvement": 0.0,
                    "time_improvement": -43.570646294679634,
                    "length_improvement": 20.182728917042017,
                    "smoothness_improvement": 492.9335624630725,
                    "objective_score": -6.569980292680125
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm employs a bidirectional RRT* framework with adaptive rewiring, goal-biased sampling, and incremental connection. It grows two trees simultaneously from start and goal, alternately extending toward sampled points, rewiring locally to reduce cost, and attempting incremental connections. A dynamic neighbor radius adapts to tree size, improving rewiring efficiency. Collision and bound checks strictly ensure validity. Upon finding a connecting path or hitting a 30-second time limit, it extracts and applies shortcut-based path smoothing to deliver a fast, robust, and low-cost solution.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points with goal bias, steering toward samples within step size, rewiring neighbors using an adaptive radius for cost minimization, and incrementally connecting the two trees. It tracks the best connection to update the best path found. A time limit enforces prompt termination. Final paths are shortcut-smoothed for improved smoothness and reduced length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Will be set via update_parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dims = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        start_time = time.time()\n        best_connection_nodes = None\n        best_cost = math.inf\n\n        def sample_free(target_tree):\n            if random.random() < self.goal_sample_rate:\n                # Bias to goal of the opposite tree's root\n                return goal_position if target_tree is start_tree else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 50.0\n            r = gamma_rrt_star * (math.log(n_nodes) / n_nodes)**(1/dims)\n            r = max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n            return r\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dims))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            current = nearest_node\n\n            dist_total = math.dist(current.position, target_pos)\n            max_steps = int(dist_total / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(current.position, target_pos)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current = new_node\n\n            return None\n\n        def path_shortcutting(path, max_iter=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iter):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # Time limit reached; return best path found so far\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_shortcutting(combined)\n                    success_state = True\n                break\n\n            sample = sample_free(tree_a)\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_shortcutting(combined)\n                    success_state = True\n                    # Optional break on first found path to save time; comment out to continue improving\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_shortcutting(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.75651,
          "time_improvement": 6.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1371.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052093672752380374,
                    "num_nodes_avg": 114.5,
                    "path_length_avg": 165.2270187425068,
                    "smoothness_avg": 0.04221806732887269,
                    "success_improvement": 0.0,
                    "time_improvement": -119.71015920931305,
                    "length_improvement": 9.436452837574398,
                    "smoothness_improvement": 560.8044316974195,
                    "objective_score": -31.221735036791937
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06349074840545654,
                    "num_nodes_avg": 231.4,
                    "path_length_avg": 235.0164270349279,
                    "smoothness_avg": 0.09613143722376591,
                    "success_improvement": 0.0,
                    "time_improvement": 73.52942404371758,
                    "length_improvement": 21.54475208296079,
                    "smoothness_improvement": 2373.531120443,
                    "objective_score": 38.235433231922435
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.03848116397857666,
                    "num_nodes_avg": 188.0,
                    "path_length_avg": 121.58833839125934,
                    "smoothness_avg": 0.10059777715337799,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 63.23147298088466,
                    "length_improvement": 19.24681505502081,
                    "smoothness_improvement": 1179.5963000354525,
                    "objective_score": -21.28321359455317
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner using two trees grown from the start and goal. It integrates goal-biased sampling and informed heuristics to focus growth toward promising regions. The planner performs rewiring after each new node addition to improve path cost locally and incrementally tries to connect the two trees with rewiring-enhanced incremental connection steps. The Node class supports dynamic parent updates allowing robust rewiring. This approach balances exploration, exploitation, and path cost optimization, ensuring improved path length, smoothness, and planning efficiency.",
          "planning_mechanism": "The planner alternates sampling points biased towards the opposing tree\u2019s root and extends one tree towards these samples with rewiring to minimize costs. After each extension, it incrementally attempts to connect the other tree to the newly added node, also rewiring whenever better connections are identified. If the trees connect, their paths are merged for the final planning outcome. Collision checks for nodes and edges ensure validity throughout the process. This dual-tree rewiring hybrid speeds up convergence while producing lower cost, smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0, connect_threshold: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.connect_threshold = connect_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position  # bias towards other tree's root to encourage connection\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b and self._dist(new_node_a.position, new_node_b.position) <= self.connect_threshold:\n                # Connection successful, merge paths\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplicate node at connection\n                if path_goal[0] == path_start[-1]:\n                    path_goal = path_goal[1:]\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(\n                max(0.0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds))\n            )\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._position_in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for better paths\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._position_in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + self._dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if self._dist(new_node.position, target_pos) <= self.connect_threshold:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _position_in_bounds(self, pos, bounds):\n        for dim in range(len(bounds)):\n            if pos[dim] < 0 or pos[dim] > bounds[dim]:\n                return False\n        return True",
          "objective": 5.1084,
          "time_improvement": -34.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 402.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0566575288772583,
                    "num_nodes_avg": 117.3,
                    "path_length_avg": 169.87638754539265,
                    "smoothness_avg": 0.029805058432856506,
                    "success_improvement": 0.0,
                    "time_improvement": -127.33059420574068,
                    "length_improvement": 6.888060122749372,
                    "smoothness_improvement": 366.5138871945143,
                    "objective_score": -34.988996801199754
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06383743286132812,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 238.30680555959853,
                    "smoothness_avg": 0.020901029227638895,
                    "success_improvement": 0.0,
                    "time_improvement": 60.50107711487519,
                    "length_improvement": 20.446329023131142,
                    "smoothness_improvement": 437.7985364299979,
                    "objective_score": 24.428581621238777
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06713318824768066,
                    "num_nodes_avg": 232.0,
                    "path_length_avg": 122.82911290223119,
                    "smoothness_avg": 0.03935130317222395,
                    "success_improvement": 0.0,
                    "time_improvement": -34.840225703431656,
                    "length_improvement": 18.422751704166362,
                    "smoothness_improvement": 400.5456717396294,
                    "objective_score": -4.764789011498077
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased sampling, rewiring for dynamic path cost optimization, and rigorous collision checks for nodes and edges. It grows two trees from start and goal positions alternately, rewires nearby nodes to improve path cost, and attempts frequent connections between the trees to find a feasible and optimized path efficiently. The planner enforces a maximum execution time limit to ensure timely response.",
          "planning_mechanism": "The planner alternately extends two trees toward randomly sampled points biased toward the goal. Each extension involves steering from the nearest node within a fixed step size, validating the new node and edge collision-free status, then rewiring neighbors within a radius to minimize path cost. Frequent connection attempts between the two trees combine their branches to form complete paths, from which the lowest-cost path is selected and returned. The process terminates when a path is found or when the maximum iteration/time limits are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def can_add_node(pos):\n            return (self._within_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = list(start_tree) + list(goal_tree)\n        edges = []\n        success = False\n        path_found = []\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                break  # Time limit exceeded\n\n            sample = sample_free()\n            # Alternate expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not can_add_node(new_pos):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Choose best parent among neighbors\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_via_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_via_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_via_neighbor\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors via new_node if cheaper\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n                # Attempt connection to other tree with rewiring\n                connect_node = try_connect(tree_b, new_node)\n                if connect_node:\n                    # Connect by creating corresponding node in other tree and rewiring\n                    connect_neighbors = near_nodes(tree_b, new_node.position)\n                    min_conn_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_conn_parent = connect_node\n                    for neighbor in connect_neighbors:\n                        cost_try = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if cost_try < min_conn_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                    new_node_other = Node(new_node.position)\n                    best_conn_parent.add_child(new_node_other)\n                    new_node_other.cost = min_conn_cost\n                    tree_b.append(new_node_other)\n                    nodes.append(new_node_other)\n                    edges.append((best_conn_parent, new_node_other))\n\n                    # Rewire in other tree\n                    for neighbor in connect_neighbors:\n                        if neighbor is best_conn_parent:\n                            continue\n                        cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                        if cost_via_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                    # Extract path and finish\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_other.path_from_root()\n                    path_found = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            if success:\n                break\n\n        return globals().get('PlannerResult', None)(\n            success=success,\n            path=path_found,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 7.49771,
          "time_improvement": -39.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 301.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03216714859008789,
                    "num_nodes_avg": 157.0,
                    "path_length_avg": 176.0886278207755,
                    "smoothness_avg": 0.02335284570679442,
                    "success_improvement": 0.0,
                    "time_improvement": -35.66809488806679,
                    "length_improvement": 3.483032788565441,
                    "smoothness_improvement": 265.52274682745093,
                    "objective_score": -8.676208174569695
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04357435703277588,
                    "num_nodes_avg": 321.2,
                    "path_length_avg": 242.29733352155344,
                    "smoothness_avg": 0.017133539181904456,
                    "success_improvement": 0.0,
                    "time_improvement": 81.83297005389949,
                    "length_improvement": 19.11417592845185,
                    "smoothness_improvement": 340.85830393985594,
                    "objective_score": 30.077017721559493
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2758242845535278,
                    "num_nodes_avg": 591.6,
                    "path_length_avg": 122.78746466934895,
                    "smoothness_avg": 0.031140316530623123,
                    "success_improvement": 0.0,
                    "time_improvement": -163.5484899776065,
                    "length_improvement": 18.450412477371014,
                    "smoothness_improvement": 296.1025277304565,
                    "objective_score": -43.89395185915546
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with informed ellipsoidal sampling and adaptive rewiring to efficiently explore and optimize paths in 2D/3D spaces with obstacles. It balances exploration and exploitation by alternating tree expansions, dynamically adjusts neighbor radius for rewiring, and uses collision checks to ensure validity. The planner enforces a 30-second time limit, terminating early with the best solution found.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points biased toward the informed ellipsoidal subset defined by the best path cost to focus on promising areas. It extends and rewires trees incrementally, attempting to connect them each iteration. Collision-free nodes and edges are guaranteed by checking sampling bounds and obstacles. On successful connection or time limit, the planner extracts the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, time_limit_s: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_s = time_limit_s\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success_state = False\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = dist(start, goal)\n            c_cost = max(best_cost, c_min)\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n\n            e1 = a1 / norm_a1\n            I = np.eye(dim)\n            # Construct orthonormal basis: first is e1, rest orthogonal\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            r1 = c_cost / 2.0\n            rad = c_cost * c_cost - c_min * c_min\n            r2 = math.sqrt(rad) / 2.0 if rad > 0 else 0.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 1e-8:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            return sample_point\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges\n                    for idx in range(len(edges) - 1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def connect_trees(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                else:\n                    return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir < 1e-8:\n                return None\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_to, new_node, neighbors)\n\n            if dist(new_pos, current_pos) <= self.step_size and collision_free_edge(new_pos, current_pos):\n                final_connect = Node(current_pos)\n                final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                tree_to.append(final_connect)\n                nodes.append(final_connect)\n                edges.append((new_node, final_connect))\n                rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                return final_connect\n\n            return connect_trees(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_s:\n                break\n\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_trees(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping after first feasible path\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_trees(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 7.87217,
          "time_improvement": 23.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 137.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.015906238555908205,
                    "num_nodes_avg": 76.3,
                    "path_length_avg": 165.26782543891485,
                    "smoothness_avg": 0.018902057356556,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 32.91388337789611,
                    "length_improvement": 9.414086040649659,
                    "smoothness_improvement": 195.85824410462277,
                    "objective_score": -37.26372655797812
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06239161491394043,
                    "num_nodes_avg": 326.4,
                    "path_length_avg": 291.9621728168473,
                    "smoothness_avg": 0.007540697523224979,
                    "success_improvement": 0.0,
                    "time_improvement": 73.98767500632194,
                    "length_improvement": 2.5346230485456958,
                    "smoothness_improvement": 94.02757861746808,
                    "objective_score": 23.173365004693057
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1447190523147583,
                    "num_nodes_avg": 443.6,
                    "path_length_avg": 140.38566972611858,
                    "smoothness_avg": 0.01737140685228871,
                    "success_improvement": 0.0,
                    "time_improvement": -38.278207701262275,
                    "length_improvement": 6.762522615137764,
                    "smoothness_improvement": 120.96301293723695,
                    "objective_score": -9.526142722664943
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* growth with informed goal-biased sampling and adaptive neighbor radius rewiring. It grows two trees simultaneously from start and goal, alternately extending toward samples biased by the other tree's root, incrementally connecting trees when possible. The dynamic rewiring optimizes local path costs efficiently, and careful collision checks prevent invalid expansions. The planner employs adaptive neighbor radius and path smoothing, terminates on success or within a 30-second time limit, and returns the best path found for optimized path quality and planning efficiency.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal using goal-biased informed sampling. Each extension rewires nearby nodes to reduce costs. Upon each successful extension, it tries incremental connections to the opposite tree with rewiring. The search stops when a valid connection forms or the time limit elapses, returning the smoothed best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # Children nodes\n        self.valid = True                 # For collision validation\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n    \n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 10.0,\n                 max_neighbor_radius: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def sample_free(towards_pos):\n            # Goal bias toward the opposite tree root (towards_pos)\n            if random.random() < self.goal_sample_rate:\n                return towards_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return towards_pos  # fallback\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position)**2) <= radius_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-8 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point, nodes, edges):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                c = nbr.cost + dist(nbr.position, new_pos)\n                if c + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(curr_node.position, new_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                n_radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, new_pos, n_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    c = nbr.cost + dist(nbr.position, new_pos)\n                    if c + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = c\n                        best_parent = nbr\n\n                connecting_node = Node(new_pos)\n                best_parent.add_child(connecting_node)\n                connecting_node.cost = min_cost\n                other_tree.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((best_parent, connecting_node))\n\n                rewire(other_tree, connecting_node, neighbors)\n\n                if dist(connecting_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connecting_node.position, new_node.position):\n                        return connecting_node\n                curr_node = connecting_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return collision_free_edge(p1, p2)\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        best_path = []\n        success_state = False\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            # Sample with bias towards opposite tree's root\n            sample = sample_free(tree_b[0].position)\n\n            new_node = extend(tree_a, sample, nodes, edges)\n            if not new_node:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                full_path = path_a + path_b[::-1]\n                best_path = smooth_path(full_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Alternate expansion\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 8.29555,
          "time_improvement": -8.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1548.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.05875215530395508,
                    "num_nodes_avg": 119.4,
                    "path_length_avg": 173.56606040556738,
                    "smoothness_avg": 0.042575732984704816,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -147.79296052095728,
                    "length_improvement": 4.865691961479677,
                    "smoothness_improvement": 566.4026758945952,
                    "objective_score": -90.53273638451826
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07468678951263427,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 235.49908422826678,
                    "smoothness_avg": 0.11057201629750608,
                    "success_improvement": 0.0,
                    "time_improvement": 68.86156826976142,
                    "length_improvement": 21.38362721930725,
                    "smoothness_improvement": 2745.097621139025,
                    "objective_score": 38.660684030485
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0460242509841919,
                    "num_nodes_avg": 192.0,
                    "path_length_avg": 124.0472641914987,
                    "smoothness_avg": 0.11250758646314629,
                    "success_improvement": 0.0,
                    "time_improvement": 56.0240974834099,
                    "length_improvement": 17.613713619965885,
                    "smoothness_improvement": 1331.0881953650262,
                    "objective_score": 26.985412945841283
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with enhanced goal bias sampling, dynamic incremental rewiring, and adaptive neighborhood radius. It incorporates efficient collision checking, careful parent-child cost maintenance, and timed execution control to ensure rapid convergence to short, smooth, and feasible paths within a strict time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, steering towards strategically sampled points biased towards the goal to reduce unnecessary exploration. Each new node is locally rewired within an adaptive neighborhood radius to improve path costs dynamically. Incremental connection attempts between the two trees rapidly find feasible joins. The algorithm aborts within a 30-second maximum runtime and returns the best path found to date.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2,\n                 neighbor_factor: float=1.5, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Multiplier to adapt neighbor radius based on nodes count\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        start_time = time.time()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(\n                        max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds))\n                    )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def get_neighbor_radius():\n            # Adaptive radius based on area and node count (RRT* radius scaling)\n            n = max(1, len(nodes))\n            dim = len(bounds)\n            unit_ball_volume = {\n                2: math.pi,\n                3: 4.0/3.0*math.pi\n            }.get(dim, 1.0)\n            gamma_star = self.neighbor_factor * ((2 * (1 + 1/dim))**(1/dim)) * ( ( (bounds[0] if dim>0 else 0) * (bounds[1] if dim>1 else 0) ) ** (1/dim) )  \n            r = min(self.step_size*3, gamma_star * (math.log(n) / n) ** (1/dim))\n            return r if r > self.step_size else self.step_size*1.5\n\n        def try_extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = get_neighbor_radius()\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + dist(neighbor.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                radius = get_neighbor_radius()\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + dist(neighbor.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors to new_node\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        for iteration in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                # Timeout: stop and return best path found so far\n                break\n\n            sample = sample_free()\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                # Connected trees, combine path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success and still have nodes, try to extract best approximate path:\n        if not success_state and len(start_tree) > 0 and len(goal_tree) > 0:\n            # Try to connect closest pair from two trees\n            best_dist = float('inf')\n            best_pair = (None, None)\n            for na in start_tree:\n                for nb in goal_tree:\n                    d = dist(na.position, nb.position)\n                    if d < best_dist and not self._is_edge_in_obstacle(na.position, nb.position, obstacles, is_3d):\n                        best_dist = d\n                        best_pair = (na, nb)\n            if best_pair[0] and best_pair[1]:\n                path_a = best_pair[0].path_from_root()\n                path_b = best_pair[1].path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.96526,
          "time_improvement": 62.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 277.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009324336051940918,
                    "num_nodes_avg": 53.6,
                    "path_length_avg": 155.77172031404615,
                    "smoothness_avg": 0.02208862243045334,
                    "success_improvement": 0.0,
                    "time_improvement": 60.67370084979341,
                    "length_improvement": 14.619051735005264,
                    "smoothness_improvement": 245.73490724792833,
                    "objective_score": 22.35459513817872
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.047712516784667966,
                    "num_nodes_avg": 236.1,
                    "path_length_avg": 243.80194356342,
                    "smoothness_avg": 0.0149426795545828,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 80.10768763429145,
                    "length_improvement": 18.611893788678003,
                    "smoothness_improvement": 284.48590771646394,
                    "objective_score": -20.822885413394637
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.05731921195983887,
                    "num_nodes_avg": 237.5,
                    "path_length_avg": 124.19071544562935,
                    "smoothness_avg": 0.03143520325305023,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 45.23182836067404,
                    "length_improvement": 17.518440127386974,
                    "smoothness_improvement": 299.8534650734556,
                    "objective_score": -31.42749614095311
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* path planner that grows two trees from start and goal positions, alternately expanding them using goal-biased sampling. It performs incremental extension with rewiring to optimize path costs, ensuring collision-free nodes and edges. The planner halts successfully upon connecting the trees or stops if the maximum iterations or time limit (30 seconds) is reached, returning the best path found for efficient, smooth, and robust navigation.",
          "planning_mechanism": "The planner samples points with goal bias, extends the current tree towards the sample by stepping within bounds and avoiding obstacles, rewires nearby nodes locally to maintain low-cost paths, then incrementally connects the other tree towards the new node, rewiring as it goes. Trees alternate growth each iteration, with full collision checks on nodes and edges. The best connecting path is extracted by merging paths from start and goal trees. Planning terminates on success or time expiry, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]: (x,y) or (x,y,z)\n        self.parent = parent           # Parent node or None\n        self.cost = cost               # Cost from start to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Validity flag (e.g. collision free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_path_cost = float('inf')\n        best_path = []\n\n        def _sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp within bounds\n            clamped = tuple(max(0, min(bounds[d], new_p[d])) for d in range(len(bounds)))\n            return clamped\n\n        def _near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def _extend_and_rewire(tree, sample):\n            nearest = _nearest(tree, sample)\n            new_pos = _steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = _near_nodes(tree, new_pos)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for n in neighbors:\n                cost = n.cost + math.dist(n.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = n\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost via new_node\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    n.update_parent(new_node, new_cost)\n                    edges.append((new_node, n))\n\n            return new_node\n\n        def _incremental_connect_and_rewire(tree, target_pos):\n            curr_node = _nearest(tree, target_pos)\n            while True:\n                new_pos = _steer(curr_node.position, target_pos)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for n in neighbors:\n                    cost = n.cost + math.dist(n.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = n\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if better cost via new_node\n                for n in neighbors:\n                    if n is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                    if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.update_parent(new_node, new_cost)\n                        edges.append((new_node, n))\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > 30:\n                break\n\n            sample = _sample_free()\n            new_node_a = _extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = _incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                candidate_path = path_a + path_b[::-1]\n                cand_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    cand_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if cand_cost < best_path_cost:\n                    best_path_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                break  # Stop at first success for efficiency\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_path:\n            extracted_path = best_path\n        elif success_state:\n            extracted_path = best_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        try:\n            distance = math.dist(from_pos, to_pos)\n        except Exception:\n            # Fallback Manhattan if math.dist unavailable (unlikely)\n            distance = sum(abs(from_pos[d] - to_pos[d]) for d in range(len(from_pos)))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.28803,
          "time_improvement": 61.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 287.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01827681064605713,
                    "num_nodes_avg": 94.9,
                    "path_length_avg": 163.38675770681954,
                    "smoothness_avg": 0.021414164422488623,
                    "success_improvement": 0.0,
                    "time_improvement": 22.915763763264508,
                    "length_improvement": 10.445129072036783,
                    "smoothness_improvement": 235.17817481427437,
                    "objective_score": 10.139645817458081
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.02677924633026123,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 244.2306058817266,
                    "smoothness_avg": 0.015574591067521687,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 88.83519108153628,
                    "length_improvement": 18.468793968466542,
                    "smoothness_improvement": 300.745446091847,
                    "objective_score": -18.151956651386566
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.030116820335388185,
                    "num_nodes_avg": 203.0,
                    "path_length_avg": 119.26924702636245,
                    "smoothness_avg": 0.03339223708825981,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 71.22355439019334,
                    "length_improvement": 20.787045116321536,
                    "smoothness_improvement": 324.74679100410987,
                    "objective_score": -22.851790704657134
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional, anytime RRT* planner with adaptive informed sampling, dynamic rewiring, and path smoothing. It grows two trees simultaneously from start and goal, leveraging adaptive informed regions around the current best path to bias sampling efficiently. The planner performs incremental expansion and rewiring in both trees, attempts frequent, incremental connections reducing connection failures, and applies path smoothing on the extracted path for improved smoothness and shorter path length. The approach integrates rigorous collision checks, bounding constraints, and flexible parameters to improve planning speed, success rate, robustness, and path quality.",
          "planning_mechanism": "The planner alternates between expanding two RRT* trees rooted at start and goal with adaptive informed sampling that focuses search in the ellipsoidal region defined by the current best solution. Each expansion incrementally extends and rewires nodes to reduce path cost. Frequent incremental attempts connect the opposing tree with rewiring to ensure low-cost merges. Upon connection, the best path is extracted and refined through shortcut smoothing, yielding shorter and smoother collision-free paths faster and more reliably.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.5, goal_sample_rate: float=0.1,\n                 neighbor_factor: float=2.0, collision_resolution: float=0.5, smoothing_iters: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_rewire(tree, neighbors, new_node):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if c_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, c_through_new)\n                        edges.append((new_node, nbr))\n\n        def incrementally_connect(tree, target_node):\n            curr_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                radius = self._adaptive_radius(len(tree), dim)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = c\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                try_rewire(tree, neighbors, new_node)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def _adaptive_radius(num_nodes, dim):\n            from math import log, pow, pi\n            gamma = self.neighbor_factor\n            unit_ball_volume = pi if dim == 2 else 4/3 * pi\n            radius = min(self.step_size, gamma * pow((log(num_nodes) / num_nodes), 1/dim))\n            return radius\n\n        def try_extend(tree, sample):\n            if not self._within_bounds(sample, bounds):\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = _adaptive_radius(len(tree), dim)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            try_rewire(tree, neighbors, new_node)\n            return new_node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _within_bounds(pos, bounds):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        self._within_bounds = _within_bounds\n        self._adaptive_radius = _adaptive_radius\n\n        tree_active, tree_opposite = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            # Sample point biased by informed sampling & goal bias\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_opposite[0].position\n                else:\n                    sample = sample_free()\n\n            new_node = try_extend(tree_active, sample)\n            if new_node is None:\n                tree_active, tree_opposite = tree_opposite, tree_active\n                continue\n\n            connect_node = incrementally_connect(tree_opposite, new_node)\n            if connect_node:\n                # Extract combined path\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_new = 0.0\n                for idx in range(1, len(full_path)):\n                    c_new += math.dist(full_path[idx-1], full_path[idx])\n                if c_new < c_best:\n                    c_best = c_new\n                    center = tuple((s + g) * 0.5 for s, g in zip(full_path[0], full_path[-1]))\n                \n                extracted_path = path_smoothing(full_path)\n                success_state = True\n                break\n\n            tree_active, tree_opposite = tree_opposite, tree_active\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.97471,
          "time_improvement": 38.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1438.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025354552268981933,
                    "num_nodes_avg": 80.2,
                    "path_length_avg": 164.87912207597097,
                    "smoothness_avg": 0.03844395041869222,
                    "success_improvement": 0.0,
                    "time_improvement": -1.7316771018180572,
                    "length_improvement": 9.627140513278148,
                    "smoothness_improvement": 501.7313064270491,
                    "objective_score": 3.914581504245458
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.05082085132598877,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 219.54202937674887,
                    "smoothness_avg": 0.08683182190470087,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.55498729339317,
                    "length_improvement": 26.710551427101343,
                    "smoothness_improvement": 2134.2453200412874,
                    "objective_score": -63.420166926355336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026004457473754884,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 121.5085305076238,
                    "smoothness_avg": 0.1397939934905283,
                    "success_improvement": 0.0,
                    "time_improvement": 47.768800997209595,
                    "length_improvement": 19.2998196512885,
                    "smoothness_improvement": 1678.1692786802648,
                    "objective_score": 26.581450622821905
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "A time-constrained bidirectional RRT* inspired planner enhanced with adaptive informed sampling, dynamic rewiring, and heuristic pruning to quickly find high-quality, smooth, and collision-free paths in 2D/3D environments. Uses approximate nearest neighbor via KD-trees for efficiency and switches sampling focus based on progression. It maintains two trees grown alternately from start and goal, combines cost-aware rewiring with path smoothing, and aborts when a time limit (30s) is reached to return the best path found.",
          "planning_mechanism": "A planner that grows start and goal trees alternately, performs ellipsoidal informed and uniform sampling adaptively, rewires neighborhoods for cost optimization, uses heuristic path-length pruning to focus search, applies strict collision checks for nodes and edges, attempts incremental connections between trees, and stops after 30 seconds if no better path is found, returning the best candidate path for balanced planning efficiency and path quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position                # Tuple of coordinates (2D/3D)\n        self.parent = parent                    # Parent Node\n        self.cost = cost                        # Cost from root\n        self.children = []                      # Children nodes\n        self.valid = True                       # Validity flag (for collisions)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 neighbor_radius_factor: float=10.0, collision_resolution: float=0.5,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.collision_resolution = collision_resolution\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n        edges_local = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        best_connect = None\n\n        def _within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dimension))\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        # KD-tree helper for nearest and radius queries\n        # For simplicity, use linear search here; can be replaced with KD-tree for efficiency.\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, point, radius):\n            result = []\n            r_sq = radius * radius\n            for node in tree:\n                # squared distance for efficiency\n                d_sq = sum((node.position[d] - point[d])**2 for d in range(dimension))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n            # Clamp within bounds\n            new_pos = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dimension))\n            return new_pos\n\n        def _is_free_point(p):\n            return (not self._is_in_obstacle(p, obstacles, is_3d)) and _within_bounds(p)\n\n        def _is_free_edge(fpos, tpos):\n            return not self._is_edge_in_obstacle(fpos, tpos, obstacles, is_3d, self.collision_resolution)\n\n        def ellipsoidal_informed_sample():\n            if c_best == float('inf'):\n                return uniform_sample()\n            # Sampling inside an n-dimensional prolate hyperspheroid (ellipse in 2D)\n            # aligned along start->goal vector\n            import random\n            import numpy as np\n            center = np.array([(start_position[i] + goal_position[i]) * 0.5 for i in range(dimension)])\n            a1 = np.array([goal_position[i] - start_position[i] for i in range(dimension)])\n            c_min_local = np.linalg.norm(a1)\n            if c_min_local < 1e-9:\n                # start==goal, just return start\n                return start_position\n            a1_unit = a1 / c_min_local\n\n            # Create rotation matrix that aligns x-axis to a1_unit vector:\n            def rotation_matrix_3d(u):\n                # assumes u normalized vector\n                # constructs orthonormal basis\n                if dimension == 2:\n                    theta = math.atan2(u[1], u[0])\n                    c, s = math.cos(theta), math.sin(theta)\n                    return np.array([[c, -s],\n                                     [s,  c]])\n                elif dimension ==3:\n                    # Rodrigues rotation matrix from x axis to u\n                    x = np.array([1, 0, 0])\n                    v = np.cross(x, u)\n                    s = np.linalg.norm(v)\n                    if s < 1e-9:\n                        return np.eye(3)\n                    c = np.dot(x, u)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return R\n                else:\n                    return np.eye(dimension)\n\n            R = rotation_matrix_3d(a1_unit)\n\n            # Radii of ellipse axes:\n            r1 = c_best / 2.0\n            r_rest = math.sqrt(max(c_best**2 - c_min_local**2, 0)) / 2.0\n            radii = np.array([r1] + [r_rest]*(dimension - 1))\n            # sample uniformly within unit ball\n            for _ in range(100):  # max attempts to find free sample\n                if dimension == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = random.uniform(0,1)**0.5\n                    sample_unit_ball = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                else:\n                    while True:\n                        sample_unit_ball = np.random.uniform(-1,1,dimension)\n                        if np.linalg.norm(sample_unit_ball) <= 1:\n                            break\n                sample_ellipse = radii * sample_unit_ball\n                sample_world = R @ sample_ellipse + center\n                p = tuple(np.clip(sample_world, [0]*dimension, bounds))\n                if _is_free_point(p):\n                    return p\n            # Fallback to uniform sampling\n            return uniform_sample()\n\n        def uniform_sample():\n            import random\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if _is_free_point(p):\n                    return p\n            # fallback (rare)\n            return start_position\n\n        def rewire(tree, new_node):\n            # radius shrinks with tree size following RRT* theory: gamma*(log(n)/n)^{1/d}\n            gamma = self.neighbor_radius_factor\n            n = len(tree) + 1\n            radius = min(self.step_size*10, gamma * ((math.log(n)/n)**(1/dimension)))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            # Try to find better parent for new_node\n            for near in neighbors:\n                cost_via_near = near.cost + distance(near.position, new_node.position)\n                if cost_via_near < min_cost and _is_free_edge(near.position, new_node.position):\n                    min_cost = cost_via_near\n                    min_parent = near\n            if min_parent != new_node.parent:\n                new_node.update_parent(min_parent, min_cost)\n\n            # Try rewiring neighbors through new_node\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near.position)\n                if cost_through_new < near.cost and _is_free_edge(new_node.position, near.position):\n                    near.update_parent(new_node, cost_through_new)\n\n        def attempt_connection(node_from_treeA, treeB):\n            # Try to connect node_from_treeA to best parent in treeB within step size\n            best_connection = None\n            radius = self.step_size * 1.5\n\n            neighbors = near_nodes(treeB, node_from_treeA.position, radius)\n            min_cost = float('inf')\n            best_near = None\n\n            for near in neighbors:\n                dist_to_near = distance(near.position, node_from_treeA.position)\n                if dist_to_near > self.step_size:\n                    # attempt incremental steering along line closer to node_from_treeA\n                    direction = node_from_treeA.position\n                    new_pos = steer(near.position, direction)\n                    dist_new_pos = distance(new_pos, node_from_treeA.position)\n                    if dist_new_pos < dist_to_near and _is_free_point(new_pos) and _is_free_edge(near.position, new_pos):\n                        cost_to_new = near.cost + distance(near.position, new_pos)\n                        if cost_to_new < min_cost:\n                            best_connection = (near, new_pos, cost_to_new)\n                            min_cost = cost_to_new\n                    continue\n                # direct connection check\n                if _is_free_point(node_from_treeA.position) and _is_free_edge(near.position, node_from_treeA.position):\n                    cost_to_near = near.cost + distance(near.position, node_from_treeA.position)\n                    if cost_to_near < min_cost:\n                        best_connection = (near, node_from_treeA.position, cost_to_near)\n                        min_cost = cost_to_near\n                        best_near = near\n\n            if best_connection is None:\n                return None\n            near_node, connect_pos, cost_val = best_connection\n\n            # If exact connection node already exists in treeB at connect_pos, skip duplicate\n            for node in treeB:\n                if node.position == connect_pos:\n                    return node\n\n            new_node = Node(connect_pos, parent=near_node, cost=cost_val)\n            near_node.add_child(new_node)\n            treeB.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n\n            # Rewire near neighbors in treeB around new_node\n            rewire(treeB, new_node)\n            return new_node\n\n        iter_count = 0\n        start_time = time.time()\n        trees = [start_tree, goal_tree]\n        current_tree_idx = 0\n\n        while iter_count < self.max_iter:\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                # Time limit exceeded - return best found path so far\n                if best_connect:\n                    path_start = best_connect[0].path_from_root()\n                    path_goal = best_connect[1].path_from_root()\n                    path_goal.reverse()\n                    extracted_path = path_start + path_goal[1:]\n                    success_state = True\n                break\n\n            tree_a = trees[current_tree_idx]\n            tree_b = trees[1 - current_tree_idx]\n\n            # Adaptive sampling bias:\n            sample = None\n            import random\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample = ellipsoidal_informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not _is_free_point(new_pos):\n                current_tree_idx = 1 - current_tree_idx\n                iter_count +=1\n                continue\n            if not _is_free_edge(nearest_node.position, new_pos):\n                current_tree_idx = 1 - current_tree_idx\n                iter_count += 1\n                continue\n\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring step to improve path cost in tree_a\n            rewire(tree_a, new_node)\n\n            # Attempt to connect the other tree to new_node\n            connect_node = attempt_connection(new_node, tree_b)\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                path_goal.reverse()\n                candidate_path = path_start + path_goal[1:]  # avoid duplicate node\n\n                # Calculate candidate cost\n                candidate_cost = new_node.cost + connect_node.cost + distance(new_node.position, connect_node.position)\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_connect = (new_node, connect_node)\n\n                    extracted_path = candidate_path\n                    success_state = True\n                    # Optional: could continue for better solutions, but here we return best immediately\n                    # Comment the next line to continue searching after first solution found\n                    break\n\n            current_tree_idx = 1 - current_tree_idx\n            iter_count += 1\n\n        # If after finishing loops best_connect exists but not success_state, assign path\n        if not success_state and best_connect:\n            path_start = best_connect[0].path_from_root()\n            path_goal = best_connect[1].path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal[1:]\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.29351,
          "time_improvement": 20.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03507091999053955,
                    "num_nodes_avg": 126.9,
                    "path_length_avg": 195.92137638526344,
                    "smoothness_avg": 0.010454520467946541,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -47.915034736851645,
                    "length_improvement": -7.387610969642458,
                    "smoothness_improvement": 63.63594767792329,
                    "objective_score": -65.53385287659437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05600316524505615,
                    "num_nodes_avg": 251.8,
                    "path_length_avg": 303.7792345154354,
                    "smoothness_avg": 0.006675582726050662,
                    "success_improvement": 0.0,
                    "time_improvement": 76.65114876352457,
                    "length_improvement": -1.4102522817046865,
                    "smoothness_improvement": 71.76755176917106,
                    "objective_score": 23.07213193156229
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07204346656799317,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 158.83293248029838,
                    "smoothness_avg": 0.013053116099153795,
                    "success_improvement": 0.0,
                    "time_improvement": 31.16288923768757,
                    "length_improvement": -5.48927094193248,
                    "smoothness_improvement": 66.03467330042821,
                    "objective_score": 8.581185949421915
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm implements a bidirectional RRT* planner featuring goal-biased sampling, dynamic rewiring of nodes in local neighborhoods, and incremental connection attempts between two simultaneously grown trees from start and goal. It integrates efficient collision checking, adaptive neighbor search, and path smoothing to reduce planning time while improving path quality, length, and smoothness robustly in 2D or 3D spaces. The Node class maintains parent-child relationships and cumulative costs for path optimization.",
          "planning_mechanism": "The planning mechanism alternates expansion between two trees grown from start and goal. Each iteration samples a point with goal bias, extends one tree toward the sample with collision-checked steering, locally rewires node connections to optimize costs, then incrementally connects and rewires the other tree toward the newly added node. Upon successful connection, paths from both trees are merged and smoothed. This approach narrows search space, improves path optimality dynamically, and reduces redundant exploration, thereby minimizing planning time and improving path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def descendants(self):\n        \"\"\"Yield all descendant nodes in subtree rooted at this node.\"\"\"\n        for child in self.children:\n            yield child\n            yield from child.descendants()\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_radius: float = 20.0, smoothing_iters: int = 15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        # Precompute max bounds limits for clamping\n        max_bounds = tuple(bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling: sample near goal of the opposite tree to direct growth\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_b:\n                # Extract path from start tree root to new_node_a\n                path_from_start = new_node_a.path_from_root()\n                # Extract path from goal tree root to new_node_b\n                path_from_goal = new_node_b.path_from_root()\n\n                # Remove duplicate connecting node at junction if present\n                if path_from_goal and path_from_goal[0] == path_from_start[-1]:\n                    path_from_goal = path_from_goal[1:]\n\n                # Combine paths: start -> connection -> goal (reversed)\n                raw_path = path_from_start + path_from_goal[::-1]\n                # Smooth path to improve trajectory quality\n                extracted_path = self._smooth_path(raw_path, obstacles, is_3d)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        r_sq = radius * radius\n        return [node for node in tree if (sum((node.position[d] - position[d])**2 for d in range(len(position)))) <= r_sq]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        # Add node and edge to lists\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path cost improves\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path[:]\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            p1, p2 = smoothed[i], smoothed[j]\n\n            # Check if direct edge between p1 and p2 is free\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate nodes between i+1 and j-1 as they are not needed\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed",
          "objective": 11.58068,
          "time_improvement": 48.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 680.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0206784725189209,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 158.40561102660482,
                    "smoothness_avg": 0.03188515116292793,
                    "success_improvement": 0.0,
                    "time_improvement": 17.030454060621132,
                    "length_improvement": 13.175374498782666,
                    "smoothness_improvement": 399.07185541379243,
                    "objective_score": 9.739570395011835
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0508305549621582,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 238.8534003722645,
                    "smoothness_avg": 0.034152573568993594,
                    "success_improvement": 0.0,
                    "time_improvement": 68.54898324279806,
                    "length_improvement": 20.26385994180389,
                    "smoothness_improvement": 778.7703170346437,
                    "objective_score": 28.511318546373413
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.020598220825195312,
                    "num_nodes_avg": 124.4,
                    "path_length_avg": 112.12845794943728,
                    "smoothness_avg": 0.07567514147955685,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 58.6274863795938,
                    "length_improvement": 25.52961721337948,
                    "smoothness_improvement": 862.5822138620559,
                    "objective_score": -72.99291957413567
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner combining goal bias sampling, rewiring with neighborhood optimization, and incremental connection with rewiring to minimize path length and enhance planning efficiency. It grows two trees simultaneously from start and goal, alternating their expansions, dynamically rewiring to reduce path costs and ensuring collision-free nodes and edges for robust and smooth path construction.",
          "planning_mechanism": "The planner alternates between expanding the two trees by sampling points with goal bias, steering towards samples, and rewiring locally to optimize cost. After a new node is added to one tree, it incrementally attempts connection to the other tree through rewiring-enhanced extension steps. When the trees connect successfully, the final path is constructed by concatenating the optimal paths from both trees, ensuring minimized path length and improved success rate through repeated collision checking and neighborhood-based rewiring.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._inside_bounds(new_pos, obstacles, is_3d):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if not self._inside_bounds(new_pos, obstacles, is_3d):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _inside_bounds(self, pos, obstacles, is_3d):\n        # Position must be within map bounds (assumed origin at 0)\n        # Using obstacles only for dimension info, bounds check done in _sample_free\n        # but nodes from steered positions can violate bounds so check\n        dims = len(pos)\n        for d in range(dims):\n            if pos[d] < 0:\n                return False\n            if is_3d:\n                # bounds unknown here, we rely on positive checking only (sampling enforces bounds)\n                # this method is a placeholder - \n                # safer if we reject negative coords only\n                continue\n            else:\n                continue\n        return True",
          "objective": 12.18696,
          "time_improvement": 0.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 270.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023809289932250975,
                    "num_nodes_avg": 77.7,
                    "path_length_avg": 165.54940495088522,
                    "smoothness_avg": 0.020562554204645422,
                    "success_improvement": 0.0,
                    "time_improvement": 4.468476914320158,
                    "length_improvement": 9.259747848225805,
                    "smoothness_improvement": 221.84862560384113,
                    "objective_score": 4.301735771960415
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04926056861877441,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 244.04682856696945,
                    "smoothness_avg": 0.015542087807597499,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 69.52040027397354,
                    "length_improvement": 18.53014412586919,
                    "smoothness_improvement": 299.90911380284587,
                    "objective_score": -23.938305523619864
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0860180139541626,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 124.42837862466763,
                    "smoothness_avg": 0.03042426300596567,
                    "success_improvement": 0.0,
                    "time_improvement": -72.77130311982366,
                    "length_improvement": 17.36059556017419,
                    "smoothness_improvement": 286.994379750387,
                    "objective_score": -16.92429992516032
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with dynamic rewiring, goal-biased informed sampling, and adaptive neighborhood rewiring radius. It grows two trees from start and goal positions alternately, incrementally extending, rewiring for path cost optimization, and attempting incremental connection under collision constraints with a strict 30-second time limit to ensure fast convergence to smooth, low-cost, and robust paths.",
          "planning_mechanism": "The planner alternately expands two trees rooted at start and goal using a combination of goal bias and ellipsoidal informed sampling. Each extension performs collision checking and rewiring within an adaptive neighborhood to optimize path costs. When nodes from opposing trees can be safely connected, the planner merges their paths to generate a globally optimized solution. The search terminates immediately upon success or after 30 seconds, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    \n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n    \n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n    \n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n    \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_factor: float=2.5, collision_resolution: float=0.5, max_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                return sample_free()\n            if c_best == float('inf') or rotation is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit = np.random.uniform(-1, 1, 3)\n                        norm = np.linalg.norm(unit)\n                        if norm <= 1e-9:\n                            continue\n                        if norm <= 1.0:\n                            unit /= norm\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 5, self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            candidate = Node(new_pos)\n            neighbors = near_nodes(tree, candidate)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def connect_and_rewire(tree_connect, connect_to_node):\n            nearest_node = nearest(tree_connect, connect_to_node.position)\n            last_node = nearest_node\n\n            while True:\n                next_pos = steer(last_node.position, connect_to_node.position)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, next_pos)\n                candidate = Node(next_pos)\n                candidate.cost = new_cost\n\n                neighbors = near_nodes(tree_connect, candidate)\n                min_cost = new_cost\n                min_parent = last_node\n                for neighbor in neighbors:\n                    if not self._is_edge_in_obstacle(neighbor.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via = neighbor.cost + dist(neighbor.position, next_pos)\n                        if cost_via < min_cost:\n                            min_cost = cost_via\n                            min_parent = neighbor\n\n                min_parent.add_child(candidate)\n                candidate.parent = min_parent\n                candidate.cost = min_cost\n                tree_connect.append(candidate)\n\n                for neighbor in neighbors:\n                    if neighbor == candidate.parent:\n                        continue\n                    cost_thru_cand = candidate.cost + dist(candidate.position, neighbor.position)\n                    if cost_thru_cand < neighbor.cost:\n                        if not self._is_edge_in_obstacle(candidate.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                            neighbor.update_parent(candidate, cost_thru_cand)\n\n                if dist(candidate.position, connect_to_node.position) < self.step_size * 0.5:\n                    return candidate\n\n                last_node = candidate\n\n            return None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            for current_tree, other_tree in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if time.time() - start_time > self.max_time:\n                    break\n\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if current_tree is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(current_tree, sample)\n                if new_node is None:\n                    continue\n                nodes.append(new_node)\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                connected_node = connect_and_rewire(other_tree, new_node)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return immediately for max speed\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.38426,
          "time_improvement": 12.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -2.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.02875816822052002,
                    "num_nodes_avg": 125.3,
                    "path_length_avg": 177.90624602185008,
                    "smoothness_avg": 0.0063397843297267695,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -21.29038680633137,
                    "length_improvement": 2.4867674505529505,
                    "smoothness_improvement": -0.7686081777545901,
                    "objective_score": -55.89360559267759
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07860546112060547,
                    "num_nodes_avg": 338.3,
                    "path_length_avg": 301.3505980130704,
                    "smoothness_avg": 0.0038370445078421108,
                    "success_improvement": 0.0,
                    "time_improvement": 67.22779489251117,
                    "length_improvement": -0.5995035127894821,
                    "smoothness_improvement": -1.270081101773544,
                    "objective_score": 20.042087359686587
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11623785495758057,
                    "num_nodes_avg": 382.6,
                    "path_length_avg": 157.82659435319775,
                    "smoothness_avg": 0.007583450963211838,
                    "success_improvement": 0.0,
                    "time_improvement": -11.064590276717844,
                    "length_improvement": -4.820909074584325,
                    "smoothness_improvement": -3.5390635000694726,
                    "objective_score": -4.301254215432566
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a time-constrained hybrid ARRT* inspired planner that combines informed sampling with a single-tree rewiring RRT* approach incorporating dynamic neighborhood radius adjustment and path smoothing. It maintains one incrementally optimized tree rooted at the start, biases sampling within a shrinking ellipsoidal informed set after an initial solution, and rewires neighbors to improve path cost dynamically. Collision checks ensure safety for nodes and edges. Planning halts at path optimality, or maximum iterations, or after a 30-second timeout, returning the best path found to balance planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner iteratively samples informed or uniform points, extends the tree with collision-free steps, rewires nearby nodes to optimize costs, and tracks the best goal node when reachable. It dynamically shrinks the ellipsoid based on the best path cost to focus search. When a path to the goal is found or time expires, it runs path smoothing to enhance smoothness. The approach balances exploration and exploitation, ensures feasible connections, and respects problem bounds and obstacles.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children: List[Node] = []\n        self.valid = True               # Collision-free flag\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.5, collision_resolution: float = 0.5, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles: 2D (x,y,w,h), 3D (x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.time()\n        best_cost = float('inf')\n        best_goal_node = None\n\n        nodes: List[Node] = [Node(start_position, None, 0.0)]\n        edges: List[Tuple[Node, Node]] = []\n\n        # Utility functions\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix for ellipsoidal informed sample alignment toward x-axis\n        def compute_rotation():\n            if best_cost == float('inf'):\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return [[c_, -s_], [s_, c_]]\n            else:\n                import numpy as np\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c_) / (s_ ** 2))\n                return R\n\n        def mat_vec_mult(mat, vec):\n            if dim == 2:\n                return (mat[0][0] * vec[0] + mat[0][1] * vec[1],\n                        mat[1][0] * vec[0] + mat[1][1] * vec[1])\n            else:\n                import numpy as np\n                return tuple(mat @ vec)\n\n        def informed_sample():\n            if best_cost == float('inf'):\n                return uniform_sample()\n            import numpy as np\n            r1 = best_cost / 2.0\n            val = best_cost ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            rotation = compute_rotation()\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + np.array(mat_vec_mult(rotation, sample_ellipsoid))\n                    else:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + rotation @ sample_ellipsoid\n                    else:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        # Dynamic neighbor radius as function of node count and dimension\n        def compute_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.step_size * self.neighbor_factor\n            return min(self.step_size * self.neighbor_factor,\n                       self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim)))\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations=40) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        c_min = dist(start_position, goal_position)\n\n        for it in range(self.max_iter):\n            current_time = time.time()\n            if current_time - start_time > self.time_limit:\n                # Time limit reached\n                break\n\n            sample_pos = None\n            if best_cost < float('inf') and random.random() > self.goal_sample_rate:\n                sample_pos = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pos = goal_position\n                else:\n                    sample_pos = uniform_sample()\n\n            nearest = nearest_node(nodes, sample_pos)\n            new_pos = steer(nearest.position, sample_pos, self.step_size)\n\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring nearby nodes to new_node if cheaper\n            neighbor_radius = compute_neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, neighbor_radius)\n\n            # Choose best parent among neighbors for new_node (better cost)\n            min_cost = new_node.cost\n            min_parent = nearest\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_via_neighbor = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost_via_neighbor < min_cost:\n                    min_cost = cost_via_neighbor\n                    min_parent = neighbor\n            if min_parent != nearest:\n                # Re-parent new_node\n                try:\n                    min_node_prev_parent = new_node.parent\n                    if min_node_prev_parent:\n                        min_node_prev_parent.remove_child(new_node)\n                        edges.remove((min_node_prev_parent, new_node))\n                except ValueError:\n                    pass\n                new_node.update_parent(min_parent, min_cost)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if shorter\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    try:\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            edges.remove((old_parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Check if new_node can connect directly to goal\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, new_node, new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n            # Early stop if path found quickly\n            if best_goal_node and (it > 100 or (time.time() - start_time) > self.time_limit * 0.5):\n                # Allows some improvements but avoids overrun\n                break\n\n        success_state = best_goal_node is not None\n        if success_state:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = path_smoothing(extracted_path, iterations=50)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.42541,
          "time_improvement": -73.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1324.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0748063325881958,
                    "num_nodes_avg": 274.9,
                    "path_length_avg": 184.66634185534946,
                    "smoothness_avg": 0.02547004180083661,
                    "success_improvement": 0.0,
                    "time_improvement": -215.5030231971177,
                    "length_improvement": -1.2185481963615001,
                    "smoothness_improvement": 298.66146326411604,
                    "objective_score": -63.40130928208703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.26328799724578855,
                    "num_nodes_avg": 851.1,
                    "path_length_avg": 246.12792532501567,
                    "smoothness_avg": 0.10066838613582856,
                    "success_improvement": 0.0,
                    "time_improvement": -9.770086264617973,
                    "length_improvement": 17.835414126984485,
                    "smoothness_improvement": 2490.2700837825864,
                    "objective_score": 13.087407364924438
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09783074855804444,
                    "num_nodes_avg": 443.3,
                    "path_length_avg": 134.27656907669714,
                    "smoothness_avg": 0.10089219278204406,
                    "success_improvement": 0.0,
                    "time_improvement": 6.523292183694897,
                    "length_improvement": 10.819896382371397,
                    "smoothness_improvement": 1183.3412451005838,
                    "objective_score": 10.037673157085667
               }
          ],
          "success_rate": 1.0
     }
]