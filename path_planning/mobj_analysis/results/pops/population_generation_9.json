[
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling. It grows two trees alternately from start and goal, dynamically rewiring neighbors to optimize path cost and smoothness. Rigorous collision checks for nodes and edges ensure path validity. The algorithm enforces a 30-second runtime limit, returns the best feasible path found so far, and applies path smoothing for improved quality and shorter lengths.",
          "planning_mechanism": "The planner alternately samples points biased towards the opposite tree\u2019s root, extends the current tree incrementally with step-size limits, rewires neighbors within an adaptive radius to minimize cost, and attempts incremental connections to the other tree. On successful connection or timeout, it reconstructs and smooths the combined path. Nodes and edges are tracked for roadmap analysis.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Update parent and cost, then propagate cost updates recursively to children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            # Goal-biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return tree_to_root_pos  # fallback\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                # Shortcut path\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Combine with no duplicated connect node\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=100)\n                    success_state = True\n\n                # Early termination when found a connection\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early stop but found best path, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=100)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.71144,
          "time_improvement": 64.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1391.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01094198226928711,
                    "num_nodes_avg": 71.9,
                    "path_length_avg": 159.3879990283421,
                    "smoothness_avg": 0.03611968111442979,
                    "success_improvement": 0.0,
                    "time_improvement": 53.851119734292496,
                    "length_improvement": 12.636912068096395,
                    "smoothness_improvement": 465.3514445837642,
                    "objective_score": 21.009475556825848
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055727267265319826,
                    "num_nodes_avg": 295.1,
                    "path_length_avg": 229.22588968501387,
                    "smoothness_avg": 0.0851665813883569,
                    "success_improvement": 0.0,
                    "time_improvement": 76.76617620629713,
                    "length_improvement": 23.477800121738362,
                    "smoothness_improvement": 2091.3974821314937,
                    "objective_score": 38.18240029689428
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04135787487030029,
                    "num_nodes_avg": 235.5,
                    "path_length_avg": 122.57216148158086,
                    "smoothness_avg": 0.13488954490947164,
                    "success_improvement": 0.0,
                    "time_improvement": 60.482792556160256,
                    "length_improvement": 18.593406603050504,
                    "smoothness_improvement": 1615.7850547379617,
                    "objective_score": 29.942444361147988
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased and informed sampling, adaptive neighbor radius, incremental extend-and-rewire expansions, and progressive tree connection attempts. It dynamically rewires nodes to optimize path cost while respecting map boundaries and obstacles, applies multiple passes of path smoothing, and enforces a strict time limit of 30 seconds to ensure timely responses.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled points generated with a bias towards the goal and an ellipsoidal informed region after an initial solution is found. Each extension attempts to connect to the opposite tree incrementally. Adaptive neighbor radius ensures locally appropriate rewiring for cost optimization. On connection, best paths from both trees are combined, smoothed, and returned. The process halts if time runs out, returning the best available path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Cost from root\n        self.children: List[Node] = []        # List of child nodes\n        self.valid = True                     # For collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                           # Tuple[int, ...]\n        start_pos = map.start                       # Tuple[float, ...]\n        goal_pos = map.goal                         # Tuple[float, ...]\n        obstacles = map.obstacles                   # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning parameter\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors for potentially better paths\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n\n        iter_cnt = 0\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplication of connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Apply smoothing and return early\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or iteration limit, return best path found (if any)\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.07081,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1580.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01549065113067627,
                    "num_nodes_avg": 67.1,
                    "path_length_avg": 160.82071621613,
                    "smoothness_avg": 0.04018716215495074,
                    "success_improvement": 0.0,
                    "time_improvement": 34.666663985190205,
                    "length_improvement": 11.851617074613193,
                    "smoothness_improvement": 529.0163555443684,
                    "objective_score": 15.415404388201543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04627766609191895,
                    "num_nodes_avg": 218.8,
                    "path_length_avg": 234.7337667638325,
                    "smoothness_avg": 0.10335063168007959,
                    "success_improvement": 0.0,
                    "time_improvement": 80.70590588186646,
                    "length_improvement": 21.639112217377225,
                    "smoothness_improvement": 2559.2861935795413,
                    "objective_score": 41.33602517593309
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.049237298965454104,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 125.59843408327171,
                    "smoothness_avg": 0.13770665612117666,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95404893761946,
                    "length_improvement": 16.583500436623012,
                    "smoothness_improvement": 1651.6185014133298,
                    "objective_score": 27.46100727567709
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius, incremental extend-and-rewire expansions, and continuous path optimization. It employs goal bias and ellipsoidal informed sampling after the first solution to focus search, ensures collision-free node and edge placement, and manages trees with parent-child relationships for efficient rewiring and cost updates. It enforces a strict 30-second time limit, returning the best smoothed path found if time expires.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending towards sampled points drawn either uniformly or from an informed ellipsoidal region after an initial solution is found. Each extension rewires nearby nodes within an adaptive radius for cost optimization. Incremental connection attempts are made between trees to merge paths early. Efficient collision checks prevent invalid expansions. Path smoothing refines the solution before returning. The process halts upon time expiration or success, delivering an optimized, smooth, and low-cost path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []  # Child nodes list\n        self.valid = True               # For collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...] (W,H) or (W,H,D)\n        start_pos = map.start                  # Tuple[float, ...]\n        goal_pos = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles (rectangular)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning constant\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees from start and goal\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n        iteration = 0\n        success_state = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iteration += 1\n\n            # Sample point for tree extension\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            # Extend the chosen tree\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicate connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # After max iterations or timeout, return best found path if any\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.52708,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1634.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01539454460144043,
                    "num_nodes_avg": 62.4,
                    "path_length_avg": 162.07334389473203,
                    "smoothness_avg": 0.038528230647502874,
                    "success_improvement": 0.0,
                    "time_improvement": 35.07200267075055,
                    "length_improvement": 11.16503199481564,
                    "smoothness_improvement": 503.05047502538207,
                    "objective_score": 15.269859575315202
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.060103225708007815,
                    "num_nodes_avg": 246.0,
                    "path_length_avg": 235.23042013392615,
                    "smoothness_avg": 0.11139777289001798,
                    "success_improvement": 0.0,
                    "time_improvement": 74.94175070734124,
                    "length_improvement": 21.473315027065336,
                    "smoothness_improvement": 2766.3449330327885,
                    "objective_score": 40.60891288277938
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0526397705078125,
                    "num_nodes_avg": 220.7,
                    "path_length_avg": 123.26986202793978,
                    "smoothness_avg": 0.13625179478905936,
                    "success_improvement": 0.0,
                    "time_improvement": 49.70300728756376,
                    "length_improvement": 18.13002712108873,
                    "smoothness_improvement": 1633.1127726554907,
                    "objective_score": 26.702471473764327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines a bidirectional RRT* framework with adaptive neighborhood rewiring, informed ellipsoidal sampling after initial solution, goal-biased sampling, incremental connection attempts, recursive cost propagation in the tree, and randomized path smoothing. It enforces strict 30-second time limits, robust collision checking for nodes and edges, and adaptive neighbor radius for balancing exploration and exploitation to improve planning efficiency, path quality, robustness, and smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions with goal-biased and informed sampling. Each new node is connected with lowest cost parent from neighbors found with an adaptive radius, followed by rewiring neighbors to reduce costs. Incremental connection attempts try to join the two trees progressively. Upon connection, the combined path is smoothed via randomized shortcutting. The algorithm terminates early if the time limit is exceeded or a sufficiently good path is found, immediately returning the best solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # Collision-free flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to children\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Rotation matrix aligning standard axis to vector direction (for informed sampling)\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                # Compute orthogonal vector k and Rodrigues formula components\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Informed sampling inside an ellipsoid between start and goal with current best cost c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best/2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                # Sample unit n-ball\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT* scaling)\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        # Rewire neighbors if cheaper path via new_node is found, with recursive cost update\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        # Extend tree towards target point, with rewiring and collision checks\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Incrementally connect new_node with the opposite tree by successive steps with rewiring\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        # Path smoothing by randomized shortcutting with collision checks\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached\n                if best_path_nodes:\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    # Rebuild edges from trees if needed\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n                else:\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n            iter_count += 1\n\n            # Select sample point respecting informed sampling after first solution\n            if informed_sampling_enabled:\n                sample = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node:\n                    # Build combined path\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                    # Remove duplicate joining node\n                    if path_from_goal and path_from_goal[0] == new_node.position:\n                        path_from_goal = path_from_goal[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    # Compute total cost of combined path\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    # Update edges to reflect current tree structure\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    # Early return with smoothed path if meaningful improvement\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node:\n                    path_from_goal = new_node.path_from_root()\n                    path_from_start = connect_node.path_from_root()\n                    if path_from_start and path_from_start[0] == new_node.position:\n                        path_from_start = path_from_start[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            grow_start = not grow_start\n\n        # Max iter reached - return best path if found\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            success_state = True\n        else:\n            path_smoothed = []\n            success_state = False\n\n        return PlannerResult(success_state, path_smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.0503,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01970551013946533,
                    "num_nodes_avg": 77.3,
                    "path_length_avg": 155.21948600660014,
                    "smoothness_avg": 0.04314336898114142,
                    "success_improvement": 0.0,
                    "time_improvement": 16.890083933565084,
                    "length_improvement": 14.921740109629011,
                    "smoothness_improvement": 575.2874118801233,
                    "objective_score": 10.927810261395944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05414080619812012,
                    "num_nodes_avg": 233.5,
                    "path_length_avg": 234.3512013169539,
                    "smoothness_avg": 0.09883281178837662,
                    "success_improvement": 0.0,
                    "time_improvement": 77.42760388254398,
                    "length_improvement": 21.76682357508114,
                    "smoothness_improvement": 2443.039433711886,
                    "objective_score": 39.79684304833885
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04749903678894043,
                    "num_nodes_avg": 216.4,
                    "path_length_avg": 124.7482991878453,
                    "smoothness_avg": 0.12755005669926972,
                    "success_improvement": 0.0,
                    "time_improvement": 54.614948276294115,
                    "length_improvement": 17.148119555091732,
                    "smoothness_improvement": 1522.4273064488602,
                    "objective_score": 27.42624492615088
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling, designed for improved planning efficiency, path quality, and robustness. It grows two trees alternately from start and goal, rewiring neighbors to optimize path cost dynamically, performs rigorous collision checks, applies path smoothing, and respects a strict 30-second time limit, returning the best feasible solution found.",
          "planning_mechanism": "The planning mechanism alternates expansions between start and goal trees by sampling points biased toward the opposite root, incrementally extends trees within step-size limits, rewires neighbors within an adaptive radius for cost minimization, attempts incremental tree connection with rewiring, and upon connection or timeout, reconstructs and smooths the combined path to achieve shorter, feasible, and smoother paths efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates to children recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions: tree_a expands next\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def valid_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def sample_free(from_root, to_root):\n            if random.random() < self.goal_sample_rate:\n                return to_root\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if valid_node(p):\n                    return p\n            return to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(near_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost and valid_edge(nb.position, new_pos):\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nb in neighbors:\n                    cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost and valid_edge(nb.position, new_pos):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for iter_idx in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached - return best found so far\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Compute total cost including connection edge\n                connection_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connection_cost < best_cost:\n                    best_cost = connection_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]  # Avoid duplicating connect node\n                    extracted_path = path_smoothing(combined, max_iters=100)\n                    success_state = True\n                # Optionally break early on first found path for speed\n                break\n\n            # Swap trees to alternate expansions\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timed out or loop ended without early break but have best connection, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined, max_iters=100)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.60906,
          "time_improvement": 50.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1438.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018255233764648438,
                    "num_nodes_avg": 86.9,
                    "path_length_avg": 158.6310064628254,
                    "smoothness_avg": 0.03500431078560962,
                    "success_improvement": 0.0,
                    "time_improvement": 23.006766370665183,
                    "length_improvement": 13.051831688570914,
                    "smoothness_improvement": 447.89347687229304,
                    "objective_score": 11.751863633275203
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.044417715072631835,
                    "num_nodes_avg": 265.0,
                    "path_length_avg": 239.7954843297636,
                    "smoothness_avg": 0.1051344353301448,
                    "success_improvement": 0.0,
                    "time_improvement": 81.48135704550045,
                    "length_improvement": 19.949365200407478,
                    "smoothness_improvement": 2605.1847463175554,
                    "objective_score": 41.4602038853194
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05558626651763916,
                    "num_nodes_avg": 281.0,
                    "path_length_avg": 126.12447201816266,
                    "smoothness_avg": 0.10695029455126903,
                    "success_improvement": 0.0,
                    "time_improvement": 46.887647590821175,
                    "length_improvement": 16.23413108750312,
                    "smoothness_improvement": 1260.3998524425672,
                    "objective_score": 23.61511975695981
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.46582,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1244.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019983816146850585,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 170.2199533723818,
                    "smoothness_avg": 0.03191661323621712,
                    "success_improvement": 0.0,
                    "time_improvement": 15.716301131147329,
                    "length_improvement": 6.6997462488276955,
                    "smoothness_improvement": 399.5643051817539,
                    "objective_score": 8.052661115018507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05431396961212158,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 236.52350437862407,
                    "smoothness_avg": 0.08310278940495856,
                    "success_improvement": 0.0,
                    "time_improvement": 77.35540855616505,
                    "length_improvement": 21.04164628681887,
                    "smoothness_improvement": 2038.2946279093733,
                    "objective_score": 37.606424963760155
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03142735958099365,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 125.86434766351888,
                    "smoothness_avg": 0.10952251178835211,
                    "success_improvement": 0.0,
                    "time_improvement": 69.97134180929318,
                    "length_improvement": 16.406893298066827,
                    "smoothness_improvement": 1293.1182658369369,
                    "objective_score": 30.738372531586002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation uses a bidirectional RRT* algorithm that simultaneously grows two trees from the start and goal positions, respectively. The planner incrementally extends each tree by sampling points with a goal bias, steering toward samples by a fixed step size, and choosing minimum cost parents from nearby neighbors while enforcing collision-free constraints. It dynamically rewires neighbors to optimize path costs. The algorithm attempts to connect the two trees at each iteration, returning the shortest found path upon connection or when the 30-second time limit expires. Finally, path smoothing via random shortcutting reduces unnecessary waypoints, improving path length and smoothness.",
          "planning_mechanism": "The planner alternately grows two search trees bidirectionally from start and goal, performing nearest neighbor queries and neighborhood rewiring for cost optimization. New nodes are added if collision-free, and trees are connected when possible to find paths faster. Rewiring and adaptive neighbor radius enhance path quality. The planning process respects map bounds and obstacles, employing collision checks on nodes and edges. Early termination occurs if a valid path is found or when time limits expire, ensuring efficiency and practical usability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # float\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_constant: float = 30.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        edges = []\n        connection_found = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        start_time = time.time()\n\n        def swap_trees():\n            nonlocal start_tree, goal_tree\n            start_tree, goal_tree = goal_tree, start_tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            dims = len(bounds)\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    yield goal_position\n                else:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        yield point\n\n        sample_iterator = sample_free()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            sample = next(sample_iterator)\n\n            # Extend start_tree towards sample\n            nearest_start = self._nearest(start_tree, sample)\n            new_pos_start = self._steer(nearest_start.position, sample)\n\n            if not self._in_bounds(new_pos_start, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_start, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d):\n                continue\n\n            # Find neighbors in start_tree for rewiring\n            neighbor_radius_start = self._adaptive_radius(len(start_tree))\n            neighbors_start = self._near_nodes(start_tree, new_pos_start, neighbor_radius_start)\n\n            # Choose best parent in start_tree\n            min_cost_start = nearest_start.cost + dist(nearest_start.position, new_pos_start)\n            best_parent_start = nearest_start\n            for neighbor in neighbors_start:\n                cost = neighbor.cost + dist(neighbor.position, new_pos_start)\n                if cost < min_cost_start and not self._is_edge_in_obstacle(neighbor.position, new_pos_start, obstacles, is_3d):\n                    min_cost_start = cost\n                    best_parent_start = neighbor\n\n            new_start_node = Node(new_pos_start)\n            best_parent_start.add_child(new_start_node)\n            new_start_node.cost = min_cost_start\n            start_tree.append(new_start_node)\n            edges.append((best_parent_start, new_start_node))\n\n            # Rewire neighbors in start_tree through new_start_node\n            for neighbor in neighbors_start:\n                if neighbor is best_parent_start:\n                    continue\n                new_cost = new_start_node.cost + dist(new_start_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_start_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_start_node, new_cost)\n                    edges.append((new_start_node, neighbor))\n\n            # Extend goal_tree towards new_start_node.position to attempt connection\n            nearest_goal = self._nearest(goal_tree, new_start_node.position)\n            new_pos_goal = self._steer(nearest_goal.position, new_start_node.position)\n\n            if not self._in_bounds(new_pos_goal, bounds):\n                pass  # don't connect if out of bounds\n            elif self._is_in_obstacle(new_pos_goal, obstacles, is_3d):\n                pass  # skip if in obstacle\n            elif self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d):\n                pass  # skip if edge collides\n            else:\n                neighbor_radius_goal = self._adaptive_radius(len(goal_tree))\n                neighbors_goal = self._near_nodes(goal_tree, new_pos_goal, neighbor_radius_goal)\n\n                min_cost_goal = nearest_goal.cost + dist(nearest_goal.position, new_pos_goal)\n                best_parent_goal = nearest_goal\n                for neighbor in neighbors_goal:\n                    cost = neighbor.cost + dist(neighbor.position, new_pos_goal)\n                    if cost < min_cost_goal and not self._is_edge_in_obstacle(neighbor.position, new_pos_goal, obstacles, is_3d):\n                        min_cost_goal = cost\n                        best_parent_goal = neighbor\n\n                new_goal_node = Node(new_pos_goal)\n                best_parent_goal.add_child(new_goal_node)\n                new_goal_node.cost = min_cost_goal\n                goal_tree.append(new_goal_node)\n                edges.append((best_parent_goal, new_goal_node))\n\n                # Rewire neighbors in goal_tree through new_goal_node\n                for neighbor in neighbors_goal:\n                    if neighbor is best_parent_goal:\n                        continue\n                    new_cost = new_goal_node.cost + dist(new_goal_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_goal_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_goal_node, new_cost)\n                        edges.append((new_goal_node, neighbor))\n\n                # Check if we can connect new_start_node and new_goal_node\n                if dist(new_start_node.position, new_goal_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_start_node.position, new_goal_node.position, obstacles, is_3d):\n                        cost_to_connect = new_start_node.cost + dist(new_start_node.position, new_goal_node.position) + new_goal_node.cost\n                        if cost_to_connect < best_cost:\n                            best_cost = cost_to_connect\n                            best_start_node = new_start_node\n                            best_goal_node = new_goal_node\n                            connection_found = True\n\n            if connection_found:\n                break\n\n            # Swap trees for balanced growth\n            swap_trees()\n\n        success_state = connection_found\n        extracted_path = []\n\n        if success_state and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            path_goal.reverse()  # reverse to goal root\n            # Concatenate paths avoiding duplication of connection point\n            full_path = path_start + path_goal[1:]\n            extracted_path = self._path_smoothing(full_path, obstacles, is_3d)\n        else:\n            # If no connection found, return best path among both trees' closest nodes to goal\n            # Find closest node in start_tree to goal and in goal_tree to start, pick shorter path\n            def best_approx_path(tree, target_pos):\n                best_node = min(tree, key=lambda n: dist(n.position, target_pos))\n                return best_node.path_from_root(), best_node.cost, best_node\n\n            start_path, start_cost, _ = best_approx_path(start_tree, goal_position)\n            goal_path, goal_cost, _ = best_approx_path(goal_tree, start_position)\n\n            # Pick the path with smaller heuristic cost to goal or start respectively\n            if start_cost + dist(start_path[-1], goal_position) < goal_cost + dist(goal_path[-1], start_position):\n                approx_path = start_path\n            else:\n                approx_path = goal_path[::-1]\n\n            extracted_path = self._path_smoothing(approx_path, obstacles, is_3d)\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree,\n            edges=edges\n        )\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _adaptive_radius(self, n_nodes):\n        # Algorithm adapts neighbor radius proportional to (log n / n)^{1/d} with constant scaling\n        if n_nodes <= 1:\n            return self.neighbor_radius_constant\n        dim = len(bounds) if hasattr(self, 'bounds') else 2  # fallback dim=2\n        gamma_rrt_star = self.neighbor_radius_constant\n        radius = min(gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim), self.step_size * 50)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_iterations=150):\n        if len(path) < 3:\n            return path[:]\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path",
          "objective": -25.04421,
          "time_improvement": 46.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1597.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024372053146362305,
                    "num_nodes_avg": 113.8,
                    "path_length_avg": 159.5915861709516,
                    "smoothness_avg": 0.04184470687683983,
                    "success_improvement": 0.0,
                    "time_improvement": -2.79151755143659,
                    "length_improvement": 12.52532272918742,
                    "smoothness_improvement": 554.9605298579069,
                    "objective_score": 4.442411929696042
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04618837833404541,
                    "num_nodes_avg": 284.8,
                    "path_length_avg": 242.9965020999087,
                    "smoothness_avg": 0.1070723847689884,
                    "success_improvement": 0.0,
                    "time_improvement": 80.74313175234548,
                    "length_improvement": 18.880773332545168,
                    "smoothness_improvement": 2655.0495812275612,
                    "objective_score": 41.27434209835048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041561317443847653,
                    "num_nodes_avg": 236.3,
                    "path_length_avg": 124.76782145766249,
                    "smoothness_avg": 0.13211293366663907,
                    "success_improvement": 0.0,
                    "time_improvement": 60.288404367526496,
                    "length_improvement": 17.135153793029748,
                    "smoothness_improvement": 1580.4667646772543,
                    "objective_score": 29.415885892250166
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias and adaptive neighbor radius. It grows two trees from start and goal simultaneously, performing incremental extensions and rewiring steps to optimize path costs dynamically. The planner includes robust collision checks on nodes and edges, enforces boundary constraints, applies a 30-second maximum planning time limit, and performs path smoothing on the best found path, aiming for efficient planning, high-quality, and smooth paths with improved success rates.",
          "planning_mechanism": "The planner alternates expanding start and goal trees by sampling points with goal bias, extending trees toward samples with incremental steering and rewiring to minimize path costs, and tries to connect the two trees incrementally. If connection is made, the path is extracted, smoothed, and returned immediately. The process continuously updates best path within the time limit, and returns the best available solution if timeout or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs to maintain consistent cost tree\n        for c in self.children:\n            c.update_parent(self, self.cost + self._dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n        best_cost = math.inf\n        best_path = []\n        success_state = False\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos if grow_start_tree else start_pos\n            else:\n                sample_pt = sample_free()\n\n            # Extend and rewire tree\n            def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n                nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n                new_pos = steer(nearest_node.position, sample)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                # Choose best parent for new node to minimize cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for nbr in neighbors:\n                    if nbr == nearest_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors if better cost possible through new_node\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                return new_node\n\n            # Incremental connect tree to target pos\n            def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n                if not tree:\n                    return None\n                nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n                current = nearest\n                while True:\n                    new_pos = steer(current.position, target_pos)\n                    if not collision_free_node(new_pos):\n                        return None\n                    if not collision_free_edge(current.position, new_pos):\n                        return None\n\n                    n_nodes = len(tree)\n                    radius = adaptive_neighbor_radius(n_nodes + 1)\n                    neighbors = near_nodes(tree, new_pos, radius)\n\n                    min_cost = current.cost + dist(current.position, new_pos)\n                    best_parent = current\n                    for nbr in neighbors:\n                        if nbr == current:\n                            continue\n                        cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                        if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                            min_cost = cost_thru_nbr\n                            best_parent = nbr\n\n                    new_node = Node(new_pos)\n                    best_parent.add_child(new_node)\n                    new_node.cost = min_cost\n                    tree.append(new_node)\n\n                    for nbr in neighbors:\n                        if nbr is new_node.parent:\n                            continue\n                        cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                        if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                            nbr.update_parent(new_node, cost_thru_new)\n\n                    if dist(new_node.position, target_pos) <= self.step_size:\n                        if collision_free_edge(new_node.position, target_pos):\n                            return new_node\n                        else:\n                            return None\n                    current = new_node\n\n            # Path smoothing by shortcutting\n            def path_smoothing(path: list, trials: int = 150) -> list:\n                if len(path) < 3:\n                    return path[:]\n                for _ in range(trials):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if collision_free_edge(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                return path\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    # Combine paths\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    # Gather nodes and edges\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            # Check edge validity before adding\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached, return best found\n        smoothed = path_smoothing(best_path) if best_path else []\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                if self._is_edge_in_obstacle(node.position, c.position, obstacles, is_3d, resolution=self.step_size / 5) is False:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.90026,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025222420692443848,
                    "num_nodes_avg": 63.2,
                    "path_length_avg": 160.0580798305058,
                    "smoothness_avg": 0.04718916170306709,
                    "success_improvement": 0.0,
                    "time_improvement": -6.378025836696076,
                    "length_improvement": 12.269630162320688,
                    "smoothness_improvement": 638.6128535577737,
                    "objective_score": 3.7335825492441836
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05890662670135498,
                    "num_nodes_avg": 256.9,
                    "path_length_avg": 232.53460831884667,
                    "smoothness_avg": 0.10468998429038108,
                    "success_improvement": 0.0,
                    "time_improvement": 75.44063701267409,
                    "length_improvement": 22.373254605579614,
                    "smoothness_improvement": 2593.7487009392908,
                    "objective_score": 40.0755855296146
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03397202491760254,
                    "num_nodes_avg": 178.8,
                    "path_length_avg": 123.73967937037617,
                    "smoothness_avg": 0.11896354211628588,
                    "success_improvement": 0.0,
                    "time_improvement": 67.53992896960364,
                    "length_improvement": 17.817996812540226,
                    "smoothness_improvement": 1413.2074747438844,
                    "objective_score": 30.891615427108558
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* path planner combining adaptive neighbor radius, goal-biased sampling, incremental rewiring with collision checks, and path smoothing to efficiently find high-quality feasible paths within obstacles and bounded map environments. It alternates growing trees from start and goal, attempts to connect them incrementally, and returns the best path found within a time limit.",
          "planning_mechanism": "The planner maintains two trees growing towards each other with alternate expansions. Each iteration samples a point biased toward the goal or randomly in free space, extends the current tree toward the sample, rewires neighbors to optimize cost, then incrementally attempts to connect the two trees. Upon connection or time expiry, it extracts and smooths the path, ensuring nodes and edges are collision-free and positions stay within bounds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants cost\n        for c in self.children:\n            c.update_parent(self, new_cost + math.dist(self.position, c.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim)) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = math.inf\n        best_path = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, c_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connected_node = Node(next_pos)\n                best_parent.add_child(connected_node)\n                connected_node.cost = min_cost\n                other_tree.append(connected_node)\n\n                rewire(other_tree, connected_node, neighbors)\n\n                if dist(connected_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connected_node.position, new_node.position):\n                        return connected_node\n                    else:\n                        return None\n\n                curr_node = connected_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    return PlannerResult(True, path_smoothing(best_path), all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if grow_start_tree else start_pos\n            else:\n                sample = sample_free()\n\n            tree_current = tree_start if grow_start_tree else tree_goal\n            tree_other = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(tree_current, sample)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect_trees(new_node, tree_other)\n            if connect_node:\n\n                path_from_start = new_node.path_from_root() if grow_start_tree else connect_node.path_from_root()\n                path_from_goal = connect_node.path_from_root() if grow_start_tree else new_node.path_from_root()\n                if path_from_goal and path_from_start[-1] == path_from_goal[0]:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted_path = path_smoothing(best_path)\n                    return PlannerResult(True, extracted_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            return PlannerResult(True, path_smoothing(best_path), all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.70721,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025034070014953613,
                    "num_nodes_avg": 85.2,
                    "path_length_avg": 160.83205557163677,
                    "smoothness_avg": 0.04271756748555565,
                    "success_improvement": 0.0,
                    "time_improvement": -5.583638435076933,
                    "length_improvement": 11.845401794176341,
                    "smoothness_improvement": 568.622693831459,
                    "objective_score": 3.537102297469483
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05883321762084961,
                    "num_nodes_avg": 262.7,
                    "path_length_avg": 230.1373557782327,
                    "smoothness_avg": 0.09222740725247403,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47124274170076,
                    "length_improvement": 23.17352650472507,
                    "smoothness_improvement": 2273.0776173225318,
                    "objective_score": 38.641466210067904
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031036186218261718,
                    "num_nodes_avg": 169.8,
                    "path_length_avg": 124.8629660544588,
                    "smoothness_avg": 0.12460987105239034,
                    "success_improvement": 0.0,
                    "time_improvement": 70.34510566853544,
                    "length_improvement": 17.07196328213648,
                    "smoothness_improvement": 1485.0283620424839,
                    "objective_score": 31.943066167200346
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed and goal-biased sampling, adaptive neighborhood rewiring, incremental tree connection, and time-bounded execution. It balances fast convergence and path quality by dynamically rewiring nodes for cost optimization, alternating expansions from start and goal, and smoothing the resulting path for improved smoothness and shorter length while respecting obstacle constraints and map boundaries.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, alternately sampling points biased toward the goal or informed ellipsoidal region after a first solution. Each extension steers within a step size, checks collisions for nodes and edges, rewires neighbors to reduce costs, and attempts incremental connection between trees. When a connection is established or time limit is reached, it extracts, smooths, and returns the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            # RRT* radius scaling for dimension dim\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def clamp_to_bounds(pos):\n            return tuple(\n                max(0.0, min(bounds[d], pos[d])) for d in range(dim)\n            )\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                # fallback to identity if direction is aligned with x-axis\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta*cos_theta)\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        # Connect the new_node to opposite tree incrementally with rewiring\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    # Time limit reached \u2014 extract best path found so far\n                    if best_path:\n                        extracted_path_final = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path_final, all_nodes, edges)\n                    else:\n                        return PlannerResult(False, [], all_nodes, edges)\n\n                iter_count += 1\n                sample = None\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start_tree:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_goal)\n                    if connect_node:\n                        # Build path\n                        path_s = new_node.path_from_root()\n                        path_g = connect_node.path_from_root()\n\n                        # Avoid duplicate node position overlap in merged path\n                        if path_g and path_g[0] == new_node.position:\n                            path_g = path_g[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        # Update edges for all new nodes (maintain consistent edges)\n                        # Clear and re-build edges\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_start)\n                    if connect_node:\n                        path_g = new_node.path_from_root()\n                        path_s = connect_node.path_from_root()\n                        if path_s and path_s[0] == new_node.position:\n                            path_s = path_s[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                grow_start_tree = not grow_start_tree\n            break  # exit outer while if max_iter reached\n\n        # No complete connection found, try best path extraction\n        if best_path:\n            extracted_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            success_state = False\n            extracted_path = []\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.40163,
          "time_improvement": 45.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1453.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02057945728302002,
                    "num_nodes_avg": 65.5,
                    "path_length_avg": 156.83014571172365,
                    "smoothness_avg": 0.03866421328032622,
                    "success_improvement": 0.0,
                    "time_improvement": 13.204126390052256,
                    "length_improvement": 14.038912002714524,
                    "smoothness_improvement": 505.1788985200809,
                    "objective_score": 9.294914810158986
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04782705307006836,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 235.04300669404265,
                    "smoothness_avg": 0.09978280006234666,
                    "success_improvement": 0.0,
                    "time_improvement": 80.05993514249408,
                    "length_improvement": 21.535879027695216,
                    "smoothness_improvement": 2467.483316250031,
                    "objective_score": 40.66257292953742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059801268577575686,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 124.49733655203302,
                    "smoothness_avg": 0.1167675547851698,
                    "success_improvement": 0.0,
                    "time_improvement": 42.86023778552829,
                    "length_improvement": 17.314796988241735,
                    "smoothness_improvement": 1385.2746779830118,
                    "objective_score": 23.247404123221894
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* approach with adaptive neighbor radius, goal-biased sampling, and incremental extend-and-rewire steps to efficiently grow two trees from start and goal towards each other. It performs rigorous collision and edge checks, dynamically rewires nodes to optimize path cost, and applies path smoothing for better quality. The planning process enforces a strict 30-second runtime limit, returning the best feasible path found at timeout or successful connection.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the opposite tree root. New nodes are added with step size limits, parents chosen from neighbors within an adaptive radius to minimize cost, and rewiring performed to improve the tree structure. Incremental connections from one tree to the other attempt efficient merges. On successful connection or timeout, the combined path is extracted and smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= r_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            to_remove = []\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            to_remove.append((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            for e in to_remove:\n                edges.remove(e)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined, max_iters=100)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined, max_iters=100)\n            success_state = True\n\n        return type('PlannerResult', (), {})() if False else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.38696,
          "time_improvement": 44.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018783712387084962,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 153.71064836573322,
                    "smoothness_avg": 0.04239088328876562,
                    "success_improvement": 0.0,
                    "time_improvement": 20.77785609923607,
                    "length_improvement": 15.748757929650598,
                    "smoothness_improvement": 563.5093767456073,
                    "objective_score": 12.200655299428979
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05699787139892578,
                    "num_nodes_avg": 298.5,
                    "path_length_avg": 243.06794856753677,
                    "smoothness_avg": 0.10890286053066733,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23643566812932,
                    "length_improvement": 18.856922445178366,
                    "smoothness_improvement": 2702.14904101396,
                    "objective_score": 40.15306039454427
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06685750484466553,
                    "num_nodes_avg": 274.5,
                    "path_length_avg": 123.54875955604457,
                    "smoothness_avg": 0.1082207456314781,
                    "success_improvement": 0.0,
                    "time_improvement": 36.11804532003545,
                    "length_improvement": 17.944796662594666,
                    "smoothness_improvement": 1276.5598964078824,
                    "objective_score": 20.80717241056898
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius, goal biasing, and informed sampling after finding an initial solution. It grows two trees from start and goal, alternately extending toward sampled points while rewiring locally to optimize path cost. Incremental tree connection attempts link the trees more smoothly. The planner applies path smoothing via random shortcutting to improve smoothness and path length. It respects map boundaries and obstacles using efficient collision checks and enforces a 30-second planning time limit.",
          "planning_mechanism": "The planner grows start and goal trees alternately, sampling points biased towards goal and an ellipsoidal informed region once a feasible path is found. Each tree extends toward the sample with step-size limited moves and rewiring in a dynamically sized neighborhood to reduce cost. Incremental connect attempts progressively extend one tree toward the other, rewiring along the way for better path cost. Once connected, the combined path is smoothed and returned early or upon timeout returns the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 30.0\n            r = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(10.0, min(30.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= radius_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree)+1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Rotation matrix for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.2:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_uniform()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        # Update edges and nodes\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # timeout or no path found\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = start_tree + goal_tree\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.01238,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1320.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020772933959960938,
                    "num_nodes_avg": 74.8,
                    "path_length_avg": 156.27132570498082,
                    "smoothness_avg": 0.03790982453400855,
                    "success_improvement": 0.0,
                    "time_improvement": 12.388119584464997,
                    "length_improvement": 14.345210103479932,
                    "smoothness_improvement": 493.3710764588266,
                    "objective_score": 9.052333278329618
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0604996919631958,
                    "num_nodes_avg": 270.5,
                    "path_length_avg": 232.94389614083244,
                    "smoothness_avg": 0.08778471754963123,
                    "success_improvement": 0.0,
                    "time_improvement": 74.7764559142316,
                    "length_improvement": 22.236622549904006,
                    "smoothness_improvement": 2158.764011328336,
                    "objective_score": 37.674081340891966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052280592918396,
                    "num_nodes_avg": 215.1,
                    "path_length_avg": 122.25503846353101,
                    "smoothness_avg": 0.11063049750459705,
                    "success_improvement": 0.0,
                    "time_improvement": 50.046199372617984,
                    "length_improvement": 18.804024611863845,
                    "smoothness_improvement": 1307.2117623645743,
                    "objective_score": 25.310723545981038
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a time-limited bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius tuning. It combines goal-biased sampling with ellipsoidal informed sampling to focus exploration progressively, uses rewiring within a dynamically chosen neighbor radius to optimize path cost locally, and alternates growth between two trees starting from start and goal positions. Collision-free nodes and edges are guaranteed for safe and feasible path expansion. The algorithm stops early either upon a successful connection or exceeding the 30-second execution limit, returning the best found path with smoothing applied for improved smoothness and quality.",
          "planning_mechanism": "The planner grows two RRT* trees from start and goal alternately, sampling with a bias towards the goal and inside an ellipsoidal informed subset after the first feasible solution to accelerate convergence. Each extension steers toward a sampled point, rewires neighbors to optimize cost, and attempts incremental connection to the opposite tree with rewiring. Paths are merged on successful connection, smoothed for smoothness, and returned immediately. Execution time is tracked and enforced with early termination, returning the best feasible path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0     # Enforced 30 sec time limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=resolution)\n\n        # Unit ball sample for uniform direction sampling in nD\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        informed_sampling_enabled = False\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct rotation matrix to align x-axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Use Householder transform to rotate direction to x-axis\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    # Compute rotation matrix R that aligns x-axis with \"direction\"\n                    # Approach: compute orthonormal basis with \"direction\" as first vector\n                    ux, uy, uz = direction\n                    # Construct an arbitrary orthogonal basis:\n                    if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                        # direction close to z-axis:\n                        vx_, vy_, vz_ = 1,0,0\n                    else:\n                        vx_, vy_, vz_ = -uy, ux, 0\n                    norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                    vx_ /= norm_v_\n                    vy_ /= norm_v_\n                    vz_ /= norm_v_\n                    wx = uy * vz_ - uz * vy_\n                    wy = uz * vx_ - ux * vz_\n                    wz = ux * vy_ - uy * vx_\n\n                    R = [\n                        [ux, vx_, wx],\n                        [uy, vy_, wy],\n                        [uz, vz_, wz]\n                    ]\n\n            # Radii of prolate hyperspheroid\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        # Adaptive neighbor radius for rewiring (following RRT* theory)\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return 50.0  # large initial radius\n            gamma_rrt = 30.0\n            return max(5.0, min(30.0, gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp(next_pos)\n\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # time limit exceeded: return best path so far\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_goal)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    # Make sure to remove duplicate connecting node\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    # Refresh edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_start)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached - return best path if any\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.98338,
          "time_improvement": 49.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1290.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02227151393890381,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 176.73650863221073,
                    "smoothness_avg": 0.04163013462817498,
                    "success_improvement": 0.0,
                    "time_improvement": 6.067711973228136,
                    "length_improvement": 3.1279190494893707,
                    "smoothness_improvement": 551.6020082152062,
                    "objective_score": 5.203907442942346
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04452013969421387,
                    "num_nodes_avg": 216.7,
                    "path_length_avg": 234.6283220155596,
                    "smoothness_avg": 0.08281404133923359,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43865415108714,
                    "length_improvement": 21.674312709409516,
                    "smoothness_improvement": 2030.8649322014446,
                    "objective_score": 38.92078344821527
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04296309947967529,
                    "num_nodes_avg": 221.2,
                    "path_length_avg": 122.72804706569131,
                    "smoothness_avg": 0.1091637086355884,
                    "success_improvement": 0.0,
                    "time_improvement": 58.94900983445225,
                    "length_improvement": 18.489874820558175,
                    "smoothness_improvement": 1288.5543162178765,
                    "objective_score": 27.825449495536688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner with incremental rewiring, goal-biased sampling, collision checking for nodes and edges, adaptive neighbor radius, and early termination on time limit or successful connection. It balances exploration and exploitation to efficiently find lower-cost, smoother paths in 2D or 3D bounded spaces with obstacles.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions alternately, sampling nodes biased toward the goal and informed by an adaptive ellipsoidal region after an initial path is found. It extends each tree by steering towards sampled points, rewires neighbors to optimize path costs, attempts incremental connection between trees, performs collision checks for nodes and edges, applies shortcut smoothing to the final path, and terminates within a 30-second time budget, returning the best discovered path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # alternate growth\n        success_state = False\n        extracted_path = []\n        best_connection = None\n        best_cost = float('inf')\n        c_best = math.dist(start_pos, goal_pos)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n        use_informed_sampling = False\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_pos, goal_pos)])\n            M = np.outer(a1, np.array([1.0] + [0] * (dim - 1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1 / dim)\n            r_vec = r * z_unit\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_best ** 2, 0)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2] * (dim - 1))\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback if no free sample found\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.96468,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1343.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020919609069824218,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 162.1552476112867,
                    "smoothness_avg": 0.036750846642726535,
                    "success_improvement": 0.0,
                    "time_improvement": 11.769502964875004,
                    "length_improvement": 11.12013926992458,
                    "smoothness_improvement": 475.23055569949014,
                    "objective_score": 8.131031521944868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05067124366760254,
                    "num_nodes_avg": 285.6,
                    "path_length_avg": 236.9991428088577,
                    "smoothness_avg": 0.09505745680222014,
                    "success_improvement": 0.0,
                    "time_improvement": 78.87413461033807,
                    "length_improvement": 20.882864488313764,
                    "smoothness_improvement": 2345.896830639797,
                    "objective_score": 39.56829743396317
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05418672561645508,
                    "num_nodes_avg": 285.8,
                    "path_length_avg": 122.85691426491363,
                    "smoothness_avg": 0.10293133869600272,
                    "success_improvement": 0.0,
                    "time_improvement": 48.22490073285691,
                    "length_improvement": 18.404287362831315,
                    "smoothness_improvement": 1209.279030612043,
                    "objective_score": 24.194722845483554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive rewiring, goal-biased sampling, incremental tree extension, and comprehensive collision checks in 2D or 3D environments. It grows two trees alternately from start and goal, steering toward sampled points with goal bias, dynamically rewiring neighbors for cost optimization, and attempting to connect both trees. A 30-second time limit ensures timely termination, returning the best feasible path found with path smoothing to enhance path quality and smoothness.",
          "planning_mechanism": "The planner alternates expansion between two trees grown from start and goal, samples points biased toward the opposing tree root to focus search, extends trees incrementally with steering and collision checks, rewires neighbors to maintain minimal cost paths, attempts to connect trees upon each extension, and extracts plus smooths the path from the best connection found within a fixed time budget.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.children: List[Node] = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node:'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node:'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent:'Node', new_cost:float):\n        # Remove from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs to maintain consistent path cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_pos, None, 0.0)]\n        tree_goal: List[Node] = [Node(goal_pos, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from: List[Node], tree_to: List[Node]) -> Tuple[float, ...]:\n            # Biased sampling: with probability sample towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to[0].position\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to[0].position  # fallback\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.neighbor_radius_max\n            r = gamma * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= r_sq]\n\n        def try_extend(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(nodes)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, target_pos)\n            dist = math.dist(nearest_node.position, target_pos)\n            if dist <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_node.position, target_pos, obstacles, is_3d):\n                    # Confirm node not inside obstacle\n                    if not self._is_in_obstacle(target_pos, obstacles, is_3d):\n                        # Add new connecting node if not same position\n                        if nearest_node.position == target_pos:\n                            return nearest_node\n                        new_node = Node(target_pos)\n                        n_nodes = len(nodes)\n                        radius = adaptive_radius(n_nodes)\n                        neighbors = near_nodes(tree, target_pos, radius)\n\n                        min_cost = nearest_node.cost + dist\n                        best_parent = nearest_node\n                        for neighbor in neighbors:\n                            cost_try = neighbor.cost + math.dist(neighbor.position, target_pos)\n                            if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, target_pos, obstacles, is_3d):\n                                min_cost = cost_try\n                                best_parent = neighbor\n\n                        best_parent.add_child(new_node)\n                        new_node.cost = min_cost\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((best_parent, new_node))\n\n                        # Rewire neighbors\n                        for neighbor in neighbors:\n                            if neighbor == best_parent:\n                                continue\n                            cost_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                            if cost_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                                if neighbor.parent:\n                                    try:\n                                        edges.remove((neighbor.parent, neighbor))\n                                        neighbor.parent.remove_child(neighbor)\n                                    except ValueError:\n                                        pass\n                                neighbor.update_parent(new_node, cost_new)\n                                edges.append((new_node, neighbor))\n                        return new_node\n                    else:\n                        return None\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters: int=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(p[i], p[j], obstacles, is_3d):\n                    p = p[:i + 1] + p[j:]\n                    length = len(p)\n            return p\n\n        start_time = time.time()\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]  # Avoid duplicate node\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no early found path but a best connection exists from previous attempts\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.58518,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1417.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024649524688720705,
                    "num_nodes_avg": 105.4,
                    "path_length_avg": 166.91945521918504,
                    "smoothness_avg": 0.040141717194436294,
                    "success_improvement": 0.0,
                    "time_improvement": -3.961780915999072,
                    "length_improvement": 8.508801586334897,
                    "smoothness_improvement": 528.305043227006,
                    "objective_score": 3.154751258602288
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05258700847625732,
                    "num_nodes_avg": 251.6,
                    "path_length_avg": 232.81072027790407,
                    "smoothness_avg": 0.10563858396811202,
                    "success_improvement": 0.0,
                    "time_improvement": 78.07541355009758,
                    "length_improvement": 22.281080486204168,
                    "smoothness_improvement": 2618.1568538960382,
                    "objective_score": 40.9696244317503
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04286239147186279,
                    "num_nodes_avg": 263.3,
                    "path_length_avg": 125.02145416728165,
                    "smoothness_avg": 0.09472155685278838,
                    "success_improvement": 0.0,
                    "time_improvement": 59.04523574665066,
                    "length_improvement": 16.966703023992473,
                    "smoothness_improvement": 1104.8512115494175,
                    "objective_score": 26.63116738654078
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius based on node count and dimensionality, and incremental extend-and-rewire expansions for cost optimization. It incorporates goal bias and ellipsoidal informed sampling after the first feasible path is found to focus node sampling in promising regions. Collision checks ensure that nodes and edges are free of obstacles before integration. The algorithm applies path smoothing to refine the final solution and enforces a strict 30-second planning time limit, returning the best smooth path found.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternating expansions towards randomly sampled points with a goal bias. After an initial solution is discovered, informed ellipsoidal sampling directs exploration within a dynamically shrinking sampling region. Each new node selects a parent from neighbors minimizing path cost, with rewiring to optimize nearby nodes. Incremental connection attempts merge the trees efficiently. The process halts on timeout or path success, outputting an optimized, smooth path and tree structures.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = None            # Node or None\n        self.cost = cost              # float, cost from root\n        self.children = []\n        self.valid = True             # collision validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' cost\n        for child in self.children:\n            dist_child = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 35.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 6)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            rsq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= rsq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials=120) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_tree_start = True\n        iteration = 0\n        success_state = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iteration += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # Time expired or max iteration reached without new feasible solution:\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.45919,
          "time_improvement": 43.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1470.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024570059776306153,
                    "num_nodes_avg": 76.8,
                    "path_length_avg": 165.5423396159319,
                    "smoothness_avg": 0.042320651547462965,
                    "success_improvement": 0.0,
                    "time_improvement": -3.6266298768096257,
                    "length_improvement": 9.26362047027112,
                    "smoothness_improvement": 562.4100974835534,
                    "objective_score": 3.5767856184291036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03827869892120361,
                    "num_nodes_avg": 164.2,
                    "path_length_avg": 237.3758446423225,
                    "smoothness_avg": 0.10033007531393567,
                    "success_improvement": 0.0,
                    "time_improvement": 84.04083692901777,
                    "length_improvement": 20.757110573542125,
                    "smoothness_improvement": 2481.565102659847,
                    "objective_score": 41.77149870671299
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.053995156288146974,
                    "num_nodes_avg": 233.4,
                    "path_length_avg": 122.89180984088978,
                    "smoothness_avg": 0.11526273346024477,
                    "success_improvement": 0.0,
                    "time_improvement": 48.40794410513774,
                    "length_improvement": 18.38111138281672,
                    "smoothness_improvement": 1366.1334618043215,
                    "objective_score": 25.02927281712627
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner that grows two trees from start and goal positions simultaneously, using goal-biased sampling and rewiring to improve path quality. It performs collision checks for nodes and edges, adapts neighbor selection dynamically, and attempts incremental connections between trees. Planning terminates early if a path is found or when a 30-second time limit is reached, returning the best path found with smoothing for path quality.",
          "planning_mechanism": "The planner alternates growth between start and goal trees by sampling with a goal bias, steering towards sampled points within bounds, and rewiring neighbors to reduce cost. It incrementally tries to connect the two trees while ensuring collision-free edges. When connected, it combines and smooths the path. If time expires, it returns the best solution found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position      # 2D or 3D tuple\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children: List[Node] = []\n        self.valid = True             # Validity flag\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for c in self.children:\n            dist = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Utility functions\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = tuple(max(0.0, min(bounds[d], next_pos[d])) for d in range(dim))\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                rewire(other_tree, new_connect_node, neighbors)\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_planning_time:\n                # Time limit exceeded\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if grow_start else start_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        break\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                    # Rebuild edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path)\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.15036,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1485.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027719449996948243,
                    "num_nodes_avg": 97.0,
                    "path_length_avg": 169.02153344580506,
                    "smoothness_avg": 0.035920387588157424,
                    "success_improvement": 0.0,
                    "time_improvement": -16.909491119452742,
                    "length_improvement": 7.356619200763384,
                    "smoothness_improvement": 462.23206812478253,
                    "objective_score": -1.2903631550592327
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05424120426177979,
                    "num_nodes_avg": 251.5,
                    "path_length_avg": 238.44224799201925,
                    "smoothness_avg": 0.10659538648665523,
                    "success_improvement": 0.0,
                    "time_improvement": 77.38574590107878,
                    "length_improvement": 20.401114440694847,
                    "smoothness_improvement": 2642.776071855153,
                    "objective_score": 40.50982701773837
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036684513092041016,
                    "num_nodes_avg": 181.4,
                    "path_length_avg": 120.52960811595942,
                    "smoothness_avg": 0.11410709817953761,
                    "success_improvement": 0.0,
                    "time_improvement": 64.94816239033914,
                    "length_improvement": 19.94997329255693,
                    "smoothness_improvement": 1351.4338663338497,
                    "objective_score": 30.231612707282373
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal-biased and informed ellipsoidal sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and rigorous collision checks. It dynamically grows two trees from start and goal, alternately sampling and extending while rewiring locally to optimize path cost. The planner enforces map bounds and obstacle constraints in 2D/3D environments and terminates after finding a feasible path or upon a hard 30-second timeout, returning the best path with smoothing applied to enhance path quality and smoothness.",
          "planning_mechanism": "The planning mechanism grows two trees bidirectionally aiming to connect start and goal efficiently. Sampling combines uniform, goal bias, and informed ellipsoidal strategies focusing exploration on promising regions. New nodes are added by steering towards samples, validated by collision checks, and rewired in a neighborhood with adaptive radius. Incremental connection attempts between the two trees bridge them progressively. Upon successful connection or timeout, the path is extracted and improved through collision-safe shortcut smoothing, ensuring a robust, efficient, and smooth solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=30.0, max_planning_time: float=30.0,\n                 smoothing_iterations: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 25.0\n            r = gamma * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def collision_node_free(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:  # 3D\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            return goal_position\n\n        def rewire(tree, new_node, neighbors, edges):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree, sample_pt, nodes, edges):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors, edges)\n            return new_node\n\n        def try_connect(new_node, other_tree, nodes, edges):\n            if not other_tree:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors, edges)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n        informed_sampling_enabled = False\n\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_pt, nodes, edges)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_goal, nodes, edges)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample_pt, nodes, edges)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_start, nodes, edges)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iteration reached\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_iterations)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.01377,
          "time_improvement": 43.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1376.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02363123893737793,
                    "num_nodes_avg": 85.2,
                    "path_length_avg": 166.15928304004447,
                    "smoothness_avg": 0.036672179991164,
                    "success_improvement": 0.0,
                    "time_improvement": 0.33293882110897616,
                    "length_improvement": 8.92546400342086,
                    "smoothness_improvement": 473.9992517751683,
                    "objective_score": 4.254970705892706
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.044646406173706056,
                    "num_nodes_avg": 237.9,
                    "path_length_avg": 236.0175755014033,
                    "smoothness_avg": 0.09890766255625752,
                    "success_improvement": 0.0,
                    "time_improvement": 81.38601110434297,
                    "length_improvement": 21.21053990839047,
                    "smoothness_improvement": 2444.9653978822903,
                    "objective_score": 40.88273830239244
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.054766273498535155,
                    "num_nodes_avg": 276.0,
                    "path_length_avg": 123.77993803653915,
                    "smoothness_avg": 0.10289381160970752,
                    "success_improvement": 0.0,
                    "time_improvement": 47.67114612260147,
                    "length_improvement": 17.79125892338645,
                    "smoothness_improvement": 1208.8016888443296,
                    "objective_score": 23.90360406567938
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius and informed sampling after a first solution is found. It alternates growing two trees from start and goal, incrementally extending and rewiring nodes to minimize path cost, while maintaining strict collision checks and clamping positions within bounds. The planner applies path smoothing on the extracted path, and enforces a 30-second runtime limit to ensure timely return of the best found path.",
          "planning_mechanism": "The planner grows two trees alternatively, sampling points with goal bias and later focused informed sampling inside an ellipsoidal subset defined by the best path cost. Each iteration extends one tree towards the sample with a step-size constrained steer, rewires locally to improve costs, then incrementally attempts to connect the other tree. Upon successful connection or timeout, the best path is extracted, smoothed, and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=8.0, neighbor_radius_max=30.0,\n                 max_planning_time=30.0, smoothing_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import time\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def propagate_costs(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-10 < child.cost:\n                    child.cost = new_cost\n                    propagate_costs(child)\n\n        self._propagate_costs = propagate_costs\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    propagate_costs(nbr)\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr_node = connect_node\n\n        def path_smooth(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i+2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        iter_count = 0\n        grow_start = True\n        success_state = False\n        extracted_path = []\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = try_connect(new_node, other_tree)\n\n            if connect_node:\n                path_s = new_node.path_from_root()\n                path_g = connect_node.path_from_root()\n                if path_g and path_g[0] == new_node.position:\n                    path_g = path_g[1:]\n                combined = path_s + path_g[::-1]\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined\n                    informed_enabled = True\n\n                # Update all_nodes and edges\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for child in node.children:\n                        if collision_free_edge(node.position, child.position):\n                            edges.append((node, child))\n\n                extracted_path = path_smooth(best_path, self.smoothing_trials)\n                success_state = True\n                # Early exit on first valid path found\n                break\n\n            grow_start = not grow_start\n\n        if not success_state and best_path:\n            extracted_path = path_smooth(best_path, self.smoothing_trials)\n            success_state = True\n        elif not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.619,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1329.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02542247772216797,
                    "num_nodes_avg": 66.4,
                    "path_length_avg": 158.04188338762918,
                    "smoothness_avg": 0.04257911968298753,
                    "success_improvement": 0.0,
                    "time_improvement": -7.221785923656363,
                    "length_improvement": 13.374739381338483,
                    "smoothness_improvement": 566.4556850770527,
                    "objective_score": 3.340690524556052
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04310841560363769,
                    "num_nodes_avg": 240.3,
                    "path_length_avg": 237.46317982130995,
                    "smoothness_avg": 0.08844010205024158,
                    "success_improvement": 0.0,
                    "time_improvement": 82.02723045090121,
                    "length_improvement": 20.727955576992372,
                    "smoothness_improvement": 2175.6275265834156,
                    "objective_score": 39.631897883585914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05217833518981933,
                    "num_nodes_avg": 248.4,
                    "path_length_avg": 123.3226961463844,
                    "smoothness_avg": 0.10569638778892007,
                    "success_improvement": 0.0,
                    "time_improvement": 50.14390603393877,
                    "length_improvement": 18.094937215308175,
                    "smoothness_improvement": 1244.450250979258,
                    "objective_score": 24.884410508139553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* algorithm combining goal-biased and informed ellipsoidal sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and rigorous collision checks. It alternates growth between start and goal trees, dynamically rewires nodes for optimal path cost, and performs path smoothing on solutions. The planner enforces bounds and obstacle constraints in 2D/3D, and respects a strict 30-second runtime limit, returning the best feasible path when timed out.",
          "planning_mechanism": "The planner grows two trees bidirectionally with adaptive and informed sampling to efficiently explore promising regions. New nodes are connected with collision-free edges and rewired locally for cost optimization. Incremental attempts connect the trees as soon as possible. Once a connection is found or time expires, the path is extracted and smoothed via collision-safe shortcuts, yielding a high-quality, smooth path with minimized length, ensuring robustness and speed.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 25.0\n            r = gamma * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def collision_node_free(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            # Use finer resolution for collision checking for robustness\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_enabled = False\n\n        def clamp_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            # Return rotation matrix that aligns x-axis to direction vector in 2D or 3D\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                # Compute axis k (cross with x-axis)\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            # fallback to goal\n            return goal_position\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if len(tree) == 0:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Node or None:\n            if len(other_tree) == 0:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_position, None, 0.0)]\n        tree_goal: List[Node] = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n        edges.clear()\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found so far\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            # Sampling\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            # Extend appropriate tree\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # Avoid duplicate nodes at connection\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    # Refresh edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success = True\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_iterations)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.61736,
          "time_improvement": 41.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1456.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01728057861328125,
                    "num_nodes_avg": 68.6,
                    "path_length_avg": 167.34606457465054,
                    "smoothness_avg": 0.039486046191842615,
                    "success_improvement": 0.0,
                    "time_improvement": 27.117469785626007,
                    "length_improvement": 8.274970238546423,
                    "smoothness_improvement": 518.0423682240439,
                    "objective_score": 12.380446824517307
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03963184356689453,
                    "num_nodes_avg": 232.2,
                    "path_length_avg": 237.28845906535452,
                    "smoothness_avg": 0.09407634338894924,
                    "success_improvement": 0.0,
                    "time_improvement": 83.47668358348058,
                    "length_improvement": 20.78628239438841,
                    "smoothness_improvement": 2320.6520758489087,
                    "objective_score": 40.8035219331664
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09072043895721435,
                    "num_nodes_avg": 302.7,
                    "path_length_avg": 127.75138773269472,
                    "smoothness_avg": 0.1280235503232115,
                    "success_improvement": 0.0,
                    "time_improvement": 13.317151403180654,
                    "length_improvement": 15.153611135312167,
                    "smoothness_improvement": 1528.4501103957357,
                    "objective_score": 14.668118199995309
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner enhanced with adaptive informed sampling, dynamic neighbor radius calculation, incremental extend-and-rewire expansions, and continuous path optimization. It grows two trees from start and goal simultaneously, alternately extending and rewiring nodes while checking collisions for both nodes and edges. After the first solution, it focuses sampling within an informed ellipsoidal region to speed convergence. The planner enforces a 30-second time limit and performs path smoothing before returning an optimized, smooth, and low-cost path.",
          "planning_mechanism": "The planner alternates growth of two trees (from start and goal), samples points using goal bias and informed sampling after the initial path is found, extends trees by steering towards sampled points with collision checks, rewires nearby nodes for cost improvements, attempts incremental connections between trees, and stops when either a path is found or time expires, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 35.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = max(0.0, min(goal_sample_rate, 1.0))\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import time\n        import random\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Use finer resolution but cap minimal step\n            resolution = max(self.step_size / 5, 0.5)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return goal_pos\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            # Returns rotation matrix aligning first axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple( (start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple( (goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # clamp within bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        # Initialize two trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iteration = 0\n        success_state = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n            iteration += 1\n\n            # Sample point selection\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicate connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges list\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Time expired or max iterations reached\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.57233,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1480.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028072762489318847,
                    "num_nodes_avg": 90.3,
                    "path_length_avg": 162.46877963935552,
                    "smoothness_avg": 0.04219891237514792,
                    "success_improvement": 0.0,
                    "time_improvement": -18.39962110737604,
                    "length_improvement": 10.948287397107153,
                    "smoothness_improvement": 560.504615075979,
                    "objective_score": -0.5277057774114859
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.044449996948242185,
                    "num_nodes_avg": 221.0,
                    "path_length_avg": 232.42376958695195,
                    "smoothness_avg": 0.09879474995532041,
                    "success_improvement": 0.0,
                    "time_improvement": 81.46789807924448,
                    "length_improvement": 22.410255764602077,
                    "smoothness_improvement": 2442.0600753325193,
                    "objective_score": 41.132720953356355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04803330898284912,
                    "num_nodes_avg": 219.5,
                    "path_length_avg": 122.74604542626767,
                    "smoothness_avg": 0.12083485367923123,
                    "success_improvement": 0.0,
                    "time_improvement": 54.10445432116765,
                    "length_improvement": 18.47792116645319,
                    "smoothness_improvement": 1437.0104196986977,
                    "objective_score": 27.111972628134424
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighbor radius and rewiring that grows two trees from start and goal simultaneously. It incrementally samples nodes biased toward the goals, extends both trees using step-limited steering, and attempts connection between trees with continuous collision checking. Rewiring optimizes node costs locally. A 30-second time limit enforces timely termination, and post-connection path smoothing improves path quality by shortcutting unnecessary waypoints. The algorithm balances exploration and exploitation to reduce planning time and path length while maintaining robustness and success rate.",
          "planning_mechanism": "The planner alternates growing trees from start and goal, samples with goal bias, extends toward sampled points if collision-free, rewires nearby nodes to optimize costs, attempts connection between trees each iteration, and stops either when a path is found or the 30-second limit expires. Extracted paths are smoothed before returning to improve smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Accumulated path cost from root\n        self.children: List[Node] = []            # Children nodes\n        self.valid = True                         # Validity flag (collision-free)\n\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node:'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node:'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent:'Node', new_cost:float):\n        # Remove from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and update cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, \n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)  # Clamp between 0 and 1\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Data containers\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(towards_goal:bool) -> Tuple[float, ...]:\n            if towards_goal and random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            # Based on RRT* theory: radius shrinks as nodes increase, bounded by min and max radius\n            gamma = self.neighbor_radius_max  # max radius\n            # log term ensures connectivity with probabilistic guarantees\n            rad = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return max(rad, self.neighbor_radius_min)\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= r_sq]\n\n        def add_node(tree: List[Node], pos: Tuple[float, ...], parent_node: Node, cost: float) -> Node:\n            new_node = Node(pos, parent_node, cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            # Edge already removed possibly\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Update parent and cost recursively\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(nodes)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree: List[Node], new_node: Node) -> Node:\n            nearest_node = nearest(tree, new_node.position)\n            dist = math.dist(nearest_node.position, new_node.position)\n            if dist <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_node.position, new_node.position, obstacles, is_3d) and not self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                    return nearest_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations=100) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            p = path[:]\n            for _ in range(iterations):\n                if len(p) <= 2:\n                    break\n                i = random.randint(0, len(p) - 2)\n                j = random.randint(i + 1, len(p) - 1)\n                if j == i + 1:\n                    continue\n                if not self._is_edge_in_obstacle(p[i], p[j], obstacles, is_3d):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        start_time = time.time()\n        # Alternate growing trees: True means grow tree_start, False means grow tree_goal\n        grow_start_tree = True\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached, return best found path if any\n                if best_path:\n                    extracted_path = path_smoothing(best_path)\n                    success_state = True\n                break\n\n            if grow_start_tree:\n                sample_point = sample_free(towards_goal=True)\n                new_node_start = try_extend(tree_start, sample_point)\n                if new_node_start is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node_goal = try_connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    # Connect goal tree to start tree at new_node_start.position\n                    n_nodes_goal = len(nodes)\n                    radius_goal = adaptive_neighbor_radius(n_nodes_goal)\n                    neighbors_goal = near_nodes(tree_goal, new_node_start.position, radius_goal)\n\n                    # Choose best parent in goal tree for connection point\n                    min_cost_goal = connect_node_goal.cost + math.dist(connect_node_goal.position, new_node_start.position)\n                    best_parent_goal = connect_node_goal\n                    for neighbor in neighbors_goal:\n                        cost_through = neighbor.cost + math.dist(neighbor.position, new_node_start.position)\n                        if cost_through < min_cost_goal and not self._is_edge_in_obstacle(neighbor.position, new_node_start.position, obstacles, is_3d):\n                            min_cost_goal = cost_through\n                            best_parent_goal = neighbor\n\n                    new_node_goal = add_node(tree_goal, new_node_start.position, best_parent_goal, min_cost_goal)\n                    rewire(tree_goal, new_node_goal, neighbors_goal)\n\n                    # Extract path from start root -> new_node_start\n                    path_start = new_node_start.path_from_root()\n                    # Extract path from goal root -> new_node_goal\n                    path_goal = new_node_goal.path_from_root()\n\n                    connected_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                    cost_path = new_node_start.cost + new_node_goal.cost\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = connected_path\n                        extracted_path = path_smoothing(best_path)\n                        success_state = True\n                    break\n\n            else:\n                # Grow goal tree toward start goal with reversed bias\n                sample_point = sample_free(towards_goal=False)\n                new_node_goal = try_extend(tree_goal, sample_point)\n                if new_node_goal is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node_start = try_connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    n_nodes_start = len(nodes)\n                    radius_start = adaptive_neighbor_radius(n_nodes_start)\n                    neighbors_start = near_nodes(tree_start, new_node_goal.position, radius_start)\n\n                    min_cost_start = connect_node_start.cost + math.dist(connect_node_start.position, new_node_goal.position)\n                    best_parent_start = connect_node_start\n                    for neighbor in neighbors_start:\n                        cost_through = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                        if cost_through < min_cost_start and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                            min_cost_start = cost_through\n                            best_parent_start = neighbor\n\n                    new_node_start = add_node(tree_start, new_node_goal.position, best_parent_start, min_cost_start)\n                    rewire(tree_start, new_node_start, neighbors_start)\n\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n\n                    connected_path = path_start + path_goal[::-1][1:]\n\n                    cost_path = new_node_start.cost + new_node_goal.cost\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = connected_path\n                        extracted_path = path_smoothing(best_path)\n                        success_state = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        # If no connection found but nodes exist, try to approximate best path between closest pair\n        if not success_state and nodes:\n            # Find minimal-cost bridge between tree_start and tree_goal\n            min_bridge_cost = math.inf\n            bridge_nodes = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    dist = math.dist(ns.position, ng.position)\n                    if dist <= self.step_size * 2:  # heuristic connection attempt distance\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d):\n                            cost_bridge = ns.cost + dist + ng.cost\n                            if cost_bridge < min_bridge_cost:\n                                min_bridge_cost = cost_bridge\n                                bridge_nodes = (ns, ng)\n            if bridge_nodes:\n                ns, ng = bridge_nodes\n                path_start = ns.path_from_root()\n                path_goal = ng.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                extracted_path = path_smoothing(combined_path)\n                success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.49643,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1374.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03155448436737061,
                    "num_nodes_avg": 132.1,
                    "path_length_avg": 165.4504062373288,
                    "smoothness_avg": 0.0434797382446403,
                    "success_improvement": 0.0,
                    "time_improvement": -33.084123614724135,
                    "length_improvement": 9.314010611861088,
                    "smoothness_improvement": 580.5523212914276,
                    "objective_score": -5.159673355587885
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04292302131652832,
                    "num_nodes_avg": 251.6,
                    "path_length_avg": 231.90063815813036,
                    "smoothness_avg": 0.08227857184034407,
                    "success_improvement": 0.0,
                    "time_improvement": 82.10452507542588,
                    "length_improvement": 22.58489209304601,
                    "smoothness_improvement": 2017.0869163119266,
                    "objective_score": 39.2337705227966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02547919750213623,
                    "num_nodes_avg": 175.1,
                    "path_length_avg": 127.2492309717258,
                    "smoothness_avg": 0.1276946223645137,
                    "success_improvement": 0.0,
                    "time_improvement": 75.65477587153477,
                    "length_improvement": 15.487119745812356,
                    "smoothness_improvement": 1524.2661710400362,
                    "objective_score": 33.41518756582308
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm implements a hybrid bidirectional RRT* planner integrating adaptive neighbor radius, goal-biased and informed ellipsoidal sampling, incremental connection attempts, recursive cost updates on rewiring, and iterative path smoothing. It employs dual-tree alternating growth, robust collision checks at node and edge levels, boundary clamping, and halts execution after 30 seconds or upon successful connection to efficiently produce high-quality, smooth, and collision-free paths in 2D or 3D environments.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternating their expansion. Sampling is biased toward the goal initially, switching to informed ellipsoidal sampling after discovering a solution to focus search on promising regions. New nodes connect to optimal neighbors within an adaptive radius, with rewiring to improve path costs propagated recursively. Incremental connection attempts bridge the two trees progressively. Discovered paths are combined, smoothed via shortcutting, and returned immediately if found or when the time budget expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] e.g. 2D (x,y), 3D (x,y,z)\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []                 # List[Node]\n        self.valid = True                  # Collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively propagate cost updates to children\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_r = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_r = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_r, y_r)\n                else:\n                    x_r = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_r = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_r = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_r, y_r, z_r)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Select parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors through new node if cost improves path\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 150) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            sample_pt: tuple\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or iter limit reached, return best path found so far if any\n        success = False\n        smoothed = []\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.46954,
          "time_improvement": 40.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1473.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02840700149536133,
                    "num_nodes_avg": 88.4,
                    "path_length_avg": 164.0537953412001,
                    "smoothness_avg": 0.042036379874528525,
                    "success_improvement": 0.0,
                    "time_improvement": -19.809306801464498,
                    "length_improvement": 10.079515174745083,
                    "smoothness_improvement": 557.9606284963114,
                    "objective_score": -1.1370858630087755
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07167351245880127,
                    "num_nodes_avg": 230.1,
                    "path_length_avg": 236.91702684179592,
                    "smoothness_avg": 0.1009805385888655,
                    "success_improvement": 0.0,
                    "time_improvement": 70.11786436224779,
                    "length_improvement": 20.910277161696044,
                    "smoothness_improvement": 2498.3019912335512,
                    "objective_score": 37.7089246971813
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032135963439941406,
                    "num_nodes_avg": 178.1,
                    "path_length_avg": 126.22031052006233,
                    "smoothness_avg": 0.1150068615223547,
                    "success_improvement": 0.0,
                    "time_improvement": 69.2942749682778,
                    "length_improvement": 16.170479717880408,
                    "smoothness_improvement": 1362.8787896408617,
                    "objective_score": 30.83677238226373
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal biasing, adaptive rewiring, and incremental tree connections to improve planning efficiency, path quality, and robustness. It grows two search trees simultaneously from start and goal points, dynamically rewires nodes to reduce path costs, biases sampling toward the goal to accelerate convergence, and enforces a maximum planning time. It terminates early upon finding a feasible path or time expiration, returning the best solution found.",
          "planning_mechanism": "The planner alternates growing and rewiring two trees from start and goal by sampling points (biased toward goal), extending nodes stepwise with collision checks, rewiring neighbors for cost reduction, and incrementally connecting the trees. If trees connect, the resultant low-cost path is extracted by merging paths from both trees. Within a 30-second limit, the algorithm balances exploration and exploitation to find smooth, short, and feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # Tuple of nodes in start and goal trees\n\n        def sample_free():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_thru_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            target = new_node.position\n            current_node = nearest(tree, target)\n\n            while True:\n                dist = math.dist(current_node.position, target)\n                if dist <= self.step_size:\n                    new_pos = target\n                else:\n                    new_pos = steer(current_node.position, target)\n\n                if (\n                    not within_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                for neighbor in neighbors:\n                    cost_thru_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node_goal, cost_thru_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # Avoid duplicate middle node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded, return best path found (if any)\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n\n                tree_start, tree_goal = tree_goal, tree_start\n\n                # Optional early break to reduce planning time on success\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.99894,
          "time_improvement": 59.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 276.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013381409645080566,
                    "num_nodes_avg": 76.5,
                    "path_length_avg": 166.83413501227932,
                    "smoothness_avg": 0.019463577249412372,
                    "success_improvement": 0.0,
                    "time_improvement": 43.56259621891708,
                    "length_improvement": 8.555566943725118,
                    "smoothness_improvement": 204.64724978778887,
                    "objective_score": 15.803128503359092
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052031731605529784,
                    "num_nodes_avg": 274.1,
                    "path_length_avg": 246.89388693282086,
                    "smoothness_avg": 0.015621323729922434,
                    "success_improvement": 0.0,
                    "time_improvement": 78.30691969788298,
                    "length_improvement": 17.57971409531666,
                    "smoothness_improvement": 301.94791115559445,
                    "objective_score": 28.5177582842062
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04690549373626709,
                    "num_nodes_avg": 239.1,
                    "path_length_avg": 124.15395131017871,
                    "smoothness_avg": 0.033219353543958816,
                    "success_improvement": 0.0,
                    "time_improvement": 55.18207519016236,
                    "length_improvement": 17.542857115633282,
                    "smoothness_improvement": 322.5477250815371,
                    "objective_score": 21.67593260558305
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive neighbor radius and dynamic rewiring to minimize path length while reducing planning time. It uses goal-biased sampling, rigorous node and edge collision checking, and incremental steering. The planner alternates growth between two trees (start and goal) to efficiently find a feasible path. Early termination occurs upon connection or after 30 seconds, returning the best path found. Post-processing applies path smoothing through shortcutting to enhance path smoothness and quality.",
          "planning_mechanism": "The planner grows two trees from start and goal with goal-biased sampling, connecting and rewiring nodes within an adaptive radius to optimize costs. It performs collision checks to ensure validity of expansions and edges. Alternating tree growth and early termination reduce search time. After path extraction, shortcutting smooths the path, removing unnecessary nodes for shorter, feasible routes.",
          "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, max_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # heuristic factor per dimension\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            for _ in range(20):  # Rejection sampling to avoid obstacles\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos if tree_toggle else start_pos\n\n        def nearest(tree, point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, point))\n            return nearest_node\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, position) ** 2) <= r_sq]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(other_tree, from_node):\n            nearest_node = nearest(other_tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        def path_shortcut(path: list, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        best_cost = float('inf')\n        best_connection = None  # (path_start, path_goal_reversed)\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            rand_point = sample_free(grow_start)\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            parent_node = new_node.parent\n            if parent_node:\n                edges.append((parent_node, new_node))\n\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position, best_parent_other, min_cost)\n                other_tree.append(connecting_node_other)\n                edges.append((best_parent_other, connecting_node_other))\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                joined_path = path_start + path_goal[::-1][1:]\n                total_cost = new_node.cost + connecting_node_other.cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n                    final_path = joined_path\n                    success = True\n                    # Early termination on first valid connection with improved cost\n                    break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        if not success and best_connection:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=100)\n\n        # Rebuild node and edge collections consistently for output\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n\n        def collect_nodes_and_edges(node: Node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n    \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.40382,
          "time_improvement": 37.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1385.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02850348949432373,
                    "num_nodes_avg": 119.3,
                    "path_length_avg": 166.63069161371672,
                    "smoothness_avg": 0.04110201384851541,
                    "success_improvement": 0.0,
                    "time_improvement": -20.216254372901542,
                    "length_improvement": 8.667077494244227,
                    "smoothness_improvement": 543.3357711809051,
                    "objective_score": -1.6147819571170916
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0411912202835083,
                    "num_nodes_avg": 247.4,
                    "path_length_avg": 236.20123759928438,
                    "smoothness_avg": 0.0911022068289662,
                    "success_improvement": 0.0,
                    "time_improvement": 82.82654792028157,
                    "length_improvement": 21.149228213697384,
                    "smoothness_improvement": 2244.125399976569,
                    "objective_score": 40.29843701870679
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05265343189239502,
                    "num_nodes_avg": 250.2,
                    "path_length_avg": 122.08508005860313,
                    "smoothness_avg": 0.11536932958306656,
                    "success_improvement": 0.0,
                    "time_improvement": 49.68995391453116,
                    "length_improvement": 18.916902891867394,
                    "smoothness_improvement": 1367.4893566185074,
                    "objective_score": 25.527813535825363
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner with goal-biased and informed ellipsoidal sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and rigorous collision checks. It grows two trees alternating from start and goal positions, rewiring nodes to optimize path cost and applying path smoothing. Planning halts on reaching a path or a strict 30-second time limit, returning the highest quality path found.",
          "planning_mechanism": "The planner alternately samples and extends each tree with adaptive radius neighbors for rewiring. A goal bias increases direct sampling near targets, and informed ellipsoidal sampling focuses on promising regions when better solutions emerge. Trees incrementally connect with rewiring to minimize costs. Bound checks and obstacle collision checks guard validity. Once connected or timed out, the path is extracted and smoothed to deliver a robust, efficient, and smooth solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0, smoothing_iterations: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_node_free(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 25.0\n            r = gamma * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, pos)**2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            return goal_position\n\n        def rewire(tree, new_node, neighbors, edges):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree, sample_pt, nodes, edges):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors, edges)\n            return new_node\n\n        def try_connect(new_node, other_tree, nodes, edges):\n            if not other_tree:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors, edges)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_pt, nodes, edges)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_goal, nodes, edges)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample_pt, nodes, edges)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_start, nodes, edges)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                    best_path = path_smoothing(best_path, self.smoothing_iterations)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_iterations)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.23616,
          "time_improvement": 38.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1304.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023841094970703126,
                    "num_nodes_avg": 73.8,
                    "path_length_avg": 159.82231877573184,
                    "smoothness_avg": 0.04127413897774287,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5521495218089567,
                    "length_improvement": 12.39885453231527,
                    "smoothness_improvement": 546.0299032290155,
                    "objective_score": 5.044275566065445
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.054149413108825685,
                    "num_nodes_avg": 244.6,
                    "path_length_avg": 242.80188975040224,
                    "smoothness_avg": 0.08626823891228026,
                    "success_improvement": 0.0,
                    "time_improvement": 77.42401548755254,
                    "length_improvement": 18.945740536416313,
                    "smoothness_improvement": 2119.7439237138833,
                    "objective_score": 37.61507237211844
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06545498371124267,
                    "num_nodes_avg": 252.7,
                    "path_length_avg": 123.58634081302493,
                    "smoothness_avg": 0.10578249999006557,
                    "success_improvement": 0.0,
                    "time_improvement": 37.45814605653728,
                    "length_improvement": 17.919836981135465,
                    "smoothness_improvement": 1245.5455918216871,
                    "objective_score": 21.049139172296712
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with dynamic neighbor radius adjustment, goal-biased and informed ellipsoidal sampling, incremental rewiring-based path cost optimization, and recursive cost propagation. It employs efficient collision checking to ensure node and edge validity, alternately extends the start and goal trees while smoothly connecting them with shortest-cost incremental connections. Path smoothing via randomized shortcutting refines the final path. The planning halts upon reaching a time limit or on first valid connection, returning the best path found to maximize success, efficiency, and path quality.",
          "planning_mechanism": "The planner grows two trees backward and forward between start and goal using bidirectional RRT*. If a path is found, informed sampling restricts sample points to an ellipsoidal region around the best path cost to focus search. Neighbor radius is dynamically computed to balance exploration and rewiring efficiency. Extensions pick the best parent among neighbors to minimize cost and rewire neighbors accordingly. Trees attempt incremental connections via incremental steering and rewiring. The algorithm returns early when a path is connected or time limit is reached, applying path smoothing before output.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come from root\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n    \n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove self from old parent's children list\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and update cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update children cost\n        for c in self.children:\n            dist = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0, neighbor_radius_max: float=25.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def sample_free():\n            for _ in range(1000):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback if cannot find free sample quickly\n            return start\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start, goal)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if (c_best == math.inf) or (c_best < c_min - 1e-10):\n                return sample_free()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            # Rotation matrix for mapping ellipsoid axes to world frame\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                # Rotate sample_scaled by R\n                if dim == 2:\n                    x = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x, y)\n                else:\n                    x = (R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2])\n                    y = (R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2])\n                    z = (R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2])\n                    rotated = (x, y, z)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rotation_matrix(direction):\n            # Generates rotation matrix that aligns x-axis with 'direction' vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 20.0\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, target_point):\n            nearest = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_incremental(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                close_enough = dist(connect_node.position, new_node.position) <= self.step_size\n                if close_enough and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr = connect_node\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n        grow_start = True\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal if grow_start else start\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_incremental(new_node, tree_goal)\n                if connect_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Rebuild edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_incremental(new_node, tree_start)\n                if connect_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # After max iterations or time: Deliver best found\n        if best_path:\n            best_path = path_smoothing(best_path)\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.09132,
          "time_improvement": 34.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1553.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02857050895690918,
                    "num_nodes_avg": 81.8,
                    "path_length_avg": 161.92066206418525,
                    "smoothness_avg": 0.04208443805283196,
                    "success_improvement": 0.0,
                    "time_improvement": -20.498915510363737,
                    "length_improvement": 11.248719325536763,
                    "smoothness_improvement": 558.7128433467647,
                    "objective_score": -1.1063665712679445
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05740489959716797,
                    "num_nodes_avg": 264.9,
                    "path_length_avg": 245.95812539904222,
                    "smoothness_avg": 0.10251968068971082,
                    "success_improvement": 0.0,
                    "time_improvement": 76.06673738753712,
                    "length_improvement": 17.8920982296943,
                    "smoothness_improvement": 2537.9052260875465,
                    "objective_score": 39.08796699263773
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.055819153785705566,
                    "num_nodes_avg": 228.3,
                    "path_length_avg": 124.39524722084711,
                    "smoothness_avg": 0.1307603600958968,
                    "success_improvement": 0.0,
                    "time_improvement": 46.66512516886235,
                    "length_improvement": 17.38259986104386,
                    "smoothness_improvement": 1563.2621286940089,
                    "objective_score": 25.292368166337525
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive goal-biased and informed ellipsoidal sampling. It grows two trees simultaneously from start and goal positions, alternately expanding and rewiring nodes to optimize paths. The planner enforces strict collision checking on nodes and edges, dynamically adjusts neighbor radius based on tree size and dimensionality, and performs post-processing path smoothing. The algorithm respects a 30-second limit, returning the best found feasible path to balance planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner alternates growth of two trees from start and goal using goal bias and informed sampling after first solution, performing incremental extend-and-rewire steps. It attempts to connect the two trees at each expansion, maintaining minimal-cost paths with adaptive neighbor radius rewiring. On success or timeout, it smooths and returns the optimal path found within the time bound.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position           # Tuple[float,...]\n        self.parent = None                 # Node or None\n        self.cost = cost                  # Cost from root\n        self.children: List['Node'] = []\n        self.valid = True                  # Node validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update downstream\n        for child in self.children:\n            dist_c = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_c)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0, smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = max(0.0, min(goal_sample_rate, 1.0))\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.neighbor_radius_max\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position)**2) <= r_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_enabled = False\n        success_state = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            attempts = 0\n            while attempts < 50:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                attempts += 1\n            return goal_pos\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr_node = connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        edges: List[Tuple[Node, Node]] = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # Time limit reached: stop search, return best path found so far\n                break\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect_trees(new_node, other_tree)\n\n            if connect_node:\n                path_s = new_node.path_from_root()\n                path_g = connect_node.path_from_root()\n                if path_g and path_g[0] == new_node.position:\n                    path_g = path_g[1:]\n                combined_path = path_s + path_g[::-1]\n\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling_enabled = True\n                    success_state = True\n\n                # Rebuild edges\n                edges.clear()\n                all_nodes = tree_start + tree_goal\n                for node in all_nodes:\n                    for child in node.children:\n                        if collision_free_edge(node.position, child.position):\n                            edges.append((node, child))\n\n                # Path smoothing\n                best_path = path_smoothing(best_path, self.smoothing_trials)\n\n                break\n\n            grow_start_tree = not grow_start_tree\n\n        # If no direct connection found but path found, smooth path\n        if not success_state and best_path:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n            success_state = True\n\n        all_nodes = tree_start + tree_goal\n        if not edges:\n            edges.clear()\n            for node in all_nodes:\n                for child in node.children:\n                    edges.append((node, child))\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.08114,
          "time_improvement": 32.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1661.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03534960746765137,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 165.5540677152622,
                    "smoothness_avg": 0.04140358035123975,
                    "success_improvement": 0.0,
                    "time_improvement": -49.09042642514609,
                    "length_improvement": 9.257192113184557,
                    "smoothness_improvement": 548.0559418106832,
                    "objective_score": -10.135409795853498
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06494598388671875,
                    "num_nodes_avg": 256.3,
                    "path_length_avg": 240.1481441711855,
                    "smoothness_avg": 0.1178568952321051,
                    "success_improvement": 0.0,
                    "time_improvement": 72.92270696589972,
                    "length_improvement": 19.831637194590144,
                    "smoothness_improvement": 2932.542803212465,
                    "objective_score": 40.50585354475027
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02843763828277588,
                    "num_nodes_avg": 155.3,
                    "path_length_avg": 124.12364756155826,
                    "smoothness_avg": 0.125975392201208,
                    "success_improvement": 0.0,
                    "time_improvement": 72.82800301617206,
                    "length_improvement": 17.562983422557547,
                    "smoothness_improvement": 1502.3976902631578,
                    "objective_score": 32.87298604067892
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* variant with adaptive neighbor rewiring, goal-biased and informed sampling, incremental connection attempts, and path smoothing. It alternates growing trees from start and goal while dynamically rewiring nearby nodes to optimize path costs, uses collision checks to ensure validity, and enforces a maximum planning time to return the best solution found efficiently.",
          "planning_mechanism": "The planner samples points biased towards the goal and within informed ellipsoids after a solution is found, extends trees by steering towards samples within a step size limit, rewires neighbors to minimize costs, attempts incremental connection with rewiring between both trees, and performs path smoothing to reduce unnecessary waypoints before returning the optimized path or a failure state if timed out.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost update recursively to children\n        for c in self.children:\n            dist = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=10.0, neighbor_radius_max=30.0,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            # 3D approximate rotation matrix aligning x-axis to direction\n            vx, vy, vz = direction\n            kx, ky, kz = -vy, vx, 0.0\n            norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n            if norm_k < 1e-12:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            kx /= norm_k; ky /= norm_k; kz /= norm_k\n            cos_theta = vx\n            sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n            K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n            I = [[1,0,0],[0,1,0],[0,0,1]]\n\n            def mat_add(A,B):\n                return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n            def mat_scale(A,s):\n                return [[A[i][j]*s for j in range(3)] for i in range(3)]\n            def mat_mul(A,B):\n                return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n            K2 = mat_mul(K,K)\n            R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n            return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_planning_time:\n                # Time limit exceeded\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Rebuild edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations done, return best found if any\n        if best_path:\n            best_path = path_smoothing(best_path)\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.77895,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1414.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020661187171936036,
                    "num_nodes_avg": 84.3,
                    "path_length_avg": 160.61427250673296,
                    "smoothness_avg": 0.03845975354123328,
                    "success_improvement": 0.0,
                    "time_improvement": 12.85942259096992,
                    "length_improvement": 11.964772143043625,
                    "smoothness_improvement": 501.9786596118466,
                    "objective_score": 8.760674503958933
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05249233245849609,
                    "num_nodes_avg": 240.6,
                    "path_length_avg": 235.3262802393561,
                    "smoothness_avg": 0.09443823991870184,
                    "success_improvement": 0.0,
                    "time_improvement": 78.11488589500335,
                    "length_improvement": 21.441314164692674,
                    "smoothness_improvement": 2329.963934222978,
                    "objective_score": 39.37254827255443
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09164626598358154,
                    "num_nodes_avg": 282.2,
                    "path_length_avg": 124.80294443268312,
                    "smoothness_avg": 0.11873500820805918,
                    "success_improvement": 0.0,
                    "time_improvement": 12.432529096720257,
                    "length_improvement": 17.111826785397387,
                    "smoothness_improvement": 1410.3005402998594,
                    "objective_score": 14.203626787594851
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner utilizing dynamic informed sampling, adaptive neighbor radius, incremental rewiring, and path smoothing with integrated time-budget enforcement. It balances exploration and exploitation by growing two trees from start and goal, progressively refining paths considering collision constraints to generate shorter, smoother, and feasible paths efficiently.",
          "planning_mechanism": "The planner grows bidirectional RRT* trees alternately with goal biasing and informed ellipsoidal sampling after initial solution discovery. It incrementally extends and rewires near neighbors using an adaptive radius based on node count and dimensionality, performs meticulous collision checking on nodes and edges, and attempts incremental connection. If connected, it extracts and smooths the path. The planner enforces a 30-second time limit, returning the best path found, ensuring practical usability and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # From root to this node\n        self.children = []              # List of children nodes\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update descendants cost recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate tree growth\n        success_state = False\n        extracted_path = []\n        best_connection = None\n        best_cost = float('inf')\n        c_best = math.dist(start_pos, goal_pos)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n        use_informed_sampling = False\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n            # Unit vector along start-goal\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_pos, goal_pos)])\n            M = np.outer(a1, np.array([1.0] + [0] * (dim - 1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n\n            while True:\n                z = np.random.normal(0,1,dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1/dim)\n            r_vec = r * z_unit\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_best ** 2, 0)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2] * (dim - 1))\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.35749,
          "time_improvement": 29.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1588.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028732967376708985,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 162.02270475755276,
                    "smoothness_avg": 0.04115715604890256,
                    "success_improvement": 0.0,
                    "time_improvement": -21.184099783102077,
                    "length_improvement": 11.19278810833208,
                    "smoothness_improvement": 544.1988663601688,
                    "objective_score": -1.3956779814633626
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049467158317565915,
                    "num_nodes_avg": 268.6,
                    "path_length_avg": 231.62486987469825,
                    "smoothness_avg": 0.1131365462742473,
                    "success_improvement": 0.0,
                    "time_improvement": 79.37614212350282,
                    "length_improvement": 22.676951483605585,
                    "smoothness_improvement": 2811.084824596856,
                    "objective_score": 42.403657056756245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07304623126983642,
                    "num_nodes_avg": 341.5,
                    "path_length_avg": 120.79068484586617,
                    "smoothness_avg": 0.1186759904436205,
                    "success_improvement": 0.0,
                    "time_improvement": 30.20475343249037,
                    "length_improvement": 19.776578559690794,
                    "smoothness_improvement": 1409.5498386924373,
                    "objective_score": 20.064490935147457
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with dynamic rewiring, goal-biased and informed ellipsoidal sampling, adaptive neighborhood radius, and comprehensive collision checking for nodes and edges. It grows two trees from start and goal positions alternately, performs incremental extension, rewires local neighborhoods to optimize path costs, and attempts incremental connection with rewiring. The planner enforces a strict 30-second time limit, returning the best path found so far to ensure planning efficiency, path quality, smoothness, and robustness.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal positions using a combination of goal-biased and ellipsoidal informed sampling to focus the search. Each new node is extended cautiously with collision checks and rewiring to nearby nodes to reduce overall cost. The opposing tree incrementally connects to newly added nodes with additional rewiring, continuously improving path quality. The process terminates on success or time expiry, providing robust, low-cost, and smooth paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5,\n                 max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size              # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Constants for informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)*0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            temp_node = Node(new_pos)\n            neighbors = near_nodes(tree, temp_node)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos)\n                candidate_node.cost = cost_to_next\n\n                neighbors = near_nodes(tree_connect, candidate_node)\n\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n\n                min_parent.add_child(candidate_node)\n                candidate_node.parent = min_parent\n                candidate_node.cost = min_cost\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n\n                last_node = candidate_node\n\n            return None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # For both trees alternately\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n\n                # Sampling: goal bias + informed sampling when path found\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Build combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    # Compute path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node subtree\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return on first found path to maximize speed\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no connection found return best partial path by checking nearby nodes between trees\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.16994,
          "time_improvement": 68.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007612085342407227,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 184.4913298419197,
                    "smoothness_avg": 0.010519350526551577,
                    "success_improvement": 0.0,
                    "time_improvement": 67.89528566271517,
                    "length_improvement": -1.1226213385578332,
                    "smoothness_improvement": 64.65067887581763,
                    "objective_score": 20.46731482548207
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0381946325302124,
                    "num_nodes_avg": 201.0,
                    "path_length_avg": 307.68127601525805,
                    "smoothness_avg": 0.006362886119035033,
                    "success_improvement": 0.0,
                    "time_improvement": 84.07588590613632,
                    "length_improvement": -2.7128660483826366,
                    "smoothness_improvement": 63.72164284439662,
                    "objective_score": 24.99880077638635
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04949972629547119,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 158.73835880469125,
                    "smoothness_avg": 0.012861891384057036,
                    "success_improvement": 0.0,
                    "time_improvement": 52.703301159312666,
                    "length_improvement": -5.42645960970871,
                    "smoothness_improvement": 63.60230903913767,
                    "objective_score": 15.043709971047745
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* with adaptive neighbor radius and goal-biased sampling, combining local rewiring, incremental tree connection, and post-solution path smoothing within a 30-second time limit. It manages nodes with robust parent-child relationships and performs rigorous node and edge collision checks to ensure feasible, high-quality, and smooth paths efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the opposite tree's root to encourage connection. Each expansion steers toward sampled points respecting a step size and performs adaptive-rewiring using a dynamically computed neighbor radius based on the current tree size and dimension. Incremental connect attempts progressively link trees while rewiring optimizes path costs. Upon connection, the combined path is smoothed via shortcutting. The process halts early if 30 seconds elapse, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n        # Recursively update cost of descendants\n        for child in self.children:\n            child_cost = self.cost + math.dist(self.position, child.position)\n            child.update_parent(self, child_cost)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree: List[Node] = [Node(start_pos)]\n        goal_tree: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_free_point(p):\n            return within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def sample_free(tree_indicator: bool):\n            # tree_indicator=True means sampling for start_tree toward goal, else vice versa\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 30.0  # tuning param, can be adjusted\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not is_free_point(new_pos) or not is_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr_node = nearest\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not is_free_point(new_pos) or not is_free_edge(curr_node.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path: List[Tuple[float, ...]], iterations: int = 100) -> List[Tuple[float, ...]]:\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) - 1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                if is_free_edge(p1, p2):\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_indicator=True)\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicated node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined_path, iterations=100)\n                    success = True\n                    # Optional: stop early on first solution, comment next line to keep searching\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.0713,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1531.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024182724952697753,
                    "num_nodes_avg": 103.1,
                    "path_length_avg": 156.2190449823175,
                    "smoothness_avg": 0.040275037558805106,
                    "success_improvement": 0.0,
                    "time_improvement": -1.9930073797584058,
                    "length_improvement": 14.37386599601276,
                    "smoothness_improvement": 530.3917964391828,
                    "objective_score": 4.928829967470945
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06206269264221191,
                    "num_nodes_avg": 370.0,
                    "path_length_avg": 235.10600365298006,
                    "smoothness_avg": 0.1031911715268196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.1248093478783,
                    "length_improvement": 21.514848829534984,
                    "smoothness_improvement": 2555.183168981656,
                    "objective_score": 39.316328415178766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08631713390350342,
                    "num_nodes_avg": 359.6,
                    "path_length_avg": 126.64040269645093,
                    "smoothness_avg": 0.12630717040516848,
                    "success_improvement": 0.0,
                    "time_improvement": 17.52448361721952,
                    "length_improvement": 15.891474496962882,
                    "smoothness_improvement": 1506.6178845282157,
                    "objective_score": 15.96872940719951
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner incorporating goal-biased and informed sampling, adaptive neighbor radius, dynamic rewiring with recursive cost updates, and progressive incremental tree connections. It enforces strict 30-second planning time limit, applies path smoothing, and ensures collision-free, boundary-respecting expansions, balancing planning efficiency and path quality.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions, sampling points with goal bias and informed ellipsoidal sampling after initial solution discovery. Nodes are connected with rewiring of neighbors for cost optimization and incremental attempts link opposing trees. The best path found is combined, smoothed, and returned either on success or upon reaching the time budget, ensuring efficient and robust route planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Path cost from root\n        self.children = []                   # List[Node]\n        self.valid = True                    # Collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children for consistent cost tree\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_r = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_r = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_r, y_r)\n                else:\n                    x_r = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_r = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_r = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_r, y_r, z_r)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent for new node to minimize cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to possibly lower cost routes via new node\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 150) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or iteration limit reached; return best found path if any\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.94609,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1498.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025188755989074708,
                    "num_nodes_avg": 66.2,
                    "path_length_avg": 157.89328902934858,
                    "smoothness_avg": 0.042858784246731806,
                    "success_improvement": 0.0,
                    "time_improvement": -6.236041658077569,
                    "length_improvement": 13.45618630374037,
                    "smoothness_improvement": 570.8330428009708,
                    "objective_score": 3.674589977329658
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05411760807037354,
                    "num_nodes_avg": 229.2,
                    "path_length_avg": 237.40725040109592,
                    "smoothness_avg": 0.10389042997477224,
                    "success_improvement": 0.0,
                    "time_improvement": 77.43727565076189,
                    "length_improvement": 20.746626427298914,
                    "smoothness_improvement": 2573.1755925029793,
                    "objective_score": 40.24638594320325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08452324867248535,
                    "num_nodes_avg": 263.3,
                    "path_length_avg": 124.96527655293502,
                    "smoothness_avg": 0.11391471514756088,
                    "success_improvement": 0.0,
                    "time_improvement": 19.238530459009446,
                    "length_improvement": 17.004013520550973,
                    "smoothness_improvement": 1348.9867683673442,
                    "objective_score": 15.91729568364975
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal biasing, incremental extend-and-rewire, and path smoothing to efficiently find feasible, short, and smooth paths within a 30-second time limit. <The planner simultaneously grows two trees from start and goal positions, sampling points biased toward goals, extending nodes stepwise while avoiding obstacles, rewiring neighbors to minimize path cost, and incrementally connecting the trees. Upon successful connection or timeout, it returns the shortest smoothed path found, balancing exploration and exploitation for robustness and quality.>",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, sampling points biased toward goals, extending nodes stepwise while avoiding obstacles, rewiring neighbors to minimize path cost, and incrementally connecting the trees. Upon successful connection or timeout, it returns the shortest smoothed path found, balancing exploration and exploitation for robustness and quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update costs of children\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 25.0, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternating tree\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_a is start_tree else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n\n        def neighbor_radius(num_nodes):\n            if num_nodes == 0:\n                return self.neighbor_radius_max\n            gamma = 2 * (1 + 1/dimension) ** (1/dimension) * \\\n                ((math.pi ** (dimension/2)) / math.gamma(dimension/2 + 1)) ** (1/dimension)\n            r = gamma * (math.log(num_nodes + 1) / (num_nodes + 1)) ** (1/dimension)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, point))\n            new_pos = steer(nearest_node.position, point)\n            if (not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_incremental_connect(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                r = neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def merge_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            path_b.reverse()\n            return path_a + path_b[1:]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                candidate_path = merge_paths(new_node_a, new_node_b)\n                candidate_path = path_smoothing(candidate_path)\n\n                cost = 0.0\n                for idx in range(1, len(candidate_path)):\n                    cost += math.dist(candidate_path[idx-1], candidate_path[idx])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = candidate_path\n                    success = True\n                # Early stop upon finding a better path\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout with no full path found, attempt to return partial best path\n        if not success and best_path == []:\n            # Try closest node to goal in start tree\n            closest_to_goal = min(start_tree, key=lambda n: math.dist(n.position, goal_pos))\n            if math.dist(closest_to_goal.position, goal_pos) <= self.step_size:\n                best_path = closest_to_goal.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.84906,
          "time_improvement": 25.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1736.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03349788188934326,
                    "num_nodes_avg": 113.9,
                    "path_length_avg": 159.0457139542737,
                    "smoothness_avg": 0.04433123827313681,
                    "success_improvement": 0.0,
                    "time_improvement": -41.28059271355697,
                    "length_improvement": 12.824523941047373,
                    "smoothness_improvement": 593.8801457993051,
                    "objective_score": -6.84987229686109
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0513988733291626,
                    "num_nodes_avg": 293.0,
                    "path_length_avg": 234.4364991384319,
                    "smoothness_avg": 0.12602951180228042,
                    "success_improvement": 0.0,
                    "time_improvement": 78.57077110135297,
                    "length_improvement": 21.73834870711012,
                    "smoothness_improvement": 3142.8301140608573,
                    "objective_score": 43.6330516421322
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06520779132843017,
                    "num_nodes_avg": 311.8,
                    "path_length_avg": 119.67342714951776,
                    "smoothness_avg": 0.12345947495706663,
                    "success_improvement": 0.0,
                    "time_improvement": 37.69433693193338,
                    "length_improvement": 20.518607923511016,
                    "smoothness_improvement": 1470.3954086233734,
                    "objective_score": 22.763999707399083
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* growth with informed ellipsoidal sampling, adaptive neighbor radius rewiring, dynamic incremental connection between trees, and robust obstacle and edge collision checks. It balances exploration and exploitation by focusing samples in promising regions, efficiently rewires locally for cost optimization, and enforces strict time limits to guarantee timely results. Path smoothing via shortcutting follows path extraction to improve smoothness and remove unnecessary waypoints.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal, sampling with goal bias and informed ellipsoidal regions once a connection is found. Each extension involves steering with limited step size, collision and edge checks, then rewiring neighbors within an adaptive radius based on current node count. Incremental incremental connection attempts bridge the two trees efficiently. The algorithm terminates successfully when start and goal trees connect or when the 30-second time limit is reached, returning the best path found after smoothing.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Trees alternate growth each iteration\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_connection_nodes = None\n        best_cost = math.inf\n\n        start_time = time.perf_counter()\n\n        # Precompute start-goal dist and initialize sampling ellipse params\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2.0 for s, g in zip(start_position, goal_position))\n        use_informed_sampling = False\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _ellipsoidal_sample(c_max: float) -> Tuple[float, ...]:\n            # Implements informed sampling inside an ellipse between start and goal\n            # Reference: Informed RRT* sampling (Gammell, 2014)\n            if c_max == math.inf:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)], dtype=float)\n            # Build orthonormal basis matrix C via a rotation matrix:\n            # Create identity and replace first dim with a1\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))  # rank-1 matrix\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, Vt)\n\n            # Sample in unit n-ball \n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:  # avoid division by zero\n                    break\n            z_unit = z / norm_z\n\n            # Sample radius with probability ~ r^{dim-1} to fill ball uniformly\n            r = random.random() ** (1/dim)\n            r *= z_unit\n\n            # Lengths of the ellipse axes\n            r1 = c_max / 2.0\n            r2 = math.sqrt(c_max**2 - c_best**2) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                # For 3D, use r2 for axes 2 and 3\n                L = np.diag([r1, r2, r2])\n            else:\n                # fallback: use r2 for other axes\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = np.dot(C, np.dot(L, r))\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):  # Max 100 attempts\n                if use_informed_sampling and best_cost < math.inf:\n                    sample = _ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                    return sample\n            # fallback to uniform sample ignoring obstacle if no free found (very unlikely)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    # If direct connection between new_node and target_pos is collision-free, return new_node\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iterations: int=120) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iterations):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time exceeded: break and return best path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate, sample towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Update informed sampling usage and parameters\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2.0 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n\n                    # Extract and smooth path early for faster return on success\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Make sure no duplicate point at connection\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.54166,
          "time_improvement": 27.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1572.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030754804611206055,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 155.39801050614182,
                    "smoothness_avg": 0.0472465218485357,
                    "success_improvement": 0.0,
                    "time_improvement": -29.71139604033075,
                    "length_improvement": 14.82388800252849,
                    "smoothness_improvement": 639.5106643939071,
                    "objective_score": -2.7510878896239914
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06528630256652831,
                    "num_nodes_avg": 280.8,
                    "path_length_avg": 237.27958937981202,
                    "smoothness_avg": 0.11296131328131831,
                    "success_improvement": 0.0,
                    "time_improvement": 72.78082123152922,
                    "length_improvement": 20.789243350722238,
                    "smoothness_improvement": 2806.57595347357,
                    "objective_score": 40.02497480697106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06531059741973877,
                    "num_nodes_avg": 312.0,
                    "path_length_avg": 122.54529492889571,
                    "smoothness_avg": 0.10770517113827668,
                    "success_improvement": 0.0,
                    "time_improvement": 37.596106313230834,
                    "length_improvement": 18.611250088096217,
                    "smoothness_improvement": 1270.001826910111,
                    "objective_score": 21.351091046139047
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive neighbor radius based on tree size, incremental extend-and-rewire steps, and a post-processing path smoothing step. It rigorously checks collisions for nodes and edges, manages explicit parent-child relationships with clean rewiring, and enforces a maximum time limit to ensure responsiveness while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from the start and goal positions, extending each alternately towards goal-biased random samples. For each new node, it selects the best parent within an adaptive neighbor radius minimizing cost and rewires neighbors if cheaper paths are found. Incremental connect attempts between trees are performed carefully to gradually and safely link the two trees. Upon a successful connection, extracted paths are smoothed to improve smoothness and reduce length. Time-limiting ensures that the planning process halts within 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling goal, False for goal_tree sampling start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            # Volume of ball in R^d: For 2D \u03c0r^2, 3D (4/3)\u03c0r^3; Using heuristic R ~ gamma * (log(n)/n)^(1/d)\n            gamma = 25.0  # tuning parameter\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not valid_node(new_pos): \n                return None\n            if not valid_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path, iterations=50):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) -1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                # Check collision-free shortcut\n                if valid_edge(p1, p2):\n                    # Remove intermediate nodes\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Time exceeded: return best found\n                break\n\n            sample = sample_free(tree_indicator=True)  # tree_a grows towards goal_pos\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Found connection\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate connect node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success = True\n\n                # Attempt smoothing\n                smoothed_path = path_smoothing(best_path, iterations=100)\n                best_path = smoothed_path\n\n                # Stop on first found improved solution\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.40207,
          "time_improvement": 31.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1263.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019640398025512696,
                    "num_nodes_avg": 93.8,
                    "path_length_avg": 153.83644111358143,
                    "smoothness_avg": 0.029869960489300924,
                    "success_improvement": 0.0,
                    "time_improvement": 17.164700641643794,
                    "length_improvement": 15.679808931241347,
                    "smoothness_improvement": 367.52974531494084,
                    "objective_score": 10.123020705316112
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11281363964080811,
                    "num_nodes_avg": 504.4,
                    "path_length_avg": 238.70686820192523,
                    "smoothness_avg": 0.08618445945156529,
                    "success_improvement": 0.0,
                    "time_improvement": 52.965714028974354,
                    "length_improvement": 20.312776597957804,
                    "smoothness_improvement": 2117.588217845781,
                    "objective_score": 30.54021061751277
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0793837308883667,
                    "num_nodes_avg": 407.3,
                    "path_length_avg": 122.15175915589433,
                    "smoothness_avg": 0.11043538889563216,
                    "success_improvement": 0.0,
                    "time_improvement": 24.14930962919764,
                    "length_improvement": 18.87261781036399,
                    "smoothness_improvement": 1304.7299952599603,
                    "objective_score": 17.54296642713189
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a time-limited, bidirectional RRT* planner with adaptive neighbor radius, goal-biased sampling, incremental extension and rewiring, and early termination upon successful connection. It grows two trees alternately from start and goal, rewiring locally to optimize path cost, while performing rigorous collision checking on nodes and edges in both 2D and 3D environments. The adaptive radius scales with node count to balance exploration vs exploitation, and time budget guarantees timely return with the best path found.",
          "planning_mechanism": "The planner samples points biased toward the goal, incrementally extends the nearest nodes in alternating trees, rewires neighbor nodes to reduce path costs, and tries to connect the two trees incrementally. It maintains and updates the best path found so far, stops early if a path is found or the time budget is exceeded, and returns the best feasible path with graph details.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children if exists\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update children cost\n        for child in self.children:\n            child.update_parent(self, new_cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, \n                 goal_sample_rate: float=0.15, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import time\n        import random\n        import math\n\n        start_time = time.perf_counter()\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            # Adaptive neighbor radius based on node count and dimension (from RRT* literature)\n            gamma = 50.0  # tunable constant\n            unit_ball_volume = 3.14159 if dim == 2 else 4.18879  # approx vol of unit ball (circle/sphere)\n            r = min(self.step_size * 5, gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim))\n            return max(r, self.step_size)  # radius at least step_size\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def valid_new_node(parent_node, new_pos):\n            if (not self._within_bounds(new_pos, bounds) or \n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d)):\n                return False\n            return True\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_new_node(nearest_node, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost = neighbor.cost + edge_dist\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve paths\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except (ValueError, AttributeError):\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally grow tree towards new_node.position, rewiring neighbors\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if not valid_new_node(current_node, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    edge_dist = math.dist(neighbor.position, new_pos)\n                    cost = neighbor.cost + edge_dist\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_tree_node = Node(new_pos)\n                best_parent.add_child(new_tree_node)\n                new_tree_node.cost = min_cost\n                tree.append(new_tree_node)\n                nodes.append(new_tree_node)\n                edges.append((best_parent, new_tree_node))\n\n                # Rewire neighbors if beneficial\n                for neighbor in neighbors:\n                    cost_through_new = new_tree_node.cost + math.dist(new_tree_node.position, neighbor.position)\n                    if (cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_tree_node.position, neighbor.position, obstacles, is_3d)):\n                        neighbor.update_parent(new_tree_node, cost_through_new)\n                        edges.append((new_tree_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n\n                if new_tree_node.position == target_pos:\n                    return new_tree_node\n                current_node = new_tree_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        # Initialization\n        nodes = []\n        edges = []\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success_state = False\n        extracted_path = []\n\n        # Alternate growth mode flag (True: extend start, False: extend goal)\n        extend_start_tree = True\n\n        for i in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded: return best path found so far\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd = sample_free()\n            if extend_start_tree:\n                new_node = try_extend_and_rewire(tree_start, rnd)\n                if new_node is None:\n                    extend_start_tree = not extend_start_tree\n                    continue\n                connect_node = try_connect_and_rewire(tree_goal, new_node)\n            else:\n                new_node = try_extend_and_rewire(tree_goal, rnd)\n                if new_node is None:\n                    extend_start_tree = not extend_start_tree\n                    continue\n                connect_node = try_connect_and_rewire(tree_start, new_node)\n\n            if connect_node:\n                total_cost = new_node.cost + connect_node.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node, connect_node)\n                    extracted_path = merge_paths(new_node, connect_node)\n                    success_state = True\n                    # Early stop on found path to reduce search time\n                    break\n\n            extend_start_tree = not extend_start_tree  # Swap the trees to balance growth\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -19.29129,
          "time_improvement": 52.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 249.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017214751243591307,
                    "num_nodes_avg": 85.4,
                    "path_length_avg": 162.45403846964155,
                    "smoothness_avg": 0.025295390961639026,
                    "success_improvement": 0.0,
                    "time_improvement": 27.395103154723543,
                    "length_improvement": 10.956367265816162,
                    "smoothness_improvement": 295.9277983703062,
                    "objective_score": 11.889443391431826
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05150196552276611,
                    "num_nodes_avg": 308.1,
                    "path_length_avg": 263.26314823528526,
                    "smoothness_avg": 0.011204579401821988,
                    "success_improvement": 0.0,
                    "time_improvement": 78.5277898826744,
                    "length_improvement": 12.115183509491798,
                    "smoothness_improvement": 188.30189834121762,
                    "objective_score": 26.922883158406766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052243614196777345,
                    "num_nodes_avg": 282.3,
                    "path_length_avg": 130.0660806664245,
                    "smoothness_avg": 0.028519530529673744,
                    "success_improvement": 0.0,
                    "time_improvement": 50.08153232475334,
                    "length_improvement": 13.616302302561847,
                    "smoothness_improvement": 262.76632324468045,
                    "objective_score": 19.061551774161774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines bidirectional RRT* growth with informed ellipsoidal sampling, adaptive neighbor radius rewiring, incremental tree connection, and stringent collision checking to improve planning efficiency, path quality, robustness, and success rate. It dynamically focuses sampling in promising regions after initial solutions, rewires neighbors for cost improvements, and applies path smoothing to enhance smoothness while enforcing a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two alternating trees from start and goal positions using goal-biased and informed ellipsoidal sampling. Each extension steers toward sampled points with step limits, tests collisions for nodes and edges, rewires neighbors within an adaptive radius, and incrementally connects the opposite tree. Upon connecting trees, it extracts and smooths the combined path. The process halts immediately when time exceeds 30 seconds or upon finding the best path, returning the optimized path and search graph.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Path cost from root to this node\n        self.children = []\n        self.valid = True                   # For collision checking etc.\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=7.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0, smoothing_iterations: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate growth each iteration\n\n        success_state = False\n        best_connection = None\n        best_cost = math.inf\n        extracted_path = []\n\n        start_time = time.perf_counter()\n\n        # Precompute initial heuristic distance\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n        use_informed_sampling = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == math.inf:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)], dtype=float)\n            # Create basis C using SVD on outer product (a1 . e1^T)\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, Vt)\n\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = random.random() ** (1/dim)\n            r_vec = r * z_unit\n\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(0, c_max**2 - c_best**2)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = np.dot(C, np.dot(L, r_vec))\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < math.inf:\n                    pt = ellipsoidal_sample(best_cost)\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d) and in_bounds(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_add_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def add_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_add_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and can_add_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and can_add_edge(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not can_add_node(new_pos) or not can_add_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for nbr in neighbors:\n                    cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and can_add_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and can_add_edge(new_node.position, nbr.position):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if can_add_edge(new_node.position, target_pos):\n                        return new_node\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(self.smoothing_iterations):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not can_add_edge(path[i], path[j]):\n                    continue\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n            return path\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                if best_connection is not None:\n                    node_a, node_b = best_connection\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    if path_b and path_b[0] == node_a.position:\n                        path_b = path_b[1:]\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = add_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                conn_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if conn_cost < best_cost:\n                    best_cost = conn_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.20325,
          "time_improvement": 26.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1596.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.038010573387145995,
                    "num_nodes_avg": 97.1,
                    "path_length_avg": 160.50356753889423,
                    "smoothness_avg": 0.03292035310733157,
                    "success_improvement": 0.0,
                    "time_improvement": -60.31331041341328,
                    "length_improvement": 12.025451290148505,
                    "smoothness_improvement": 415.2750138207118,
                    "objective_score": -13.61252779689072
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05404739379882813,
                    "num_nodes_avg": 282.2,
                    "path_length_avg": 233.83484452622756,
                    "smoothness_avg": 0.11510091586030832,
                    "success_improvement": 0.0,
                    "time_improvement": 77.46654939937623,
                    "length_improvement": 21.939198334331742,
                    "smoothness_improvement": 2861.6294689244287,
                    "objective_score": 41.93595183130136
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04139411449432373,
                    "num_nodes_avg": 236.9,
                    "path_length_avg": 123.48568728675438,
                    "smoothness_avg": 0.126644539553945,
                    "success_improvement": 0.0,
                    "time_improvement": 60.44816580745249,
                    "length_improvement": 17.986686260678493,
                    "smoothness_improvement": 1510.909195198653,
                    "objective_score": 29.286332970364708
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* trees with adaptive neighbor radius rewiring, goal-biased and informed ellipsoidal sampling after initial solution, incremental connection attempts with rewiring, robust collision checking in 2D/3D, and path smoothing via shortcutting. It enforces a 30-second max planning time and dynamically improves path cost and smoothness while efficiently exploring the configuration space.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples biased towards the goal or informed ellipse after a first solution is found, extends trees with step size limits while rewiring neighbors for cost optimization, attempts incremental connections between trees with rewiring, performs comprehensive obstacle checks, and applies shortcut path smoothing before returning the best path found or terminating if time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []\n        self.valid = True                  # Validity flag for collision\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' cost\n        for c in self.children:\n            dist_c = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist_c)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate growth\n        success_state = False\n        extracted_path = []\n        best_connection_nodes = None\n        best_cost = float('inf')\n\n        start_time = time.perf_counter()\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n        use_informed_sampling = False\n        rng = random.Random()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 30.0\n            r = gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)])\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1/dim)\n            r_vec = r * z_unit\n\n            r1 = c_max/2.0\n            r2 = math.sqrt(max(c_max**2 - c_best**2, 0))/2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback uniform sample ignoring obstacle if needed (unlikely)\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos)/self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=120):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            # Goal bias sampling\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = (new_node_a.cost + new_node_b.cost + \n                                math.dist(new_node_a.position, new_node_b.position))\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no final success but a best connection was found, return it\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.1736,
          "time_improvement": 29.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1460.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021906590461730956,
                    "num_nodes_avg": 94.3,
                    "path_length_avg": 164.82019876529642,
                    "smoothness_avg": 0.04242478953845123,
                    "success_improvement": 0.0,
                    "time_improvement": 7.606812425023407,
                    "length_improvement": 9.659437313558474,
                    "smoothness_improvement": 564.0400831817867,
                    "objective_score": 7.034131606127651
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055688667297363284,
                    "num_nodes_avg": 275.4,
                    "path_length_avg": 233.536148522463,
                    "smoothness_avg": 0.09844953476103444,
                    "success_improvement": 0.0,
                    "time_improvement": 76.78226931292077,
                    "length_improvement": 22.038911657876113,
                    "smoothness_improvement": 2433.177439735087,
                    "objective_score": 39.60835032412689
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10334131717681885,
                    "num_nodes_avg": 371.2,
                    "path_length_avg": 123.52674639577147,
                    "smoothness_avg": 0.11649523857042132,
                    "success_improvement": 0.0,
                    "time_improvement": 1.2579761120995374,
                    "length_improvement": 17.959416755494015,
                    "smoothness_improvement": 1381.8108358317033,
                    "objective_score": 10.87833036388718
               }
          ],
          "success_rate": 1.0
     }
]