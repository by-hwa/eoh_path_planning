[
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.654359830512174,
          "time_improvement": 54.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020609617233276367,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 17.306726487427596,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 6.787323209480537
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03164470195770264,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 80.42008291490608,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.76431560419259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01710929870605469,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.63515364948351,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 21.411440677863403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
          "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.50088,
          "time_improvement": 36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.974939814675388,
          "time_improvement": 44.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012398910522460938,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 50.2510654377263,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 14.8169556563946
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027178692817687988,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 83.18339188143196,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 25.336085485098604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05079307556152344,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": -2.020326334253888,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": -1.2282216974670441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional growth and rewiring strategies of bidirectional RRT* with goal-biased sampling and dynamic incremental connection attempts. It features two trees grown from start and goal that alternate expansions. Each expansion uses neighborhood rewiring to reduce path cost, and after each new node is added, an incremental connection attempt with rewiring is made to join the two trees as early as possible. Collision checks ensure validity of nodes and edges, and careful cost-based parent selection with children management maintains tree consistency and path quality. The planner terminates early upon finding a valid connecting path, outputting an optimized, smooth, and low-cost route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased random sampling. Each iteration extends one tree by steering towards a sampled point with step size limits and rewiring neighbors within a radius to minimize path cost. Then, it attempts an incremental connection from the other tree to the newly added node with rewiring to further optimize cost and connect paths. Collision checks ensure nodes and edges are valid, preventing invalid expansions. This bidirectional, rewiring-based approach accelerates convergence, improves path quality and smoothness, and reduces planning time by rapidly discovering a valid optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost of descendants\n        for child in self.children:\n            dist = self._distance(child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def is_collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    prev_parent = neighbor.parent\n                    if prev_parent:\n                        if (prev_parent, neighbor) in edges:\n                            edges.remove((prev_parent, neighbor))\n                        prev_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample):\n            # Find nearest node\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, connect_node):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, connect_node.position))\n            dist = math.dist(nearest_node.position, connect_node.position)\n            if dist > self.step_size:\n                return None\n\n            if not is_collision_free_node(connect_node.position):\n                return None\n            if not is_collision_free_edge(nearest_node.position, connect_node.position):\n                return None\n\n            neighbors = near_nodes(tree, connect_node.position)\n\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, connect_node.position)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, connect_node.position):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(connect_node.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        success_state = False\n        final_path = []\n\n        # Alternate tree starts with start tree\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                final_path = path_a + path_b[1:]  # avoid duplicate connection node\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -12.01814,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 316.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027533936500549316,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 160.569386712611,
                    "smoothness_avg": 0.02450451608453697,
                    "success_improvement": 0.0,
                    "time_improvement": -10.476158588791257,
                    "length_improvement": 11.989374758062796,
                    "smoothness_improvement": 283.54888913137535,
                    "objective_score": 0.672771820632059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052264285087585446,
                    "num_nodes_avg": 325.9,
                    "path_length_avg": 240.06426952247952,
                    "smoothness_avg": 0.017266584034611274,
                    "success_improvement": 0.0,
                    "time_improvement": 67.66187370339429,
                    "length_improvement": 19.8596369665261,
                    "smoothness_improvement": 344.28164382833637,
                    "objective_score": 25.99189772346519
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042936849594116214,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.98176033662389,
                    "smoothness_avg": 0.03298287097098217,
                    "success_improvement": 0.0,
                    "time_improvement": 13.759280001647332,
                    "length_improvement": 18.321370546532442,
                    "smoothness_improvement": 319.53968420860195,
                    "objective_score": 9.389756530843698
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified yet effective bidirectional RRT* inspired planner using dual trees growing simultaneously from start and goal with goal bias sampling and rewiring. The Node class supports parent updates and child management to maintain tree consistency. Goal bias accelerates convergence, rewiring improves path quality by locally optimizing connections, and collision checking ensures safe expansions. The planner alternates tree expansions, attempts incremental connection with rewiring, and merges paths upon successful connection, balancing exploration and exploitation for efficient, robust pathfinding.",
          "planning_mechanism": "The planner initializes two trees from start and goal points. At each iteration, it samples a point biased towards the goal, extends one tree towards the sample with rewiring to optimize costs, then incrementally attempts to connect the other tree back with rewiring. Collision and edge checks guarantee validity. Upon connection, paths are concatenated to produce the final solution. This alternation and rewiring enable fast convergence to high-quality, smooth paths with reduced computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For collision/status checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n\n        # Find optimal parent among neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor == nearest:\n                continue\n            candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = candidate_cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors through new_node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        current = nearest\n\n        while True:\n            new_pos = self._steer(current.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = current.cost + math.dist(current.position, new_pos)\n            best_parent = current\n            for neighbor in neighbors:\n                if neighbor == current:\n                    continue\n                candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.84193,
          "time_improvement": 18.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01887509822845459,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 151.17482827913645,
                    "smoothness_avg": 0.02102342809722014,
                    "success_improvement": 0.0,
                    "time_improvement": 24.26624702849299,
                    "length_improvement": 17.138681101754965,
                    "smoothness_improvement": 229.06230282631154,
                    "objective_score": 11.85292184303045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07972452640533448,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 235.8839930063653,
                    "smoothness_avg": 0.01930007836028916,
                    "success_improvement": 0.0,
                    "time_improvement": 50.67105960576548,
                    "length_improvement": 21.25513359019308,
                    "smoothness_improvement": 396.60491749478894,
                    "objective_score": 21.435369187242205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06023519039154053,
                    "num_nodes_avg": 310.7,
                    "path_length_avg": 122.75329360888414,
                    "smoothness_avg": 0.03676825833269663,
                    "success_improvement": 0.0,
                    "time_improvement": -20.985266448523078,
                    "length_improvement": 18.4731072686807,
                    "smoothness_improvement": 367.68953204137927,
                    "objective_score": -0.7625108206138871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm is a bidirectional RRT* inspired planner with enhanced efficiency through goal-biased random sampling, dynamic local rewiring during tree expansions, and incremental connection attempts between start and goal trees. It incorporates efficient nearest neighbor querying, adaptive steering with step size limits, and rigorous collision checking for node positions and edges. The rewiring optimizes cost and path quality while alternating tree expansions accelerates convergence. This leads to faster planning times, improved path smoothness, and higher success rates.",
          "planning_mechanism": "The planner grows two trees simultaneously, sampling mostly towards the goal to improve search focus. On each iteration, one tree is extended toward a sampled point with rewiring of nearby nodes to minimize cost. Then it attempts connecting the other tree to the newly added node via rewiring to form a continuous path. Collision checks ensure validity at every step. By alternating expansions and rewiring, the method quickly converges to a collision-free, optimized path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Efficient nearest search: linear for simplicity, can be optimized with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Re-assign parent\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, connect_to_node):\n            nearest_node = nearest(tree, connect_to_node.position)\n            dist = math.dist(nearest_node.position, connect_to_node.position)\n            if dist > self.step_size:\n                return None\n            if self._is_in_obstacle(connect_to_node.position, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, connect_to_node.position, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, connect_to_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, connect_to_node.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, connect_to_node.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(connect_to_node.position, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Alternate tree expansion each iteration to balance growth\n        start_tree = tree_start\n        goal_tree = tree_goal\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = try_extend(start_tree, sample)\n            if new_node_start is None:\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            new_node_goal = try_connect(goal_tree, new_node_start)\n            if new_node_goal:\n                # Paths connecting start_tree root to new_node_start, and goal_tree root to new_node_goal\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path_goal.reverse()\n                extracted_path = path_start + path_goal[1:]  # Avoid duplicating connecting node\n                success_state = True\n                break\n\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -10.74705,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 218.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021436524391174317,
                    "num_nodes_avg": 147.8,
                    "path_length_avg": 161.4200586584748,
                    "smoothness_avg": 0.018596289666266766,
                    "success_improvement": 0.0,
                    "time_improvement": 13.988874486413575,
                    "length_improvement": 11.523107984775253,
                    "smoothness_improvement": 191.07231576642934,
                    "objective_score": 7.45664552171127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06319136619567871,
                    "num_nodes_avg": 366.1,
                    "path_length_avg": 251.15246650705654,
                    "smoothness_avg": 0.0131187349704594,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90082591838002,
                    "length_improvement": 16.15807765702018,
                    "smoothness_improvement": 237.55449983278646,
                    "objective_score": 22.689635806081974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05267148017883301,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 130.14155852635278,
                    "smoothness_avg": 0.025465211964407646,
                    "success_improvement": 0.0,
                    "time_improvement": -5.793192023664093,
                    "length_improvement": 13.566173501866952,
                    "smoothness_improvement": 223.915616540841,
                    "objective_score": 2.094855175978368
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner integrating adaptive informed sampling with goal bias, rewiring for path cost optimization, and incremental connection of trees. It balances exploration and exploitation by focusing samples within an ellipsoidal informed region when a solution is found, uses fixed-radius rewiring to improve solution quality dynamically, and performs collision-aware incremental connections to swiftly merge two trees. Post-processing smoothing via random shortcutting further refines the path for length and smoothness improvements.",
          "planning_mechanism": "The planner alternates growing start and goal trees with rewiring of neighbors to minimize path costs. It samples with goal bias and informed ellipsoidal sampling towards the goal to accelerate convergence. When trees approach, an incremental rewiring-enhanced connection is performed to join them. After a valid path is found, path smoothing is applied to reduce detours and shorten the path. The structure maintains robust parent-child relations and ensures strict collision checks for nodes and edges throughout the process.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float) -> None:\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 7000,\n        step_size: float = 4.0,\n        goal_sample_rate: float = 0.15,\n        neighbor_radius: float = 20.0,\n        smoothing_iters: int = 50,\n        collision_resolution: float = 0.5,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        # Trees and data structures\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Variables for informed sampling\n        c_best = math.inf\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2.0 for s, g in zip(start_position, goal_position))\n        # Rotation matrix from unit vector along x axis to vector from start to goal\n        def rotation_to_goal():\n            \"\"\"Calculate rotation matrix to align x-axis with vector from start to goal in dimension D.\"\"\"\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1 = a1 / np.linalg.norm(a1)\n            Id = np.eye(dimension)\n            if dimension == 2:\n                # 2D rotation matrix\n                angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            else:\n                # For 3D, use Householder transformation\n                e1 = np.zeros(dimension)\n                e1[0] = 1.0\n                v = a1 - e1\n                if np.linalg.norm(v) < 1e-10:\n                    return Id\n                v = v / np.linalg.norm(v)\n                H = Id - 2.0 * np.outer(v, v)\n                return H\n\n        rotation_matrix = rotation_to_goal()\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid defined by current best cost c_best\n            if c_best == math.inf:\n                return uniform_sample()\n            r1 = c_best/2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            while True:\n                # Sample unit ball in dimension\n                if dimension == 2:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    unit_ball = np.array([x, y])\n                else:\n                    # Sample 3D unit ball via rejection\n                    while True:\n                        px = random.uniform(-1,1)\n                        py = random.uniform(-1,1)\n                        pz = random.uniform(-1,1)\n                        if px*px+py*py+pz*pz <= 1:\n                            unit_ball = np.array([px, py, pz])\n                            break\n                L = np.diag([r1] + [r2]*(dimension-1))\n                sample_local = L @ unit_ball\n\n                # Rotate and translate sample\n                sample_world = rotation_matrix @ sample_local + np.array(x_center)\n\n                point = tuple(np.clip(sample_world, [0]*dimension, bounds))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def uniform_sample():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def sample():\n            # Goal bias applied along with informed sampling when c_best is finite\n            if c_best < math.inf:\n                p_goal = random.random()\n                if p_goal < self.goal_sample_rate:\n                    return goal_position\n                if random.random() < 0.5:\n                    return informed_sample()\n                return uniform_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                not collision_free_edge(nearest_node.position, new_pos)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent by cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(curr_node.position, new_pos)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_final_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate node position at connection\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n\n                p1 = new_path[i]\n                p2 = new_path[j]\n\n                if collision_free_edge(p1, p2):\n                    # Shortcut by removing intermediate points\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                extracted_path = extract_final_path(new_node_a, new_node_b)\n                # Update c_best and informed sampling parameters\n                c_best = sum(math.dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1))\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -8.07632,
          "time_improvement": -4.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1103.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03546233177185058,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 160.4244848049874,
                    "smoothness_avg": 0.035022633560391106,
                    "success_improvement": 0.0,
                    "time_improvement": -42.28776145674394,
                    "length_improvement": 12.068797789748949,
                    "smoothness_improvement": 448.1802680861655,
                    "objective_score": -8.031667538642562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08922274112701416,
                    "num_nodes_avg": 355.5,
                    "path_length_avg": 229.67382658668322,
                    "smoothness_avg": 0.06373306979660538,
                    "success_improvement": 0.0,
                    "time_improvement": 44.79411195887387,
                    "length_improvement": 23.3282658908123,
                    "smoothness_improvement": 1539.897790941334,
                    "objective_score": 25.803375720531292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05740001201629639,
                    "num_nodes_avg": 222.1,
                    "path_length_avg": 117.09146594625352,
                    "smoothness_avg": 0.11160099977024449,
                    "success_improvement": 0.0,
                    "time_improvement": -15.29067481648307,
                    "length_improvement": 22.233423614938765,
                    "smoothness_improvement": 1319.556479548584,
                    "objective_score": 6.457264675785753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified, goal-biased bidirectional RRT* algorithm with incremental rewiring to optimize path cost and improve planning efficiency. Two trees grow from start and goal positions alternating expansions, where each new node connects through the lowest-cost parent within a fixed neighbor radius. Rewiring of nearby nodes reduces path costs dynamically. Collision checks on nodes and edges ensure feasibility and robustness. Once the two trees connect, their root paths are combined to form a smooth, optimized route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling points biased towards each opposite root to accelerate convergence. Each extension involves cost-based parent selection and rewiring of neighbors to refine path quality. After every extension, an incremental connection attempt with rewiring is made to join trees earlier and improve path smoothness. Collision and boundary checks maintain reliability and avoid invalid expansions, resulting in improved success rates and reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free(tree_from, tree_to_root):\n            if random.random() < self.goal_sample_rate:\n                # bias sample towards opposing tree root\n                return tree_to_root.position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample_point = sample_free(tree_a[0], tree_b[0])\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.54897,
          "time_improvement": 10.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 237.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024068188667297364,
                    "num_nodes_avg": 118.1,
                    "path_length_avg": 162.16088273051918,
                    "smoothness_avg": 0.018111696645408973,
                    "success_improvement": 0.0,
                    "time_improvement": 3.4296811100641387,
                    "length_improvement": 11.117050571779089,
                    "smoothness_improvement": 183.48738267941727,
                    "objective_score": 4.169751360772146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07468876838684083,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 243.3674034244215,
                    "smoothness_avg": 0.013951704330297302,
                    "success_improvement": 0.0,
                    "time_improvement": 53.78689632922378,
                    "length_improvement": 18.756955794620104,
                    "smoothness_improvement": 258.98740142499486,
                    "objective_score": 21.18239706481613
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06368763446807861,
                    "num_nodes_avg": 330.2,
                    "path_length_avg": 117.95792484222511,
                    "smoothness_avg": 0.02891657606089635,
                    "success_improvement": 0.0,
                    "time_improvement": -27.91966582177128,
                    "length_improvement": 21.657962872573307,
                    "smoothness_improvement": 267.81671309497943,
                    "objective_score": -2.7052236065418245
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT*-style path planner that grows two trees from start and goal positions simultaneously, employing goal-biased sampling, incremental tree expansion with cost-based rewiring, and frequent incremental connection attempts between the two trees. It ensures collision-free nodes and edges while dynamically optimizing path cost through rewiring in both trees. The algorithm promotes efficiency, robustness, and quality by balancing exploration and exploitation with structured incremental connections and rewiring to produce smooth, shorter paths.",
          "planning_mechanism": "The planner alternates growth between two trees using goal-biased random samples, extends and rewires one tree towards samples, then incrementally connects and rewires the opposite tree towards the newly added node. This frequent attempt to link the trees combined with rewiring optimizes path cost on the fly. Collision checking for nodes and edges ensures validity. Upon successful connection, paths are merged to output a smooth and optimized final route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update costs recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(child.position))\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._within_bounds(pos, bounds)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            \n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge paths from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.40105,
          "time_improvement": 0.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 291.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021263980865478517,
                    "num_nodes_avg": 90.2,
                    "path_length_avg": 155.46314810612068,
                    "smoothness_avg": 0.02029841917168108,
                    "success_improvement": 0.0,
                    "time_improvement": 14.681181810789734,
                    "length_improvement": 14.78818505180875,
                    "smoothness_improvement": 217.71433875954466,
                    "objective_score": 8.450563247396394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07615876197814941,
                    "num_nodes_avg": 383.7,
                    "path_length_avg": 238.22231704511987,
                    "smoothness_avg": 0.015554505787950446,
                    "success_improvement": 0.0,
                    "time_improvement": 52.87734904791542,
                    "length_improvement": 20.474533721131174,
                    "smoothness_improvement": 300.2286373816369,
                    "objective_score": 21.459254645509045
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08309917449951172,
                    "num_nodes_avg": 392.6,
                    "path_length_avg": 115.95748746207536,
                    "smoothness_avg": 0.035670171688152404,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90867420064964,
                    "length_improvement": 22.986558129877153,
                    "smoothness_improvement": 353.72195097510166,
                    "objective_score": -13.706680879343953
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* planner by integrating informed ellipsoidal goal-biased sampling to focus exploration on promising regions, dynamically adjusting neighbor radius based on the node count and dimension for efficient rewiring, and incremental rewiring to continuously improve path quality. A balance of exploration and exploitation is achieved by alternating tree growth, ensuring collision-free node and edge connections. The planner uses numpy for efficient linear algebra operations in sampling, employs adaptive step sizing, and terminates early upon finding a feasible low-cost path, thereby reducing planning time and improving path smoothness and quality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately, samples points biased towards the dynamically defined ellipsoidal informed subset around the current best path cost, extends trees towards sampled points with constrained steps, performs collision checks, rewires neighbors within an adaptive radius, attempts connection between trees at each iteration, and returns an optimized smooth path on success or after reaching iteration limits.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal bias\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of 2D or 3D boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        # Current best path and its cost, initialize with None and infinity\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        # Adaptive neighbor radius: \u03b3 * (log(n)/n)^(1/d), \u03b3 ~ 30 (tuned)\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        # Ellipsoidal informed sampling between start and goal constrained by current best cost\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):  # No solution found yet: uniform random sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoid parameters\n            c_min = dist(start, goal)\n            if best_cost < c_min:\n                # Numerics: clamp to c_min to avoid pathological ellipsoid\n                c_cost = c_min\n            else:\n                c_cost = best_cost\n\n            # Center of ellipsoid\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n\n            # Rotation matrix aligning x-axis to start-goal vector\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)  # start==goal rare case\n\n            e1 = a1 / norm_a1  # Unit vector from start to goal\n\n            # Construct basis via QR decomposition for dimension d\n            I = np.eye(dim)\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            # Ellipsoid radii\n            r1 = c_cost / 2.0\n            if c_cost * c_cost - c_min * c_min <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_cost * c_cost - c_min * c_min) / 2.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Sample uniformly from unit ball in dim-dimensions\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 0:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n\n            # Scale and transform sample to ellipsoid\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            # Final collision check for sample is omitted here (usually acceptable)\n            return sample_point\n\n        # Rewiring logic\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n                    # Update edges list: remove old edge\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        # Extension + rewiring for one tree towards a sampled point\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            # Choose best parent with min cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Attempt to connect two trees via the newly added node in tree_a by extending tree_b towards it incrementally,\n        # rewiring and choosing lower cost parents until connection or failure\n        def connect_and_rewire(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                # Direct check\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir == 0:\n                return None\n\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            # Choose best parent among neighbors\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_to, new_node, neighbors)\n\n            # Recursively attempt to connect further or reach the target\n            if dist(new_pos, current_pos) <= self.step_size:\n                # Final connection attempt\n                if collision_free_edge(new_pos, current_pos):\n                    final_connect = Node(current_pos)\n                    final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                    tree_to.append(final_connect)\n                    nodes.append(final_connect)\n                    edges.append((new_node, final_connect))\n                    rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                    return final_connect\n                return None\n\n            # Continue extending towards current_pos if possible\n            return connect_and_rewire(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    # Reconstruct full path from start to goal\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n\n            grow_start = not grow_start\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.28427,
          "time_improvement": 13.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 128.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028359365463256837,
                    "num_nodes_avg": 110.4,
                    "path_length_avg": 171.9092710773572,
                    "smoothness_avg": 0.017696900898962236,
                    "success_improvement": 0.0,
                    "time_improvement": -13.788079533551127,
                    "length_improvement": 5.773804445778623,
                    "smoothness_improvement": 176.99492850414552,
                    "objective_score": -2.0966883283888853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06134157180786133,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 289.6449868661758,
                    "smoothness_avg": 0.007427513234392058,
                    "success_improvement": 0.0,
                    "time_improvement": 62.04537203502058,
                    "length_improvement": 3.3081664153793446,
                    "smoothness_improvement": 91.11526534244898,
                    "objective_score": 19.730821220294285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05503737926483154,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 144.51516822016083,
                    "smoothness_avg": 0.016953867316359176,
                    "success_improvement": 0.0,
                    "time_improvement": -10.545213714792496,
                    "length_improvement": 4.019906340982156,
                    "smoothness_improvement": 115.65194085977592,
                    "objective_score": -1.7813231419424378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring, and incremental tree connection. It incorporates ellipsoidal heuristic sampling focused around the current best path cost to bias exploration towards promising regions. The planner maintains two growing trees from start and goal states, performs collision-aware rewiring in both trees for path cost optimization, and incrementally connects the two trees with rewiring-enhanced procedures to ensure robustness and shorter paths. Post solution, path smoothing via random shortcutting enhances path smoothness and quality.",
          "planning_mechanism": "The planner samples states within the ellipsoidal informed subset guided by current best path cost or uniformly if no path exists, growing two trees bidirectionally with rewiring to minimize costs. It extends one tree toward sampled points and incrementally connects the other tree towards the new node, rewiring neighbors to reduce path cost. Once connected, the path is extracted and smoothed by repeatedly attempting collision-free shortcuts, reducing overall path length and improving smoothness while maintaining collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_radius_factor: float = 50.0,\n                 collision_check_resolution: float = 0.5, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.collision_check_resolution = collision_check_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_uniform_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def rot_matrix_ellipsoid(start, goal):\n            \"\"\"Compute rotation matrix aligning unit vector to vector from start to goal in dim-space.\"\"\"\n            import numpy as np\n            unit_x = np.zeros(dim)\n            unit_x[0] = 1.0\n            vec = np.array(goal) - np.array(start)\n            length = np.linalg.norm(vec)\n            if length == 0:\n                return np.eye(dim)\n            vec = vec / length\n            if dim == 2:\n                # 2D rotation matrix to align x-axis to vec\n                c = vec[0]\n                s = vec[1]\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                # 3D: compute axis-angle rotation matrix aligning x-axis to vec\n                v = np.cross(unit_x, vec)\n                s = np.linalg.norm(v)\n                c = np.dot(unit_x, vec)\n                if s == 0:\n                    return np.eye(3) if c > 0 else -np.eye(3)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                return R\n            else:\n                return np.eye(dim)\n\n        def informed_sample(start, goal, c_max):\n            import numpy as np\n            if c_max == float('inf'):\n                return sample_uniform_free()\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                return sample_uniform_free()\n\n            # Sample in unit n-ball\n            while True:\n                a = np.random.normal(0, 1, dim)\n                norm_a = np.linalg.norm(a)\n                sample_ball = a / norm_a * (random.random() ** (1 / dim))\n                # Scale ellipsoid radii\n                r1 = c_max / 2.0\n                if dim == 2:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2])\n                elif dim == 3:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2, r2])\n                else:\n                    # fallback uniform if higher dims\n                    return sample_uniform_free()\n                # Rotate and translate sample\n                R = rot_matrix_ellipsoid(np.array(start), np.array(goal))\n                pt = np.dot(R, L @ sample_ball) + (np.array(start) + np.array(goal)) / 2.0\n                pt_tuple = tuple(pt.tolist())\n                if within_bounds(pt_tuple) and not self._is_in_obstacle(pt_tuple, obstacles, is_3d):\n                    return pt_tuple\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def can_connect(n1, n2):\n            if self._is_in_obstacle(n2.position, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, self.collision_check_resolution):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n\n            radius = self._calc_neighbor_radius(len(tree))\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent for minimal cost connection\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                        min_cost = tentative_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if new_node offers lower cost path\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.remove_child(nb)\n                            except ValueError:\n                                pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]):\n            nearest_node = nearest(tree, target_pos)\n            current = nearest_node\n            radius = self._calc_neighbor_radius(len(tree))\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nb in neighbors:\n                    tentative_cost = nb.cost + dist(nb.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                            min_cost = tentative_cost\n                            best_parent = nb\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if path costs improve\n                for nb in neighbors:\n                    if nb == best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost < nb.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                    nb.parent.remove_child(nb)\n                                except ValueError:\n                                    pass\n                            nb.update_parent(new_node, new_cost)\n                            edges.append((new_node, nb))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current = new_node\n\n        def try_connect_trees(node_in_a: Node, tree_b: List[Node]):\n            # Attempt incremental connect from tree_b to node_in_a.position\n            return incremental_connect_and_rewire(tree_b, node_in_a.position)\n\n        def path_smooth(path: List[Tuple[float, ...]]):\n            # Random shortcutting path smoothing\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_check_resolution):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        tree_a = start_tree\n        tree_b = goal_tree\n\n        for iter_count in range(self.max_iter):\n            # Informed sampling using current best cost or uniform\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = informed_sample(start_pos, goal_pos, best_cost)\n\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect_trees(new_node_a, tree_b)\n            if new_node_b:\n                # Successfully connected trees\n                cost_path = new_node_a.cost + new_node_b.cost + dist(new_node_a.position, new_node_b.position)\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    # Extract path: start root \u2192 new_node_a + reversed(goal root \u2192 new_node_b)\n                    path_from_start = new_node_a.path_from_root()\n                    path_from_goal = new_node_b.path_from_root()\n                    # Ensure no duplicate node at connection point\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n                    extracted_path = path_smooth(combined_path)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _calc_neighbor_radius(self, n):\n        # According to Karaman and Frazzoli (RRT*) scaling for neighbor radius\n        # r_n = min{max_radius, gamma * (log(n)/n)^(1/d)}\n        if n <= 1:\n            return self.neighbor_radius_factor\n        gamma_rrt_star = self.neighbor_radius_factor\n        radius = gamma_rrt_star * (math.log(n) / n) ** (1 / 2.0)  # 2D/3D same formula for simplicity\n        radius = max(radius, self.step_size)\n        radius = min(radius, gamma_rrt_star)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.6295,
          "time_improvement": 15.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1412.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043416929244995114,
                    "num_nodes_avg": 83.9,
                    "path_length_avg": 164.18372191414562,
                    "smoothness_avg": 0.03720324769360068,
                    "success_improvement": 0.0,
                    "time_improvement": -74.2044970799114,
                    "length_improvement": 10.008300361295342,
                    "smoothness_improvement": 482.3116145502763,
                    "objective_score": -17.84813097896297
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050745177268981936,
                    "num_nodes_avg": 229.8,
                    "path_length_avg": 238.21428623172022,
                    "smoothness_avg": 0.08991796263875351,
                    "success_improvement": 0.0,
                    "time_improvement": 68.60181003685484,
                    "length_improvement": 20.47721463779812,
                    "smoothness_improvement": 2213.653943985784,
                    "objective_score": 35.74425565854499
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.024538660049438478,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 118.18445541862111,
                    "smoothness_avg": 0.1289315433122978,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 50.71292536683033,
                    "length_improvement": 21.507512049957953,
                    "smoothness_improvement": 1539.9997141958427,
                    "objective_score": -22.784621408980087
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of unidirectional and bidirectional RRT* algorithms by growing two trees simultaneously from start and goal, utilizing goal-biased sampling to accelerate convergence. It uses adaptive neighbor radius for rewiring to optimize path cost dynamically. Incremental extension steps and rewiring in both trees improve path quality and smoothness. Node parent-child updates support effective rewiring, and robust collision checks prevent invalid expansions. Once a connection is made between trees, the combined path is smoothed via a post-processing step to reduce unnecessary turns and shorten path lengths, ensuring robust, efficient, and high-quality path planning in 2D or 3D environments.",
          "planning_mechanism": "The planner alternates tree expansion between start and goal trees with goal-biased sampling towards the other tree\u2019s root, extending nodes incrementally with fixed step size. Adaptive neighborhood radius is used to find neighbors for rewiring to minimize cost dynamically during tree growth. After each extension, an incremental connection attempt is made from the opposite tree towards the new node with rewiring. Upon successful connection, the two trees' paths are merged and smoothed before returning the final optimized path. Collision checks ensure all nodes and edges are obstacle-free, and bounds are respected throughout the sampling and extension process.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 10.0,\n                 max_neighbor_radius: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 25.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_connect_trees(connect_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, connect_node.position)\n            while True:\n                new_pos = steer(curr_node.position, connect_node.position)\n                if (not in_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    c = nbr.cost + math.dist(nbr.position, new_node.position)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, connect_node.position) <= self.step_size:\n                    # Check direct connection without obstacle\n                    if (not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = path[:]\n\n            for _ in range(max_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                if can_connect(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        success_state = False\n        final_node_a = None\n        final_node_b = None\n\n        for _ in range(self.max_iter):\n            # Sample with bias towards opposite tree's root to focus growth\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            # Extend tree_a towards sample with rewiring\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n\n            # Try connecting tree_b incrementally to new_node\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n            if connect_node:\n                # Merge paths from both trees at connection nodes\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                # Remove duplicate connection point at start of path_b\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = path_smoothing(extracted_path)\n                success_state = True\n                final_node_a = new_node\n                final_node_b = connect_node\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.30597,
          "time_improvement": -43.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1370.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05125737190246582,
                    "num_nodes_avg": 114.6,
                    "path_length_avg": 157.05829791223314,
                    "smoothness_avg": 0.028447812996236242,
                    "success_improvement": 0.0,
                    "time_improvement": -105.66320210074187,
                    "length_improvement": 13.913858166312298,
                    "smoothness_improvement": 345.27004880576834,
                    "objective_score": -27.18983875293126
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09705915451049804,
                    "num_nodes_avg": 435.7,
                    "path_length_avg": 233.61929174719415,
                    "smoothness_avg": 0.10187133667784667,
                    "success_improvement": 0.0,
                    "time_improvement": 39.94539116832186,
                    "length_improvement": 22.011156056315826,
                    "smoothness_improvement": 2521.2228676789655,
                    "objective_score": 28.99196290015455
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0812455415725708,
                    "num_nodes_avg": 400.2,
                    "path_length_avg": 120.27345826984924,
                    "smoothness_avg": 0.10552908652875204,
                    "success_improvement": 0.0,
                    "time_improvement": -63.18556363843585,
                    "length_improvement": 20.12009582379838,
                    "smoothness_improvement": 1242.3221912988151,
                    "objective_score": -8.720038970277002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines goal-biased informed sampling with bidirectional RRT* style growth and dynamic rewiring. It maintains two trees grown from start and goal positions respectively, alternating expansions and incremental connect-and-rewire steps to efficiently explore the space. The sampling is guided by an ellipsoidal informed region after the first solution, focusing search and improving convergence speed. The planner uses adaptive neighbor radius recalculated per iteration for rewiring to optimize path cost continuously. Path smoothing is performed at the end to enhance smoothness and reduce unnecessary waypoints. Robust collision and edge validity checks ensure feasible expansions within bounds.",
          "planning_mechanism": "The planner alternates expansions of start and goal trees by sampling informed points biased toward the current best path. Each expansion attempts to connect the opposite tree via incremental steps and performs rewiring on neighborhood nodes to optimize the tree costs. Once a path is found, it extracts and smooths the path before returning. The informed sampler shrinks the ellipsoidal sampling domain as better returns are found, focusing effort on promising regions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float,...] (2D/3D)\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Path cost from root\n        self.children = []\n        self.valid = True                     # Validity flag (collision-free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, neighbor_factor: float = 2.5,\n                 goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix from unit vector a1 to x-axis (for informed sampling)\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])\n                R = eye + vx + (vx @ vx) * ((1 - c)/(s_**2))\n                return R\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)/2 for s,g in zip(start_pos, goal_pos))\n        rotation = _rotation_matrix() if np else None\n\n        def informed_sample():\n            if np is None or c_best == float('inf'):\n                # fallback uniform sampling inside bounds\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            else:\n                r2 = 0.0\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D sampling inside unit ball\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Initialize trees and data\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        edges = []\n        path_found = False\n        best_goal_node = None\n\n        def nearest_node(tree, pos):\n            return min(tree, key=lambda n: dist(n.position, pos))\n\n        def get_near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def try_connect(tree_from, tree_to, new_node, radius):\n            # Incremental connect and rewire from new_node towards nearest in tree_to within radius\n            # Returns connected goal node if success else None\n            connected_goal_node = None\n            nearest_in_to = nearest_node(tree_to, new_node.position)\n            direction = tuple(nearest_in_to.position[d] - new_node.position[d] for d in range(dim))\n            dist_to_nearest = dist(new_node.position, nearest_in_to.position)\n            steps = max(1, int(dist_to_nearest / self.step_size))\n\n            last_node = new_node\n            for i in range(1, steps + 1):\n                interm_pos = tuple(new_node.position[d] + direction[d]* i/steps for d in range(dim))\n                if not within_bounds(interm_pos):\n                    return None\n                if self._is_in_obstacle(interm_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, interm_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, interm_pos)\n                interm_node = Node(interm_pos, parent=last_node, cost=new_cost)\n                last_node.add_child(interm_node)\n                tree_from.append(interm_node)\n                edges.append((last_node, interm_node))\n\n                # Rewire near nodes around interm_node\n                neighbor_radius = min(self.step_size,\n                                      self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n                near_nodes = get_near_nodes(tree_from, interm_node.position, neighbor_radius)\n                for near in near_nodes:\n                    if near == interm_node.parent:\n                        continue\n                    if self._is_edge_in_obstacle(interm_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        continue\n                    cost_through_interm = interm_node.cost + dist(interm_node.position, near.position)\n                    if cost_through_interm < near.cost:\n                        near.update_parent(interm_node, cost_through_interm)\n\n                last_node = interm_node\n\n            # Final connection to nearest_in_to node\n            if (self._is_edge_in_obstacle(last_node.position, nearest_in_to.position, obstacles, is_3d, self.collision_resolution)\n                    or self._is_in_obstacle(nearest_in_to.position, obstacles, is_3d)):\n                return None\n            cost_connect = last_node.cost + dist(last_node.position, nearest_in_to.position)\n            connect_node = Node(nearest_in_to.position, parent=last_node, cost=cost_connect)\n            last_node.add_child(connect_node)\n            tree_from.append(connect_node)\n            edges.append((last_node, connect_node))\n\n            # Rewire near nodes in tree_from around connect_node\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n            near_nodes = get_near_nodes(tree_from, connect_node.position, neighbor_radius)\n            for near in near_nodes:\n                if near == connect_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(connect_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_connect = connect_node.cost + dist(connect_node.position, near.position)\n                if cost_through_connect < near.cost:\n                    near.update_parent(connect_node, cost_through_connect)\n\n            return connect_node\n\n        # Main loop alternating expansions of start and goal trees\n        for it in range(self.max_iter):\n            # Alternate trees\n            if it % 2 == 0:\n                tree_from = start_tree\n                tree_to = goal_tree\n            else:\n                tree_from = goal_tree\n                tree_to = start_tree\n\n            # Sample point\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_from is start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            # Nearest node in tree_from\n            nearest = nearest_node(tree_from, sample)\n\n            # Steer towards sample\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Dynamic neighbor radius for rewiring\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n\n            # Find neighbors to possibly rewire\n            near_nodes = get_near_nodes(tree_from, new_node.position, neighbor_radius)\n\n            # Choose best parent among near nodes (including current)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in near_nodes:\n                if self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_near = near.cost + dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if shorter through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    try:\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                    except (ValueError, AttributeError):\n                        pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect tree_from's new_node to tree_to\n            connect_node = try_connect(tree_from, tree_to, new_node, neighbor_radius)\n            if connect_node is not None:\n                # Path found, extract full path\n                if tree_from is start_tree:\n                    path_start = connect_node.path_from_root()\n                    # Corresponding node in tree_to has same position as connect_node.parent or connect_node itself at connection point\n                    # Find corresponding node in tree_to for path merging\n                    counterpart = nearest_node(tree_to, connect_node.position)\n                    path_goal = counterpart.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + counterpart.cost\n                else:\n                    path_start = nearest_node(tree_to, connect_node.position).path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + nearest_node(tree_to, connect_node.position).cost\n\n                # Update best solution\n                if cost_path < c_best:\n                    c_best = cost_path\n                    best_goal_node = connect_node if tree_from is start_tree else nearest_node(tree_to, connect_node.position)\n                    extracted_path = full_path\n                    path_found = True\n                    center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                    # update rotation for informed sampling to bias future samples\n                    rotation = _rotation_matrix() if np else None\n\n                # Optional early stop to allow better rewiring in remaining iterations or break immediately\n                # Here break on first found path for planning efficiency\n                break\n\n        # If found path, apply simple path smoothing by shortcuts along path\n        def path_smoothing(path, iterations=30):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if path_found:\n            extracted_path = path_smoothing(extracted_path, iterations=40)\n\n        # Combine all nodes from both trees and edges\n        all_nodes = start_tree + [n for n in goal_tree if n not in start_tree]\n\n        return PlannerResult(\n            success=path_found,\n            path=extracted_path if path_found else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.56739,
          "time_improvement": -32.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 729.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015814971923828126,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 164.28036986617082,
                    "smoothness_avg": 0.023170487001020087,
                    "success_improvement": 0.0,
                    "time_improvement": 36.54458575876863,
                    "length_improvement": 9.955326087305531,
                    "smoothness_improvement": 262.66843708381487,
                    "objective_score": 14.26778313051077
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10339927673339844,
                    "num_nodes_avg": 621.6,
                    "path_length_avg": 246.6354463547729,
                    "smoothness_avg": 0.038038996749436046,
                    "success_improvement": 0.0,
                    "time_improvement": 36.02248907874998,
                    "length_improvement": 17.66598899906865,
                    "smoothness_improvement": 878.7707847448972,
                    "objective_score": 18.73379844716321
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13381729125976563,
                    "num_nodes_avg": 728.5,
                    "path_length_avg": 137.74339529427704,
                    "smoothness_avg": 0.09003650182892373,
                    "success_improvement": 0.0,
                    "time_improvement": -168.77844219043237,
                    "length_improvement": 8.51739548117924,
                    "smoothness_improvement": 1045.257657460649,
                    "objective_score": -43.70376527359062
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner employs bidirectional RRT* with adaptive rewiring and goal biasing strategies. It grows two trees from start and goal positions alternately, samples points with bias toward the goal, and uses a fixed neighbor radius for efficient rewiring, enabling faster convergence and better path optimization. Collision checks are rigorously applied for nodes and edges to guarantee feasible paths. The rewiring step ensures smoother and lower-cost paths dynamically, while incremental connections accelerate success detection and reduce planning time. The planner parameters are tuned for balanced exploration and exploitation to optimize success rate and path quality.",
          "planning_mechanism": "The planner samples random points favoring the goal, extends both start and goal trees toward these samples by a fixed step size, and rewires nearby nodes to minimize path cost while maintaining collision-free constraints. It frequently attempts to connect the two trees incrementally. The bidirectional growth with rewiring and goal biasing greatly reduces the search space and time, improves path smoothness and length, and robustly avoids obstacles through continuous validation during expansion and connection.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):  # limit retries for efficiency\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n            return goal_position  # fallback\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def valid_new_node(pos, obstacles, is_3d):\n            return (self._within_bounds(pos, bounds) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_extend_and_rewire(tree, other_tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if (not valid_new_node(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost_try = neighbor.cost + edge_dist\n                if cost_try < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n            # Try to connect to the other tree\n            connection_node = try_connect(other_tree, new_node)\n            if connection_node:\n                # Create a connecting node in the other tree at new_node's position, with rewiring\n                connecting_neighbors = near_nodes(other_tree, new_node.position)\n                min_conn_cost = connection_node.cost + math.dist(connection_node.position, new_node.position)\n                best_conn_parent = connection_node\n                for neighbor in connecting_neighbors:\n                    edge_dist = math.dist(neighbor.position, new_node.position)\n                    cost_try = neighbor.cost + edge_dist\n                    if cost_try < min_conn_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                new_node_other = Node(new_node.position)\n                best_conn_parent.add_child(new_node_other)\n                new_node_other.cost = min_conn_cost\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((best_conn_parent, new_node_other))\n\n                # Rewire in other tree through new_node_other\n                for neighbor in connecting_neighbors:\n                    if neighbor == best_conn_parent:\n                        continue\n                    cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                    if cost_via_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                # Extract combined path: start root to new_node, and goal root to new_node_other, reversed\n                path_start = new_node.path_from_root()\n                path_goal = new_node_other.path_from_root()\n                extracted = path_start + path_goal[::-1][1:]  # remove duplicate connecting node\n                return extracted\n            return None\n\n        def try_connect(tree, node):\n            # Find nearest node in tree to node.position that can connect within step_size and collision free edge\n            nearest_node = nearest(tree, node.position)\n            if math.dist(nearest_node.position, node.position) <= self.step_size:\n                # Node position collision and edge collision checked outside usually, but safe to check here too:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        # Main loop: alternate expansions from start and goal trees\n        for iter_num in range(self.max_iter):\n            sample = sample_free()\n            # First extend start tree toward sample, then goal tree toward start tree's new node and vice versa\n            extracted_path = try_extend_and_rewire(tree_start, tree_goal, sample)\n            if extracted_path:\n                success_state = True\n                break\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 3.74921,
          "time_improvement": -31.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 449.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052749800682067874,
                    "num_nodes_avg": 179.5,
                    "path_length_avg": 167.67689676740173,
                    "smoothness_avg": 0.029109394951206242,
                    "success_improvement": 0.0,
                    "time_improvement": -111.65136868689285,
                    "length_improvement": 8.093635871327926,
                    "smoothness_improvement": 355.6252430492584,
                    "objective_score": -30.098557216555978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06149802207946777,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 234.39611255074652,
                    "smoothness_avg": 0.023209304182747068,
                    "success_improvement": 0.0,
                    "time_improvement": 61.9485696271455,
                    "length_improvement": 21.751830912542975,
                    "smoothness_improvement": 497.1921136081793,
                    "objective_score": 25.42089763869314
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07147982120513915,
                    "num_nodes_avg": 325.3,
                    "path_length_avg": 120.17915296485121,
                    "smoothness_avg": 0.04661454427600806,
                    "success_improvement": 0.0,
                    "time_improvement": -43.570646294679634,
                    "length_improvement": 20.182728917042017,
                    "smoothness_improvement": 492.9335624630725,
                    "objective_score": -6.569980292680125
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner using two trees grown from the start and goal. It integrates goal-biased sampling and informed heuristics to focus growth toward promising regions. The planner performs rewiring after each new node addition to improve path cost locally and incrementally tries to connect the two trees with rewiring-enhanced incremental connection steps. The Node class supports dynamic parent updates allowing robust rewiring. This approach balances exploration, exploitation, and path cost optimization, ensuring improved path length, smoothness, and planning efficiency.",
          "planning_mechanism": "The planner alternates sampling points biased towards the opposing tree\u2019s root and extends one tree towards these samples with rewiring to minimize costs. After each extension, it incrementally attempts to connect the other tree to the newly added node, also rewiring whenever better connections are identified. If the trees connect, their paths are merged for the final planning outcome. Collision checks for nodes and edges ensure validity throughout the process. This dual-tree rewiring hybrid speeds up convergence while producing lower cost, smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0, connect_threshold: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.connect_threshold = connect_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position  # bias towards other tree's root to encourage connection\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b and self._dist(new_node_a.position, new_node_b.position) <= self.connect_threshold:\n                # Connection successful, merge paths\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplicate node at connection\n                if path_goal[0] == path_start[-1]:\n                    path_goal = path_goal[1:]\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(\n                max(0.0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds))\n            )\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._position_in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for better paths\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._position_in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + self._dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if self._dist(new_node.position, target_pos) <= self.connect_threshold:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _position_in_bounds(self, pos, bounds):\n        for dim in range(len(bounds)):\n            if pos[dim] < 0 or pos[dim] > bounds[dim]:\n                return False\n        return True",
          "objective": 5.1084,
          "time_improvement": -34.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 402.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0566575288772583,
                    "num_nodes_avg": 117.3,
                    "path_length_avg": 169.87638754539265,
                    "smoothness_avg": 0.029805058432856506,
                    "success_improvement": 0.0,
                    "time_improvement": -127.33059420574068,
                    "length_improvement": 6.888060122749372,
                    "smoothness_improvement": 366.5138871945143,
                    "objective_score": -34.988996801199754
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06383743286132812,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 238.30680555959853,
                    "smoothness_avg": 0.020901029227638895,
                    "success_improvement": 0.0,
                    "time_improvement": 60.50107711487519,
                    "length_improvement": 20.446329023131142,
                    "smoothness_improvement": 437.7985364299979,
                    "objective_score": 24.428581621238777
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06713318824768066,
                    "num_nodes_avg": 232.0,
                    "path_length_avg": 122.82911290223119,
                    "smoothness_avg": 0.03935130317222395,
                    "success_improvement": 0.0,
                    "time_improvement": -34.840225703431656,
                    "length_improvement": 18.422751704166362,
                    "smoothness_improvement": 400.5456717396294,
                    "objective_score": -4.764789011498077
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional, anytime RRT* planner with adaptive informed sampling, dynamic rewiring, and path smoothing. It grows two trees simultaneously from start and goal, leveraging adaptive informed regions around the current best path to bias sampling efficiently. The planner performs incremental expansion and rewiring in both trees, attempts frequent, incremental connections reducing connection failures, and applies path smoothing on the extracted path for improved smoothness and shorter path length. The approach integrates rigorous collision checks, bounding constraints, and flexible parameters to improve planning speed, success rate, robustness, and path quality.",
          "planning_mechanism": "The planner alternates between expanding two RRT* trees rooted at start and goal with adaptive informed sampling that focuses search in the ellipsoidal region defined by the current best solution. Each expansion incrementally extends and rewires nodes to reduce path cost. Frequent incremental attempts connect the opposing tree with rewiring to ensure low-cost merges. Upon connection, the best path is extracted and refined through shortcut smoothing, yielding shorter and smoother collision-free paths faster and more reliably.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.5, goal_sample_rate: float=0.1,\n                 neighbor_factor: float=2.0, collision_resolution: float=0.5, smoothing_iters: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_rewire(tree, neighbors, new_node):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if c_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, c_through_new)\n                        edges.append((new_node, nbr))\n\n        def incrementally_connect(tree, target_node):\n            curr_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                radius = self._adaptive_radius(len(tree), dim)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = c\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                try_rewire(tree, neighbors, new_node)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def _adaptive_radius(num_nodes, dim):\n            from math import log, pow, pi\n            gamma = self.neighbor_factor\n            unit_ball_volume = pi if dim == 2 else 4/3 * pi\n            radius = min(self.step_size, gamma * pow((log(num_nodes) / num_nodes), 1/dim))\n            return radius\n\n        def try_extend(tree, sample):\n            if not self._within_bounds(sample, bounds):\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = _adaptive_radius(len(tree), dim)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            try_rewire(tree, neighbors, new_node)\n            return new_node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _within_bounds(pos, bounds):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        self._within_bounds = _within_bounds\n        self._adaptive_radius = _adaptive_radius\n\n        tree_active, tree_opposite = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            # Sample point biased by informed sampling & goal bias\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_opposite[0].position\n                else:\n                    sample = sample_free()\n\n            new_node = try_extend(tree_active, sample)\n            if new_node is None:\n                tree_active, tree_opposite = tree_opposite, tree_active\n                continue\n\n            connect_node = incrementally_connect(tree_opposite, new_node)\n            if connect_node:\n                # Extract combined path\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_new = 0.0\n                for idx in range(1, len(full_path)):\n                    c_new += math.dist(full_path[idx-1], full_path[idx])\n                if c_new < c_best:\n                    c_best = c_new\n                    center = tuple((s + g) * 0.5 for s, g in zip(full_path[0], full_path[-1]))\n                \n                extracted_path = path_smoothing(full_path)\n                success_state = True\n                break\n\n            tree_active, tree_opposite = tree_opposite, tree_active\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.97471,
          "time_improvement": 38.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1438.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025354552268981933,
                    "num_nodes_avg": 80.2,
                    "path_length_avg": 164.87912207597097,
                    "smoothness_avg": 0.03844395041869222,
                    "success_improvement": 0.0,
                    "time_improvement": -1.7316771018180572,
                    "length_improvement": 9.627140513278148,
                    "smoothness_improvement": 501.7313064270491,
                    "objective_score": 3.914581504245458
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.05082085132598877,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 219.54202937674887,
                    "smoothness_avg": 0.08683182190470087,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.55498729339317,
                    "length_improvement": 26.710551427101343,
                    "smoothness_improvement": 2134.2453200412874,
                    "objective_score": -63.420166926355336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026004457473754884,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 121.5085305076238,
                    "smoothness_avg": 0.1397939934905283,
                    "success_improvement": 0.0,
                    "time_improvement": 47.768800997209595,
                    "length_improvement": 19.2998196512885,
                    "smoothness_improvement": 1678.1692786802648,
                    "objective_score": 26.581450622821905
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm implements a bidirectional RRT* planner featuring goal-biased sampling, dynamic rewiring of nodes in local neighborhoods, and incremental connection attempts between two simultaneously grown trees from start and goal. It integrates efficient collision checking, adaptive neighbor search, and path smoothing to reduce planning time while improving path quality, length, and smoothness robustly in 2D or 3D spaces. The Node class maintains parent-child relationships and cumulative costs for path optimization.",
          "planning_mechanism": "The planning mechanism alternates expansion between two trees grown from start and goal. Each iteration samples a point with goal bias, extends one tree toward the sample with collision-checked steering, locally rewires node connections to optimize costs, then incrementally connects and rewires the other tree toward the newly added node. Upon successful connection, paths from both trees are merged and smoothed. This approach narrows search space, improves path optimality dynamically, and reduces redundant exploration, thereby minimizing planning time and improving path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def descendants(self):\n        \"\"\"Yield all descendant nodes in subtree rooted at this node.\"\"\"\n        for child in self.children:\n            yield child\n            yield from child.descendants()\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_radius: float = 20.0, smoothing_iters: int = 15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        # Precompute max bounds limits for clamping\n        max_bounds = tuple(bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling: sample near goal of the opposite tree to direct growth\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_b:\n                # Extract path from start tree root to new_node_a\n                path_from_start = new_node_a.path_from_root()\n                # Extract path from goal tree root to new_node_b\n                path_from_goal = new_node_b.path_from_root()\n\n                # Remove duplicate connecting node at junction if present\n                if path_from_goal and path_from_goal[0] == path_from_start[-1]:\n                    path_from_goal = path_from_goal[1:]\n\n                # Combine paths: start -> connection -> goal (reversed)\n                raw_path = path_from_start + path_from_goal[::-1]\n                # Smooth path to improve trajectory quality\n                extracted_path = self._smooth_path(raw_path, obstacles, is_3d)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        r_sq = radius * radius\n        return [node for node in tree if (sum((node.position[d] - position[d])**2 for d in range(len(position)))) <= r_sq]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        # Add node and edge to lists\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path cost improves\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path[:]\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            p1, p2 = smoothed[i], smoothed[j]\n\n            # Check if direct edge between p1 and p2 is free\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate nodes between i+1 and j-1 as they are not needed\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed",
          "objective": 11.58068,
          "time_improvement": 48.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 680.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0206784725189209,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 158.40561102660482,
                    "smoothness_avg": 0.03188515116292793,
                    "success_improvement": 0.0,
                    "time_improvement": 17.030454060621132,
                    "length_improvement": 13.175374498782666,
                    "smoothness_improvement": 399.07185541379243,
                    "objective_score": 9.739570395011835
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0508305549621582,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 238.8534003722645,
                    "smoothness_avg": 0.034152573568993594,
                    "success_improvement": 0.0,
                    "time_improvement": 68.54898324279806,
                    "length_improvement": 20.26385994180389,
                    "smoothness_improvement": 778.7703170346437,
                    "objective_score": 28.511318546373413
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.020598220825195312,
                    "num_nodes_avg": 124.4,
                    "path_length_avg": 112.12845794943728,
                    "smoothness_avg": 0.07567514147955685,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 58.6274863795938,
                    "length_improvement": 25.52961721337948,
                    "smoothness_improvement": 862.5822138620559,
                    "objective_score": -72.99291957413567
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner combining goal bias sampling, rewiring with neighborhood optimization, and incremental connection with rewiring to minimize path length and enhance planning efficiency. It grows two trees simultaneously from start and goal, alternating their expansions, dynamically rewiring to reduce path costs and ensuring collision-free nodes and edges for robust and smooth path construction.",
          "planning_mechanism": "The planner alternates between expanding the two trees by sampling points with goal bias, steering towards samples, and rewiring locally to optimize cost. After a new node is added to one tree, it incrementally attempts connection to the other tree through rewiring-enhanced extension steps. When the trees connect successfully, the final path is constructed by concatenating the optimal paths from both trees, ensuring minimized path length and improved success rate through repeated collision checking and neighborhood-based rewiring.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._inside_bounds(new_pos, obstacles, is_3d):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if not self._inside_bounds(new_pos, obstacles, is_3d):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _inside_bounds(self, pos, obstacles, is_3d):\n        # Position must be within map bounds (assumed origin at 0)\n        # Using obstacles only for dimension info, bounds check done in _sample_free\n        # but nodes from steered positions can violate bounds so check\n        dims = len(pos)\n        for d in range(dims):\n            if pos[d] < 0:\n                return False\n            if is_3d:\n                # bounds unknown here, we rely on positive checking only (sampling enforces bounds)\n                # this method is a placeholder - \n                # safer if we reject negative coords only\n                continue\n            else:\n                continue\n        return True",
          "objective": 12.18696,
          "time_improvement": 0.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 270.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023809289932250975,
                    "num_nodes_avg": 77.7,
                    "path_length_avg": 165.54940495088522,
                    "smoothness_avg": 0.020562554204645422,
                    "success_improvement": 0.0,
                    "time_improvement": 4.468476914320158,
                    "length_improvement": 9.259747848225805,
                    "smoothness_improvement": 221.84862560384113,
                    "objective_score": 4.301735771960415
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04926056861877441,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 244.04682856696945,
                    "smoothness_avg": 0.015542087807597499,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 69.52040027397354,
                    "length_improvement": 18.53014412586919,
                    "smoothness_improvement": 299.90911380284587,
                    "objective_score": -23.938305523619864
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0860180139541626,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 124.42837862466763,
                    "smoothness_avg": 0.03042426300596567,
                    "success_improvement": 0.0,
                    "time_improvement": -72.77130311982366,
                    "length_improvement": 17.36059556017419,
                    "smoothness_improvement": 286.994379750387,
                    "objective_score": -16.92429992516032
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal bias sampling and incremental rewiring for path cost minimization. Two trees grow simultaneously from start and goal, each expanding toward sampled points with step size control and rewiring nearby nodes within a fixed radius to improve path quality. The planner attempts incremental, rewiring-enhanced connections between the trees at each iteration. Collision checks on nodes and edges ensure path feasibility. Clean rewiring via the Node's `update_parent` method maintains an optimized tree structure supporting shorter, smoother paths with higher success rates and reduced planning time.",
          "planning_mechanism": "The planner alternates growth between two trees, sampling points biased towards the opposing tree\u2019s root to accelerate connection. Each extension rewires neighbors for cost improvement. After extending one tree, it incrementally connects and rewires the other tree toward the new node. Upon successful connection, it concatenates the two root paths into a final optimized path. Robust collision checks and parent-child updates ensure path smoothness and reliability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling towards the other tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Construct final path by merging roots paths at connection nodes\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicated connection point in path_b\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if cheaper through new_node\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.69474,
          "time_improvement": -63.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 216.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02477607727050781,
                    "num_nodes_avg": 130.2,
                    "path_length_avg": 156.00336705470224,
                    "smoothness_avg": 0.01769763222411566,
                    "success_improvement": 0.0,
                    "time_improvement": 0.5893747997072792,
                    "length_improvement": 14.49208248577416,
                    "smoothness_improvement": 177.00637533089463,
                    "objective_score": 3.960260813721489
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0780069351196289,
                    "num_nodes_avg": 444.3,
                    "path_length_avg": 245.59103894997367,
                    "smoothness_avg": 0.013820258121187475,
                    "success_improvement": 0.0,
                    "time_improvement": 51.733806065035225,
                    "length_improvement": 18.014642252390974,
                    "smoothness_improvement": 255.60519578772144,
                    "objective_score": 20.40109624892737
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17042129039764403,
                    "num_nodes_avg": 567.8,
                    "path_length_avg": 126.69445055050053,
                    "smoothness_avg": 0.02473458198827077,
                    "success_improvement": 0.0,
                    "time_improvement": -242.29932856916415,
                    "length_improvement": 15.85557848578538,
                    "smoothness_improvement": 214.62205717387496,
                    "objective_score": -68.4455725877228
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements an improved unidirectional RRT* variant with informed sampling using ellipsoidal regions aligned along the start-goal vector, combined with adaptive neighbor radius rewiring, goal biasing, and post-planning path smoothing. It dynamically shrinks the sampling domain based on the cost of the best path found, ensures collision-free nodes and edges, and maintains efficient parent-child relationships to optimize path cost and smoothness.",
          "planning_mechanism": "The planner initializes from the start and iteratively samples points biased towards an informed ellipsoid or the goal with a set probability. It extends the tree towards samples by fixed steps while verifying nodes and edges for collisions. It then rewires neighbors inside an adaptive radius to optimize path costs. Upon nearing the goal, it connects directly if collision-free and extracts the path, applying shortcut smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, \n                 goal_sample_rate: float = 0.15, neighbor_factor: float = 30.0, \n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        # Precompute rotation matrix for ellipsoidal informed sampling\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                import numpy as np\n                a1v = np.array(a1)\n                eye = np.eye(dim)\n                v = np.cross([1] + [0]*(dim-1), a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1] + [0]*(dim-1), a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # fallback uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                # no solution found yet - uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                arg = c_best ** 2 - c_min ** 2\n                r2 = math.sqrt(arg) / 2.0 if arg > 0 else 0.0\n\n                if dim == 2:\n                    while True:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        sample_world = sample_ellipsoid\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid\n                        sample_world = sample_world + np.array(center)\n                        clipped = np.clip(sample_world, [0] * dim, bounds)\n                        p = tuple(clipped)\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    while True:\n                        sample_unit = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(sample_unit) <= 1:\n                            sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                            sample_world = sample_ellipsoid\n                            if rotation is not None:\n                                sample_world = rotation @ sample_ellipsoid\n                            sample_world = sample_world + np.array(center)\n                            clipped = np.clip(sample_world, [0] * dim, bounds)\n                            p = tuple(clipped)\n                            if not self._is_in_obstacle(p, obstacles, is_3d):\n                                return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n_nodes):\n            import math\n            if n_nodes <= 1:\n                return self.step_size * 2\n            radius = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(radius, self.step_size * 3)\n\n        for _ in range(self.max_iter):\n            if c_best < float(\"inf\") and random.random() < (1 - self.goal_sample_rate):\n                sample = _informed_sample()\n            else:\n                sample = _sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            min_cost = new_cost\n            min_parent = nearest_node\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.71326,
          "time_improvement": -90.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1889.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06702051162719727,
                    "num_nodes_avg": 308.1,
                    "path_length_avg": 169.29886988839934,
                    "smoothness_avg": 0.04100510499933652,
                    "success_improvement": 0.0,
                    "time_improvement": -168.9106467242872,
                    "length_improvement": 7.2046067019003015,
                    "smoothness_improvement": 541.8189372503213,
                    "objective_score": -46.523177990654496
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21944727897644042,
                    "num_nodes_avg": 830.9,
                    "path_length_avg": 237.7122159268916,
                    "smoothness_avg": 0.14466695389978618,
                    "success_improvement": 0.0,
                    "time_improvement": -35.78132392118496,
                    "length_improvement": 20.64482015684237,
                    "smoothness_improvement": 3622.3849232366215,
                    "objective_score": 11.506491471196092
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08296387195587158,
                    "num_nodes_avg": 462.0,
                    "path_length_avg": 125.36556539524406,
                    "smoothness_avg": 0.12610706940062055,
                    "success_improvement": 0.0,
                    "time_improvement": -66.63691255787805,
                    "length_improvement": 16.738160731195663,
                    "smoothness_improvement": 1504.0726145202857,
                    "objective_score": -9.123078548522853
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional RRT* variant with informed ellipsoidal sampling, adaptive neighbor rewiring, incremental connect-and-rewire steps, and goal biasing to rapidly find and optimize collision-free paths in 2D/3D environments. It smartly toggles between growing two trees from start and goal, rewires neighbors for path cost minimization, and applies path smoothing to return high-quality solutions efficiently.",
          "planning_mechanism": "The planner alternately extends two trees towards sampled points, using ellipsoidal informed sampling biased by the current best path cost and goal biasing. Each extension involves rewiring nearby nodes to reduce path cost. After each successful extension, the planner attempts incremental connection and rewiring of the opposite tree to the newly added node. On successfully connecting the trees, it merges and smooths the combined path, then terminates early to return the optimized route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # Children nodes list\n        self.valid = True               # Validity for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.2,\n                 neighbor_factor: float = 25.0, collision_resolution: float = 0.5, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            try:\n                import numpy as np\n                diff = [g - s for s, g in zip(start_position, goal_position)]\n                norm = math.dist(start_position, goal_position)\n                if norm < 1e-9:\n                    return np.eye(dim)\n                a1 = np.array(diff) / norm\n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    c, s_ = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s_], [s_, c]])\n                else:\n                    e1 = np.array([1.0] + [0.0]*(dim-1))\n                    v = np.cross(e1, a1)\n                    s_v = np.linalg.norm(v)\n                    if s_v < 1e-9:\n                        return np.eye(dim)\n                    c = np.dot(e1, a1)\n                    vx = np.zeros((dim, dim))\n                    # Construct skew-symmetric matrix vx for 3D only\n                    if dim == 3:\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = np.eye(dim) + vx + vx@vx*((1 - c) / (s_v**2))\n                    return R\n            except ImportError:\n                return None\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # No solution yet - uniform sampling free from obstacles\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            r1 = c_best / 2.0\n            val = max(0.0, c_best**2 - c_min**2)\n            r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = [radius * math.cos(theta), radius * math.sin(theta)]\n                    ellipsoid_sample = [r1 * unit_sample[0], r2 * unit_sample[1]]\n                    if rotation is not None:\n                        import numpy as np\n                        sample_world = rotation @ ellipsoid_sample + np.array(center)\n                    else:\n                        sample_world = [center[0] + ellipsoid_sample[0], center[1] + ellipsoid_sample[1]]\n                    p = tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                else:\n                    import numpy as np\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, dim)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    ellipsoid_sample = np.array([r1] + [r2]*(dim-1)) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ ellipsoid_sample + np.array(center)\n                    else:\n                        sample_world = np.array(center) + ellipsoid_sample\n                    p = tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(pos[d], bounds[d])) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            import math\n            if n_nodes <= 1:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 6.0)\n\n        def near_nodes(tree_nodes, position, radius):\n            return [node for node in tree_nodes if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cand_cost < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n            radius = adaptive_neighbor_radius(len(tree))\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cand_cost < min_cost:\n                        if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                            min_cost = cand_cost\n                            best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                            if nbr.parent:\n                                try:\n                                    edges.remove((nbr.parent, nbr))\n                                    nbr.parent.remove_child(nbr)\n                                except ValueError:\n                                    pass\n                            nbr.update_parent(new_node, cost_through_new)\n                            edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path):\n            import random\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n            smoothed = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path: List[tuple] = []\n        best_cost_path = float('inf')\n\n        for _ in range(self.max_iter):\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample_point = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample_point = uniform_sample()\n\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                if len(path_b) > 0 and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                combined_path = path_a + path_b\n                path_cost = new_node_a.cost + new_node_b.cost\n\n                if path_cost < best_cost_path:\n                    best_cost_path = path_cost\n                    c_best = path_cost\n                    center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n                extracted_path = path_smoothing(combined_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.97902,
          "time_improvement": 25.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1457.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030217814445495605,
                    "num_nodes_avg": 83.5,
                    "path_length_avg": 157.0391117014654,
                    "smoothness_avg": 0.039521206483810835,
                    "success_improvement": 0.0,
                    "time_improvement": -21.24485217798908,
                    "length_improvement": 13.924374432459064,
                    "smoothness_improvement": 518.5927031451425,
                    "objective_score": -0.9956172511791981
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04668238162994385,
                    "num_nodes_avg": 279.7,
                    "path_length_avg": 229.11793200634392,
                    "smoothness_avg": 0.0964909836890141,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 71.11563373639149,
                    "length_improvement": 23.513839502267878,
                    "smoothness_improvement": 2382.782509964687,
                    "objective_score": -12.048629428805535
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.03779945373535156,
                    "num_nodes_avg": 225.5,
                    "path_length_avg": 123.93051226029738,
                    "smoothness_avg": 0.12335843121327912,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 24.077985774535055,
                    "length_improvement": 17.691254693540266,
                    "smoothness_improvement": 1469.1101396606693,
                    "objective_score": -31.892802630628076
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a unidirectional, informed RRT* planner with adaptive neighbor radius and rewiring, focusing sampling within an ellipsoidal informed region between start and goal to efficiently find near-optimal paths. It maintains rigorous collision checks and bounds enforcement for nodes and edges, dynamically refines its tree structure to improve path quality and success rate.",
          "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling points biased towards the informed ellipsoid around the current best path cost or globally sampling otherwise. It steers towards these samples with fixed step size while ensuring node and edge collision-free validity. Neighboring nodes are evaluated within an adaptive radius for rewiring to reduce path costs. The process terminates once the goal is connected or iteration limit is reached, extracting the best found path by backtracking.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_factor: float=2.5, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n            while True:\n                if dim == 2 and np is not None:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                elif dim == 3 and np is not None:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    p = sample_free()\n\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        for _ in range(self.max_iter):\n            sample = None\n            if c_best < float('inf') and random.random() < 1 - self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            gamma = self.neighbor_factor\n            unit_ball_volume = math.pi if dim == 2 else 4/3 * math.pi\n            radius = min(self.step_size, gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            near_nodes = [n for n in nodes if n != new_node and math.dist(n.position, new_node.position) <= radius]\n\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n\n            for near in near_nodes:\n                cost_candidate = near.cost + math.dist(near.position, new_node.position)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_candidate\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                        except (ValueError, AttributeError):\n                            pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.63382,
          "time_improvement": -53.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.048303866386413576,
                    "num_nodes_avg": 282.5,
                    "path_length_avg": 197.33983891595304,
                    "smoothness_avg": 0.009950325225839406,
                    "success_improvement": 0.0,
                    "time_improvement": -93.81266471834658,
                    "length_improvement": -8.165092759690593,
                    "smoothness_improvement": 55.74419726145427,
                    "objective_score": -29.49809698113482
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.20108270645141602,
                    "num_nodes_avg": 842.6,
                    "path_length_avg": 306.1422547803274,
                    "smoothness_avg": 0.006399543535369534,
                    "success_improvement": 0.0,
                    "time_improvement": -24.418385258536347,
                    "length_improvement": -2.19909646189272,
                    "smoothness_improvement": 64.6648645699531,
                    "objective_score": -7.442010547089683
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0702040433883667,
                    "num_nodes_avg": 439.0,
                    "path_length_avg": 157.72117905085278,
                    "smoothness_avg": 0.012441624227179402,
                    "success_improvement": 0.0,
                    "time_improvement": -41.00818541279275,
                    "length_improvement": -4.750897250104076,
                    "smoothness_improvement": 58.256541824548854,
                    "objective_score": -12.961352364735896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner integrating adaptive step sizing, goal-biased sampling, and efficient incremental rewiring for expedited convergence. It alternates growth between start and goal trees, uses dynamic neighbor radius scaling based on tree size for efficient rewiring, and incorporates direct path attempts to speed up connection. The planner performs robust collision checking on nodes and edges, applies pruning of suboptimal nodes, and smooths the final path by shortcutting unnecessary waypoints to deliver efficient, smooth, and feasible paths rapidly.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by sampling within bounds with a goal bias. Each iteration alternates expansion between trees, steering incrementally towards samples. New nodes are connected via minimal-cost parents within a dynamically scaled neighbor radius, followed by rewiring neighbors for local cost improvements. Frequent attempts are made to directly connect the two trees when close. Upon success, the path is reconstructed and smoothed by shortcutting feasible segments, enhancing smoothness and reducing path length while maintaining collision-free constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost to reach this node from root\n        self.children = []\n        self.valid = True                 # Validity flag for collision etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    \n    def disconnect_children(self):\n        for child in self.children[:]:\n            child.parent = None\n        self.children.clear()\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0, goal_sample_rate: float=0.2, max_neighbor_radius: float=30.0, min_neighbor_radius: float=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.3)\n\n        def adaptive_neighbor_radius(num_nodes):\n            # Radius scaled based on tree size (RRT* radius decreasing with more nodes)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, 50.0 * (math.log(num_nodes + 1) / (num_nodes + 1))**(1/dim)))\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-6 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree_from, node_from, tree_to):\n            # Attempt direct connection within step_size from node_from to nodes in tree_to\n            candidates = near_nodes(tree_to, node_from.position, self.step_size)\n            min_cost = float('inf')\n            best_connect = None\n            for candidate in candidates:\n                if collision_free_edge(node_from.position, candidate.position):\n                    total_cost = node_from.cost + dist(node_from.position, candidate.position) + candidate.cost\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_connect = candidate\n            return best_connect\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove overlap at meeting point\n            return path_start + path_goal[::-1][1:]\n\n        def path_smooth(path):\n            # Shortcut smoothing by checking straight-line feasibility between non-adjacent nodes\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal[:] \n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n\n        for iter_count in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n            if grow_start:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_start, new_node, tree_goal)\n                if connect_node is not None:\n                    # Connect by linking the two trees at best_connect\n                    connecting_node = Node(new_node.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n\n                    # Rewire near nodes in goal tree to connecting_node\n                    n_radius = adaptive_neighbor_radius(len(tree_goal))\n                    neighbors = near_nodes(tree_goal, connecting_node.position, n_radius)\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    # Reconstruct path\n                    final_path = reconstruct_path(new_node, connecting_node)\n                    # Apply smoothing\n                    final_path = path_smooth(final_path)\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_goal, new_node, tree_start)\n                if connect_node is not None:\n                    connecting_node = Node(new_node.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n\n                    n_radius = adaptive_neighbor_radius(len(tree_start))\n                    neighbors = near_nodes(tree_start, connecting_node.position, n_radius)\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    final_path = reconstruct_path(connecting_node, new_node)\n                    final_path = path_smooth(final_path)\n                    success = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.10016,
          "time_improvement": -94.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1560.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07176172733306885,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 164.07408821044345,
                    "smoothness_avg": 0.041678064989647254,
                    "success_improvement": 0.0,
                    "time_improvement": -187.93412701069983,
                    "length_improvement": 10.068392331551712,
                    "smoothness_improvement": 552.3522224546931,
                    "objective_score": -51.60479852462613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09400091171264649,
                    "num_nodes_avg": 329.3,
                    "path_length_avg": 231.65746108796742,
                    "smoothness_avg": 0.1097279862570906,
                    "success_improvement": 0.0,
                    "time_improvement": 41.837655487576846,
                    "length_improvement": 22.666071598530273,
                    "smoothness_improvement": 2723.3801202688687,
                    "objective_score": 30.70141156732345
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11801156997680665,
                    "num_nodes_avg": 341.0,
                    "path_length_avg": 122.79671989611192,
                    "smoothness_avg": 0.11829656009312739,
                    "success_improvement": 0.0,
                    "time_improvement": -137.03189356329554,
                    "length_improvement": 18.444265596441586,
                    "smoothness_improvement": 1404.7235126408002,
                    "objective_score": -30.397097386496338
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid path planner combining bidirectional RRT*'s rewiring and incremental cost optimization with goal-biased, informed sampling from unidirectional informed RRT*. It maintains two trees growing alternately from start and goal, uses ellipsoidal informed sampling to focus exploration, applies rewiring within neighborhoods for path cost improvement, and ensures rigorous collision checking for nodes and edges to produce high-quality, smooth, and efficient paths.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points biased by an ellipsoidal informed region around the best found path cost to concentrate search efforts. Each extension attempts to connect the other tree incrementally with rewiring to reduce path costs progressively. Goal biasing, adaptive neighborhood rewiring, and strict collision checks help improve planning time, path quality, and success rate while simplifying the connectivity logic by integrating RRT* rewiring with dual-tree bidirectional search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0] * dim, bounds))\n                else:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0] * dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n        def connect_nodes(new_node, other_tree):\n            curr_nearest = nearest(other_tree, new_node.position)\n            # Incrementally extend from curr_nearest towards new_node with rewiring\n            direction = new_node.position\n            last_node = curr_nearest\n\n            while True:\n                pos_next = steer(last_node.position, direction)\n                if pos_next == last_node.position:\n                    break\n                if self._is_in_obstacle(pos_next, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, pos_next, obstacles, is_3d, self.collision_resolution):\n                    return None\n                cost_to_next = last_node.cost + math.dist(last_node.position, pos_next)\n                candidate_node = Node(pos_next, parent=last_node, cost=cost_to_next)\n                # Rewire candidate_node parent among neighbours in other_tree\n                neighbors = near_nodes(other_tree, candidate_node)\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    cost_via_near = near.cost + math.dist(near.position, pos_next)\n                    if cost_via_near < min_cost and not self._is_edge_in_obstacle(near.position, pos_next,\n                                                                                  obstacles, is_3d,\n                                                                                  self.collision_resolution):\n                        min_cost = cost_via_near\n                        min_parent = near\n                if min_parent != last_node:\n                    candidate_node.parent = min_parent\n                    candidate_node.cost = min_cost\n                    min_parent.add_child(candidate_node)\n                else:\n                    last_node.add_child(candidate_node)\n                other_tree.append(candidate_node)\n                nodes.append(candidate_node)\n                edges.append((candidate_node.parent, candidate_node))\n\n                # Attempt to rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + math.dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost and not self._is_edge_in_obstacle(candidate_node.position,\n                                                                                            near.position,\n                                                                                            obstacles, is_3d,\n                                                                                            self.collision_resolution):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = candidate_node\n                        near.cost = cost_through_candidate\n                        candidate_node.add_child(near)\n                        edges.append((candidate_node, near))\n\n                if math.dist(pos_next, direction) < self.step_size * 0.5:\n                    return candidate_node\n                last_node = candidate_node\n\n            return None\n\n        # Main loop alternating expansion of start and goal trees\n        for i in range(self.max_iter):\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Sampling\n                sample = None\n                if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire near nodes in tree_a around new_node\n                neighbors = near_nodes(tree_a, new_node)\n                min_cost = new_node.cost\n                min_parent = new_node.parent\n\n                for near in neighbors:\n                    cost_candidate = near.cost + math.dist(near.position, new_node.position)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_node.position,\n                                                                                  obstacles, is_3d,\n                                                                                  self.collision_resolution):\n                        min_cost = cost_candidate\n                        min_parent = near\n                if min_parent != new_node.parent:\n                    new_node.update_parent(min_parent, min_cost)\n                    try:\n                        edges.remove((new_node.parent, new_node))\n                    except (ValueError, AttributeError):\n                        pass\n                    edges.append((min_parent, new_node))\n\n                for near in neighbors:\n                    if near == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                    if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position,\n                                                                                     near.position, obstacles,\n                                                                                     is_3d,\n                                                                                     self.collision_resolution):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n                # Attempt to connect to the other tree incrementally with rewiring\n                connected_node = connect_nodes(new_node, tree_b)\n                if connected_node is not None:\n                    # Extract path combining new_node (in tree_a) and connected_node (in tree_b)\n                    path_a = []\n                    curr = new_node\n                    while curr is not None:\n                        path_a.append(curr.position)\n                        curr = curr.parent\n                    path_b = []\n                    curr = connected_node\n                    while curr is not None:\n                        path_b.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path_a[::-1] + path_b\n                    success_state = True\n\n                    # Update best cost\n                    path_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if path_cost < c_best:\n                        c_best = path_cost\n                        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n                        # rotation unchanged (depends only on start and goal)\n\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.76404,
          "time_improvement": -2.0,
          "length_improvement": -3.0,
          "smoothness_improvement": -3.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015021467208862304,
                    "num_nodes_avg": 117.6,
                    "path_length_avg": 187.22071853496146,
                    "smoothness_avg": 0.006201579148821495,
                    "success_improvement": 0.0,
                    "time_improvement": 39.72841502087828,
                    "length_improvement": -2.618642531145551,
                    "smoothness_improvement": -2.9318193762760227,
                    "objective_score": 11.380136903152994
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04503486156463623,
                    "num_nodes_avg": 368.9,
                    "path_length_avg": 301.49843150421884,
                    "smoothness_avg": 0.0037699475174776927,
                    "success_improvement": 0.0,
                    "time_improvement": 72.13502416445965,
                    "length_improvement": -0.648854587285943,
                    "smoothness_improvement": -2.996534991858748,
                    "objective_score": 21.49575365692141
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.10808990001678467,
                    "num_nodes_avg": 513.7,
                    "path_length_avg": 158.2287978503895,
                    "smoothness_avg": 0.007558457089107224,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -117.10374398951838,
                    "length_improvement": -5.088033486546662,
                    "smoothness_improvement": -3.856983733824273,
                    "objective_score": -86.16801481283395
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that grows two trees simultaneously from start and goal positions, employing goal-biased sampling, adaptive rewiring with neighborhood consideration, and incremental connection attempts. It improves planning efficiency and path quality by dynamically optimizing parent-child relations and costs during both tree extensions and inter-tree connections, while rigorously checking for collisions in 2D/3D environments.",
          "planning_mechanism": "The planner alternates growing two trees toward random, goal-biased samples, extending toward them with step size limits. Each extension involves rewiring nearby nodes to minimize path costs. Incremental, rewiring-enabled connections from one tree to the other efficiently merge the trees. Continuous collision checking maintains path validity, and path extraction merges start and goal tree paths upon successful connection.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(tree_from_start=True):\n            # Goal biasing: sample goal_pos from start tree; start_pos from goal tree, else random\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_from_start else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    if neighbor == curr_node:\n                        continue\n                    cost_candidate = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, new_cost)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            sample = sample_free(tree_from_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Add all new edges from rewiring: reconstruct edges list for correctness\n            edges.clear()\n            for tree in [start_tree, goal_tree]:\n                for node in tree:\n                    for child in node.children:\n                        edges.append((node, child))\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Add edges from incremental connection rewiring:\n                edges.clear()\n                for tree in [start_tree, goal_tree]:\n                    for node in tree:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Merge start -> goal path, avoid duplicate connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # Collect all nodes - may have duplicates if reused, but here both trees combined\n        all_nodes_set = set(start_tree) | set(goal_tree)\n        nodes = list(all_nodes_set)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 18.69555,
          "time_improvement": 33.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 315.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.029830431938171385,
                    "num_nodes_avg": 122.3,
                    "path_length_avg": 168.03885929839015,
                    "smoothness_avg": 0.021687404577900745,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -19.690532790609794,
                    "length_improvement": 7.895238472429828,
                    "smoothness_improvement": 239.4549765969684,
                    "objective_score": -53.13083725971212
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0477452278137207,
                    "num_nodes_avg": 245.4,
                    "path_length_avg": 245.717339118139,
                    "smoothness_avg": 0.015576380313218563,
                    "success_improvement": 0.0,
                    "time_improvement": 70.45800579663793,
                    "length_improvement": 17.97247962090861,
                    "smoothness_improvement": 300.7914846723692,
                    "objective_score": 26.235855086534947
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.02552957534790039,
                    "num_nodes_avg": 160.6,
                    "path_length_avg": 119.1512117893651,
                    "smoothness_avg": 0.039598764619383234,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 48.72262450394522,
                    "length_improvement": 20.865438500501185,
                    "smoothness_improvement": 403.69336308179146,
                    "objective_score": -29.191658133307232
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal biasing, rewiring, and incremental connection strategies to minimize path length while ensuring collision-free paths. By simultaneously growing two trees from start and goal, rewiring nodes within a neighbor radius to reduce path costs, and carefully connecting the two trees, the planner optimizes for path quality and search efficiency in 2D/3D spaces with obstacle avoidance.",
          "planning_mechanism": "The planner alternates expansions between two trees, sampling points biased towards the opposing tree\u2019s root to speed convergence. New nodes are added by steering towards samples within step size limits, with parent selection and rewiring based on minimizing cumulative cost locally. An incremental connection method attempts to link the other tree to each newly added node with rewiring-enabled steps. Each candidate node and edge undergo collision checks to maintain feasibility. Once the trees connect, paths are merged and returned as the optimized solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...] (2D or 3D)\n        self.parent = parent             # Parent Node\n        self.cost = cost                 # Cost from root\n        self.children = []               # List of child Nodes\n        self.valid = True                # Validity flag (optional)\n\n    def add_child(self, child_node) -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node) -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost) -> None:\n        # Detach from current parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal bias: sample goal of opposite tree to encourage connection\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Merge path from both trees; avoid duplicating connecting node\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        # Reject if new position or edge lies inside obstacle or outside bounds\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        # Create new node without parent yet\n        new_node = Node(new_pos)\n\n        # Find neighbors within radius for rewiring & parent selection\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor is nearest:\n                continue\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper path possible\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Remove old edge\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_pos)\n        current_node = nearest\n\n        while True:\n            new_pos = self._steer(current_node.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for neighbor in neighbors:\n                if neighbor is current_node:\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper path possible\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n\n        return False",
          "objective": 21.54223,
          "time_improvement": 25.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 275.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012533068656921387,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 177.00893311429718,
                    "smoothness_avg": 0.019697850316234604,
                    "success_improvement": 0.0,
                    "time_improvement": 49.71277425156288,
                    "length_improvement": 2.9785988740156215,
                    "smoothness_improvement": 208.31413201566394,
                    "objective_score": 16.551122710350306
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.03654544353485108,
                    "num_nodes_avg": 247.4,
                    "path_length_avg": 239.76390072708136,
                    "smoothness_avg": 0.01522429284687948,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 77.38778658093217,
                    "length_improvement": 19.959908716066412,
                    "smoothness_improvement": 291.7320205651132,
                    "objective_score": -21.333022179681493
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.07614445686340332,
                    "num_nodes_avg": 315.5,
                    "path_length_avg": 117.3763090913454,
                    "smoothness_avg": 0.03346384408092015,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -52.939790549590626,
                    "length_improvement": 22.044244360741736,
                    "smoothness_improvement": 325.6576266652711,
                    "objective_score": -59.84480015940247
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive step size, dynamic rewiring, and goal bias sampling to efficiently explore free space and incrementally connect start and goal trees. It carefully manages parent-child relationships and performs rigorous collision checks for nodes and edges in both 2D and 3D environments to ensure safety and path feasibility, resulting in improved planning speed, success rate, and path quality.",
          "planning_mechanism": "The algorithm grows two trees simultaneously from the start and goal positions, alternately sampling points biased toward the opposing tree's root to accelerate connection. Each extension rewires nearby nodes within a dynamic radius based on tree size, optimizing path costs dynamically. The incremental connection phase attempts to connect the trees with rewiring-enhanced expansions. Collision checks prevent invalid node placements and paths. Once connected, the path is extracted by concatenating the root paths of the connection nodes, yielding a smooth, low-cost solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and validity\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.12,\n                 rewire_factor: float = 30.0,\n                 resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor\n        self.resolution = resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(tree_from_start=True):\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_from_start else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def dynamic_neighbor_radius(tree_size):\n            # Decrease radius with tree growth, bounded below\n            min_radius = 5.0\n            radius = min(self.rewire_factor * (math.log(tree_size + 1) / (tree_size + 1))**0.5, self.rewire_factor)\n            return max(radius, min_radius)\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.resolution):\n                return None\n\n            radius = dynamic_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                cost_candidate = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.resolution):\n                    neighbor.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.resolution):\n                    return None\n\n                radius = dynamic_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    if neighbor == curr_node:\n                        continue\n                    cost_candidate = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.resolution):\n                        min_cost = cost_candidate\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.resolution):\n                        neighbor.update_parent(new_node, new_cost)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        # Initialize trees and data structures\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        import random\n\n        for _ in range(self.max_iter):\n            sample = sample_free(tree_from_start=(tree_a is start_tree))\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Rebuild edges from children-parent relationships\n                edges.clear()\n                for tree in [start_tree, goal_tree]:\n                    for node in tree:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicate node at connection\n                if path_goal and path_goal[0] == new_node_a.position:\n                    path_goal = path_goal[1:]\n                extracted_path = path_start + path_goal[::-1]\n\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # Final nodes: unique combination of both trees\n        all_nodes_set = set(start_tree).union(set(goal_tree))\n        nodes = list(all_nodes_set)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 25.14506,
          "time_improvement": 17.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 127.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.015123105049133301,
                    "num_nodes_avg": 83.4,
                    "path_length_avg": 160.63604775491788,
                    "smoothness_avg": 0.016168465268575086,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 39.32060707230627,
                    "length_improvement": 11.952836784462578,
                    "smoothness_improvement": 153.071591837492,
                    "objective_score": -35.047892562228135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05102295875549316,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 271.1100781435301,
                    "smoothness_avg": 0.0071304046671271035,
                    "success_improvement": 0.0,
                    "time_improvement": 68.42993486859021,
                    "length_improvement": 9.495652444765492,
                    "smoothness_improvement": 83.47044790807058,
                    "objective_score": 22.845463189070514
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.07802553176879883,
                    "num_nodes_avg": 322.6,
                    "path_length_avg": 127.5834143939766,
                    "smoothness_avg": 0.019333877711263943,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -56.71801964058504,
                    "length_improvement": 15.265171028857893,
                    "smoothness_improvement": 145.92549740887105,
                    "objective_score": -63.23274419935957
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a unidirectional informed RRT* with adaptive neighborhood rewiring, combining goal-biased sampling, dynamic ellipsoidal informed sampling to improve convergence, and rigorous collision checking for nodes and edges. It maintains a single tree expanding from start towards goal with incremental cost-based rewiring, dynamically refining path quality and smoothness while efficiently reducing exploration of unpromising regions. The rewiring radius adapts with growth in nodes, and path extraction updates upon successful close reach to goal.",
          "planning_mechanism": "The planner samples points informed by an ellipsoidal heuristic shaped by current best path cost, or uniformly for exploration, with occasional direct goal biasing. For each sample, it extends the nearest node toward it stepwise, verifying node and edge collision-free status, then selects the lowest-cost parent within an adaptive radius. Rewiring reassigns parents of neighbors when advantageous, improving overall path cost. When the goal is reachable within step size and collision-free, a goal node is appended, and the optimal path is extracted by backtracking from goal to start. The ellipsoid parameters update accordingly, focusing future samples in promising regions to accelerate convergence toward smooth and short paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\n        # Recursively update descendants cost\n        for child in self.children:\n            dist = self._distance(child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_factor: float=2.5, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start, goal)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            elif dim == 3:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n            return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample\n                return uniform_sample()\n\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n\n            while True:\n                if dim == 2:\n                    if np is None:\n                        # Fallback uniform random sample\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        local = np.array([radius * math.cos(theta), radius * math.sin(theta)]) * np.array([r1, r2])\n                        sample = rotation @ local + np.array(center) if rotation is not None else local + np.array(center)\n                        p = tuple(np.clip(sample, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                elif dim == 3:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        while True:\n                            local = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(local) <= 1:\n                                break\n                        local = local * np.array([r1, r2, r2])\n                        sample = rotation @ local + np.array(center) if rotation is not None else local + np.array(center)\n                        p = tuple(np.clip(sample, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def sample_point():\n            if c_best < float('inf') and random.random() < 1 - self.goal_sample_rate:\n                return informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return uniform_sample()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(position, radius):\n            return [n for n in nodes if math.dist(n.position, position) <= radius]\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            sample = sample_point()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._within_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius\n            gamma = self.neighbor_factor\n            radius = min(self.step_size,\n                         gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)) if len(nodes) > 1 else self.step_size)\n\n            neighbors = near_nodes(new_node.position, radius)\n\n            # Choose best parent in neighbors\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in neighbors:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                new_node.update_parent(min_parent, min_cost)\n                try:\n                    edges.remove((nearest_node, new_node))\n                except ValueError:\n                    pass\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through new_node reduces cost\n            for near in neighbors:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        old_parent = near.parent\n                        near.update_parent(new_node, cost_through_new)\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n            # Check if goal can be connected\n            dist_to_goal = math.dist(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, self.collision_resolution)\n                   and not self._is_in_obstacle(goal, obstacles, is_3d)):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = goal_node.path_from_root()\n                    c_best = goal_node.cost\n                    center = tuple((s + g) / 2 for s, g in zip(start, goal))\n                    rotation = rotation_matrix()\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 28.88075,
          "time_improvement": -41.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04487242698669434,
                    "num_nodes_avg": 264.3,
                    "path_length_avg": 191.72891197464,
                    "smoothness_avg": 0.010307707869916392,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -80.04448292190617,
                    "length_improvement": -5.089654792329865,
                    "smoothness_improvement": 61.33801171009212,
                    "objective_score": -74.72458577648734
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2658307313919067,
                    "num_nodes_avg": 1015.2,
                    "path_length_avg": 300.1012170528991,
                    "smoothness_avg": 0.006526076530058787,
                    "success_improvement": 0.0,
                    "time_improvement": -64.48073002174293,
                    "length_improvement": -0.18242418684729214,
                    "smoothness_improvement": 67.92064966133982,
                    "objective_score": -19.041100595585636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03886511325836182,
                    "num_nodes_avg": 334.2,
                    "path_length_avg": 149.05833285563048,
                    "smoothness_avg": 0.013233474792776026,
                    "success_improvement": 0.0,
                    "time_improvement": 21.937557554806062,
                    "length_improvement": 1.0025527123553555,
                    "smoothness_improvement": 68.32882257060902,
                    "objective_score": 7.123421921765934
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner integrating goal biasing, adaptive rewiring, and dynamic neighborhood radius to optimize path length and planning time. It grows two trees simultaneously from start and goal, extends toward randomly sampled points with goal bias, performs rewiring in local neighborhoods for path cost improvements, and attempts incremental connections between the two trees. The rewiring leverages a clean `update_parent` method, and dynamic neighbor radius adapts as trees grow to balance exploration and refinement. Path smoothing is applied upon successful connection to improve smoothness and reduce final path length.",
          "planning_mechanism": "The planner operates by alternating expansions between the start and goal trees. On each iteration, it samples a point biased toward the goal, extends a tree toward the sample, and rewires neighbors within a dynamically adjusted radius to optimize costs. Then, it tries to incrementally connect the other tree to the new node, performing rewiring during connection attempts. Upon connection, it extracts and smooths the path, ensuring collision-free edges throughout. This approach balances rapid convergence, path optimality, and robustness while reducing search time and path length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0,\n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=5.0, max_neighbor_radius: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        def sample_free(goal_bias_for_start=True):\n            if self._random() < self.goal_sample_rate:\n                return goal_position if goal_bias_for_start else start_position\n            while True:\n                p = tuple(self._random() * bounds[d] for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not self._within_bounds(new_pos, bounds) or \n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Find best parent with minimal cost and no collision edge\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]  # copy\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) < 3:\n                    break\n                i = int(self._random() * (len(path) - 2))\n                j = i + 2 + int(self._random() * (len(path) - i - 2))\n                if j >= len(path):\n                    j = len(path) - 1\n                if j <= i + 1:\n                    attempts += 1\n                    continue\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # shortcut possible, remove intermediate points\n                    del path[i+1:j]\n                    attempts = 0  # reset attempts after successful shortcut\n                else:\n                    attempts += 1\n            return path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample = sample_free(goal_bias_for_start=(tree_a is start_tree))\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # no duplicate node\n\n                extracted_path = smooth_path(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _random(self):\n        import random\n        return random.random()",
          "objective": 31.4162,
          "time_improvement": 25.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.030724310874938966,
                    "num_nodes_avg": 71.1,
                    "path_length_avg": 157.91653342559775,
                    "smoothness_avg": 0.039195557778776334,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -23.27709990481612,
                    "length_improvement": 13.44344568182517,
                    "smoothness_improvement": 513.4955937538712,
                    "objective_score": -51.72696286631044
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05501160621643066,
                    "num_nodes_avg": 292.7,
                    "path_length_avg": 238.13800306506613,
                    "smoothness_avg": 0.08852300147839336,
                    "success_improvement": 0.0,
                    "time_improvement": 65.96198978662312,
                    "length_improvement": 20.502680154516465,
                    "smoothness_improvement": 2177.7605885798052,
                    "objective_score": 34.77793590978925
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.033825016021728514,
                    "num_nodes_avg": 232.8,
                    "path_length_avg": 113.88543715421818,
                    "smoothness_avg": 0.13694466961526325,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 32.06083438246896,
                    "length_improvement": 24.36271528392311,
                    "smoothness_improvement": 1641.9260893021046,
                    "objective_score": -77.29957618196414
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a unidirectional RRT*-informed planner with adaptive neighbor radius and dynamic rewiring. It focuses sampling within an ellipsoidal region between start and goal, improving sampling efficiency and convergence speed. It incorporates rigorous collision checks and edge validations to ensure validity while maintaining path optimality and smoothing via rewiring.",
          "planning_mechanism": "The planner grows a single tree rooted at the start by alternating informed ellipsoidal sampling and global sampling, extending towards sampled points by fixed steps. It dynamically adjusts neighbor radius based on node density to rewire for cost improvements. The algorithm terminates upon connecting to the goal or reaching max iterations, constructing the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # Validity flag (e.g., collision)\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.5, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            r1 = c_best / 2\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2\n            else:\n                r2 = 0\n\n            while True:\n                if dim == 2:\n                    if np is None:\n                        # fallback uniform sample since no numpy\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        for _ in range(self.max_iter):\n            # Sampling with bias towards goal and informed region\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_free()\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards the sample by step size\n            vect = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample)\n            unit_vect = tuple(v / dist_to_sample for v in vect)\n            new_pos = tuple(\n                max(0, min(nearest_node.position[d] + unit_vect[d] * scale, bounds[d])) for d in range(dim)\n            )\n\n            # Validate new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Dynamic neighbor radius for rewiring: gamma * (log(n)/n)^{1/dim}\n            gamma = self.neighbor_factor\n            unit_ball_vol = math.pi if dim == 2 else 4/3 * math.pi\n            radius = min(self.step_size,\n                         gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            # Find neighbors inside radius\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            # Choose best parent for new_node from neighbors\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire near nodes if beneficial to connect through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                        except (ValueError, AttributeError):\n                            pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Check if close to goal for connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    # Update best cost bound for ellipsoid sampling\n                    c_best = goal_node.cost\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 34.77692,
          "time_improvement": -114.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09198317527770997,
                    "num_nodes_avg": 399.7,
                    "path_length_avg": 195.53317065233801,
                    "smoothness_avg": 0.009885326809741763,
                    "success_improvement": 0.0,
                    "time_improvement": -269.0699242833706,
                    "length_improvement": -7.174829255912539,
                    "smoothness_improvement": 54.72683090320648,
                    "objective_score": -81.88230898167765
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.25761568546295166,
                    "num_nodes_avg": 939.1,
                    "path_length_avg": 314.92541461098097,
                    "smoothness_avg": 0.006274528374508394,
                    "success_improvement": 0.0,
                    "time_improvement": -59.39773324224487,
                    "length_improvement": -5.1311680226032195,
                    "smoothness_improvement": 61.44813443621522,
                    "objective_score": -18.538312905013026
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05713896751403809,
                    "num_nodes_avg": 405.6,
                    "path_length_avg": 149.1699784713527,
                    "smoothness_avg": 0.013114445762026972,
                    "success_improvement": 0.0,
                    "time_improvement": -14.766354424111938,
                    "length_improvement": 0.9284030103855829,
                    "smoothness_improvement": 66.81478208529019,
                    "objective_score": -3.910151814730014
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an optimized unidirectional RRT* planner with key improvements focused on minimizing path length while ensuring planning efficiency and robustness. It incorporates goal-biased sampling for directed growth, rewiring using an adaptive neighbor radius to optimize node parent selection and reduce path costs, and post-processing path smoothing to produce smoother and shorter final paths. The tree\u2019s parent-child relationships are carefully managed with `update_parent` for clean rewiring, while all obstacles and edge collisions are rigorously checked for validity. These changes collectively improve success rate, reduce search time, and yield higher-quality paths compared to classic RRT or RRT* implementations.",
          "planning_mechanism": "The planner operates by iteratively sampling points within the map bounds, biased with a fixed probability toward the goal to speed convergence. For each sample, it extends the nearest node towards the sample using a fixed step size, verifies collision-free conditions, then adds the new node choosing the best parent from nearby neighbors to minimize path cost. It then rewires neighbors if they can achieve a lower cost via the new node. Once a node is close enough to the goal, the final path is extracted and smoothed by shortcutting unnecessary waypoints, leading to a shorter and smoother path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        start_node = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_node)\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def near_nodes(position):\n            # Adaptive neighbor radius depending on iteration count and total nodes, capped between min and max\n            n = len(nodes)\n            gamma = self.neighbor_radius_max\n            radius = max(self.neighbor_radius_min,\n                         min(gamma * (math.log(n + 1) / (n + 1)) ** (1 / len(bounds)),\n                             self.neighbor_radius_max))\n            return [node for node in nodes if dist(node.position, position) <= radius]\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n\n            nearest_node = min(nodes, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            # Check new node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node candidate\n            new_node = Node(new_pos)\n            neighbors = near_nodes(new_pos)\n\n            # Choose best parent to minimize cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if potential_cost < min_cost:\n                    # Check edge collision from neighbor to new_node\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = potential_cost\n                        best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Update edge connections\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Check if goal reached within step size and connection is collision free\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_parent = new_node\n                    goal_cost = new_node.cost + dist(new_node.position, goal_position)\n                    goal_parent.add_child(goal_node)\n                    goal_node.cost = goal_cost\n                    nodes.append(goal_node)\n                    edges.append((goal_parent, goal_node))\n                    # Extract path and smooth it\n                    raw_path = goal_node.path_from_root()\n                    smoothed_path = self._path_smoothing(raw_path, obstacles, is_3d)\n                    extracted_path = smoothed_path\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) <= 2:\n            return path[:]\n\n        def collision_free(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            if collision_free(path[i], path[j]):\n                # Shortcut: remove intermediate points between i+1 and j-1\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.22387,
          "time_improvement": -148.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1134.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06379935741424561,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 171.39855818816042,
                    "smoothness_avg": 0.03467149781761094,
                    "success_improvement": 0.0,
                    "time_improvement": -155.98620551109923,
                    "length_improvement": 6.0537342731109876,
                    "smoothness_improvement": 442.68423120818613,
                    "objective_score": -43.371693642666635
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.38007965087890627,
                    "num_nodes_avg": 901.3,
                    "path_length_avg": 223.6383857241507,
                    "smoothness_avg": 0.07249447064951711,
                    "success_improvement": 0.0,
                    "time_improvement": -135.17137433898284,
                    "length_improvement": 25.34306977125868,
                    "smoothness_improvement": 1765.3349454687113,
                    "objective_score": -26.656123620099557
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12580482959747313,
                    "num_nodes_avg": 443.4,
                    "path_length_avg": 119.01202274778555,
                    "smoothness_avg": 0.10173214917597768,
                    "success_improvement": 0.0,
                    "time_improvement": -152.6850289743404,
                    "length_improvement": 20.957881234448408,
                    "smoothness_improvement": 1194.0254284322875,
                    "objective_score": -35.643805303251
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner is a bidirectional RRT* inspired algorithm combining goal-biased sampling with adaptive dynamic neighborhood radius rewiring and incremental rewiring-enhanced connection between two trees. It merges advantages of structured rewiring, clear node-parent-child management, incremental connection for robust linking, and path smoothing to improve planning efficiency, path quality, and success rate, while maintaining robust collision checks in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees. Each iteration samples with goal bias to guide exploration efficiently. Extending a tree applies rewiring with a dynamically adapted neighbor radius for cost optimization. The other tree incrementally attempts connection and rewiring toward the new node. Successful connection merges paths and applies path smoothing to enhance smoothness and reduce length. Throughout, stringent node and edge collision checks ensure valid growth within bounds and obstacle-free trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...], e.g. 2D:(x,y), 3D:(x,y,z)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision validity flag\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=25.0,\n                 smoothing_attempts: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_attempts = smoothing_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        def _random():\n            return random.random()\n\n        def sample_free(goal_bias_for_start=True):\n            if _random() < self.goal_sample_rate:\n                return goal_position if goal_bias_for_start else start_position\n            while True:\n                p = tuple(_random() * bounds[d] for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            if n_nodes == 0:\n                return self.max_neighbor_radius\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Find best parent minimizing cost and obstacle-free path\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost can be improved through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            attempts = 0\n            while attempts < self.smoothing_attempts:\n                if len(smoothed) < 3:\n                    break\n                i = int(_random() * (len(smoothed) - 2))\n                j = i + 2 + int(_random() * (len(smoothed) - i - 2))\n                if j >= len(smoothed):\n                    j = len(smoothed) - 1\n                if j <= i + 1:\n                    attempts += 1\n                    continue\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    del smoothed[i+1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return smoothed\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample = sample_free(goal_bias_for_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # concatenate without duplicate node\n                extracted_path = smooth_path(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = 0.0\n        try:\n            distance = math.dist(from_pos, to_pos)\n        except Exception:\n            return True\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 35.76289,
          "time_improvement": 9.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1639.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03294820785522461,
                    "num_nodes_avg": 64.9,
                    "path_length_avg": 164.29379223929922,
                    "smoothness_avg": 0.0455884836989978,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -32.2001827147975,
                    "length_improvement": 9.947969071902737,
                    "smoothness_improvement": 613.5587668661695,
                    "objective_score": -54.602667165727844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05318691730499268,
                    "num_nodes_avg": 249.4,
                    "path_length_avg": 240.74215481233563,
                    "smoothness_avg": 0.1205013499174397,
                    "success_improvement": 0.0,
                    "time_improvement": 67.09100208194512,
                    "length_improvement": 19.63333934492593,
                    "smoothness_improvement": 3000.5865269898445,
                    "objective_score": 39.05690112851795
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.05383450984954834,
                    "num_nodes_avg": 224.3,
                    "path_length_avg": 119.12664613448604,
                    "smoothness_avg": 0.11037028043636468,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -8.129192851160328,
                    "length_improvement": 20.88175383878108,
                    "smoothness_improvement": 1303.9018204638846,
                    "objective_score": -91.74289798527245
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a unidirectional informed RRT* path planning algorithm using adaptive sampling within an ellipsoidal informed set, goal biasing, and rewiring for path cost optimization. It incrementally grows a single tree from the start towards the goal, selectively rewiring neighbors within an adaptive radius to maintain lower-cost connections. Once a feasible path is found, it refines the solution by shortcut path smoothing, improving smoothness and path quality. The planner handles 2D and 3D environments with precise collision checks for nodes and edges.",
          "planning_mechanism": "The planner iteratively samples points biased by an informed ellipsoid centered around the current best path or performs global random sampling with occasional goal bias. For each sample, it extends the nearest tree node towards the sample within a fixed step size, checking node and edge collisions. It then connects the new node with the best parent from nearby nodes to minimize cost and rewires neighbors if improved paths are found via this new node. When the tree reaches near the goal, it connects directly, extracts the path, and performs shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start to this node\n        self.children = []\n        self.valid = True                 # For collision or validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_factor: float = 30.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # Fallback uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                while True:\n                    if dim == 2:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n):\n            import math\n            gamma = self.neighbor_factor\n            radius = gamma * ((math.log(n) / n) ** (1.0 / dim)) if n > 1 else self.step_size * 2\n            return min(radius, self.step_size * 3)\n\n        for _ in range(self.max_iter):\n            sample = _informed_sample() if (c_best < float('inf') and random.random() < (1 - self.goal_sample_rate)) else _sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=cost_to_new)\n\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            min_cost = cost_to_new\n            min_parent = nearest_node\n            for near in near_nodes:\n                candidate_cost = near.cost + math.dist(near.position, new_node.position)\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = candidate_cost\n                        min_parent = near\n\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 37.68423,
          "time_improvement": -165.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1761.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044990921020507814,
                    "num_nodes_avg": 194.6,
                    "path_length_avg": 165.5207622849113,
                    "smoothness_avg": 0.048098359834809604,
                    "success_improvement": 0.0,
                    "time_improvement": -80.51992404421507,
                    "length_improvement": 9.27544734731819,
                    "smoothness_improvement": 652.8437786748879,
                    "objective_score": -19.03666885042644
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3306701898574829,
                    "num_nodes_avg": 1016.5,
                    "path_length_avg": 246.58571364093532,
                    "smoothness_avg": 0.12484997435332801,
                    "success_improvement": 0.0,
                    "time_improvement": -104.59964857864061,
                    "length_improvement": 17.682591210424434,
                    "smoothness_improvement": 3112.479765912828,
                    "objective_score": -12.280977501943154
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20413784980773925,
                    "num_nodes_avg": 632.1,
                    "path_length_avg": 122.7958777824947,
                    "smoothness_avg": 0.12707901707366764,
                    "success_improvement": 0.0,
                    "time_improvement": -310.0206538848506,
                    "length_improvement": 18.444824888209006,
                    "smoothness_improvement": 1516.4357171797303,
                    "objective_score": -81.73505260191473
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner utilizing informed sampling and dynamic rewiring in both trees to improve search efficiency and path quality. It samples points focusing exploration toward promising paths, grows two trees alternately from start and goal positions with step-size limited steering, and incrementally attempts to connect them via rewiring-enhanced incremental connections. The planner manages parent-child relationships carefully to maintain path cost consistency and performs rigorous collision checking on nodes and edges. Neighborhood-based rewiring optimizes local tree structure continuously, promoting shorter, smoother, and more robust paths with reduced planning time.",
          "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal using goal-biased informed sampling within bounds while avoiding obstacles. Each extension step includes rewiring neighbor nodes for improved cost. After extending one tree, it incrementally connects and rewires the other tree to the new node. When trees connect successfully, their paths merge to form the final optimized path. Throughout, the planner clamps positions within map bounds, uses neighborhood radius for rewiring, and performs collision checks on nodes and edges to ensure valid expansions and connections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0, informed_sampling: bool = True):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.informed_sampling = informed_sampling\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        # Variables to hold best current path cost to enable informed sampling\n        best_path_cost = float('inf')\n        best_goal_node_a = None\n        best_goal_node_b = None\n\n        for _ in range(self.max_iter):\n            # Informed sampling around ellipse between start and goal to reduce random search\n            if self.informed_sampling and best_goal_node_a and best_goal_node_b:\n                sample = self._informed_sample(bounds, start_position, goal_position, best_path_cost, obstacles, is_3d)\n            else:\n                # Goal biased sampling toggled by goal_sample_rate per tree role\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Update best path info for informed sampling\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_goal_node_a = new_node_a\n                    best_goal_node_b = new_node_b\n\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _informed_sample(self, bounds, start, goal, c_best, obstacles, is_3d):\n        import random\n        import math\n\n        # If no better path found yet, fallback to uniform sampling\n        if c_best == float('inf'):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Coordinate transform: construct ellipse parameters\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return start\n\n        # Ellipse axes lengths\n        a = c_best / 2.0\n        b = math.sqrt(a * a - (c_min / 2.0) ** 2)\n\n        # Build coordinate frame aligned to start-goal line in n-D\n        # Here simplify for 2D or 3D usage for position rotation\n\n        dim = len(start)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n\n        # Unit vector from start to goal\n        unit_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n        # Orthogonal basis completion for 2D or 3D\n        # For 2D: orthogonal vector can be easily computed\n        def ortho_basis_2d(v):\n            return (-v[1], v[0])\n        def ortho_basis_3d(v):\n            import numpy as np\n            v = np.array(v)\n            # TODO: a simple arbitrary orthogonal vector\n            if abs(v[0]) < 1e-9 and abs(v[1]) < 1e-9:\n                ortho1 = np.array([1,0,0])\n            else:\n                ortho1 = np.array([-v[1], v[0], 0])\n            norm = np.linalg.norm(ortho1)\n            if norm < 1e-9:\n                ortho1 = np.array([0,1,0])\n            else:\n                ortho1 = ortho1 / norm\n            ortho2 = np.cross(v, ortho1)\n            return ortho1, ortho2\n\n        # Sample from unit circle (or sphere) scaled by axes\n        while True:\n            if dim == 2:\n                # Sample point in unit circle\n                theta = random.uniform(0, 2 * math.pi)\n                r = math.sqrt(random.uniform(0,1))\n                x_prime = r * math.cos(theta)\n                y_prime = r * math.sin(theta)\n\n                # Scale by ellipse radii\n                x_ellipse = a * x_prime\n                y_ellipse = b * y_prime\n\n                # Rotate back to world\n                # Construct rotation matrix from ellipse frame (x-axis along start-goal)\n                ux, uy = unit_vec\n                px = center[0] + ux * x_ellipse - uy * y_ellipse\n                py = center[1] + uy * x_ellipse + ux * y_ellipse\n                sample = (px, py)\n            elif dim == 3:\n                import numpy as np\n                # Sample uniformly in unit sphere\n                while True:\n                    pt = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(pt) <= 1:\n                        break\n                # Scale to ellipsoid axes: largest a on start-goal axis, and two orthogonal axes b\n                ortho1, ortho2 = ortho_basis_3d(unit_vec)\n                scaled_pt = unit_vec * (pt[0] * a) + ortho1 * (pt[1] * b) + ortho2 * (pt[2] * b)\n                sample_np = np.array(center) + scaled_pt\n                sample = tuple(float(x) for x in sample_np)\n            else:\n                # For other dims fallback uniform\n                return self._sample_free(bounds, obstacles, is_3d)\n\n            # Clamp sample within bounds\n            sample = tuple(max(0, min(bounds[d], sample[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        import math\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 38.33569,
          "time_improvement": 22.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 377.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.030640292167663574,
                    "num_nodes_avg": 83.1,
                    "path_length_avg": 177.20687049701016,
                    "smoothness_avg": 0.022555476380968623,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -22.93998632030573,
                    "length_improvement": 2.8701062580320933,
                    "smoothness_improvement": 253.0421853630723,
                    "objective_score": -55.04276371766993
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.06067368984222412,
                    "num_nodes_avg": 240.6,
                    "path_length_avg": 231.72464877371485,
                    "smoothness_avg": 0.021242376773695816,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 62.45861888838912,
                    "length_improvement": 22.643642415137474,
                    "smoothness_improvement": 446.5816546527421,
                    "objective_score": -24.50077757719205
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.03626518249511719,
                    "num_nodes_avg": 167.7,
                    "path_length_avg": 118.68970731735166,
                    "smoothness_avg": 0.04173275622253171,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 27.15964308477957,
                    "length_improvement": 21.17194779633112,
                    "smoothness_improvement": 430.83757875896487,
                    "objective_score": -35.46352962150507
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant integrating goal-biased sampling, adaptive rewiring, and incremental connection steps to optimize path length and reduce planning time. It employs an adaptive neighbor radius based on the current tree size and dimensionality, ensures robust collision checking at nodes and edges, and incorporates a path smoothing post-processing step to improve path smoothness and quality.",
          "planning_mechanism": "The planner initializes two trees from start and goal, alternately extends them towards sampled points (with goal bias), and rewires nodes within an adaptive radius for cost optimization. It attempts incremental connections from one tree to the newly added node in the other, rewiring for lower cost. Upon success, it extracts and smooths the final path. Collision checking prevents invalid expansions and connections, while adaptive parameters and incremental connections hasten convergence and improve path optimization.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_factor: float=50.0, smoothing_iters: int=100, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor        # For adaptive neighbor radius\n        self.smoothing_iters = smoothing_iters        # Number of smoothing attempts\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):  # limit trials for performance\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_position  # fallback\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def adaptive_neighbor_radius(n_nodes):\n            # Radius = min(neighbor_factor * (log(n)/n)^(1/dim), step_size*10)\n            import math\n            if n_nodes <= 1:\n                return self.step_size * 10\n            r = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1/dimension))\n            return max(min(r, self.step_size*10), self.step_size)\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def is_valid_node(pos):\n            return self._within_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_valid_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_valid_node(new_pos) or not is_valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree) + 1\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and is_valid_edge(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                    # Rewire neighbor\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_incremental_connect(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            current_node = nearest_node\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if not is_valid_node(new_pos) or not is_valid_edge(current_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and is_valid_edge(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current_node = new_node\n\n        def smooth_path(path: list):\n            # Random shortcut smoothing with collision checks\n            if len(path) < 3:\n                return path[:]\n\n            for _ in range(self.smoothing_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    # Shortcut possible\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]\n                extracted_path = smooth_path(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 38.49957,
          "time_improvement": 3.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1499.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04675657749176025,
                    "num_nodes_avg": 108.4,
                    "path_length_avg": 172.39719087012355,
                    "smoothness_avg": 0.048372468406744515,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -87.60437941540829,
                    "length_improvement": 5.506367875779504,
                    "smoothness_improvement": 657.1341730619603,
                    "objective_score": -71.89436938415679
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06540160179138184,
                    "num_nodes_avg": 323.2,
                    "path_length_avg": 231.6569602684781,
                    "smoothness_avg": 0.10507578925191075,
                    "success_improvement": 0.0,
                    "time_improvement": 59.533259563663364,
                    "length_improvement": 22.666238786491103,
                    "smoothness_improvement": 2603.6757404835303,
                    "objective_score": 35.41160432881488
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.03189253807067871,
                    "num_nodes_avg": 197.1,
                    "path_length_avg": 120.2644171492987,
                    "smoothness_avg": 0.1049713483850359,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 35.94230895395951,
                    "length_improvement": 20.126100505576158,
                    "smoothness_improvement": 1235.2278032786933,
                    "objective_score": -79.01594819630343
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional RRT* inspired planner with goal biasing, adaptive rewiring, incremental and collision-aware connection attempts, and path smoothing via random shortcutting. It maintains two trees growing from start and goal, rewires to optimize costs locally, and attempts incremental connections with cost-aware rewiring. Once connected, it applies shortcut smoothing to improve path quality and reduce length while ensuring collision-free paths. The planner balances exploration and exploitation, maximizing planning efficiency, robustness, and path optimality.",
          "planning_mechanism": "The planner alternates expansion between two trees grown from the start and goal. Each iteration samples points with goal biasing to steer growth preferentially toward the goal region. New nodes are connected using rewiring within a fixed neighbor radius to minimize cost. The connection between trees is attempted incrementally with similar rewiring, allowing robust and smooth merging. After a successful connection, a smoothing procedure randomly shortcuts segments to reduce path length and smooth turns, while maintaining collision avoidance and staying within map bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free(target_tree):\n            # Goal biasing: bias toward goal for start tree and vice versa for goal tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if target_tree is tree_start else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if new path through new_node is cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not self._within_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if cheaper path via new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def smooth_path(path):\n            # Random shortcut smoothing while maintaining feasibility\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible, replace intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate expansion of start and goal trees\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            sample = sample_free(tree_a)\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                # Swap trees and next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Connected successfully: extract full path \n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                full_path = path_a + path_b[::-1][1:]  # Avoid duplicating connecting node\n\n                # Smooth final path\n                smoothed = smooth_path(full_path)\n\n                extracted_path = smoothed\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 38.7534,
          "time_improvement": 3.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1244.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019089770317077637,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 156.00499520055658,
                    "smoothness_avg": 0.0407395382995593,
                    "success_improvement": 0.0,
                    "time_improvement": 23.404904600873394,
                    "length_improvement": 14.491190073231774,
                    "smoothness_improvement": 537.6622417114891,
                    "objective_score": 12.60802060346582
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.047786808013916014,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 228.54937110466213,
                    "smoothness_avg": 0.0875087560931508,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 70.43227836607802,
                    "length_improvement": 23.70364149636743,
                    "smoothness_improvement": 2151.6633242860917,
                    "objective_score": -13.371271569472645
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.09214890003204346,
                    "num_nodes_avg": 338.3,
                    "path_length_avg": 114.26094063563994,
                    "smoothness_avg": 0.08971801965341235,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -85.08548160712412,
                    "length_improvement": 24.113323751117075,
                    "smoothness_improvement": 1041.206587696053,
                    "objective_score": -115.49694679343355
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 40.72827445864937,
          "time_improvement": 83.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005853891372680664,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 76.51206061156843,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 24.581558370581938
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.012701749801635742,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 92.14088954656437,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -120.34921268079198
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.010230827331542968,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 79.45089303030753,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -26.417169065738065
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a unidirectional informed RRT* planner that integrates dynamic ellipsoidal informed sampling, adaptive neighbor radius rewiring, goal biasing, and incremental rewiring to efficiently explore the environment. It maintains a single tree from start to goal, continually improving path quality by rewiring nodes with lower-cost parents within an adaptive radius. The planner balances exploration and exploitation via sampling strategies refined by current best path cost, ensuring robust, shorter, and smoother paths while reducing unnecessary expansions and collisions.",
          "planning_mechanism": "The planner alternates sampling between an informed ellipsoid-shaped subset of the space, based on the current best solution cost, and uniform global sampling with occasional direct goal samples for bias. For each sample, it finds the nearest node, steers within a step size, and validates the new node\u2019s feasibility. The rewiring radius adapts dynamically based on the number of nodes and problem dimension, facilitating local improvements. Upon connecting near the goal, the path is extracted and the ellipsoid parameters updated to concentrate further search in more promising regions, accelerating convergence toward optimal paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 neighbor_factor: float=2.5, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start, goal)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            elif dim == 3:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_**2))\n                return R\n            return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n\n            while True:\n                if dim == 2:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        theta = random.uniform(0, 2*math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        local = np.array([radius * math.cos(theta), radius * math.sin(theta)]) * np.array([r1, r2])\n                        if rotation is not None:\n                            sample = rotation @ local + np.array(center)\n                        else:\n                            sample = local + np.array(center)\n                        p = tuple(np.clip(sample, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                elif dim == 3:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        while True:\n                            local = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(local) <= 1:\n                                break\n                        local = local * np.array([r1, r2, r2])\n                        if rotation is not None:\n                            sample = rotation @ local + np.array(center)\n                        else:\n                            sample = local + np.array(center)\n                        p = tuple(np.clip(sample, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def sample_point():\n            if c_best < float('inf') and random.random() < 1 - self.goal_sample_rate:\n                return informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return uniform_sample()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(position, radius):\n            return [n for n in nodes if math.dist(n.position, position) <= radius]\n\n        success = False\n        path: List[Tuple[float, ...]] = []\n\n        for _ in range(self.max_iter):\n            sample = sample_point()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n\n            # Add new node and edge\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Calculate adaptive rewiring radius\n            gamma = self.neighbor_factor\n            unit_ball_vol = math.pi if dim == 2 else 4.0/3.0 * math.pi\n            radius = min(self.step_size,\n                         gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            neighbors = near_nodes(new_node.position, radius)\n\n            # Choose best parent in neighbors\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in neighbors:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                new_node.update_parent(min_parent, min_cost)\n                try:\n                    edges.remove((nearest_node, new_node))\n                except ValueError:\n                    pass\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through the new node reduces cost\n            for near in neighbors:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        old_parent = near.parent\n                        near.update_parent(new_node, cost_through_new)\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n            # Goal check\n            dist_goal = math.dist(new_node.position, goal)\n            if dist_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal, obstacles, is_3d)):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    path.reverse()\n\n                    # Update informed sampling parameters\n                    c_best = goal_node.cost\n                    center = tuple((s + g) / 2 for s, g in zip(start, goal))\n                    rotation = rotation_matrix()\n\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 40.90784,
          "time_improvement": -77.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 58.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04367175102233887,
                    "num_nodes_avg": 265.5,
                    "path_length_avg": 205.15035082510357,
                    "smoothness_avg": 0.009825475380544709,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -75.22693464836968,
                    "length_improvement": -12.446158102577318,
                    "smoothness_improvement": 53.790026066813844,
                    "objective_score": -74.78836188469229
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.26405134201049807,
                    "num_nodes_avg": 1000.7,
                    "path_length_avg": 310.7112189414943,
                    "smoothness_avg": 0.006280132058070304,
                    "success_improvement": 0.0,
                    "time_improvement": -63.37974646384288,
                    "length_improvement": -3.7243482092318176,
                    "smoothness_improvement": 61.592321250433294,
                    "objective_score": -19.45083197474706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09565999507904052,
                    "num_nodes_avg": 444.5,
                    "path_length_avg": 159.06860456131704,
                    "smoothness_avg": 0.012360667459012426,
                    "success_improvement": 0.0,
                    "time_improvement": -92.13768426516846,
                    "length_improvement": -5.645793116646534,
                    "smoothness_improvement": 57.22677770907195,
                    "objective_score": -28.484330014334482
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This planner implements an advanced bidirectional informed RRT* algorithm integrating heuristic-guided sampling, dynamic adaptive rewiring with reduced neighborhood radius over time, and path shortcutting for path smoothing. The planner grows two trees simultaneously from the start and goal, alternately expanding toward heuristically sampled points biased by estimated cost-to-go. Each extension rewires local neighborhoods adaptively, focusing rewiring to tighten the tree and converge rapidly to a low-cost path. Upon connection, path shortcutting further improves smoothness and shortens path length. Robust collision checks ensure navigation feasibility in 2D/3D environments. Parameters dynamically adapt to balance exploration and refinement, improving planning speed, path quality, and success rate.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling points biased by an informed heuristic (distance + cost-to-go), steering toward sampled points with fixed step size, and rewiring neighbors adaptively with a shrinking radius. Incremental connection attempts between the two trees continuously try to merge the trees with rewiring enabled. After successful connection, the combined path undergoes shortcut smoothing to further reduce length and improve smoothness. Collision checks are applied at every node and edge to guarantee feasibility. This mechanism prioritizes efficient, informed exploration and refinement cycles to quickly find and improve feasible paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (e.g. collision-free)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, initial_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles: 2D or 3D cuboids\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        # Heuristic: Euclidean dist from position to goal\n        def heuristic(pos):\n            return distance(pos, goal_position)\n\n        # Informed sampling: sample points within an ellipsoidal region defined by start, goal, and path cost bound\n        # If no path found yet, sample uniformly free space; else sample inside ellipsoid\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution or large cost, sample uniformly free space\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                # Sample inside an ellipsoid with foci start and goal and major axis length c_best\n                # Transform uniform random points inside unit ball to ellipsoid\n                import numpy as np\n\n                dim = len(bounds)\n                c_center = tuple(0.5*(start[d] + goal[d]) for d in range(dim))\n                a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # Unit vector from start to goal\n                a1 = np.array(a1).reshape((dim,1))\n                ID = np.eye(dim)\n                M = np.zeros((dim,dim))\n                M[:,0] = a1[:,0]\n                # Build rotation matrix from unit vector a1 (only in 2D or 3D)\n                if dim == 2:\n                    # Simple 2D rotation\n                    theta = math.atan2(a1[1,0], a1[0,0])\n                    C = np.array([[math.cos(theta), -math.sin(theta)],\n                                  [math.sin(theta),  math.cos(theta)]])\n                elif dim == 3:\n                    # Use Gram-Schmidt with a1 as first basis vector\n                    e1 = a1[:,0]\n                    # Construct orthonormal frame\n                    if abs(e1[0]) < abs(e1[1]):\n                        v = np.array([1,0,0])\n                    else:\n                        v = np.array([0,1,0])\n                    e2 = v - np.dot(v, e1)*e1\n                    e2 /= np.linalg.norm(e2)\n                    e3 = np.cross(e1, e2)\n                    C = np.column_stack((e1, e2, e3))\n                else:\n                    C = np.eye(dim)\n\n                # Radii of ellipsoid axes\n                r1 = c_best/2.0\n                if c_best < float('inf'):\n                    r = [r1] + [math.sqrt(r1**2 - (c_min/2)**2)]*(dim-1)\n                else:\n                    r = [1.0]*(dim)\n\n                while True:\n                    # Sample random point in unit ball\n                    u = np.random.normal(0,1,dim)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:  # Avoid division by zero\n                        continue\n                    u /= norm_u\n                    # Random radius for uniform sampling in ball\n                    rad = np.random.uniform(0,1)**(1/dim)\n                    x_ball = u * rad\n                    # Scale by radii and transform by rotation matrix\n                    L = np.diag(r)\n                    x_ellipsoid = C @ (L @ x_ball) + np.array(c_center)\n                    p = tuple(float(x_ellipsoid[d]) for d in range(dim))\n                    if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        # Steer: move from from_pos towards to_pos by step_size or less\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Find nearest node in tree to position pos\n        def nearest(tree, pos):\n            return min(tree, key=lambda node: distance(node.position, pos))\n\n        # Find all nodes within radius of position pos in tree\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        # Adaptive neighbor radius shrinks over iterations for faster convergence\n        def adaptive_radius(iteration):\n            gamma_rrt_star = 30.0  # Tuning param, typical ball radius constant\n            dim = len(bounds)\n            unit_ball_volume = {\n                2: math.pi,\n                3: 4/3*math.pi,\n            }.get(dim, 1.0)\n            eta = self.step_size\n            r = min(self.initial_neighbor_radius,\n                    gamma_rrt_star*(math.log(iteration+2)/(iteration+2))**(1/dim))\n            return max(eta, r)\n\n        # Try extending tree towards target position with rewiring neighbors adaptively, return new node or None\n        def try_extend_and_rewire(tree, target_pos, iteration):\n            nearest_node = nearest(tree, target_pos)\n            new_pos = steer(nearest_node.position, target_pos)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(iteration)\n            neighbors = near_nodes(tree, new_pos, radius)\n            cost_min = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_candidate = neighbor.cost + distance(neighbor.position, new_pos)\n                if cost_candidate < cost_min:\n                    cost_min = cost_candidate\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost_min\n            tree.append(new_node)\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        # Incremental connect from tree towards target_pos by repeatedly steering and rewiring\n        def incremental_connect_and_rewire(tree, target_pos, iteration):\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(iteration)\n                neighbors = near_nodes(tree, new_pos, radius)\n                cost_min = curr_node.cost + distance(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    if neighbor == curr_node:\n                        continue\n                    if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        continue\n                    cost_candidate = neighbor.cost + distance(neighbor.position, new_pos)\n                    if cost_candidate < cost_min:\n                        cost_min = cost_candidate\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = cost_min\n                tree.append(new_node)\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        neighbor.update_parent(new_node, cost_through_new)\n\n                if distance(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        # Shortcut smoothing of path by attempting direct connections between non-adjacent nodes\n        def shortcut_path(path_nodes):\n            if len(path_nodes) < 3:\n                return path_nodes\n            smoothed = [path_nodes[0]]\n            i = 0\n            while i < len(path_nodes) - 1:\n                j = len(path_nodes) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path_nodes[i], path_nodes[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path_nodes[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Minimum possible cost (straight line)\n        c_min = distance(start_position, goal_position)\n        c_best = float('inf')\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_count in range(self.max_iter):\n            # Sample informed with heuristic\n            sample = informed_sample(c_best, c_min, start_position, goal_position)\n\n            new_node_a = try_extend_and_rewire(tree_a, sample, iter_count)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position, iter_count)\n            if new_node_b is not None:\n                # Connection found - build path from both trees\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                # Remove duplicate connecting node from goal path (reverse)\n                if path_from_goal and path_from_goal[-1] == new_node_a.position:\n                    path_from_goal = path_from_goal[:-1]\n                full_path = path_from_start + path_from_goal[::-1]\n\n                # Shortcut smoothing to improve smoothness and reduce length\n                full_path = shortcut_path(full_path)\n\n                extracted_path = full_path\n                success_state = True\n                c_best = new_node_a.cost + new_node_b.cost\n\n                # Build edges from parent-child relations for output\n                edges.clear()\n                all_nodes = set(start_tree + goal_tree)\n                nodes = list(all_nodes)\n                for node in nodes:\n                    for child in node.children:\n                        edges.append((node, child))\n\n                break\n\n            # Swap trees\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.06303,
          "time_improvement": -19.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1942.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04666004180908203,
                    "num_nodes_avg": 106.9,
                    "path_length_avg": 161.9653040251399,
                    "smoothness_avg": 0.05708533910039552,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -87.21704317713291,
                    "length_improvement": 11.224250359340388,
                    "smoothness_improvement": 793.5095197191397,
                    "objective_score": -69.9527152826761
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.047032523155212405,
                    "num_nodes_avg": 233.1,
                    "path_length_avg": 226.55034064736702,
                    "smoothness_avg": 0.13587412089935905,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 70.8989863480871,
                    "length_improvement": 24.370975401913917,
                    "smoothness_improvement": 3396.1389969140114,
                    "objective_score": -6.87541403062102
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.06967761516571044,
                    "num_nodes_avg": 250.7,
                    "path_length_avg": 117.14331986762477,
                    "smoothness_avg": 0.1365495092245469,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -39.95082910047613,
                    "length_improvement": 22.198984709382373,
                    "smoothness_improvement": 1636.8996782998984,
                    "objective_score": -49.36095339676686
               }
          ],
          "success_rate": 0.9
     }
]