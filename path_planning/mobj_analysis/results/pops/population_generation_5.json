[
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed and goal-biased sampling, adaptive neighborhood rewiring, incremental tree connection, and time-bounded execution. It balances fast convergence and path quality by dynamically rewiring nodes for cost optimization, alternating expansions from start and goal, and smoothing the resulting path for improved smoothness and shorter length while respecting obstacle constraints and map boundaries.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, alternately sampling points biased toward the goal or informed ellipsoidal region after a first solution. Each extension steers within a step size, checks collisions for nodes and edges, rewires neighbors to reduce costs, and attempts incremental connection between trees. When a connection is established or time limit is reached, it extracts, smooths, and returns the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            # RRT* radius scaling for dimension dim\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def clamp_to_bounds(pos):\n            return tuple(\n                max(0.0, min(bounds[d], pos[d])) for d in range(dim)\n            )\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                # fallback to identity if direction is aligned with x-axis\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta*cos_theta)\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        # Connect the new_node to opposite tree incrementally with rewiring\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    # Time limit reached \u2014 extract best path found so far\n                    if best_path:\n                        extracted_path_final = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path_final, all_nodes, edges)\n                    else:\n                        return PlannerResult(False, [], all_nodes, edges)\n\n                iter_count += 1\n                sample = None\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start_tree:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_goal)\n                    if connect_node:\n                        # Build path\n                        path_s = new_node.path_from_root()\n                        path_g = connect_node.path_from_root()\n\n                        # Avoid duplicate node position overlap in merged path\n                        if path_g and path_g[0] == new_node.position:\n                            path_g = path_g[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        # Update edges for all new nodes (maintain consistent edges)\n                        # Clear and re-build edges\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_start)\n                    if connect_node:\n                        path_g = new_node.path_from_root()\n                        path_s = connect_node.path_from_root()\n                        if path_s and path_s[0] == new_node.position:\n                            path_s = path_s[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                grow_start_tree = not grow_start_tree\n            break  # exit outer while if max_iter reached\n\n        # No complete connection found, try best path extraction\n        if best_path:\n            extracted_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            success_state = False\n            extracted_path = []\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.40163,
          "time_improvement": 45.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1453.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02057945728302002,
                    "num_nodes_avg": 65.5,
                    "path_length_avg": 156.83014571172365,
                    "smoothness_avg": 0.03866421328032622,
                    "success_improvement": 0.0,
                    "time_improvement": 13.204126390052256,
                    "length_improvement": 14.038912002714524,
                    "smoothness_improvement": 505.1788985200809,
                    "objective_score": 9.294914810158986
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04782705307006836,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 235.04300669404265,
                    "smoothness_avg": 0.09978280006234666,
                    "success_improvement": 0.0,
                    "time_improvement": 80.05993514249408,
                    "length_improvement": 21.535879027695216,
                    "smoothness_improvement": 2467.483316250031,
                    "objective_score": 40.66257292953742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059801268577575686,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 124.49733655203302,
                    "smoothness_avg": 0.1167675547851698,
                    "success_improvement": 0.0,
                    "time_improvement": 42.86023778552829,
                    "length_improvement": 17.314796988241735,
                    "smoothness_improvement": 1385.2746779830118,
                    "objective_score": 23.247404123221894
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with dynamic rewiring, goal-biased and informed ellipsoidal sampling, adaptive neighborhood radius, and comprehensive collision checking for nodes and edges. It grows two trees from start and goal positions alternately, performs incremental extension, rewires local neighborhoods to optimize path costs, and attempts incremental connection with rewiring. The planner enforces a strict 30-second time limit, returning the best path found so far to ensure planning efficiency, path quality, smoothness, and robustness.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal positions using a combination of goal-biased and ellipsoidal informed sampling to focus the search. Each new node is extended cautiously with collision checks and rewiring to nearby nodes to reduce overall cost. The opposing tree incrementally connects to newly added nodes with additional rewiring, continuously improving path quality. The process terminates on success or time expiry, providing robust, low-cost, and smooth paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5,\n                 max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size              # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Constants for informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)*0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            temp_node = Node(new_pos)\n            neighbors = near_nodes(tree, temp_node)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos)\n                candidate_node.cost = cost_to_next\n\n                neighbors = near_nodes(tree_connect, candidate_node)\n\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n\n                min_parent.add_child(candidate_node)\n                candidate_node.parent = min_parent\n                candidate_node.cost = min_cost\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n\n                last_node = candidate_node\n\n            return None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # For both trees alternately\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n\n                # Sampling: goal bias + informed sampling when path found\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Build combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    # Compute path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node subtree\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return on first found path to maximize speed\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no connection found return best partial path by checking nearby nodes between trees\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.16994,
          "time_improvement": 68.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007612085342407227,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 184.4913298419197,
                    "smoothness_avg": 0.010519350526551577,
                    "success_improvement": 0.0,
                    "time_improvement": 67.89528566271517,
                    "length_improvement": -1.1226213385578332,
                    "smoothness_improvement": 64.65067887581763,
                    "objective_score": 20.46731482548207
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0381946325302124,
                    "num_nodes_avg": 201.0,
                    "path_length_avg": 307.68127601525805,
                    "smoothness_avg": 0.006362886119035033,
                    "success_improvement": 0.0,
                    "time_improvement": 84.07588590613632,
                    "length_improvement": -2.7128660483826366,
                    "smoothness_improvement": 63.72164284439662,
                    "objective_score": 24.99880077638635
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04949972629547119,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 158.73835880469125,
                    "smoothness_avg": 0.012861891384057036,
                    "success_improvement": 0.0,
                    "time_improvement": 52.703301159312666,
                    "length_improvement": -5.42645960970871,
                    "smoothness_improvement": 63.60230903913767,
                    "objective_score": 15.043709971047745
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* with adaptive neighbor radius and goal-biased sampling, combining local rewiring, incremental tree connection, and post-solution path smoothing within a 30-second time limit. It manages nodes with robust parent-child relationships and performs rigorous node and edge collision checks to ensure feasible, high-quality, and smooth paths efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the opposite tree's root to encourage connection. Each expansion steers toward sampled points respecting a step size and performs adaptive-rewiring using a dynamically computed neighbor radius based on the current tree size and dimension. Incremental connect attempts progressively link trees while rewiring optimizes path costs. Upon connection, the combined path is smoothed via shortcutting. The process halts early if 30 seconds elapse, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n        # Recursively update cost of descendants\n        for child in self.children:\n            child_cost = self.cost + math.dist(self.position, child.position)\n            child.update_parent(self, child_cost)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree: List[Node] = [Node(start_pos)]\n        goal_tree: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_free_point(p):\n            return within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def sample_free(tree_indicator: bool):\n            # tree_indicator=True means sampling for start_tree toward goal, else vice versa\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 30.0  # tuning param, can be adjusted\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not is_free_point(new_pos) or not is_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr_node = nearest\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not is_free_point(new_pos) or not is_free_edge(curr_node.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and is_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path: List[Tuple[float, ...]], iterations: int = 100) -> List[Tuple[float, ...]]:\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) - 1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                if is_free_edge(p1, p2):\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_indicator=True)\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicated node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined_path, iterations=100)\n                    success = True\n                    # Optional: stop early on first solution, comment next line to keep searching\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.0713,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1531.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024182724952697753,
                    "num_nodes_avg": 103.1,
                    "path_length_avg": 156.2190449823175,
                    "smoothness_avg": 0.040275037558805106,
                    "success_improvement": 0.0,
                    "time_improvement": -1.9930073797584058,
                    "length_improvement": 14.37386599601276,
                    "smoothness_improvement": 530.3917964391828,
                    "objective_score": 4.928829967470945
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06206269264221191,
                    "num_nodes_avg": 370.0,
                    "path_length_avg": 235.10600365298006,
                    "smoothness_avg": 0.1031911715268196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.1248093478783,
                    "length_improvement": 21.514848829534984,
                    "smoothness_improvement": 2555.183168981656,
                    "objective_score": 39.316328415178766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08631713390350342,
                    "num_nodes_avg": 359.6,
                    "path_length_avg": 126.64040269645093,
                    "smoothness_avg": 0.12630717040516848,
                    "success_improvement": 0.0,
                    "time_improvement": 17.52448361721952,
                    "length_improvement": 15.891474496962882,
                    "smoothness_improvement": 1506.6178845282157,
                    "objective_score": 15.96872940719951
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* growth with informed ellipsoidal sampling, adaptive neighbor radius rewiring, dynamic incremental connection between trees, and robust obstacle and edge collision checks. It balances exploration and exploitation by focusing samples in promising regions, efficiently rewires locally for cost optimization, and enforces strict time limits to guarantee timely results. Path smoothing via shortcutting follows path extraction to improve smoothness and remove unnecessary waypoints.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal, sampling with goal bias and informed ellipsoidal regions once a connection is found. Each extension involves steering with limited step size, collision and edge checks, then rewiring neighbors within an adaptive radius based on current node count. Incremental incremental connection attempts bridge the two trees efficiently. The algorithm terminates successfully when start and goal trees connect or when the 30-second time limit is reached, returning the best path found after smoothing.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Trees alternate growth each iteration\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_connection_nodes = None\n        best_cost = math.inf\n\n        start_time = time.perf_counter()\n\n        # Precompute start-goal dist and initialize sampling ellipse params\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2.0 for s, g in zip(start_position, goal_position))\n        use_informed_sampling = False\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _ellipsoidal_sample(c_max: float) -> Tuple[float, ...]:\n            # Implements informed sampling inside an ellipse between start and goal\n            # Reference: Informed RRT* sampling (Gammell, 2014)\n            if c_max == math.inf:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)], dtype=float)\n            # Build orthonormal basis matrix C via a rotation matrix:\n            # Create identity and replace first dim with a1\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))  # rank-1 matrix\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, Vt)\n\n            # Sample in unit n-ball \n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:  # avoid division by zero\n                    break\n            z_unit = z / norm_z\n\n            # Sample radius with probability ~ r^{dim-1} to fill ball uniformly\n            r = random.random() ** (1/dim)\n            r *= z_unit\n\n            # Lengths of the ellipse axes\n            r1 = c_max / 2.0\n            r2 = math.sqrt(c_max**2 - c_best**2) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                # For 3D, use r2 for axes 2 and 3\n                L = np.diag([r1, r2, r2])\n            else:\n                # fallback: use r2 for other axes\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = np.dot(C, np.dot(L, r))\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):  # Max 100 attempts\n                if use_informed_sampling and best_cost < math.inf:\n                    sample = _ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                    return sample\n            # fallback to uniform sample ignoring obstacle if no free found (very unlikely)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    # If direct connection between new_node and target_pos is collision-free, return new_node\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iterations: int=120) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iterations):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time exceeded: break and return best path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate, sample towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Update informed sampling usage and parameters\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2.0 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n\n                    # Extract and smooth path early for faster return on success\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Make sure no duplicate point at connection\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.54166,
          "time_improvement": 27.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1572.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030754804611206055,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 155.39801050614182,
                    "smoothness_avg": 0.0472465218485357,
                    "success_improvement": 0.0,
                    "time_improvement": -29.71139604033075,
                    "length_improvement": 14.82388800252849,
                    "smoothness_improvement": 639.5106643939071,
                    "objective_score": -2.7510878896239914
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06528630256652831,
                    "num_nodes_avg": 280.8,
                    "path_length_avg": 237.27958937981202,
                    "smoothness_avg": 0.11296131328131831,
                    "success_improvement": 0.0,
                    "time_improvement": 72.78082123152922,
                    "length_improvement": 20.789243350722238,
                    "smoothness_improvement": 2806.57595347357,
                    "objective_score": 40.02497480697106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06531059741973877,
                    "num_nodes_avg": 312.0,
                    "path_length_avg": 122.54529492889571,
                    "smoothness_avg": 0.10770517113827668,
                    "success_improvement": 0.0,
                    "time_improvement": 37.596106313230834,
                    "length_improvement": 18.611250088096217,
                    "smoothness_improvement": 1270.001826910111,
                    "objective_score": 21.351091046139047
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive neighbor radius based on tree size, incremental extend-and-rewire steps, and a post-processing path smoothing step. It rigorously checks collisions for nodes and edges, manages explicit parent-child relationships with clean rewiring, and enforces a maximum time limit to ensure responsiveness while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from the start and goal positions, extending each alternately towards goal-biased random samples. For each new node, it selects the best parent within an adaptive neighbor radius minimizing cost and rewires neighbors if cheaper paths are found. Incremental connect attempts between trees are performed carefully to gradually and safely link the two trees. Upon a successful connection, extracted paths are smoothed to improve smoothness and reduce length. Time-limiting ensures that the planning process halts within 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling goal, False for goal_tree sampling start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            # Volume of ball in R^d: For 2D \u03c0r^2, 3D (4/3)\u03c0r^3; Using heuristic R ~ gamma * (log(n)/n)^(1/d)\n            gamma = 25.0  # tuning parameter\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not valid_node(new_pos): \n                return None\n            if not valid_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path, iterations=50):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) -1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                # Check collision-free shortcut\n                if valid_edge(p1, p2):\n                    # Remove intermediate nodes\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Time exceeded: return best found\n                break\n\n            sample = sample_free(tree_indicator=True)  # tree_a grows towards goal_pos\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Found connection\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate connect node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success = True\n\n                # Attempt smoothing\n                smoothed_path = path_smoothing(best_path, iterations=100)\n                best_path = smoothed_path\n\n                # Stop on first found improved solution\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.40207,
          "time_improvement": 31.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1263.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019640398025512696,
                    "num_nodes_avg": 93.8,
                    "path_length_avg": 153.83644111358143,
                    "smoothness_avg": 0.029869960489300924,
                    "success_improvement": 0.0,
                    "time_improvement": 17.164700641643794,
                    "length_improvement": 15.679808931241347,
                    "smoothness_improvement": 367.52974531494084,
                    "objective_score": 10.123020705316112
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11281363964080811,
                    "num_nodes_avg": 504.4,
                    "path_length_avg": 238.70686820192523,
                    "smoothness_avg": 0.08618445945156529,
                    "success_improvement": 0.0,
                    "time_improvement": 52.965714028974354,
                    "length_improvement": 20.312776597957804,
                    "smoothness_improvement": 2117.588217845781,
                    "objective_score": 30.54021061751277
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0793837308883667,
                    "num_nodes_avg": 407.3,
                    "path_length_avg": 122.15175915589433,
                    "smoothness_avg": 0.11043538889563216,
                    "success_improvement": 0.0,
                    "time_improvement": 24.14930962919764,
                    "length_improvement": 18.87261781036399,
                    "smoothness_improvement": 1304.7299952599603,
                    "objective_score": 17.54296642713189
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive rewiring, goal biasing, and incremental connection to rapidly find collision-free, lower cost, and smooth paths. It effectively balances exploration and exploitation by growing start and goal trees simultaneously with goal-directed sampling, local rewiring to optimize tree costs, and precise collision checks. A time budget is enforced to guarantee timely returns.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions toward randomly sampled points biased toward the goal. It incrementally extends trees within a step size, rewires neighbors within a fixed radius to minimize costs, and attempts to connect the trees. Collision checks prevent invalid nodes and edges. The best path found so far is returned if a time budget is exceeded, ensuring both efficiency and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -18.94623,
          "time_improvement": 50.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 271.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017641496658325196,
                    "num_nodes_avg": 84.5,
                    "path_length_avg": 170.50120424036766,
                    "smoothness_avg": 0.019952942408527338,
                    "success_improvement": 0.0,
                    "time_improvement": 25.59526263553606,
                    "length_improvement": 6.545588191379452,
                    "smoothness_improvement": 212.30687720138977,
                    "objective_score": 10.049230814943657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04605059623718262,
                    "num_nodes_avg": 254.1,
                    "path_length_avg": 248.84054005866628,
                    "smoothness_avg": 0.015314310037129148,
                    "success_improvement": 0.0,
                    "time_improvement": 80.80057589266545,
                    "length_improvement": 16.92986525060597,
                    "smoothness_improvement": 294.04822770699855,
                    "objective_score": 29.09638695645582
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06053769588470459,
                    "num_nodes_avg": 277.0,
                    "path_length_avg": 124.08694361494807,
                    "smoothness_avg": 0.03189665894955138,
                    "success_improvement": 0.0,
                    "time_improvement": 42.15658580257741,
                    "length_improvement": 17.587360436241912,
                    "smoothness_improvement": 305.72314747183384,
                    "objective_score": 17.693063565380776
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.654359830512174,
          "time_improvement": 54.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020609617233276367,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 17.306726487427596,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 6.787323209480537
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03164470195770264,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 80.42008291490608,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.76431560419259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01710929870605469,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.63515364948351,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 21.411440677863403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner uses a bidirectional RRT* approach with adaptive rewiring, goal-biased sampling, and incremental connection attempts between two trees grown from start and goal. It dynamically adjusts neighbor radius for efficient path optimization and applies robust collision checks to ensure feasibility. The algorithm enforces a 30-second time limit, returning the best path found within that interval. Path smoothing is applied post planning to improve path quality and smoothness.",
          "planning_mechanism": "The planner alternates expansions between two trees from start and goal positions, sampling points biased toward the opposite tree root. It extends each tree toward samples using a step size limit, rewires neighbors within an adaptive radius to minimize path cost, and incrementally attempts to connect the trees while avoiding collisions. Upon success or timeout, the best path is extracted and shortcut smoothing is applied before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            # Goal bias toward opposite tree root\n            if random.random() < self.goal_sample_rate:\n                if tree_from is start_tree:\n                    return goal_pos\n                else:\n                    return start_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            if tree_from is start_tree:\n                return goal_pos\n            else:\n                return start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            node_near = nearest(tree, node.position)\n            dist_to = math.dist(node_near.position, node.position)\n            if dist_to <= self.step_size:\n                if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(node_near.position, node.position, obstacles, is_3d):\n                    return node_near\n            return None\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        import time\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    # Optional early break for speed:\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.44179,
          "time_improvement": 28.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1195.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0321617841720581,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 154.7988312384859,
                    "smoothness_avg": 0.03852361475420025,
                    "success_improvement": 0.0,
                    "time_improvement": -35.64546993042573,
                    "length_improvement": 15.152307653733788,
                    "smoothness_improvement": 502.97822627162316,
                    "objective_score": -5.148288317022846
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0475306510925293,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 232.3176880735701,
                    "smoothness_avg": 0.07877010053743526,
                    "success_improvement": 0.0,
                    "time_improvement": 80.18351111627115,
                    "length_improvement": 22.445668827155995,
                    "smoothness_improvement": 1926.8114226383475,
                    "objective_score": 38.17824421350428
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.061810421943664554,
                    "num_nodes_avg": 280.3,
                    "path_length_avg": 118.64183299869458,
                    "smoothness_avg": 0.09862513818512744,
                    "success_improvement": 0.0,
                    "time_improvement": 40.94050350026311,
                    "length_improvement": 21.203743639253076,
                    "smoothness_improvement": 1154.504477964368,
                    "objective_score": 22.29542216775139
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation improves the bidirectional RRT* planner by incorporating adaptive rewiring, enhanced goal biasing, and optimized incremental connection strategies. It leverages spatial hashing for efficient nearest neighbor queries to reduce planning time, dynamically adjusts sampling bias based on progress, and limits neighborhood searches to reduce computation. Collision checks are carefully applied, and a strict 30-second time budget ensures timely planning termination. The planner balances exploration and exploitation to find lower-cost, smoother, and valid paths rapidly.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately using goal-biased sampling and spatially efficient nearest-neighbor queries. Each extension steers toward sampled points within step size, rewires neighbors for cost improvement, and incrementally attempts connecting the opposite tree. Strict collision checks ensure validity. The process continues until a time limit or max iteration count is reached, then returns the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=12.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        from collections import defaultdict\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Spatial hashing grid for efficient neighbor search\n        cell_size = self.neighbor_radius\n        def grid_key(pos):\n            return tuple(int(p // cell_size) for p in pos)\n\n        grid_nodes_start = defaultdict(list)\n        grid_nodes_goal = defaultdict(list)\n\n        def insert_node_to_grid(grid, node):\n            k = grid_key(node.position)\n            grid[k].append(node)\n\n        def nearby_nodes_grid(grid, pos):\n            base = grid_key(pos)\n            neighbors = []\n            # Search neighbors in adjacent cells only\n            for dx in (-1,0,1):\n                for dy in (-1,0,1):\n                    for dz in ([0] if dimension==2 else (-1,0,1)):\n                        if dimension ==2 and dz!=0:\n                            continue\n                        neighbor_cell = tuple(base[d]+(dx if d==0 else dy if d==1 else dz) for d in range(dimension))\n                        neighbors.extend(grid.get(neighbor_cell, []))\n            return neighbors\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n\n        for n in tree_start: insert_node_to_grid(grid_nodes_start, n)\n        for n in tree_goal: insert_node_to_grid(grid_nodes_goal, n)\n\n        def sample_free():\n            # Adaptive goal biasing: slightly increase goal bias if already found a better path\n            rate = self.goal_sample_rate if not success_state else min(0.4, self.goal_sample_rate + 0.1)\n            if random.random() < rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Use spatial hashing grid for efficient search\n            grid_tree = grid_nodes_start if tree is tree_start else grid_nodes_goal\n            candidates = nearby_nodes_grid(grid_tree, point)\n            if not candidates:\n                return min(tree, key=lambda n: math.dist(n.position, point))\n            return min(candidates, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            grid_tree = grid_nodes_start if tree is tree_start else grid_nodes_goal\n            neighbors = []\n            candidates = nearby_nodes_grid(grid_tree, pos)\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            neighbors = [n for n in candidates if (self._dist_sq(n.position, pos) <= radius_sq)]\n            return neighbors\n\n        def try_extend_and_rewire(tree, grid_tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            insert_node_to_grid(grid_tree, new_node)\n\n            # Rewire neighbors if beneficial\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def try_connect_and_rewire(tree, grid_tree, new_node):\n            # Incrementally extend tree toward new_node.position with rewiring\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if not self._within_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                insert_node_to_grid(grid_tree, new_node_goal)\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                            neighbor.update_parent(new_node_goal, cost_through_new)\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, grid_nodes_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, grid_nodes_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n                grid_nodes_start, grid_nodes_goal = grid_nodes_goal, grid_nodes_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=tree_start+tree_goal,\n            edges=self._extract_edges(tree_start+tree_goal)\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((a-b)**2 for a,b in zip(p1,p2))\n\n    def _extract_edges(self, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return edges\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -16.78989,
          "time_improvement": 44.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 190.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017108941078186037,
                    "num_nodes_avg": 83.8,
                    "path_length_avg": 162.78675012856405,
                    "smoothness_avg": 0.01651510601193109,
                    "success_improvement": 0.0,
                    "time_improvement": 27.84136787477236,
                    "length_improvement": 10.774002733407121,
                    "smoothness_improvement": 158.4972722134357,
                    "objective_score": 11.299697270180308
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06019690036773682,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 261.2897492478698,
                    "smoothness_avg": 0.011521411010039959,
                    "success_improvement": 0.0,
                    "time_improvement": 74.90269584883335,
                    "length_improvement": 12.773960892631509,
                    "smoothness_improvement": 196.4542038252493,
                    "objective_score": 26.007871952302555
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0747917652130127,
                    "num_nodes_avg": 307.6,
                    "path_length_avg": 124.76360771496066,
                    "smoothness_avg": 0.024739827262098366,
                    "success_improvement": 0.0,
                    "time_improvement": 28.53690596331842,
                    "length_improvement": 17.13795236029544,
                    "smoothness_improvement": 214.68877666979614,
                    "objective_score": 13.062106144403595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is a bidirectional informed RRT* algorithm with adaptive rewiring and goal-biased sampling to improve sample efficiency, path quality, and smoothness. It incorporates dynamic rewiring, collision-aware node and edge validation, and a strict 30-second execution limit to balance exploration and exploitation effectively while ensuring timely responses in both 2D and 3D spaces.",
          "planning_mechanism": "The planning mechanism grows two alternating trees from start and goal, initially exploring the space with uniform samples and switching to ellipsoidal informed sampling after a first solution is found. Each extension steers incrementally towards samples within step size limits, performs collision checks, connects optimally through neighbor-based rewiring, and attempts incremental tree connections. The algorithm maintains the best path cost and immediately returns the best valid path once time expires or a satisfactory path is achieved.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # Collision status\n\n        if parent:\n            self.parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost update to children\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=15.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.neighbor_radius\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[0, -Kz, Ky], [Kz, 0, -Kx], [-Ky, Kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-8:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <= 1.0 and norm_sq > 1e-10:\n                        norm = math.sqrt(norm_sq)\n                        return tuple(x / norm for x in pt)\n\n            while True:\n                n = dim\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n                sample_point = clamp_to_bounds(sample_point)\n                if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d_curr = dist(nearest_node.position, from_node.position)\n            if d_curr <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    # Time limit reached - return best path found so far\n                    if best_path_nodes:\n                        return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_goal, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_goal.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_goal, connecting_node, neighbors)\n\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_start, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_start.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_start, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n\n                grow_start = not grow_start\n\n            break\n\n        # If max iterations reached without success but path found\n        if best_path_nodes:\n            return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.68936,
          "time_improvement": 42.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 303.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02621774673461914,
                    "num_nodes_avg": 120.1,
                    "path_length_avg": 163.78975475831936,
                    "smoothness_avg": 0.02379259944851252,
                    "success_improvement": 0.0,
                    "time_improvement": -10.57591075510042,
                    "length_improvement": 10.224240002212797,
                    "smoothness_improvement": 272.4058478258737,
                    "objective_score": 0.23410401304180173
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05165274143218994,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 243.7262208895383,
                    "smoothness_avg": 0.01676442716657435,
                    "success_improvement": 0.0,
                    "time_improvement": 78.46492835933412,
                    "length_improvement": 18.637172196776035,
                    "smoothness_improvement": 331.36078592477384,
                    "objective_score": 28.923716876779313
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.045268702507019046,
                    "num_nodes_avg": 241.1,
                    "path_length_avg": 132.82977863188572,
                    "smoothness_avg": 0.03192310547714889,
                    "success_improvement": 0.0,
                    "time_improvement": 56.74601963245528,
                    "length_improvement": 11.780785707057527,
                    "smoothness_improvement": 306.0595453507945,
                    "objective_score": 20.91026075790206
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
          "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.50088,
          "time_improvement": 36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive neighbor radius, incremental extend-and-rewire steps, and post-processing path smoothing. It rigorously verifies collisions for nodes and edges, manages parent-child relations with clean rewiring, adapts neighbor radius dynamically for balanced exploration and exploitation, and enforces a 30-second time limit to ensure timely results while optimizing path quality, length, and smoothness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions toward goal-biased random samples. For each new node, it selects the best parent within an adaptive radius minimizing cost and rewires neighbors if cheaper connections are found. It tries to incrementally connect the two trees safely. Upon successful connection, the combined path is smoothed to improve navigation. Planning stops on success or timeout, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=25.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def _within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling towards goal, False for goal_tree sampling towards start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if _within_bounds(p) and not _is_in_obstacle(p):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and not _is_edge_in_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not _within_bounds(new_pos) or _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not _within_bounds(new_pos) or _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr_node.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) <= 2:\n                return path[:]\n            p = path[:]\n            for _ in range(iterations):\n                if len(p) <= 2:\n                    break\n                i = random.randint(0, len(p) - 2)\n                j = random.randint(i + 1, len(p) - 1)\n                if j == i + 1:\n                    continue\n                if not _is_edge_in_obstacle(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break  # timeout\n\n            sample = sample_free(tree_indicator=True)\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined_path, iterations=100)\n                    success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout but no path, try extracting best known path\n        if not success and best_path:\n            best_path = path_smoothing(best_path, iterations=100)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -16.43934,
          "time_improvement": 23.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1203.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0278092622756958,
                    "num_nodes_avg": 140.2,
                    "path_length_avg": 160.76337289480648,
                    "smoothness_avg": 0.03216259970288559,
                    "success_improvement": 0.0,
                    "time_improvement": -17.28828318804759,
                    "length_improvement": 11.883047857693684,
                    "smoothness_improvement": 403.4145275532775,
                    "objective_score": -0.7928027471091523
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12574188709259032,
                    "num_nodes_avg": 529.1,
                    "path_length_avg": 236.14255269432087,
                    "smoothness_avg": 0.07820490793912455,
                    "success_improvement": 0.0,
                    "time_improvement": 47.57566642757288,
                    "length_improvement": 21.16881892412554,
                    "smoothness_improvement": 1912.268609992039,
                    "objective_score": 28.067806763057163
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06304893493652344,
                    "num_nodes_avg": 365.2,
                    "path_length_avg": 123.13467120808863,
                    "smoothness_avg": 0.10962216477618048,
                    "success_improvement": 0.0,
                    "time_improvement": 39.75711158241963,
                    "length_improvement": 18.219814426538804,
                    "smoothness_improvement": 1294.3858444864957,
                    "objective_score": 22.04302558246613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive rewiring, goal-biased sampling, and incremental connection. It grows two trees from start and goal alternately, sampling points biased towards the opposite tree root to improve exploration efficiency. Rewiring is applied dynamically during node insertions and tree connections to optimize path cost and smoothness. Comprehensive collision checks on nodes and edges ensure path feasibility. The planner enforces a 30-second time limit, returning the best path found within that interval with shortcut smoothing for path quality.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling points biased towards the opposite tree\u2019s root. It tries to extend each tree toward the sample by limited step size, rewires neighbors within an adaptive radius to minimize cost, and incrementally attempts connections between trees while enforcing collision checks. If successful or on timeout, extracts and smooths the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            if random.random() < self.goal_sample_rate:\n                return tree_to[0].position\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to[0].position\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early termination on successful connection\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.01025,
          "time_improvement": 19.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0349745512008667,
                    "num_nodes_avg": 99.6,
                    "path_length_avg": 161.61541596370688,
                    "smoothness_avg": 0.038164240443188946,
                    "success_improvement": 0.0,
                    "time_improvement": -47.50858994225105,
                    "length_improvement": 11.41602955014295,
                    "smoothness_improvement": 497.35323791048927,
                    "objective_score": -9.482604883094279
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06216433048248291,
                    "num_nodes_avg": 302.6,
                    "path_length_avg": 235.87082513264122,
                    "smoothness_avg": 0.0877666970169375,
                    "success_improvement": 0.0,
                    "time_improvement": 74.0824344784919,
                    "length_improvement": 21.25952940545841,
                    "smoothness_improvement": 2158.3003300424616,
                    "objective_score": 37.26813787485156
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07126703262329101,
                    "num_nodes_avg": 339.7,
                    "path_length_avg": 123.54013070238454,
                    "smoothness_avg": 0.11924109929446303,
                    "success_improvement": 0.0,
                    "time_improvement": 31.904767328751372,
                    "length_improvement": 17.9505275363338,
                    "smoothness_improvement": 1416.737981563158,
                    "objective_score": 20.24522561370796
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* with incremental rewiring, adaptive neighbor radius, and goal-biased sampling to efficiently explore the space. It grows two trees simultaneously from start and goal, alternating expansion and performing rewiring for path cost optimization. A time limit ensures prompt termination, returning the best path found so far. Path smoothing via shortcutting improves path quality and smoothness post planning. The Node class manages parent-child relationships and supports clean rewiring.",
          "planning_mechanism": "The planner alternates growth between two trees, samples points with goal bias, extends and rewires each tree toward samples using an adaptive neighbor radius, and incrementally attempts connection between trees with rewiring. Collision and bounds checks ensure safety. Upon successful connection or time expiration, the best path is extracted and smoothed by shortcutting unnecessary waypoints to deliver a robust, smooth, and cost-efficient solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time limit reached: return best found path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    smoothed_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    extracted_path = smoothed_path\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    success_state = True\n                    # Early termination can be left off for more improvement, here break for efficiency\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If not success but have best path found within iterations\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1]\n            extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int, dim: int) -> float:\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        gamma_rrt_star = 50.0\n        radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n        radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n        return radius\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d: bool) -> Tuple[float, ...]:\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          sample: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes, dims)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                       tree: List[Node],\n                                       target_pos: Tuple[float, ...],\n                                       obstacles,\n                                       is_3d: bool,\n                                       nodes: List[Node],\n                                       edges: List[Tuple[Node, Node]],\n                                       bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        dist_total = math.dist(curr_node.position, target_pos)\n        max_steps = int(dist_total / self.step_size) + 2\n\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes, dims)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int=100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.71302,
          "time_improvement": 15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029410433769226075,
                    "num_nodes_avg": 93.7,
                    "path_length_avg": 151.35150865706538,
                    "smoothness_avg": 0.03576982037913053,
                    "success_improvement": 0.0,
                    "time_improvement": -24.04138054474865,
                    "length_improvement": 17.04183978693237,
                    "smoothness_improvement": 459.8753643415842,
                    "objective_score": -1.5046693843302004
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08552870750427247,
                    "num_nodes_avg": 391.9,
                    "path_length_avg": 234.64078700173286,
                    "smoothness_avg": 0.10682658825679274,
                    "success_improvement": 0.0,
                    "time_improvement": 64.34135357837532,
                    "length_improvement": 21.670151538240148,
                    "smoothness_improvement": 2648.7250599286954,
                    "objective_score": 36.880061680804104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09911580085754394,
                    "num_nodes_avg": 413.0,
                    "path_length_avg": 119.99349451886602,
                    "smoothness_avg": 0.10399153638493046,
                    "success_improvement": 0.0,
                    "time_improvement": 5.295432230668823,
                    "length_improvement": 20.30603441676022,
                    "smoothness_improvement": 1222.7646669595508,
                    "objective_score": 11.763659887350446
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive rewiring and goal biasing, growing two trees simultaneously from start and goal positions. It incrementally extends trees towards sampled points, rewires neighbors to optimize path costs, and attempts to connect the two trees. The planner uses collision checks on nodes and edges, enforces boundary constraints, and respects a strict 30-second execution limit, returning the best path found within this time.",
          "planning_mechanism": "The planner alternates growth between start and goal trees; samples are drawn with goal bias to increase efficiency. Each new node is connected optimally by choosing the parent yielding minimal path cost among neighbors within a radius. Rewiring is applied to improve existing paths. When trees connect, the combined path is extracted. Planning halts upon timeout or when an optimal connection is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision status\n\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update costs recursively for descendants\n        for child in self.children:\n            dist_child = math.dist(self.position, child.position)\n            child.update_parent(self, new_cost + dist_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.neighbor_radius\n            return [n for n in tree if math.dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success = False\n\n        start_time = time.perf_counter()\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free()\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            nearest_node = nearest(current_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                grow_start = not grow_start\n                continue\n\n            neighbors = near_nodes(current_tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    edges.append((new_node, neighbor))\n\n            # Try to connect other tree to new node\n            nearest_other = nearest(other_tree, new_node.position)\n            dist_to_other = math.dist(nearest_other.position, new_node.position)\n\n            if dist_to_other <= self.step_size and collision_free_node(new_node.position) and collision_free_edge(nearest_other.position, new_node.position):\n                neighbors_other = near_nodes(other_tree, new_node.position)\n                min_cost_other = nearest_other.cost + dist_to_other\n                best_parent_other = nearest_other\n\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                    if tentative_cost < min_cost_other and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost_other = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node = Node(new_node.position)\n                best_parent_other.children.append(connecting_node)\n                connecting_node.parent = best_parent_other\n                connecting_node.cost = min_cost_other\n                other_tree.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((best_parent_other, connecting_node))\n\n                # Rewire neighbors in other tree\n                for neighbor in neighbors_other:\n                    cost_through_conn = connecting_node.cost + math.dist(connecting_node.position, neighbor.position)\n                    if cost_through_conn < neighbor.cost and collision_free_edge(connecting_node.position, neighbor.position):\n                        neighbor.update_parent(connecting_node, cost_through_conn)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((connecting_node, neighbor))\n\n                # Construct full path\n                path_start = new_node.path_from_root() if grow_start else connecting_node.path_from_root()\n                path_goal = connecting_node.path_from_root() if grow_start else new_node.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                cost_path = 0.0\n                for i in range(len(merged_path) - 1):\n                    cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                if cost_path < best_path_cost:\n                    best_path_cost = cost_path\n                    best_path_nodes = (new_node if grow_start else connecting_node, connecting_node if grow_start else new_node)\n                    extracted_path = merged_path\n                    success = True\n\n                # Early exit on connection\n                break\n\n            grow_start = not grow_start\n\n        return type('PlannerResult', (), {})() if not hasattr(self, '_is_in_obstacle') else PlannerResult(\n            success=success,\n            path=extracted_path if success else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.01545,
          "time_improvement": 31.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 307.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02703385353088379,
                    "num_nodes_avg": 132.3,
                    "path_length_avg": 166.6201919027751,
                    "smoothness_avg": 0.02250794049854646,
                    "success_improvement": 0.0,
                    "time_improvement": -14.01792097755906,
                    "length_improvement": 8.672832552189893,
                    "smoothness_improvement": 252.29814557734463,
                    "objective_score": -1.2093190549430157
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046008515357971194,
                    "num_nodes_avg": 312.0,
                    "path_length_avg": 241.98107297576803,
                    "smoothness_avg": 0.01716456073983221,
                    "success_improvement": 0.0,
                    "time_improvement": 80.81812026152939,
                    "length_improvement": 19.219752801690095,
                    "smoothness_improvement": 341.6565109692622,
                    "objective_score": 29.797669193643145
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07670843601226807,
                    "num_nodes_avg": 375.0,
                    "path_length_avg": 121.92151278707436,
                    "smoothness_avg": 0.03366748435764057,
                    "success_improvement": 0.0,
                    "time_improvement": 26.705538229525228,
                    "length_improvement": 19.025536485380318,
                    "smoothness_improvement": 328.2479159539931,
                    "objective_score": 13.458008345703597
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional informed sampling, adaptive neighbor radius rewiring, incremental tree connection, and path smoothing within a 30-second execution limit to improve planning efficiency, path quality, success rate, and smoothness in both 2D and 3D spaces. It robustly handles collision checking for nodes and edges while ensuring paths stay within bounds.",
          "planning_mechanism": "The planner grows two alternating trees from start and goal, using a goal-biased and then ellipsoidal informed sampling after a first solution. It dynamically adapts neighbor radius for rewiring, incrementally connects trees with collision checks, rewires for optimal costs, and applies path smoothing on successful connection. Planning halts when a solution is found or the time limit expires, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                  # For collision status\n\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.0, \n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=5.0, \n                 max_neighbor_radius: float=25.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            dist_ = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        # Ellipsoidal informed sampling once a solution is found\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                # Rodrigues' formula for rotation matrix to align x-axis with direction\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[ 0, -Kz, Ky],\n                     [ Kz,   0, -Kx],\n                     [-Ky, Kx,   0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-8:\n                return sample_free()\n            center = tuple( (start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim) )\n            direction = tuple( (goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <= 1.0 and norm_sq > 1e-10:\n                        norm = math.sqrt(norm_sq)\n                        return tuple(x / norm for x in pt)\n\n            while True:\n                n = dim\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n                sample_point = clamp_to_bounds(sample_point)\n\n                if not _is_in_obstacle(sample_point):\n                    return sample_point\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(p) and not _is_in_obstacle(p):\n                    return p\n            return goal_pos  # fallback\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_\n                if new_cost < neighbor.cost and not _is_edge_in_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not within_bounds(new_pos) or _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            return add_node(tree, new_pos, best_parent, min_cost), neighbors\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr_node = nearest_node\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if (not within_bounds(new_pos) or _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr_node.position, new_pos)):\n                    return None\n                \n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not _is_edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) <= 2:\n                return path[:]\n            p = path[:]\n            for _ in range(iterations):\n                if len(p) <= 2:\n                    break\n                i = random.randint(0, len(p) - 2)\n                j = random.randint(i + 1, len(p) - 1)\n                if j == i + 1:\n                    continue\n                if not _is_edge_in_obstacle(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        import time\n        start_time = time.perf_counter()\n\n        # Initialize trees and data containers\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        grow_start_tree = True\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached, return best path found so far\n                if best_path:\n                    success = True\n                break\n\n            # Select sample point\n            if informed_sampling_enabled and best_cost < math.inf:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start_tree:\n                extended_result = extend_and_rewire(start_tree, sample)\n                if extended_result is None or extended_result[0] is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                new_node, neighbors = extended_result\n\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    combined_cost = new_node.cost + connect_node.cost\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = path_smoothing(combined_path, iterations=100)\n                        success = True\n                        informed_sampling_enabled = True\n                        # Early exit with best path found\n                        break\n            else:\n                extended_result = extend_and_rewire(goal_tree, sample)\n                if extended_result is None or extended_result[0] is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                new_node, neighbors = extended_result\n\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    combined_cost = new_node.cost + connect_node.cost\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = path_smoothing(combined_path, iterations=100)\n                        success = True\n                        informed_sampling_enabled = True\n                        # Early exit with best path found\n                        break\n\n            grow_start_tree = not grow_start_tree\n\n        # If failed but path found during process return best path\n        if not success and best_path:\n            success = True\n            best_path = path_smoothing(best_path, iterations=100)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -13.91188,
          "time_improvement": 15.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1283.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03656618595123291,
                    "num_nodes_avg": 111.8,
                    "path_length_avg": 166.3098238788635,
                    "smoothness_avg": 0.030899359385642183,
                    "success_improvement": 0.0,
                    "time_improvement": -54.22146515203471,
                    "length_improvement": 8.8429501841919,
                    "smoothness_improvement": 383.6420734181633,
                    "objective_score": -12.579639141681218
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05974745750427246,
                    "num_nodes_avg": 285.7,
                    "path_length_avg": 240.42562375190087,
                    "smoothness_avg": 0.08368068023279138,
                    "success_improvement": 0.0,
                    "time_improvement": 75.09007766042212,
                    "length_improvement": 19.73900652374046,
                    "smoothness_improvement": 2053.164175147451,
                    "objective_score": 36.74064547861198
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08059561252593994,
                    "num_nodes_avg": 334.4,
                    "path_length_avg": 123.28716033109899,
                    "smoothness_avg": 0.11876667426186698,
                    "success_improvement": 0.0,
                    "time_improvement": 22.991363815503217,
                    "length_improvement": 18.11853841178706,
                    "smoothness_improvement": 1410.7033301669494,
                    "objective_score": 17.574633477843125
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius. It leverages an ellipsoidal informed sampling region after the first solution to focus search efficiently near promising paths. It grows two trees alternately from start and goal, performing rewiring during extension and connection phases to optimize path cost dynamically. It includes robust collision checking for nodes and edges, incremental connection attempts, and path smoothing via shortcutting. A strict 30-second time limit is enforced to ensure timely results and returns the best path found so far if time runs out.",
          "planning_mechanism": "The planner samples points inside an adaptive ellipsoidal informed region after initial solution discovery and grows two search trees alternately from start and goal nodes. Each new node is created by steering towards sampled points and connected to the best parent in a dynamic neighbor radius with collision checks. The trees attempt to connect incrementally and rewire to reduce costs continuously. The algorithm terminates early if a better path is found or the time limit is reached, then extracts and smooths the final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            r = 50.0 * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        # Rotation and informed sampling based on ellipsoid (start-goal direction, cost)\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                # 3D rotation matrix aligning direction vector to x-axis\n                vx, vy, vz = direction\n                norm = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx, vy, vz = vx/norm, vy/norm, vz/norm\n                # Rodrigues' formula\n                k = (0, -vz, vy)  # cross with x-axis vector(1,0,0)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = (k[0]/k_norm, k[1]/k_norm, k[2]/k_norm)\n                cos_theta = vx\n                sin_theta = k_norm\n                K = [[0, -k[2], k[1]],\n                     [k[2], 0, -k[0]],\n                     [-k[1], k[0], 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                res = mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return res\n\n        def matrix_vector_mul(M, v):\n            return tuple(sum(M[i][j]*v[j] for j in range(dim)) for i in range(dim))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample():\n            if best_path_cost == math.inf or best_path_cost < c_min - 1e-12:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            a1 = best_path_cost / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(best_path_cost**2 - c_min**2, 0.0)) / 2.0\n                radii = (a1, a2)\n            else:\n                a_minor = math.sqrt(max(best_path_cost**2 - c_min**2, 0.0)) / 2.0\n                radii = (a1, a_minor, a_minor)\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.uniform(0,1) ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n                rotated = matrix_vector_mul(R, sample_scaled)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=self.step_size/5):\n                    # safely remove old edge and update parent\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, node):\n            # Incremental connection attempt from node to tree\n            nearest_node = nearest(tree, node.position)\n            d = dist(nearest_node.position, node.position)\n            if d <= self.step_size:\n                if self._is_in_obstacle(node.position, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d, resolution=self.step_size/5):\n                    return None\n                return nearest_node\n            return None\n\n        def path_shortcut(path, max_iter=100):\n            # Try to shortcut path by removing unnecessary points where direct connect is possible\n            if len(path) < 3:\n                return path[:]\n            import random\n            path = path[:]\n            length = len(path)\n            for _ in range(max_iter):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n\n        for iteration in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.time_limit_sec:\n                # Time limit reached, return best path if found\n                if success_state and extracted_path:\n                    extracted_path = path_shortcut(extracted_path)\n                return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n            # Sampling\n            if informed_sampling_enabled:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    radius = adaptive_radius(len(tree_goal))\n                    neighbors = near_nodes(tree_goal, new_node.position, radius)\n\n                    min_local_cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    best_parent_local = connect_node\n                    for neighbor in neighbors:\n                        tentative = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative < min_local_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                            min_local_cost = tentative\n                            best_parent_local = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent_local.add_child(connecting_node)\n                    connecting_node.cost = min_local_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent_local, connecting_node))\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    current_cost = sum(dist(combined_path[i], combined_path[i+1]) for i in range(len(combined_path)-1))\n                    if current_cost < best_path_cost:\n                        best_path_cost = current_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        informed_sampling_enabled = True\n                        extracted_path = path_shortcut(extracted_path)\n                        # Early exit on first connection with improved path\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    radius = adaptive_radius(len(tree_start))\n                    neighbors = near_nodes(tree_start, new_node.position, radius)\n\n                    min_local_cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    best_parent_local = connect_node\n                    for neighbor in neighbors:\n                        tentative = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative < min_local_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                            min_local_cost = tentative\n                            best_parent_local = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent_local.add_child(connecting_node)\n                    connecting_node.cost = min_local_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent_local, connecting_node))\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    current_cost = sum(dist(combined_path[i], combined_path[i+1]) for i in range(len(combined_path)-1))\n                    if current_cost < best_path_cost:\n                        best_path_cost = current_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        informed_sampling_enabled = True\n                        extracted_path = path_shortcut(extracted_path)\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n            grow_start = not grow_start\n\n        if success_state and extracted_path:\n            extracted_path = path_shortcut(extracted_path)\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -13.64101,
          "time_improvement": 12.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1257.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04297325611114502,
                    "num_nodes_avg": 130.8,
                    "path_length_avg": 157.85103299895425,
                    "smoothness_avg": 0.044511876320480016,
                    "success_improvement": 0.0,
                    "time_improvement": -81.24391011556828,
                    "length_improvement": 13.479347503589151,
                    "smoothness_improvement": 596.7075235020244,
                    "objective_score": -18.69376591644253
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06354947090148926,
                    "num_nodes_avg": 261.0,
                    "path_length_avg": 227.72531104550325,
                    "smoothness_avg": 0.07953574549598684,
                    "success_improvement": 0.0,
                    "time_improvement": 73.50494144852671,
                    "length_improvement": 23.978736463368314,
                    "smoothness_improvement": 1946.5120188936528,
                    "objective_score": 36.57978982169994
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05731310844421387,
                    "num_nodes_avg": 292.6,
                    "path_length_avg": 125.53460063141533,
                    "smoothness_avg": 0.10441161311024585,
                    "success_improvement": 0.0,
                    "time_improvement": 45.237660234140606,
                    "length_improvement": 16.625895575923685,
                    "smoothness_improvement": 1228.1080118987243,
                    "objective_score": 23.037017244920538
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.974939814675388,
          "time_improvement": 44.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012398910522460938,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 50.2510654377263,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 14.8169556563946
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027178692817687988,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 83.18339188143196,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 25.336085485098604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05079307556152344,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": -2.020326334253888,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": -1.2282216974670441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional growth and rewiring strategies of bidirectional RRT* with goal-biased sampling and dynamic incremental connection attempts. It features two trees grown from start and goal that alternate expansions. Each expansion uses neighborhood rewiring to reduce path cost, and after each new node is added, an incremental connection attempt with rewiring is made to join the two trees as early as possible. Collision checks ensure validity of nodes and edges, and careful cost-based parent selection with children management maintains tree consistency and path quality. The planner terminates early upon finding a valid connecting path, outputting an optimized, smooth, and low-cost route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased random sampling. Each iteration extends one tree by steering towards a sampled point with step size limits and rewiring neighbors within a radius to minimize path cost. Then, it attempts an incremental connection from the other tree to the newly added node with rewiring to further optimize cost and connect paths. Collision checks ensure nodes and edges are valid, preventing invalid expansions. This bidirectional, rewiring-based approach accelerates convergence, improves path quality and smoothness, and reduces planning time by rapidly discovering a valid optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost of descendants\n        for child in self.children:\n            dist = self._distance(child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def is_collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    prev_parent = neighbor.parent\n                    if prev_parent:\n                        if (prev_parent, neighbor) in edges:\n                            edges.remove((prev_parent, neighbor))\n                        prev_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample):\n            # Find nearest node\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, connect_node):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, connect_node.position))\n            dist = math.dist(nearest_node.position, connect_node.position)\n            if dist > self.step_size:\n                return None\n\n            if not is_collision_free_node(connect_node.position):\n                return None\n            if not is_collision_free_edge(nearest_node.position, connect_node.position):\n                return None\n\n            neighbors = near_nodes(tree, connect_node.position)\n\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, connect_node.position)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, connect_node.position):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(connect_node.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        success_state = False\n        final_path = []\n\n        # Alternate tree starts with start tree\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                final_path = path_a + path_b[1:]  # avoid duplicate connection node\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -12.01814,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 316.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027533936500549316,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 160.569386712611,
                    "smoothness_avg": 0.02450451608453697,
                    "success_improvement": 0.0,
                    "time_improvement": -10.476158588791257,
                    "length_improvement": 11.989374758062796,
                    "smoothness_improvement": 283.54888913137535,
                    "objective_score": 0.672771820632059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052264285087585446,
                    "num_nodes_avg": 325.9,
                    "path_length_avg": 240.06426952247952,
                    "smoothness_avg": 0.017266584034611274,
                    "success_improvement": 0.0,
                    "time_improvement": 67.66187370339429,
                    "length_improvement": 19.8596369665261,
                    "smoothness_improvement": 344.28164382833637,
                    "objective_score": 25.99189772346519
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042936849594116214,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.98176033662389,
                    "smoothness_avg": 0.03298287097098217,
                    "success_improvement": 0.0,
                    "time_improvement": 13.759280001647332,
                    "length_improvement": 18.321370546532442,
                    "smoothness_improvement": 319.53968420860195,
                    "objective_score": 9.389756530843698
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements a bidirectional RRT* hybrid with adaptive neighbor radius and incremental connect-and-rewire between start and goal trees. It applies goal-biased sampling, rewiring for path cost optimization, and path smoothing for improved path quality. A 30-second time limit is enforced to ensure practical execution.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending toward sampled points via incremental steps, rewiring neighbors for cost improvement. Upon successful connection, it extracts the combined path and applies path smoothing to minimize unnecessary waypoints, ensuring efficient, feasible, and smooth paths within time constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0, time_limit: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = None\n\n        start_time = time.time()\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansion\n\n        def dist(u, v):\n            return math.dist(u.position, v.position)\n\n        def dist_pos(p1, p2):\n            return math.dist(p1, p2)\n\n        def neighbor_radius(num_nodes, dim):\n            # Adaptive neighbor radius for RRT*\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( ( (math.pi ** (dim/2)) / math.gamma(dim/2 + 1) ) ** (1/dim))\n            radius = min(self.neighbor_radius_max,\n                         max(self.neighbor_radius_min, \n                             gamma_rrt_star * ((math.log(num_nodes + 1) / (num_nodes + 1)) ** (1/dim))))\n            return radius\n\n        def smooth_path(path):\n            # Path smoothing by shortcutting\n            if len(path) < 3:\n                return path\n            smooth = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth.append(path[j])\n                i = j\n            return smooth\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                # Time limit exceeded: return best found\n                if best_path_nodes:\n                    extracted_path = best_path_nodes\n                    success_state = False  # indicate partial success due to timeout\n                break\n\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges,\n                                                neighbor_radius(len(tree_a), len(bounds)))\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d,\n                                                             nodes, edges, neighbor_radius(len(tree_b), len(bounds)))\n            if new_node_b:\n                # Connected: build full path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                combined_path = path_a + path_b[1:]  # Avoid duplicate connection node\n\n                # Smooth the path for better quality\n                smoothed_path = smooth_path(combined_path)\n\n                path_cost = 0.0\n                for idx in range(1, len(smoothed_path)):\n                    path_cost += dist_pos(smoothed_path[idx-1], smoothed_path[idx])\n\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = smoothed_path\n                    success_state = True\n                    best_path_nodes = smoothed_path\n\n                break  # stop planning after solution found\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no path found but nodes exist, try to find closest node to goal in either tree and backtrack path\n        if not success_state and extracted_path == []:\n            # Try start tree first\n            goal_node = min(start_tree, key=lambda n: dist_pos(n.position, goal_position))\n            if dist_pos(goal_node.position, goal_position) <= self.step_size:\n                extracted_path = goal_node.path_from_root()\n                success_state = False  # Not fully connected to goal\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, radius):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                try:\n                    edges.remove((neighbor.parent, neighbor))\n                except ValueError:\n                    pass\n                neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, radius):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.01453,
          "time_improvement": 2.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1494.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03198220729827881,
                    "num_nodes_avg": 107.6,
                    "path_length_avg": 155.93417097606283,
                    "smoothness_avg": 0.038290459319627816,
                    "success_improvement": 0.0,
                    "time_improvement": -34.88808690397064,
                    "length_improvement": 14.530009952958453,
                    "smoothness_improvement": 499.32883741543475,
                    "objective_score": -5.063779893522328
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07013428211212158,
                    "num_nodes_avg": 376.6,
                    "path_length_avg": 231.1351195380525,
                    "smoothness_avg": 0.09753832076731418,
                    "success_improvement": 0.0,
                    "time_improvement": 70.75960059672722,
                    "length_improvement": 22.840444242659768,
                    "smoothness_improvement": 2409.731247355754,
                    "objective_score": 37.84462526432889
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13508868217468262,
                    "num_nodes_avg": 528.3,
                    "path_length_avg": 119.5917086598555,
                    "smoothness_avg": 0.1316216724454463,
                    "success_improvement": 0.0,
                    "time_improvement": -29.0764453819991,
                    "length_improvement": 20.572881453328375,
                    "smoothness_improvement": 1574.217958204814,
                    "objective_score": 3.2627324670900153
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This planner is a hybrid bidirectional RRT* algorithm incorporating informed sampling with adaptive neighbor radius rewiring, incremental connection attempts, and path smoothing. It dynamically balances exploration and exploitation, using two trees grown from start and goal that alternately extend toward samples biased by the opposite tree\u2019s root. The algorithm continuously rewires nodes to optimize path cost, performs rigorous collision checks on both nodes and edges, and enforces a strict 30-second time limit. It prioritizes planning efficiency, path quality, and robustness while providing smooth, low-cost paths.",
          "planning_mechanism": "The planner alternates growth of two trees from start and goal, each expansion using goal-biased informed sampling and adaptive neighborhood rewiring to ensure path cost improvements. Upon each extension, it tries incremental connections with the opposite tree, rewiring the trees to maintain optimality. Collision checks prevent invalid expansions. The search ends when connected or when 30 seconds are elapsed, returning the best smooth path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 10.0,\n                 max_neighbor_radius: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def sample_free(towards_pos):\n            if random.random() < self.goal_sample_rate:\n                return towards_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return towards_pos  # fallback\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position)**2) <= radius_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-8 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point, nodes, edges):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            # Clamp new_pos to bounds\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                c = nbr.cost + dist(nbr.position, new_pos)\n                if c + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(curr_node.position, new_node.position)\n                new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                n_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, n_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    c = nbr.cost + dist(nbr.position, new_pos)\n                    if c + 1e-8 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = c\n                        best_parent = nbr\n\n                connecting_node = Node(new_pos)\n                best_parent.add_child(connecting_node)\n                connecting_node.cost = min_cost\n                other_tree.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((best_parent, connecting_node))\n\n                rewire(other_tree, connecting_node, neighbors)\n\n                if dist(connecting_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connecting_node.position, new_node.position):\n                        return connecting_node\n                curr_node = connecting_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return collision_free_edge(p1, p2)\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        best_path = []\n        success_state = False\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_b[0].position)\n\n            new_node = extend(tree_a, sample, nodes, edges)\n            if not new_node:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = incremental_connect(new_node, tree_b, nodes, edges)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                full_path = path_a + path_b[::-1]\n                best_path = smooth_path(full_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.97745,
          "time_improvement": 1.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1445.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0405303955078125,
                    "num_nodes_avg": 73.9,
                    "path_length_avg": 163.41238470271804,
                    "smoothness_avg": 0.046097778020342914,
                    "success_improvement": 0.0,
                    "time_improvement": -70.94090662730258,
                    "length_improvement": 10.431082509499076,
                    "smoothness_improvement": 621.5303289455405,
                    "objective_score": -16.088403841563256
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07345347404479981,
                    "num_nodes_avg": 258.9,
                    "path_length_avg": 232.53015571614884,
                    "smoothness_avg": 0.09884186436706606,
                    "success_improvement": 0.0,
                    "time_improvement": 69.37576240968379,
                    "length_improvement": 22.37474101252121,
                    "smoothness_improvement": 2443.2723630818737,
                    "objective_score": 37.50403874081875
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10015146732330323,
                    "num_nodes_avg": 251.4,
                    "path_length_avg": 121.40235135212644,
                    "smoothness_avg": 0.10771908776871268,
                    "success_improvement": 0.0,
                    "time_improvement": 4.305858982565884,
                    "length_improvement": 19.37033879066179,
                    "smoothness_improvement": 1270.1788454220377,
                    "objective_score": 11.516719680012311
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified yet effective bidirectional RRT* inspired planner using dual trees growing simultaneously from start and goal with goal bias sampling and rewiring. The Node class supports parent updates and child management to maintain tree consistency. Goal bias accelerates convergence, rewiring improves path quality by locally optimizing connections, and collision checking ensures safe expansions. The planner alternates tree expansions, attempts incremental connection with rewiring, and merges paths upon successful connection, balancing exploration and exploitation for efficient, robust pathfinding.",
          "planning_mechanism": "The planner initializes two trees from start and goal points. At each iteration, it samples a point biased towards the goal, extends one tree towards the sample with rewiring to optimize costs, then incrementally attempts to connect the other tree back with rewiring. Collision and edge checks guarantee validity. Upon connection, paths are concatenated to produce the final solution. This alternation and rewiring enable fast convergence to high-quality, smooth paths with reduced computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For collision/status checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n\n        # Find optimal parent among neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor == nearest:\n                continue\n            candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = candidate_cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors through new_node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        current = nearest\n\n        while True:\n            new_pos = self._steer(current.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = current.cost + math.dist(current.position, new_pos)\n            best_parent = current\n            for neighbor in neighbors:\n                if neighbor == current:\n                    continue\n                candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.84193,
          "time_improvement": 18.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01887509822845459,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 151.17482827913645,
                    "smoothness_avg": 0.02102342809722014,
                    "success_improvement": 0.0,
                    "time_improvement": 24.26624702849299,
                    "length_improvement": 17.138681101754965,
                    "smoothness_improvement": 229.06230282631154,
                    "objective_score": 11.85292184303045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07972452640533448,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 235.8839930063653,
                    "smoothness_avg": 0.01930007836028916,
                    "success_improvement": 0.0,
                    "time_improvement": 50.67105960576548,
                    "length_improvement": 21.25513359019308,
                    "smoothness_improvement": 396.60491749478894,
                    "objective_score": 21.435369187242205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06023519039154053,
                    "num_nodes_avg": 310.7,
                    "path_length_avg": 122.75329360888414,
                    "smoothness_avg": 0.03676825833269663,
                    "success_improvement": 0.0,
                    "time_improvement": -20.985266448523078,
                    "length_improvement": 18.4731072686807,
                    "smoothness_improvement": 367.68953204137927,
                    "objective_score": -0.7625108206138871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm is a bidirectional RRT* inspired planner with enhanced efficiency through goal-biased random sampling, dynamic local rewiring during tree expansions, and incremental connection attempts between start and goal trees. It incorporates efficient nearest neighbor querying, adaptive steering with step size limits, and rigorous collision checking for node positions and edges. The rewiring optimizes cost and path quality while alternating tree expansions accelerates convergence. This leads to faster planning times, improved path smoothness, and higher success rates.",
          "planning_mechanism": "The planner grows two trees simultaneously, sampling mostly towards the goal to improve search focus. On each iteration, one tree is extended toward a sampled point with rewiring of nearby nodes to minimize cost. Then it attempts connecting the other tree to the newly added node via rewiring to form a continuous path. Collision checks ensure validity at every step. By alternating expansions and rewiring, the method quickly converges to a collision-free, optimized path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Efficient nearest search: linear for simplicity, can be optimized with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Re-assign parent\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, connect_to_node):\n            nearest_node = nearest(tree, connect_to_node.position)\n            dist = math.dist(nearest_node.position, connect_to_node.position)\n            if dist > self.step_size:\n                return None\n            if self._is_in_obstacle(connect_to_node.position, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, connect_to_node.position, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, connect_to_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, connect_to_node.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, connect_to_node.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(connect_to_node.position, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Alternate tree expansion each iteration to balance growth\n        start_tree = tree_start\n        goal_tree = tree_goal\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = try_extend(start_tree, sample)\n            if new_node_start is None:\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            new_node_goal = try_connect(goal_tree, new_node_start)\n            if new_node_goal:\n                # Paths connecting start_tree root to new_node_start, and goal_tree root to new_node_goal\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path_goal.reverse()\n                extracted_path = path_start + path_goal[1:]  # Avoid duplicating connecting node\n                success_state = True\n                break\n\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -10.74705,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 218.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021436524391174317,
                    "num_nodes_avg": 147.8,
                    "path_length_avg": 161.4200586584748,
                    "smoothness_avg": 0.018596289666266766,
                    "success_improvement": 0.0,
                    "time_improvement": 13.988874486413575,
                    "length_improvement": 11.523107984775253,
                    "smoothness_improvement": 191.07231576642934,
                    "objective_score": 7.45664552171127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06319136619567871,
                    "num_nodes_avg": 366.1,
                    "path_length_avg": 251.15246650705654,
                    "smoothness_avg": 0.0131187349704594,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90082591838002,
                    "length_improvement": 16.15807765702018,
                    "smoothness_improvement": 237.55449983278646,
                    "objective_score": 22.689635806081974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05267148017883301,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 130.14155852635278,
                    "smoothness_avg": 0.025465211964407646,
                    "success_improvement": 0.0,
                    "time_improvement": -5.793192023664093,
                    "length_improvement": 13.566173501866952,
                    "smoothness_improvement": 223.915616540841,
                    "objective_score": 2.094855175978368
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a time-limited bidirectional RRT* style planner with goal biasing, incremental rewiring, and nearest-neighbor pruning optimizations to improve planning efficiency, path quality, and success rate. It grows two trees from start and goal, alternates their expansions, applies rewiring in local neighborhoods for optimal paths, and uses efficient collision checks for both nodes and edges. By enforcing a 30-second time limit, it returns the best path found within the time frame, maintaining robustness and responsiveness.",
          "planning_mechanism": "The planner samples points biased toward the goal, extends each tree step-wise toward these samples while checking for collisions, rewires neighbors to reduce path cost, and attempts connection between two trees after each addition. If connected, it extracts and returns the smoothed path. The process stops early upon timeout or successful connection.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []    # Children nodes\n        self.valid = True                 # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self, max_iter: int = 5000, step_size: float = 5.0,\n        goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0,\n        time_limit_sec: float = 30.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                 # Tuple[int, ...]\n        start_position = map.start        # Tuple[float, ...]\n        goal_position = map.goal          # Tuple[float, ...]\n        obstacles = map.obstacles         # List of obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        start_time = time.time()\n\n        def sample_free() -> Tuple[float, ...]:\n            if (math.isclose(self.goal_sample_rate, 0.0) or\n                math.isclose(self.goal_sample_rate, 1.0)):\n                biased = False if self.goal_sample_rate == 0.0 else True\n            else:\n                biased = (math.random() < self.goal_sample_rate)\n            if (math.random() if hasattr(math, \"random\") else True) < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        import random\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...]) -> List[Node]:\n            radius = self.neighbor_radius\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def _can_connect(from_node: Node, to_point: Tuple[float, ...]) -> bool:\n            if not self._within_bounds(to_point, bounds):\n                return False\n            if self._is_in_obstacle(to_point, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_node.position, to_point, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not _can_connect(nearest_node, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_to_new = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_to_new < min_cost and _can_connect(neighbor, new_pos):\n                    min_cost = cost_to_new\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better path found\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost and _can_connect(new_node, neighbor.position):\n                    # Rewire neighbor\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_via_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], new_node: Node) -> Node:\n            nearest_node = nearest(tree, new_node.position)\n            dist = math.dist(nearest_node.position, new_node.position)\n            if dist > self.step_size:\n                return None\n            if not _can_connect(nearest_node, new_node.position):\n                return None\n\n            neighbors = near_nodes(tree, new_node.position)\n\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_to_new = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost_to_new < min_cost and _can_connect(neighbor, new_node.position):\n                    min_cost = cost_to_new\n                    best_parent = neighbor\n\n            connect_node = Node(new_node.position)\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            # Rewire neighbors of linking tree near new node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_connect = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if cost_via_connect < neighbor.cost and _can_connect(connect_node, neighbor.position):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = cost_via_connect\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            return connect_node\n\n        # Alternate trees:\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        best_path_cost = float(\"inf\")\n        best_path_nodes: Tuple[Node, Node] = (None, None)  # Nodes where trees connected\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            rand_point = sample_free()\n\n            new_node = try_extend(active_tree, rand_point)\n            if new_node is None:\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            connecting_node = try_connect(passive_tree, new_node)\n            if connecting_node:\n                # Calculate total cost and update best if better\n                total_cost = new_node.cost + connecting_node.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node, connecting_node)\n                    success_state = True\n\n                    # Extract path immediately to return faster\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n\n                    break  # Stop here as we found the path\n\n            # Swap trees for next iteration (bidirectional alternate expansion)\n            active_tree, passive_tree = passive_tree, active_tree\n\n        # If timed out without connection but some node pairs exist, try to extract best found path\n        if not success_state and best_path_nodes[0] is not None and best_path_nodes[1] is not None:\n            node_start, node_goal = best_path_nodes\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            extracted_path = path_start + path_goal[::-1][1:]\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -10.43827,
          "time_improvement": 16.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 453.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03988518714904785,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 165.80221023243124,
                    "smoothness_avg": 0.030869169350238666,
                    "success_improvement": 0.0,
                    "time_improvement": -68.21967727760422,
                    "length_improvement": 9.121181267454395,
                    "smoothness_improvement": 383.1695338053871,
                    "objective_score": -16.725819260763455
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07971315383911133,
                    "num_nodes_avg": 337.1,
                    "path_length_avg": 234.19078179896445,
                    "smoothness_avg": 0.02311938323250311,
                    "success_improvement": 0.0,
                    "time_improvement": 66.76597541522004,
                    "length_improvement": 21.820376227605827,
                    "smoothness_improvement": 494.87838279095973,
                    "objective_score": 26.868259784041975
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05424661636352539,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 118.01105297545473,
                    "smoothness_avg": 0.04555884297125299,
                    "success_improvement": 0.0,
                    "time_improvement": 48.16767547446619,
                    "length_improvement": 21.622677696172037,
                    "smoothness_improvement": 479.50511979035264,
                    "objective_score": 21.172363780526027
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighbor radius, incremental connection attempts, goal bias sampling, rewiring for path cost optimization, and path smoothing. It enforces collision-free node and edge checks, bounds clamping, and stops planning once a time limit is reached to ensure practical execution time.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansion with goal-biased sampling. It extends one tree towards samples, rewires neighbors to minimize path costs, then incrementally connects the other tree to the new node with rewiring. When connected, paths are merged and smoothed. Execution halts if time exceeds 30 seconds, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update costs of descendants for consistency\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.time()\n\n        # Utility functions\n        def _random():\n            import random\n            return random.random()\n\n        def sample_free(goal_bias_for_start=True):\n            # Goal biasing for alternating trees\n            if _random() < self.goal_sample_rate:\n                return goal_position if goal_bias_for_start else start_position\n            while True:\n                sample = tuple(_random() * bounds[d] for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def try_extend_and_rewire(tree, point):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improvement possible\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                if time.time() - start_time > self.time_limit_sec:\n                    return None\n                curr_node = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) < 3:\n                    break\n                i = int(_random() * (len(path) - 2))\n                j = i + 2 + int(_random() * (len(path) - i - 2))\n                if j >= len(path):\n                    j = len(path) - 1\n                if j <= i + 1:\n                    attempts += 1\n                    continue\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    del path[i + 1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break  # Time limit exceeded\n\n            sample = sample_free(goal_bias_for_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge and smooth final path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # avoid duplicate node\n                extracted_path = path_smoothing(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.42336,
          "time_improvement": 2.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1407.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04564192295074463,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 164.0663458293772,
                    "smoothness_avg": 0.037275524225553885,
                    "success_improvement": 0.0,
                    "time_improvement": -92.49927348747131,
                    "length_improvement": 10.072636053299995,
                    "smoothness_improvement": 483.4428992263453,
                    "objective_score": -23.318040339449666
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06323657035827637,
                    "num_nodes_avg": 276.4,
                    "path_length_avg": 241.39358297851035,
                    "smoothness_avg": 0.09835034963146143,
                    "success_improvement": 0.0,
                    "time_improvement": 73.63539600771674,
                    "length_improvement": 19.415873872736682,
                    "smoothness_improvement": 2430.6253349110125,
                    "objective_score": 38.12692025141742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08017446994781494,
                    "num_nodes_avg": 365.3,
                    "path_length_avg": 128.70032423974,
                    "smoothness_avg": 0.11066732728565867,
                    "success_improvement": 0.0,
                    "time_improvement": 23.393763084696577,
                    "length_improvement": 14.523372690833355,
                    "smoothness_improvement": 1307.6802344611865,
                    "objective_score": 16.461204635881575
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner integrating adaptive informed sampling with goal bias, rewiring for path cost optimization, and incremental connection of trees. It balances exploration and exploitation by focusing samples within an ellipsoidal informed region when a solution is found, uses fixed-radius rewiring to improve solution quality dynamically, and performs collision-aware incremental connections to swiftly merge two trees. Post-processing smoothing via random shortcutting further refines the path for length and smoothness improvements.",
          "planning_mechanism": "The planner alternates growing start and goal trees with rewiring of neighbors to minimize path costs. It samples with goal bias and informed ellipsoidal sampling towards the goal to accelerate convergence. When trees approach, an incremental rewiring-enhanced connection is performed to join them. After a valid path is found, path smoothing is applied to reduce detours and shorten the path. The structure maintains robust parent-child relations and ensures strict collision checks for nodes and edges throughout the process.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float) -> None:\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 7000,\n        step_size: float = 4.0,\n        goal_sample_rate: float = 0.15,\n        neighbor_radius: float = 20.0,\n        smoothing_iters: int = 50,\n        collision_resolution: float = 0.5,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        # Trees and data structures\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Variables for informed sampling\n        c_best = math.inf\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2.0 for s, g in zip(start_position, goal_position))\n        # Rotation matrix from unit vector along x axis to vector from start to goal\n        def rotation_to_goal():\n            \"\"\"Calculate rotation matrix to align x-axis with vector from start to goal in dimension D.\"\"\"\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1 = a1 / np.linalg.norm(a1)\n            Id = np.eye(dimension)\n            if dimension == 2:\n                # 2D rotation matrix\n                angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            else:\n                # For 3D, use Householder transformation\n                e1 = np.zeros(dimension)\n                e1[0] = 1.0\n                v = a1 - e1\n                if np.linalg.norm(v) < 1e-10:\n                    return Id\n                v = v / np.linalg.norm(v)\n                H = Id - 2.0 * np.outer(v, v)\n                return H\n\n        rotation_matrix = rotation_to_goal()\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid defined by current best cost c_best\n            if c_best == math.inf:\n                return uniform_sample()\n            r1 = c_best/2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            while True:\n                # Sample unit ball in dimension\n                if dimension == 2:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    unit_ball = np.array([x, y])\n                else:\n                    # Sample 3D unit ball via rejection\n                    while True:\n                        px = random.uniform(-1,1)\n                        py = random.uniform(-1,1)\n                        pz = random.uniform(-1,1)\n                        if px*px+py*py+pz*pz <= 1:\n                            unit_ball = np.array([px, py, pz])\n                            break\n                L = np.diag([r1] + [r2]*(dimension-1))\n                sample_local = L @ unit_ball\n\n                # Rotate and translate sample\n                sample_world = rotation_matrix @ sample_local + np.array(x_center)\n\n                point = tuple(np.clip(sample_world, [0]*dimension, bounds))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def uniform_sample():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def sample():\n            # Goal bias applied along with informed sampling when c_best is finite\n            if c_best < math.inf:\n                p_goal = random.random()\n                if p_goal < self.goal_sample_rate:\n                    return goal_position\n                if random.random() < 0.5:\n                    return informed_sample()\n                return uniform_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                not collision_free_edge(nearest_node.position, new_pos)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent by cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(curr_node.position, new_pos)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_final_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate node position at connection\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n\n                p1 = new_path[i]\n                p2 = new_path[j]\n\n                if collision_free_edge(p1, p2):\n                    # Shortcut by removing intermediate points\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                extracted_path = extract_final_path(new_node_a, new_node_b)\n                # Update c_best and informed sampling parameters\n                c_best = sum(math.dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1))\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -8.07632,
          "time_improvement": -4.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1103.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03546233177185058,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 160.4244848049874,
                    "smoothness_avg": 0.035022633560391106,
                    "success_improvement": 0.0,
                    "time_improvement": -42.28776145674394,
                    "length_improvement": 12.068797789748949,
                    "smoothness_improvement": 448.1802680861655,
                    "objective_score": -8.031667538642562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08922274112701416,
                    "num_nodes_avg": 355.5,
                    "path_length_avg": 229.67382658668322,
                    "smoothness_avg": 0.06373306979660538,
                    "success_improvement": 0.0,
                    "time_improvement": 44.79411195887387,
                    "length_improvement": 23.3282658908123,
                    "smoothness_improvement": 1539.897790941334,
                    "objective_score": 25.803375720531292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05740001201629639,
                    "num_nodes_avg": 222.1,
                    "path_length_avg": 117.09146594625352,
                    "smoothness_avg": 0.11160099977024449,
                    "success_improvement": 0.0,
                    "time_improvement": -15.29067481648307,
                    "length_improvement": 22.233423614938765,
                    "smoothness_improvement": 1319.556479548584,
                    "objective_score": 6.457264675785753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* style planner with goal-biased sampling, incremental rewiring for path cost improvement, and robust collision checking on nodes and edges. It grows two trees from start and goal positions, alternately extending and rewiring them to find an optimized, collision-free path within a 30-second time limit. Early termination occurs upon connection or timeout, returning the best found path with robustness and efficiency.",
          "planning_mechanism": "The planner samples points biased toward the goal, extends one tree toward the sample with rewiring among neighbors to reduce cost, then attempts to connect and rewire the other tree to the new node. This alternating bidirectional growth accelerates convergence. Collision checks ensure safety, and a 30-second limit enforces responsiveness. Upon successful connection, the path is extracted by merging paths from both trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n        best_nodes_pair = (None, None)\n\n        start_time = time.time()\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def can_connect(parent_node, point):\n            if not within_bounds(point):\n                return False\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(parent_node.position, point, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and can_connect(new_node, neighbor.position):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not can_connect(nearest_node, new_pos):\n                return None\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and can_connect(neighbor, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, connecting_node):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, connecting_node.position))\n            dist = math.dist(nearest_node.position, connecting_node.position)\n            if dist > self.step_size:\n                return None\n            if not can_connect(nearest_node, connecting_node.position):\n                return None\n            neighbors = near_nodes(tree, connecting_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, connecting_node.position)\n                if cost_through_neighbor < min_cost and can_connect(neighbor, connecting_node.position):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = Node(connecting_node.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # timeout - return best path if found\n                if best_nodes_pair[0] and best_nodes_pair[1]:\n                    path_start = best_nodes_pair[0].path_from_root()\n                    path_goal = best_nodes_pair[1].path_from_root()\n                    best_path = path_start + path_goal[::-1][1:]\n                    success = True\n                break\n\n            sample = sample_free()\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_nodes_pair = (new_node_a, new_node_b)\n                    path_start = new_node_a.path_from_root()\n                    path_goal = new_node_b.path_from_root()\n                    best_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.67587,
          "time_improvement": 5.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 454.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.042356562614440915,
                    "num_nodes_avg": 143.8,
                    "path_length_avg": 157.83194310094308,
                    "smoothness_avg": 0.0308639731286525,
                    "success_improvement": 0.0,
                    "time_improvement": -78.642944985153,
                    "length_improvement": 13.489810979187865,
                    "smoothness_improvement": 383.08820165378785,
                    "objective_score": -18.979480291439387
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06958203315734864,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 233.6167654354669,
                    "smoothness_avg": 0.02204450823573708,
                    "success_improvement": 0.0,
                    "time_improvement": 70.98984434516663,
                    "length_improvement": 22.011999411886237,
                    "smoothness_improvement": 467.2210749230031,
                    "objective_score": 28.035458560542253
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07955551147460938,
                    "num_nodes_avg": 344.2,
                    "path_length_avg": 118.77713376931536,
                    "smoothness_avg": 0.04800831145835747,
                    "success_improvement": 0.0,
                    "time_improvement": 23.985174284171702,
                    "length_improvement": 21.113883309737105,
                    "smoothness_improvement": 510.662178145365,
                    "objective_score": 13.971639837925757
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified, goal-biased bidirectional RRT* algorithm with incremental rewiring to optimize path cost and improve planning efficiency. Two trees grow from start and goal positions alternating expansions, where each new node connects through the lowest-cost parent within a fixed neighbor radius. Rewiring of nearby nodes reduces path costs dynamically. Collision checks on nodes and edges ensure feasibility and robustness. Once the two trees connect, their root paths are combined to form a smooth, optimized route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling points biased towards each opposite root to accelerate convergence. Each extension involves cost-based parent selection and rewiring of neighbors to refine path quality. After every extension, an incremental connection attempt with rewiring is made to join trees earlier and improve path smoothness. Collision and boundary checks maintain reliability and avoid invalid expansions, resulting in improved success rates and reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free(tree_from, tree_to_root):\n            if random.random() < self.goal_sample_rate:\n                # bias sample towards opposing tree root\n                return tree_to_root.position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample_point = sample_free(tree_a[0], tree_b[0])\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.54897,
          "time_improvement": 10.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 237.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024068188667297364,
                    "num_nodes_avg": 118.1,
                    "path_length_avg": 162.16088273051918,
                    "smoothness_avg": 0.018111696645408973,
                    "success_improvement": 0.0,
                    "time_improvement": 3.4296811100641387,
                    "length_improvement": 11.117050571779089,
                    "smoothness_improvement": 183.48738267941727,
                    "objective_score": 4.169751360772146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07468876838684083,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 243.3674034244215,
                    "smoothness_avg": 0.013951704330297302,
                    "success_improvement": 0.0,
                    "time_improvement": 53.78689632922378,
                    "length_improvement": 18.756955794620104,
                    "smoothness_improvement": 258.98740142499486,
                    "objective_score": 21.18239706481613
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06368763446807861,
                    "num_nodes_avg": 330.2,
                    "path_length_avg": 117.95792484222511,
                    "smoothness_avg": 0.02891657606089635,
                    "success_improvement": 0.0,
                    "time_improvement": -27.91966582177128,
                    "length_improvement": 21.657962872573307,
                    "smoothness_improvement": 267.81671309497943,
                    "objective_score": -2.7052236065418245
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner combines bidirectional RRT*-style dual-tree search with informed sampling and adaptive rewiring to balance exploration and exploitation, enabling fast convergence to low-cost, smooth paths. It integrates time-bound execution to ensure timely results. Key techniques include goal-biased sampling, incremental tree growth from both start and goal, local rewiring with cost optimization, collision-aware node and edge checks, and early path connection with continuous path improvement.",
          "planning_mechanism": "The planning mechanism grows two trees alternately from start and goal positions, sampling points biased by an ellipsoidal informed set after an initial solution is found. Each new node is added via steering within a step size, checked for collisions, and connected optimally through neighbor rewiring. The algorithm attempts incremental connection between trees, ensuring collision-free linkage. It tracks execution time to terminate early, returning the best path found. This approach reduces search time, improves path length, and enhances smoothness via dynamic rewiring and focused sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.neighbor_radius\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        # For informed sampling ellipsoid initialization\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n\n        # Initial trees (start and goal)\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True  # Alternate tree grow\n\n        # Enables informed sampling after first solution found\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                # Rodrigues' rotation formula to rotate direction to x-axis\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[0, -Kz, Ky], [Kz, 0, -Kx], [-Ky, Kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(\n                max(0.0, min(bounds[d], pos[d])) for d in range(dim)\n            )\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-8:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <= 1.0 and norm_sq > 1e-10:\n                        norm = math.sqrt(norm_sq)\n                        return tuple(x / norm for x in pt)\n\n            while True:\n                n = dim\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n                sample_point = clamp_to_bounds(sample_point)\n\n                if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                if time.perf_counter() - start_time > self.max_time_sec:\n                    # Return best path found so far\n                    # Try connecting trees to form final path if possible\n                    best_path = []\n                    success_flag = False\n                    min_cost = math.inf\n                    for n_s in tree_start:\n                        for n_g in tree_goal:\n                            if n_s.position == n_g.position:\n                                cost_sum = n_s.cost + n_g.cost\n                                if cost_sum < min_cost:\n                                    min_cost = cost_sum\n                                    path_s = n_s.path_from_root()\n                                    path_g = n_g.path_from_root()\n                                    best_path = path_s + path_g[::-1][1:]\n                                    success_flag = True\n                    return PlannerResult(success=success_flag, path=best_path, nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n                sample = None\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        # Connect new_node to tree_goal, add connecting node\n                        neighbors = near_nodes(tree_goal, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_goal.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_goal, connecting_node, neighbors)\n\n                        # Construct combined path\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        extracted_path = path_start + path_goal[::-1][1:]\n                        success_state = True\n                        if dist(start_pos, goal_pos) < best_path_cost:\n                            best_path_cost = dist(start_pos, goal_pos)\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_start, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_start.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_start, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        extracted_path = path_start + path_goal[::-1][1:]\n                        success_state = True\n                        if dist(start_pos, goal_pos) < best_path_cost:\n                            best_path_cost = dist(start_pos, goal_pos)\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=all_nodes, edges=edges)\n\n                grow_start = not grow_start\n\n            break  # End outer while after max_iter\n\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.22302,
          "time_improvement": 9.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 304.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04779033660888672,
                    "num_nodes_avg": 142.6,
                    "path_length_avg": 163.34582256410204,
                    "smoothness_avg": 0.02320058143038099,
                    "success_improvement": 0.0,
                    "time_improvement": -101.56041818966153,
                    "length_improvement": 10.467566272419091,
                    "smoothness_improvement": 263.1394802544123,
                    "objective_score": -27.05891480114258
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055781197547912595,
                    "num_nodes_avg": 272.5,
                    "path_length_avg": 244.48766974549613,
                    "smoothness_avg": 0.016638340013386384,
                    "success_improvement": 0.0,
                    "time_improvement": 76.74369158172475,
                    "length_improvement": 18.382978651567214,
                    "smoothness_improvement": 328.1164726563419,
                    "objective_score": 28.340285568112577
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05089423656463623,
                    "num_nodes_avg": 265.2,
                    "path_length_avg": 125.20713911658522,
                    "smoothness_avg": 0.03314114716678353,
                    "success_improvement": 0.0,
                    "time_improvement": 51.37085475673571,
                    "length_improvement": 16.843379922032156,
                    "smoothness_improvement": 321.55294573646177,
                    "objective_score": 20.387697140109452
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal biasing, incremental rewiring, and time-limited execution. It grows two trees simultaneously from start and goal, alternating expansion with efficient rewiring and incremental connection attempts, ensuring collision-free node and edge additions. Upon connection or time expiration, it extracts and smooths the lowest-cost path found.",
          "planning_mechanism": "The planner alternately samples points with a bias towards the goal, extends both trees towards these samples with controlled step size, performs local rewiring to minimize path costs, and incrementally connects the two trees. Collision and boundary checks ensure safety. Path smoothing post planning improves path quality and smoothness. Execution is limited to 30 seconds for timely responses.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.0,\n                 goal_sample_rate: float=0.1,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        def _adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 50.0\n            radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dimension)\n            radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n            return radius\n\n        def _sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_a is start_tree else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], p: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, p))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def _near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if math.dist(n.position, position) <= radius]\n\n        def _extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = _nearest(tree, sample)\n            new_pos = _steer(nearest_node.position, sample)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = _adaptive_neighbor_radius(n_nodes)\n            neighbors = _near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def _incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = _nearest(tree, target_pos)\n            current_node = nearest_node\n            dist_total = math.dist(current_node.position, target_pos)\n            max_steps = int(dist_total / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = _steer(current_node.position, target_pos)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                n_nodes = len(tree)\n                radius = _adaptive_neighbor_radius(n_nodes)\n                neighbors = _near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n            return None\n\n        def _path_smoothing(path: List[Tuple[float, ...]], max_iter=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iter):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        def _build_final_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicate node between paths\n            return path_a + path_b[::-1][1:]\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                # Time limit reached, return best path found if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path = _build_final_path(node_a, node_b)\n                    smoothed = _path_smoothing(path)\n                    extracted_path = smoothed\n                    success_state = True\n                break\n\n            sample = _sample_free()\n            new_node_a = _extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                iter_count += 1\n                continue\n\n            new_node_b = _incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path = _build_final_path(new_node_a, new_node_b)\n                    smoothed = _path_smoothing(path)\n                    extracted_path = smoothed\n                    success_state = True\n                    # break for performance - comment to allow further improvements\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n            iter_count += 1\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path = _build_final_path(node_a, node_b)\n            smoothed = _path_smoothing(path)\n            extracted_path = smoothed\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
          "objective": -7.19032,
          "time_improvement": 46.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1230.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02637314796447754,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 157.96575225719636,
                    "smoothness_avg": 0.03666632475565128,
                    "success_improvement": 0.0,
                    "time_improvement": -11.23133063911986,
                    "length_improvement": 13.416468060303677,
                    "smoothness_improvement": 473.9076046245469,
                    "objective_score": 1.6834324434475114
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05732207298278809,
                    "num_nodes_avg": 291.6,
                    "path_length_avg": 231.55370064666448,
                    "smoothness_avg": 0.08756025589972406,
                    "success_improvement": 0.0,
                    "time_improvement": 76.10126947673447,
                    "length_improvement": 22.700709820415902,
                    "smoothness_improvement": 2152.988451403033,
                    "objective_score": 38.135465064118684
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.02845785617828369,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 115.93419461066306,
                    "smoothness_avg": 0.09133801017962048,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 72.80868493531403,
                    "length_improvement": 23.002028132698815,
                    "smoothness_improvement": 1061.8127476141583,
                    "objective_score": -18.24792515479523
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified, efficient bidirectional RRT* planner with goal-biased sampling, adaptive neighbor radius, and dynamic rewiring. It rigorously checks for collisions on nodes and edges, grows two trees from start and goal positions alternately, and attempts to connect them incrementally. It enforces a 30-second time limit and performs path smoothing on the discovered solution to improve path quality and smoothness.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal points toward randomly sampled points biased towards the opposite goal. New nodes are added with collision-free checks, best parent selection in an adaptive radius, and rewiring of neighbors to reduce path cost. Incremental connection attempts between trees are made to form a full path. If successful, the path is extracted and smoothed before returning. Planning halts after 30 seconds or upon finding a feasible path, returning the best solution found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Node validity\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0,\n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=25.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def sample_free(towards_goal: bool):\n            # towards_goal: True when sampling for start tree (towards goal), False vice versa\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if towards_goal else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos if towards_goal else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_radius(node_count):\n            if node_count <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0  # a tuning parameter for radius scaling\n            radius = gamma * ((math.log(node_count) / node_count) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, towards_goal):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr = nearest_node\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + math.dist(curr.position, new_pos)\n                best_parent = curr\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr = new_node\n\n        def path_smoothing(raw_path, iterations=80):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) -1)\n                if j == i + 1:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if valid_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        import time\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                break  # Stop on timeout\n\n            sample = sample_free(towards_goal=True)  # Always sample toward goal for start_tree\n            new_node_a = extend_and_rewire(tree_a, sample, towards_goal=True)\n\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n\n            if new_node_b:\n                # Connected trees, build combined path\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined = path_from_start + path_from_goal[::-1][1:]\n                total_cost = new_node_a.cost + new_node_b.cost\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path_smoothing(combined, iterations=100)\n                    success = True\n\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -6.68097,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1360.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012707829475402832,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 154.20383099599104,
                    "smoothness_avg": 0.034503011040466915,
                    "success_improvement": 0.0,
                    "time_improvement": 46.403486455694804,
                    "length_improvement": 15.478436715027405,
                    "smoothness_improvement": 440.04704727098954,
                    "objective_score": 19.21696851606887
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.08892502784729003,
                    "num_nodes_avg": 401.5,
                    "path_length_avg": 233.0910483788954,
                    "smoothness_avg": 0.10117675777547004,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 62.92535899854158,
                    "length_improvement": 22.18749889729626,
                    "smoothness_improvement": 2503.3508522358534,
                    "objective_score": -14.168138259798999
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0845522403717041,
                    "num_nodes_avg": 404.1,
                    "path_length_avg": 123.82864171753332,
                    "smoothness_avg": 0.09715539375022633,
                    "success_improvement": 0.0,
                    "time_improvement": 19.210829060043242,
                    "length_improvement": 17.75891225749019,
                    "smoothness_improvement": 1135.8094372376756,
                    "objective_score": 14.99407835569939
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal-biased sampling and dynamic rewiring to efficiently find optimized, collision-free paths in 2D or 3D spaces. It grows two trees from start and goal simultaneously, attempts incremental connections between them, rewires neighbors to improve path cost locally, and applies path smoothing upon success. The search respects map bounds and obstacle constraints, enforcing robust collision checks for nodes and edges. A hard 30-second time limit ensures planning terminates timely, returning the best path found so far.",
          "planning_mechanism": "The planner alternately extends start and goal trees towards sampled points, biased towards the opposite tree's root, using fixed incremental steps. It dynamically adjusts neighbor radius to find candidate nodes for rewiring that reduce path cost. After extending a tree, it incrementally tries connecting the other tree towards the new node with rewiring for lower-cost connections. Collision checks verify node placement and edges before accepting expansions. Once both trees connect, paths from each root to the connecting nodes merge and smooth to yield a refined final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(towards_goal_root):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if towards_goal_root else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-6 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n        def extend(tree, target_point, nodes: List[Node], edges: List[Tuple[Node, Node]]):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, new_node.position)\n\n            while True:\n                new_pos = steer(curr_node.position, new_node.position)\n                if (not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos)):\n                    return None\n\n                n_radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, new_pos, n_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                connecting_node = Node(new_pos)\n                best_parent.add_child(connecting_node)\n                connecting_node.cost = min_cost\n                other_tree.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((best_parent, connecting_node))\n\n                rewire(other_tree, connecting_node, neighbors)\n\n                if dist(connecting_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connecting_node.position, new_node.position):\n                        return connecting_node\n                curr_node = connecting_node\n\n        def smooth_path(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return collision_free_edge(p1, p2)\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree[:]\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # Time limit exceeded - return best found path so far or empty\n                break\n\n            sample = goal_pos if (random.random() < self.goal_sample_rate) else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            n_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + dist(nbr.position, new_pos)\n                if c + 1e-6 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                full_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(full_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Alternate expansion\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.18931,
          "time_improvement": 43.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1321.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02274925708770752,
                    "num_nodes_avg": 67.6,
                    "path_length_avg": 158.81110092018804,
                    "smoothness_avg": 0.029083964568429703,
                    "success_improvement": 0.0,
                    "time_improvement": 4.052783523399731,
                    "length_improvement": 12.953119062711158,
                    "smoothness_improvement": 355.22720233584545,
                    "objective_score": 5.582594881241379
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.05949478149414063,
                    "num_nodes_avg": 260.7,
                    "path_length_avg": 240.88951929148098,
                    "smoothness_avg": 0.08831224278064696,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 75.19542339482445,
                    "length_improvement": 19.58414484013586,
                    "smoothness_improvement": 2172.3376154834364,
                    "objective_score": -12.662855936108306
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05254848003387451,
                    "num_nodes_avg": 237.1,
                    "path_length_avg": 123.92381622280504,
                    "smoothness_avg": 0.12062919505308514,
                    "success_improvement": 0.0,
                    "time_improvement": 49.7902348012493,
                    "length_improvement": 17.695701882811633,
                    "smoothness_improvement": 1434.3944571542602,
                    "objective_score": 25.648183102708416
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation is a bidirectional RRT*-inspired planner with advanced rewiring and informed incremental connection to minimize path length efficiently. It uses goal bias sampling, adaptive neighbor radius, and robust collision/edge checks to ensure path validity. The planner alternates expansion between two trees growing from start and goal, rewires nodes locally for optimal path cost, and incrementally attempts connection with rewiring optimizations. A time check enforces a 30-second cap to ensure timely results. After successful connection, the path is extracted and smoothed by shortcutting unnecessary waypoints, enhancing path smoothness and reducing length.",
          "planning_mechanism": "The planner samples points with goal bias, extends the active tree toward samples, rewires neighbors by cost within an adaptive radius, then incrementally connects the other tree to the new node while also rewiring. This bidirectional growth reduces search space and improves convergence. Collision checks prevent invalid expansions. Upon connection, the combined path is extracted and smoothed by iterative shortcutting to minimize length and sharp turns, producing a high-quality feasible path efficiently within time constraints.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, \n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree  # alternate growing trees\n        start_time = time.time()\n        last_best_cost = math.inf\n        best_connection_nodes = None\n\n        for iter_count in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time exceeded: break and return best path so far if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if (math.isclose(self.goal_sample_rate, 0.0) == False) and (math.isclose(self.goal_sample_rate, 1.0) == False):\n                if math.isclose(self.goal_sample_rate, 0.0):\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_position if tree_a is start_tree else start_position\n                    else:\n                        sample = self._sample_free(bounds, obstacles, is_3d)\n            else:\n                # goal_sample_rate=0 or 1 handled simply\n                sample = goal_position if tree_a is start_tree else start_position if self.goal_sample_rate==1 else self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < last_best_cost:\n                    last_best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Extract path now to allow early return\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            extracted_path = self._path_smoothing(path_a + path_b[::-1], obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int) -> float:\n        # RRT* theory: radius ~ gamma*(log(n)/n)^{1/d}\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        d = 2  # default dimension, adjusted in usage\n        # Let's keep dimension dynamic based on start node position length\n        # but fallback safely to 2D dimensional radius\n        return max(self.neighbor_radius_min, min(self.neighbor_radius_max, 50.0 * (math.log(n_nodes) / n_nodes)**(1/d)))\n\n    def _sample_free(self, bounds, obstacles, is_3d) -> Tuple[float, ...]:\n        import random\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          point: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes)\n\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if better cost available\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                      tree: List[Node],\n                                      target_pos: Tuple[float, ...],\n                                      obstacles,\n                                      is_3d: bool,\n                                      nodes: List[Node],\n                                      edges: List[Tuple[Node, Node]],\n                                      bounds: Tuple[int, ...]) -> Optional[Node]:\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n            if not self._in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int = 100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        import random\n        path = path[:]\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut possible: remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
          "objective": -6.11822,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1384.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02766132354736328,
                    "num_nodes_avg": 77.7,
                    "path_length_avg": 165.4971817884253,
                    "smoothness_avg": 0.04086364809249811,
                    "success_improvement": 0.0,
                    "time_improvement": -16.664337133991037,
                    "length_improvement": 9.288372191099048,
                    "smoothness_improvement": 539.6048294797105,
                    "objective_score": -0.44360255457894837
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04680578708648682,
                    "num_nodes_avg": 233.4,
                    "path_length_avg": 228.80053159602903,
                    "smoothness_avg": 0.09368330659549666,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 80.48572156758588,
                    "length_improvement": 23.619796895095245,
                    "smoothness_improvement": 2310.5389560604144,
                    "objective_score": -9.577629370403105
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04047691822052002,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 124.4211581054195,
                    "smoothness_avg": 0.11014912999012824,
                    "success_improvement": 0.0,
                    "time_improvement": 61.324541480339064,
                    "length_improvement": 17.365391085254622,
                    "smoothness_improvement": 1301.088803111385,
                    "objective_score": 28.37588467670957
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with adaptive neighbor radius, goal biasing, incremental rewiring, and time-limited execution. It grows two trees simultaneously from start and goal positions, alternating expansions to improve exploration efficiency and path optimality while respecting obstacle and boundary constraints. The planner dynamically adapts neighbor search radius, performs collision-free incremental connections, and applies path smoothing upon completion to output shorter, smoother paths. The search aborts as soon as a solution is found or 30 seconds time limit elapses, providing the best path found so far.",
          "planning_mechanism": "The planner alternately samples points biased toward goal regions, incrementally extends one tree toward samples with step-size-limited steering, rewires locally to reduce path costs, and attempts to connect the two trees incrementally. Strategic rewiring and adaptive neighbor radius improve path quality and convergence speed. The planner monitors elapsed time to enforce a hard runtime limit, extracting and smoothing the best path found before termination.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node'] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List[Node] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.5, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        def _adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 50.0\n            radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dimension)\n            radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n            return radius\n\n        def _sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_a is start_tree else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], p: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, p))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def _near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if math.dist(n.position, position) <= radius]\n\n        def _in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def _extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = _nearest(tree, sample)\n            new_pos = _steer(nearest_node.position, sample)\n            if not _in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = _adaptive_neighbor_radius(n_nodes)\n            neighbors = _near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def _incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = _nearest(tree, target_pos)\n            current_node = nearest_node\n            dist_total = math.dist(current_node.position, target_pos)\n            max_steps = int(dist_total / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = _steer(current_node.position, target_pos)\n                if not _in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                n_nodes = len(tree)\n                radius = _adaptive_neighbor_radius(n_nodes)\n                neighbors = _near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current_node = new_node\n\n            return None\n\n        def _path_smoothing(path: List[Tuple[float, ...]], max_iter=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iter):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # shortcut path\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        def _build_final_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicate overlapping connection node\n            return path_a + path_b[::-1][1:]\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path = _build_final_path(node_a, node_b)\n                    smoothed = _path_smoothing(path)\n                    extracted_path = smoothed\n                    success_state = True\n                break\n\n            sample = _sample_free()\n            new_node_a = _extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                iter_count += 1\n                continue\n\n            new_node_b = _incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path = _build_final_path(new_node_a, new_node_b)\n                    smoothed = _path_smoothing(path)\n                    extracted_path = smoothed\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n            iter_count += 1\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path = _build_final_path(node_a, node_b)\n            smoothed = _path_smoothing(path)\n            extracted_path = smoothed\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.99678,
          "time_improvement": 40.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1393.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03145313262939453,
                    "num_nodes_avg": 77.5,
                    "path_length_avg": 161.55902961464184,
                    "smoothness_avg": 0.04268054191918961,
                    "success_improvement": 0.0,
                    "time_improvement": -32.656662748359196,
                    "length_improvement": 11.446935801564374,
                    "smoothness_improvement": 568.0431633155262,
                    "objective_score": -4.667395847617252
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05090653896331787,
                    "num_nodes_avg": 263.0,
                    "path_length_avg": 231.8928151312163,
                    "smoothness_avg": 0.09005384779697514,
                    "success_improvement": 0.0,
                    "time_improvement": 78.77603524698496,
                    "length_improvement": 22.58750364460327,
                    "smoothness_improvement": 2217.1503669809495,
                    "objective_score": 39.236063137920894
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.028725218772888184,
                    "num_nodes_avg": 192.7,
                    "path_length_avg": 115.3221151101902,
                    "smoothness_avg": 0.11751628595000338,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 72.55322154057139,
                    "length_improvement": 23.408542192819144,
                    "smoothness_improvement": 1394.7984831341091,
                    "objective_score": -16.578332683594205
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with goal-biased informed sampling, dynamic rewiring, and incremental tree connection. It enforces rigorous collision checks on nodes and edges, manages parent-child relationships for efficient rewiring, and limits execution time to ensure timely response while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal toward randomly sampled points biased by a goal-oriented heuristic within map bounds and obstacles. For each new sampled point, it selects the best parent node minimizing path cost in a neighborhood and rewires neighbors if the new path is cheaper. The planner tries to incrementally connect the two trees with rewiring to form a full path. It terminates upon success or after 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]: spatial coordinate (2D or 3D)\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # List of child nodes\n        self.valid = True             # Node validity flag (e.g., collision free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, neighbor_radius: float=20.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def valid_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_free(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if valid_node(node.position) and edge_free(nearest_node.position, node.position):\n                    return nearest_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                # Time limit reached; return best found path so far.\n                break\n\n            sample = sample_free()\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not valid_node(new_pos):\n                    continue\n                if not edge_free(nearest_node.position, new_pos):\n                    continue\n\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_via_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_via_neighbor < min_cost and edge_free(neighbor.position, new_pos):\n                        min_cost = cost_via_neighbor\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost and edge_free(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = potential_cost\n                        edges.append((new_node, neighbor))\n\n                connect_node = try_connect(tree_b, new_node)\n                if connect_node:\n                    conn_neighbors = near_nodes(tree_b, new_node.position)\n                    min_conn_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_conn_parent = connect_node\n                    for neighbor in conn_neighbors:\n                        cost_try = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if cost_try < min_conn_cost and edge_free(neighbor.position, new_node.position):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                    new_node_other = Node(new_node.position)\n                    best_conn_parent.add_child(new_node_other)\n                    new_node_other.cost = min_conn_cost\n                    tree_b.append(new_node_other)\n                    nodes.append(new_node_other)\n                    edges.append((best_conn_parent, new_node_other))\n\n                    for neighbor in conn_neighbors:\n                        if neighbor is best_conn_parent:\n                            continue\n                        cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                        if cost_via_new < neighbor.cost and edge_free(new_node_other.position, neighbor.position):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_other.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    total_cost = new_node.cost + new_node_other.cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success = True\n\n                    # Stop immediately on first successful connection\n                    break\n\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -5.84492,
          "time_improvement": 1.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 428.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04308300018310547,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 163.1762654561707,
                    "smoothness_avg": 0.027824464800794584,
                    "success_improvement": 0.0,
                    "time_improvement": -81.70676647122058,
                    "length_improvement": 10.560503210080563,
                    "smoothness_improvement": 335.5132959248345,
                    "objective_score": -20.722362819725888
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07495694160461426,
                    "num_nodes_avg": 349.9,
                    "path_length_avg": 233.93850869422153,
                    "smoothness_avg": 0.02168014879726888,
                    "success_improvement": 0.0,
                    "time_improvement": 68.7489364037006,
                    "length_improvement": 21.90459225124772,
                    "smoothness_improvement": 457.84584413372045,
                    "objective_score": 27.294828592028328
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08740341663360596,
                    "num_nodes_avg": 319.6,
                    "path_length_avg": 123.78660059659566,
                    "smoothness_avg": 0.046524904337205866,
                    "success_improvement": 0.0,
                    "time_improvement": 16.486546824704362,
                    "length_improvement": 17.786833968233932,
                    "smoothness_improvement": 491.79334905804063,
                    "objective_score": 10.962297586348297
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT*-style path planner that grows two trees from start and goal positions simultaneously, employing goal-biased sampling, incremental tree expansion with cost-based rewiring, and frequent incremental connection attempts between the two trees. It ensures collision-free nodes and edges while dynamically optimizing path cost through rewiring in both trees. The algorithm promotes efficiency, robustness, and quality by balancing exploration and exploitation with structured incremental connections and rewiring to produce smooth, shorter paths.",
          "planning_mechanism": "The planner alternates growth between two trees using goal-biased random samples, extends and rewires one tree towards samples, then incrementally connects and rewires the opposite tree towards the newly added node. This frequent attempt to link the trees combined with rewiring optimizes path cost on the fly. Collision checking for nodes and edges ensures validity. Upon successful connection, paths are merged to output a smooth and optimized final route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update costs recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(child.position))\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._within_bounds(pos, bounds)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            \n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge paths from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.40105,
          "time_improvement": 0.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 291.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021263980865478517,
                    "num_nodes_avg": 90.2,
                    "path_length_avg": 155.46314810612068,
                    "smoothness_avg": 0.02029841917168108,
                    "success_improvement": 0.0,
                    "time_improvement": 14.681181810789734,
                    "length_improvement": 14.78818505180875,
                    "smoothness_improvement": 217.71433875954466,
                    "objective_score": 8.450563247396394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07615876197814941,
                    "num_nodes_avg": 383.7,
                    "path_length_avg": 238.22231704511987,
                    "smoothness_avg": 0.015554505787950446,
                    "success_improvement": 0.0,
                    "time_improvement": 52.87734904791542,
                    "length_improvement": 20.474533721131174,
                    "smoothness_improvement": 300.2286373816369,
                    "objective_score": 21.459254645509045
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08309917449951172,
                    "num_nodes_avg": 392.6,
                    "path_length_avg": 115.95748746207536,
                    "smoothness_avg": 0.035670171688152404,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90867420064964,
                    "length_improvement": 22.986558129877153,
                    "smoothness_improvement": 353.72195097510166,
                    "objective_score": -13.706680879343953
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* planner by integrating informed ellipsoidal goal-biased sampling to focus exploration on promising regions, dynamically adjusting neighbor radius based on the node count and dimension for efficient rewiring, and incremental rewiring to continuously improve path quality. A balance of exploration and exploitation is achieved by alternating tree growth, ensuring collision-free node and edge connections. The planner uses numpy for efficient linear algebra operations in sampling, employs adaptive step sizing, and terminates early upon finding a feasible low-cost path, thereby reducing planning time and improving path smoothness and quality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately, samples points biased towards the dynamically defined ellipsoidal informed subset around the current best path cost, extends trees towards sampled points with constrained steps, performs collision checks, rewires neighbors within an adaptive radius, attempts connection between trees at each iteration, and returns an optimized smooth path on success or after reaching iteration limits.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal bias\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of 2D or 3D boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        # Current best path and its cost, initialize with None and infinity\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        # Adaptive neighbor radius: \u03b3 * (log(n)/n)^(1/d), \u03b3 ~ 30 (tuned)\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        # Ellipsoidal informed sampling between start and goal constrained by current best cost\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):  # No solution found yet: uniform random sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoid parameters\n            c_min = dist(start, goal)\n            if best_cost < c_min:\n                # Numerics: clamp to c_min to avoid pathological ellipsoid\n                c_cost = c_min\n            else:\n                c_cost = best_cost\n\n            # Center of ellipsoid\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n\n            # Rotation matrix aligning x-axis to start-goal vector\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)  # start==goal rare case\n\n            e1 = a1 / norm_a1  # Unit vector from start to goal\n\n            # Construct basis via QR decomposition for dimension d\n            I = np.eye(dim)\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            # Ellipsoid radii\n            r1 = c_cost / 2.0\n            if c_cost * c_cost - c_min * c_min <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_cost * c_cost - c_min * c_min) / 2.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Sample uniformly from unit ball in dim-dimensions\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 0:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n\n            # Scale and transform sample to ellipsoid\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            # Final collision check for sample is omitted here (usually acceptable)\n            return sample_point\n\n        # Rewiring logic\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n                    # Update edges list: remove old edge\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        # Extension + rewiring for one tree towards a sampled point\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            # Choose best parent with min cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Attempt to connect two trees via the newly added node in tree_a by extending tree_b towards it incrementally,\n        # rewiring and choosing lower cost parents until connection or failure\n        def connect_and_rewire(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                # Direct check\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir == 0:\n                return None\n\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            # Choose best parent among neighbors\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_to, new_node, neighbors)\n\n            # Recursively attempt to connect further or reach the target\n            if dist(new_pos, current_pos) <= self.step_size:\n                # Final connection attempt\n                if collision_free_edge(new_pos, current_pos):\n                    final_connect = Node(current_pos)\n                    final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                    tree_to.append(final_connect)\n                    nodes.append(final_connect)\n                    edges.append((new_node, final_connect))\n                    rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                    return final_connect\n                return None\n\n            # Continue extending towards current_pos if possible\n            return connect_and_rewire(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    # Reconstruct full path from start to goal\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n\n            grow_start = not grow_start\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.28427,
          "time_improvement": 13.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 128.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028359365463256837,
                    "num_nodes_avg": 110.4,
                    "path_length_avg": 171.9092710773572,
                    "smoothness_avg": 0.017696900898962236,
                    "success_improvement": 0.0,
                    "time_improvement": -13.788079533551127,
                    "length_improvement": 5.773804445778623,
                    "smoothness_improvement": 176.99492850414552,
                    "objective_score": -2.0966883283888853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06134157180786133,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 289.6449868661758,
                    "smoothness_avg": 0.007427513234392058,
                    "success_improvement": 0.0,
                    "time_improvement": 62.04537203502058,
                    "length_improvement": 3.3081664153793446,
                    "smoothness_improvement": 91.11526534244898,
                    "objective_score": 19.730821220294285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05503737926483154,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 144.51516822016083,
                    "smoothness_avg": 0.016953867316359176,
                    "success_improvement": 0.0,
                    "time_improvement": -10.545213714792496,
                    "length_improvement": 4.019906340982156,
                    "smoothness_improvement": 115.65194085977592,
                    "objective_score": -1.7813231419424378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner enhanced with adaptive sampling, dynamic rewiring, and heuristic goal biasing. It grows two trees simultaneously from start and goal while focusing the sampling within an ellipsoidal informed region once a path is found, thereby accelerating convergence and improving path quality and smoothness. The planner employs time-budgeted execution with robust collision checks, adaptive neighbor radius for controlled rewiring, and a path smoothing post-processing step to produce high-quality, optimized paths within limited computation time.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal nodes. Random sampling is biased toward the goal and confined inside an informed ellipsoid (after a first solution). Each extension attempts rewiring amongst neighbors to improve path costs. The trees continuously try to connect to form a complete path. Upon success or timeout (30 sec), it extracts and smooths the best found path, returning it along with the explored graph.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent              # Parent node or None\n        self.cost = cost                  # Cost from root node\n        self.children = []                # Child nodes\n        self.valid = True                 # Node validity (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_min_radius: float = 10.0, neighbor_max_radius: float = 30.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = math.inf\n        best_path = []\n        success = False\n\n        start_time = time.time()\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            return goal_pos\n\n        def ellipsoid_sample(c_min, c_best, start_p, goal_p):\n            # Sample inside an ellipsoid with foci at start and goal\n            if c_best == math.inf:\n                return sample_uniform()\n            center = tuple((start_p[d] + goal_p[d]) / 2 for d in range(dim))\n            foci_dist = c_min / 2.0\n            # Create coordinate frame aligned with line start->goal\n            direction = tuple((goal_p[d] - start_p[d]) / c_min for d in range(dim))  # unit vector\n            # Sample random point in unit ball radius 1\n            while True:\n                if dim == 2:\n                    x, y = random.gauss(0,1), random.gauss(0,1)\n                    length = math.sqrt(x*x + y*y)\n                    if length > 1:\n                        continue\n                    uball = (x, y)\n                    break\n                else:\n                    x, y, z = random.gauss(0,1), random.gauss(0,1), random.gauss(0,1)\n                    length = math.sqrt(x*x + y*y + z*z)\n                    if length > 1:\n                        continue\n                    uball = (x, y, z)\n                    break\n            # Scale unit ball to ellipsoid axes (a,b,(c))\n            a = c_best / 2.0\n            b = math.sqrt(c_best*c_best - c_min*c_min) / 2.0 if c_best*c_best > c_min*c_min else 0.0001\n            if dim == 2:\n                sample = (uball[0]*a, uball[1]*b)\n            else:\n                sample = (uball[0]*a, uball[1]*b, uball[2]*b)\n            # Rotate sample: create rotation matrix aligning x-axis with direction vector\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                cos_ang = math.cos(angle)\n                sin_ang = math.sin(angle)\n                x_r = cos_ang * sample[0] - sin_ang * sample[1]\n                y_r = sin_ang * sample[0] + cos_ang * sample[1]\n                rotated = (x_r, y_r)\n            else:\n                # 3D coordinate alignment using Rodrigues' rotation\n                # Rotate vector sample (a, b, c) aligned with x-axis to direction vector\n                # If direction is x-axis (1,0,0), no rotation needed.\n                vx, vy, vz = direction\n                ux, uy, uz = 1.0, 0.0, 0.0\n                cross = (uy*vz - uz*vy, uz*vx - ux*vz, ux*vy - uy*vx)\n                norm_cross = math.sqrt(sum(c*c for c in cross))\n                dot = vx*ux + vy*uy + vz*uz\n                if norm_cross < 1e-10:  # parallel vectors\n                    rotated = sample\n                else:\n                    kx, ky, kz = (c / norm_cross for c in cross)\n                    angle = math.acos(dot)\n                    c = math.cos(angle)\n                    s = math.sin(angle)\n                    t = 1 - c\n                    x, y, z = sample\n                    rot_x = (t*kx*kx + c)*x + (t*kx*ky - s*kz)*y + (t*kx*kz + s*ky)*z\n                    rot_y = (t*kx*ky + s*kz)*x + (t*ky*ky + c)*y + (t*ky*kz - s*kx)*z\n                    rot_z = (t*kx*kz - s*ky)*x + (t*ky*kz + s*kx)*y + (t*kz*kz + c)*z\n                    rotated = (rot_x, rot_y, rot_z)\n            # Translate back to center\n            sample_point = tuple(center[d] + rotated[d] for d in range(dim))\n            if not within_bounds(sample_point):\n                return sample_uniform()\n            return sample_point\n\n        def sample_free(c_best):\n            if random.random() < self.goal_sample_rate:\n                return sample_goal()\n            else:\n                c_min = distance(start_pos, goal_pos)\n                return ellipsoid_sample(c_min, c_best, start_pos, goal_pos)\n\n        def steer(from_p, to_p):\n            dist = distance(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (distance(node.position, position)**2) <= r_sq]\n\n        def is_valid_node(pos):\n            if not within_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_edge_free(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def update_rewiring(new_node, near_nodes_list):\n            for near_node in near_nodes_list:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if new_cost + 1e-6 < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                    near_node.update_parent(new_node, new_cost)\n                    if (near_node.parent, near_node) not in edges:\n                        edges.append((near_node.parent, near_node))\n\n        def connect_trees(node_from_start, node_from_goal):\n            path_from_start = node_from_start.path_from_root()\n            path_from_goal = node_from_goal.path_from_root()\n            full_path = path_from_start + path_from_goal[::-1][1:]\n            return full_path\n\n        def smooth_path(path_points, max_iter=50):\n            if len(path_points) < 3:\n                return path_points\n            for _ in range(max_iter):\n                if len(path_points) <= 2:\n                    break\n                i = random.randint(0, len(path_points) - 3)\n                j = random.randint(i + 2, len(path_points) - 1)\n                p1 = path_points[i]\n                p2 = path_points[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate points between i and j\n                    path_points = path_points[:i+1] + path_points[j:]\n            return path_points\n\n        def adaptive_radius(num_nodes):\n            gamma = 50.0  # tuning parameter\n            r = gamma * ((math.log(num_nodes + 1) / (num_nodes + 1)) ** (1.0 / dim))\n            return min(max(r, self.neighbor_min_radius), self.neighbor_max_radius)\n\n        # Main loop\n        for itr in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Timeout: return best found path so far\n                if best_path:\n                    best_path = smooth_path(best_path)\n                return self._make_result(True if best_path else False, best_path, nodes, edges)\n\n            c_best = best_cost if best_cost != math.inf else math.inf\n            sample = sample_free(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not is_valid_node(new_pos):\n                    continue\n                if not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                # Create the new node with parent nearest_node\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.add_child(new_node)\n\n                # Add to nodes and tree\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Adaptive radius for rewiring\n                radius = adaptive_radius(len(tree_a))\n\n                neighbors = near(tree_a, new_pos, radius)\n                for neighbor in neighbors:\n                    cost_thru_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_thru_new + 1e-6 < neighbor.cost and is_edge_free(new_node.position, neighbor.position):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_thru_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n                # Try to connect to the other tree\n                nearest_to_other = nearest(tree_b, new_node.position)\n                dist_connect = distance(new_node.position, nearest_to_other.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, nearest_to_other.position):\n                    # Form connection nodes (clone nodes for consistent trees)\n                    node_from_tree_b = Node(nearest_to_other.position, parent=nearest_to_other.parent, cost=nearest_to_other.cost)\n                    # We keep the nearest_to_other original; best to link directly using their nodes\n                    # Extract path from new_node to start root and nearest_to_other to goal root\n                    path_candidate = connect_trees(new_node, nearest_to_other)\n                    total_cost_candidate = new_node.cost + nearest_to_other.cost + dist_connect\n                    if total_cost_candidate < best_cost:\n                        best_cost = total_cost_candidate\n                        best_path = path_candidate\n                        success = True\n\n            if success:\n                break\n\n        if success and best_path:\n            best_path = smooth_path(best_path)\n\n        return self._make_result(success, best_path, nodes, edges)\n\n\n    def _make_result(self, success, path, nodes, edges):\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.52634,
          "time_improvement": 45.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 986.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.023842811584472656,
                    "num_nodes_avg": 120.7,
                    "path_length_avg": 170.01244329249982,
                    "smoothness_avg": 0.026892605212035396,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -0.5593895082540903,
                    "length_improvement": 6.81348581181865,
                    "smoothness_improvement": 320.92766979526795,
                    "objective_score": -47.200481341136154
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05598492622375488,
                    "num_nodes_avg": 341.3,
                    "path_length_avg": 240.15563707034863,
                    "smoothness_avg": 0.06445529266484931,
                    "success_improvement": 0.0,
                    "time_improvement": 76.65875298005767,
                    "length_improvement": 19.829135849178346,
                    "smoothness_improvement": 1558.481105537356,
                    "objective_score": 34.75585859153975
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0435678243637085,
                    "num_nodes_avg": 298.1,
                    "path_length_avg": 127.081093825495,
                    "smoothness_avg": 0.09265022889715357,
                    "success_improvement": 0.0,
                    "time_improvement": 58.3711987461472,
                    "length_improvement": 15.598788432508318,
                    "smoothness_improvement": 1078.5040728432687,
                    "objective_score": 26.023637674562167
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with incremental connect-and-rewire and informed ellipsoidal sampling to accelerate convergence, improve path quality, enhance rewiring efficiency, and maintain balanced tree growth. It enforces strict collision and boundary checks for nodes and edges, uses dynamic neighborhood radius for rewiring in both trees, and integrates best path tracking with a strict 30-second time budget.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling informed points within an ellipsoid defined by the current best path cost to concentrate search efforts. Each extension involves steering, collision checking, rewiring neighbors to optimize path costs, then incrementally connecting to the opposite tree with rewiring. When a connection is found, it extracts the combined path. If time expires, it returns the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        self.parent = new_parent\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_factor: float = 2.0,\n                 collision_resolution: float = 0.5, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time = max_time  # max planning time in seconds\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Ellipsoidal informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_], [s_, c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ ** 2))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D uniform sampling inside unit sphere\n                    while True:\n                        unit_sample = np.random.uniform(-1,1,3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            if n == 0:\n                return []\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and dist(node.position, new_node.position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            neighbors = near_nodes(tree, Node(new_pos))\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    # Check if edge collision free before considering\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors via new node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def connect_trees(tree_connect, node_to_connect):\n            # Incrementally move from nearest node in tree_connect towards node_to_connect.position\n            nearest_node = nearest(tree_connect, node_to_connect.position)\n            last_node = nearest_node\n            goal_pos_local = node_to_connect.position\n\n            while True:\n                next_pos = steer(last_node.position, goal_pos_local)\n                if next_pos == last_node.position:\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                cost_to_next = last_node.cost + dist(last_node.position, next_pos)\n                candidate_node = Node(next_pos, parent=last_node, cost=cost_to_next)\n                neighbors = near_nodes(tree_connect, candidate_node)\n                min_cost = cost_to_next\n                min_parent = last_node\n                # Choose best parent in neighborhood (rewiring)\n                for near in neighbors:\n                    if not self._is_edge_in_obstacle(near.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        cost_via_near = near.cost + dist(near.position, next_pos)\n                        if cost_via_near < min_cost:\n                            min_cost = cost_via_near\n                            min_parent = near\n                if min_parent != last_node:\n                    candidate_node.parent = min_parent\n                    candidate_node.cost = min_cost\n                    min_parent.add_child(candidate_node)\n                else:\n                    last_node.add_child(candidate_node)\n\n                tree_connect.append(candidate_node)\n\n                # Rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost:\n                        if not self._is_edge_in_obstacle(candidate_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                            near.update_parent(candidate_node, cost_through_candidate)\n\n                # Check if we reached or close to target connection node\n                if dist(candidate_node.position, goal_pos_local) < self.step_size * 0.5:\n                    return candidate_node\n                last_node = candidate_node\n\n            return None\n\n        # Initialization of trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = tree_start, tree_goal  # Initialize alternating trees\n\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time:\n                break\n\n            # Sampling with goal bias and informed sampling\n            for tree_current, tree_other in [(tree_a, tree_b), (tree_b, tree_a)]:\n                if elapsed > self.max_time:\n                    break\n                sample = None\n                if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_current is tree_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                new_node = extend_and_rewire(tree_current, sample)\n                if new_node is None:\n                    continue\n\n                nodes.append(new_node)\n\n                # Add edge for new_node\n                if new_node.parent is not None:\n                    edges.append((new_node.parent, new_node))\n\n                # Rewire edges after extension already handled in extend_and_rewire\n\n                # Attempt to connect the other tree incrementally with rewiring\n                connected_node = connect_trees(tree_other, new_node)\n                if connected_node is not None:\n                    # Extract combined path\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n\n                    # Calculate path cost\n                    path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        extracted_path = combined_path\n                        success_state = True\n                        c_best = best_cost\n\n                    # Add edges for connected_node to tree_other\n                    # already added in connect_trees by adding children relationship,\n                    # but edges list missing these newly formed edges; we add them now carefully\n                    def add_edges_recursively(node):\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n                            add_edges_recursively(c)\n                    add_edges_recursively(connected_node)\n\n                    # Return immediately on first successful path (can be adjusted to keep searching)\n                    return PlannerResult(\n                        success=True,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n            # Swap trees for next iteration expansion\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no connection found, attempt to connect any nodes from both trees for best partial path\n        if not success_state:\n            min_cost = float('inf')\n            best_connection = None\n            for ns in tree_start:\n                for ng in tree_goal:\n                    if dist(ns.position, ng.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, self.collision_resolution):\n                            total_cost = ns.cost + dist(ns.position, ng.position) + ng.cost\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_connection = (ns, ng)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                best_cost = min_cost\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.08863,
          "time_improvement": 71.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011738967895507813,
                    "num_nodes_avg": 58.8,
                    "path_length_avg": 186.54654740845126,
                    "smoothness_avg": 0.010452942678314281,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 50.48975491640329,
                    "length_improvement": -2.2491186537801777,
                    "smoothness_improvement": 63.6112518439534,
                    "objective_score": -34.984840996615276
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033424091339111325,
                    "num_nodes_avg": 205.5,
                    "path_length_avg": 304.3219635036141,
                    "smoothness_avg": 0.0064799438269543454,
                    "success_improvement": 0.0,
                    "time_improvement": 86.06482092616773,
                    "length_improvement": -1.5914308395464922,
                    "smoothness_improvement": 66.73362198241959,
                    "objective_score": 25.834828219853115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02385706901550293,
                    "num_nodes_avg": 176.7,
                    "path_length_avg": 165.88087532861306,
                    "smoothness_avg": 0.012398411759637712,
                    "success_improvement": 0.0,
                    "time_improvement": 77.20471014905449,
                    "length_improvement": -10.170178994809635,
                    "smoothness_improvement": 57.706882427031125,
                    "objective_score": 21.415911657889577
               }
          ],
          "success_rate": 0.9666666666666667
     }
]