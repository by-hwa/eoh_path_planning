{
    "operator": "e1",
    "algorithm_description": "Hybrid Anytime RRT* with Adaptive Sampling and Path Smoothing",
    "planning_mechanism": "This algorithm combines the asymptotic optimality of RRT* with adaptive sampling that focuses exploration on promising regions guided by a heuristic cost-to-go estimate. It incorporates vertex rewiring for improved path quality, plus an anytime framework to iteratively improve the solution while maintaining valid paths. After finding an initial feasible path, adaptive biased sampling narrows the search space near the current best path to accelerate convergence. Finally, a post-processing smoothing step refines the path for smoothness and shorter length without violating constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        self.cost = new_cost\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        def heuristic(pos):\n            # Euclidean distance to goal as heuristic\n            return math.dist(pos, goal_position)\n\n        def sample():\n            # Adaptive sampling: with probability p, sample near current best path corridor to improve convergence\n            p = 0.7 if success_state else 0.0\n            dim = len(bounds)\n            if success_state and best_goal_node is not None:\n                if random.random() < p:\n                    # Sample along bounding box of current best path + small margin\n                    path_positions = [n.position for n in nodes if n.cost + heuristic(n.position) <= best_cost * 1.5]\n                    if not path_positions:\n                        # fallback uniform sampling\n                        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                    mins = [min(p[d] for p in path_positions) for d in range(dim)]\n                    maxs = [max(p[d] for p in path_positions) for d in range(dim)]\n                    margin = [self.step_size*2]*(dim)\n                    sample_point = []\n                    for d in range(dim):\n                        low = max(0, mins[d] - margin[d])\n                        high = min(bounds[d], maxs[d] + margin[d])\n                        sample_point.append(random.uniform(low, high))\n                    return tuple(sample_point)\n            # otherwise uniform random sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def try_add_node(x_nearest, x_new_pos):\n            # Collision checks\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                return None\n\n            # Create new node with cost estimate via x_nearest\n            new_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            x_new = Node(x_new_pos, parent=x_nearest, cost=new_cost)\n            x_nearest.add_child(x_new)\n\n            return x_new\n\n        # Radius for near neighbors depends on number of nodes (adaptive radius for rewiring)\n        def radius(n_nodes):\n            gamma_rrt_star = 50.0  # tuning parameter\n            dim = len(bounds)\n            eta = gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n            return min(eta, self.step_size * 10)\n\n        # Path smoothing by shortcutting\n        def smooth_path(path_positions):\n            if len(path_positions) <= 2:\n                return path_positions\n            smoothed = [path_positions[0]]\n            i = 0\n            while i < len(path_positions) -1:\n                j = len(path_positions) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path_positions[i], path_positions[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smoothed.append(path_positions[j])\n                i = j\n            return smoothed\n\n        for iter_num in range(self.max_iter):\n            x_rand = sample()\n            x_nearest = nearest(tree, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n            x_new = try_add_node(x_nearest, x_new_pos)\n            if x_new is None:\n                continue\n\n            # Near neighbors for rewiring\n            rewiring_radius = radius(len(tree))\n            near_nodes = near(tree, x_new.position, rewiring_radius)\n\n            # Choose best parent among near nodes\n            min_cost = x_new.cost\n            best_parent = x_new.parent\n            for n in near_nodes:\n                if n == x_new.parent:\n                    continue\n                potential_cost = n.cost + math.dist(n.position, x_new.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = n\n\n            if best_parent != x_new.parent:\n                # Re-parent x_new\n                if x_new.parent:\n                    x_new.parent.children.remove(x_new)\n                x_new.parent = best_parent\n                best_parent.children.append(x_new)\n                x_new.cost = min_cost\n\n            # Rewire near nodes through x_new if it reduces cost\n            for n in near_nodes:\n                if n == x_new:\n                    continue\n                new_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        # Remove old edge\n                        edges = [e for e in edges if e != (n.parent, n)]\n                        n.parent.children.remove(n)\n                    # Add new edge\n                    n.parent = x_new\n                    n.cost = new_cost\n                    x_new.children.append(n)\n                    edges.append((x_new, n))\n                    # Propagate cost update downstream recursively\n                    self._update_children_costs(n, obstacles, is_3d)\n\n            nodes.append(x_new)\n            edges.append((x_new.parent, x_new))\n            tree.append(x_new)\n\n            # Check if can connect to goal\n            if math.dist(x_new.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(x_new.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + math.dist(x_new.position, goal_position)\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    tree.append(goal_node)\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n\n        # Post processing: smooth path if available\n        if success_state and extracted_path:\n            extracted_path = smooth_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_children_costs(self, node, obstacles, is_3d):\n        import math\n        # Recursively update cost of descendants during rewiring\n        for child in node.children:\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child, obstacles, is_3d)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2190.26536,
    "time_improvement": -7337.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1328.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.135515332221985,
            "num_nodes_avg": 3206.9,
            "path_length_avg": 157.1358679062836,
            "smoothness_avg": 0.04959477800117372,
            "success_improvement": 0.0,
            "time_improvement": -11291.164537928382,
            "length_improvement": 13.871340823398024,
            "smoothness_improvement": 676.265972502545,
            "objective_score": -3381.193763351322
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 3.8707536935806273,
            "num_nodes_avg": 4185.9,
            "path_length_avg": 222.97147117541553,
            "smoothness_avg": 0.08666540232631718,
            "success_improvement": 0.0,
            "time_improvement": -2007.37496711104,
            "length_improvement": 25.565705043697417,
            "smoothness_improvement": 2129.9632244222976,
            "objective_score": -586.449533002461
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.855652832984925,
            "num_nodes_avg": 4674.5,
            "path_length_avg": 112.93986490021885,
            "smoothness_avg": 0.10048535844640197,
            "success_improvement": 0.0,
            "time_improvement": -8713.472492091449,
            "length_improvement": 24.99071935171731,
            "smoothness_improvement": 1178.1663423806033,
            "objective_score": -2603.152772045188
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed sampling and adaptive step sizing from the second algorithm, together with incremental space-filling exploration and goal biasing from the first. It integrates node rewiring for path cost optimization and prune-based node rejection to focus search efficiently. The approach adaptively adjusts step size near obstacles and smooths the extracted path using shortcutting to improve path quality and success rate in cluttered environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal respectively, sampling mostly in an informed ellipsoidal domain based on the current best path cost with occasional full-space exploration and goal biasing. Adaptive step sizing is used near obstacles to carefully extend nodes. Upon adding new nodes, local rewiring optimizes path cost. Trees attempt to connect at each iteration, and when successful, a shortcut-based path smoothing refines the final solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate  # Probability to sample whole space instead of informed ellipsoid\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path_positions = []\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                # Uniform random sample across whole bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed sampling within prolate hyperspheroid (ellipsoid)\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n            e1 = a1 / a1_norm\n            # Rotation matrix calculation from standard basis to e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                # Sample unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Near obstacle \u2013 reduce step size up to minimum of 1.0, or 30% base step\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(new_node, tree):\n            # Find nearby nodes to possibly rewire through new_node\n            for near_node in tree:\n                if near_node is new_node or near_node.parent is None:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    if new_cost + 1e-9 < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Remove old parent link and edge\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def connect_nodes(node_from, tree_to):\n            # Try to connect node_from to any node in tree_to\n            closest = min(tree_to, key=lambda n: math.dist(n.position, node_from.position))\n            dist_connect = math.dist(node_from.position, closest.position)\n            if dist_connect <= self.base_step:\n                if (not self._is_edge_in_obstacle(node_from.position, closest.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(closest.position, obstacles, is_3d)):\n                    return closest\n            else:\n                # Try stepping toward closest node, check edge free\n                step = adaptive_step(node_from.position, closest.position)\n                new_pos = steer(node_from.position, closest.position, step)\n                if (not self._is_in_obstacle(new_pos, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(node_from.position, new_pos, obstacles, is_3d)):\n                    return None\n            return None\n\n        def extract_path(meet_node_start, meet_node_goal):\n            # Extract path from start tree root to meet_node_start\n            path_start = meet_node_start.path_from_root()\n            # Extract path from goal tree root to meet_node_goal\n            path_goal = meet_node_goal.path_from_root()\n            # Connect (goal path reversed excluding duplicated meeting node)\n            full_path = path_start + path_goal[-2::-1]\n            return full_path\n\n        def shortcut_path(path, max_trials=100):\n            # Simple shortcut smoothing: try to connect random pairs if collision-free, remove intermediate points\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate growing trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sample with goal biasing and informed sampling\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            # Find nearest node to sample in tree_a\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size based on obstacles near path\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cost cannot lead to improvement\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring nearby nodes\n            rewire(new_node, tree_a)\n\n            # Try to connect to tree_b\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_other.position)\n\n            if dist_between <= self.base_step and not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                # Form connecting node to link trees\n                total_cost = new_node.cost + dist_between + nearest_other.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    success_state = True\n                    # Create connection node in other tree if needed\n                    connect_node = Node(nearest_other.position, new_node, new_node.cost + dist_between)\n                    new_node.add_child(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    # Extract full path\n                    if tree_a is tree_start:\n                        best_path_positions = extract_path(new_node, nearest_other)\n                    else:\n                        best_path_positions = extract_path(nearest_other, new_node)\n\n                    # Smooth the path by shortcutting\n                    best_path_positions = shortcut_path(best_path_positions, max_trials=150)\n\n                    # Early stop on finding a good path with cost near minimum\n                    if c_best <= c_min * 1.05:\n                        break\n\n        # If success, finalize extraction, else empty path\n        extracted_path = best_path_positions if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 760.097,
    "time_improvement": -2402.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1180.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0986209869384767,
            "num_nodes_avg": 1598.5,
            "path_length_avg": 148.1153176016661,
            "smoothness_avg": 0.041239978281850484,
            "success_improvement": 0.0,
            "time_improvement": -3891.2330513686234,
            "length_improvement": 18.81564738512559,
            "smoothness_improvement": 545.4952141571613,
            "objective_score": -1160.8793098627762
        },
        {
            "map_id": 1,
            "success_rate": 0.7,
            "time_avg": 1.803820300102234,
            "num_nodes_avg": 2812.2,
            "path_length_avg": 221.18189424481244,
            "smoothness_avg": 0.07640054707083399,
            "success_improvement": -30.000000000000004,
            "time_improvement": -882.0634549561763,
            "length_improvement": 26.16311733324862,
            "smoothness_improvement": 1865.8411052223212,
            "objective_score": -400.0572074940916
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.395304012298584,
            "num_nodes_avg": 2545.3,
            "path_length_avg": 114.4902045698116,
            "smoothness_avg": 0.0964821067327423,
            "success_improvement": 0.0,
            "time_improvement": -2432.6097135611635,
            "length_improvement": 23.96105756241564,
            "smoothness_improvement": 1127.2452760721567,
            "objective_score": -719.354476175505
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* variant with rewiring to improve path quality and convergence speed. It grows two trees from the start and goal, extends them towards random samples, attempts to connect the trees, and performs rewiring around new nodes to shorten paths and smooth the solution. It includes collision checking for nodes and edges to ensure safety, and stops when a connection is found or maximum iterations are reached.",
    "planning_mechanism": "The planner alternates growing the start and goal trees by sampling free configurations, extending the nearest node towards sampled points up to a step size, checking collisions, and connecting the two trees when possible. After inserting new nodes, it performs local rewiring in their neighborhood to improve the path cost and smoothness. The final path is reconstructed by concatenating the paths from the start tree and goal tree once they are connected.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # Collision flag etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    NEIGHBOR_RADIUS_FACTOR = 20.0  # Multiplier for rewiring radius relative to step_size\n\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        \n        # Check start and goal validities\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        for iteration in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            # Alternate trees each iteration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n\n            connected_node = self._connect(tree_b, new_node.position, obstacles, is_3d, nodes, edges)\n            if connected_node:\n                success_state = True\n                # Extract path from start_root to new_node\n                if iteration % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n                else:\n                    path_from_start = connected_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1]\n\n                # Optional: smooth path here if desired (not implemented)\n                break\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_dist=None) -> Tuple[float, ...]:\n        dist = self._distance(from_pos, to_pos)\n        step = max_dist if max_dist is not None else self.step_size\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extend(self, tree: List[Node], point: Tuple[float, ...], obstacles, is_3d, nodes, edges) -> Node or None:\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point, self.step_size)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n\n        self._rewire(tree, new_node, obstacles, is_3d, nodes, edges)\n\n        return new_node\n\n    def _connect(self, tree: List[Node], target: Tuple[float, ...], obstacles, is_3d, nodes, edges) -> Node or None:\n        \"\"\"\n        Attempts to connect tree nodes toward the target position by iterative steering.\n        Returns last node inserted if connection within step_size to target is successful\n        \"\"\"\n        nearest_node = self._nearest(tree, target)\n        while True:\n            new_pos = self._steer(nearest_node.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            if self._distance(new_pos, target) <= self.step_size:\n                return new_node\n\n            nearest_node = new_node\n\n    def _rewire(self, tree: List[Node], new_node: Node, obstacles, is_3d, nodes, edges):\n        \"\"\"\n        Attempt to rewire nodes in neighborhood around new_node if it can reduce their path cost.\n        Neighborhood radius scales with step_size.\n        \"\"\"\n        radius = self.NEIGHBOR_RADIUS_FACTOR * self.step_size\n        neighbors = [node for node in tree if node != new_node and self._distance(node.position, new_node.position) <= radius]\n\n        for neighbor in neighbors:\n            potential_cost = new_node.cost + self._distance(new_node.position, neighbor.position)\n            if potential_cost < neighbor.cost:\n                # Check collision between new_node and neighbor\n                if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire: change neighbor's parent to new_node\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        if neighbor in old_parent.children:\n                            old_parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    new_node.children.append(neighbor)\n                    neighbor.cost = potential_cost\n                    # Recursively update costs of descendants\n                    self._update_descendants_costs(neighbor)\n\n    def _update_descendants_costs(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._distance(node.position, child.position)\n            if child.cost < old_cost:\n                self._update_descendants_costs(child)\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.29132,
    "time_improvement": 56.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 226.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018826937675476073,
            "num_nodes_avg": 94.1,
            "path_length_avg": 177.0456869858047,
            "smoothness_avg": 0.013921323384339514,
            "success_improvement": 0.0,
            "time_improvement": 31.602712127485244,
            "length_improvement": 2.958453494639981,
            "smoothness_improvement": 117.89894160250063,
            "objective_score": 10.661999045186073
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.03453934192657471,
            "num_nodes_avg": 219.0,
            "path_length_avg": 239.94982137989717,
            "smoothness_avg": 0.017256393246681354,
            "success_improvement": -9.999999999999998,
            "time_improvement": 81.19556284935798,
            "length_improvement": 19.89784305072722,
            "smoothness_improvement": 344.0194275147717,
            "objective_score": -19.941665397473294
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025054192543029784,
            "num_nodes_avg": 193.5,
            "path_length_avg": 137.68408237690392,
            "smoothness_avg": 0.024921386851609478,
            "success_improvement": 0.0,
            "time_improvement": 54.524253610237196,
            "length_improvement": 8.55678829672085,
            "smoothness_improvement": 216.9982012470426,
            "objective_score": 19.153624748650543
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced Informed RRT* planner with tuned parameters aiming to improve efficiency, success rate, and path quality by using a refined informed sampling strategy within the ellipsoidal subset, reduced step size for smoother trajectories, adaptive neighbor radius for rewiring, and strict collision checks. It carefully balances exploration and exploitation for faster convergence to optimal paths.",
    "planning_mechanism": "The planner starts by sampling uniformly until an initial feasible path is found, then focuses sampling within a prolate hyperspheroid defined by start, goal, and best solution cost. Candidate nodes are connected with dynamic neighborhood rewiring based on radius scaled with the number of nodes for asymptotic optimality. Each extension filters out invalid or colliding nodes and edges, gradually yielding shorter, smoother paths with improved success rates within bounded space.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_constant = 50.0  # Tuned for rewiring neighborhood radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        unit_vec_norm = np.linalg.norm(unit_vec)\n        if unit_vec_norm < 1e-10:\n            unit_vec_norm = 1.0\n        a1 = unit_vec / unit_vec_norm\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        def calc_neighbor_radius(n_nodes: int) -> float:\n            \u03b3_rrt = self.neighbor_radius_constant\n            radius = \u03b3_rrt * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)\n            return max(radius, self.step_size)  # radius lower bounded by step_size\n\n        for _ in range(self.max_iter):\n            # Sample\n            if best_cost == float(\"inf\"):\n                # Uniform sampling\n                x_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                r1 = best_cost / 2.0\n                r2 = math.sqrt(best_cost ** 2 - c_min ** 2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm > 1e-10:\n                        x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n                        x_rand_np = np.dot(C, np.dot(L, x_ball)) + x_center\n                        if all(0 <= x_rand_np[d] <= bounds[d] for d in range(dim)):\n                            x_rand = tuple(x_rand_np)\n                            break\n                    else:\n                        # rare case norm~0, retry\n                        continue\n            \n            # Nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            # Steer towards x_rand from x_nearest by step_size, capped at x_rand\n            dist = math.dist(x_nearest.position, x_rand)\n            if dist <= self.step_size:\n                x_new_pos = x_rand\n            else:\n                ratio = self.step_size / dist\n                x_new_pos = tuple(x_nearest.position[d] + (x_rand[d] - x_nearest.position[d]) * ratio for d in range(dim))\n\n            # Check feasibility of new node and edge\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node\n            x_new = Node(x_new_pos)\n            # Find near nodes within radius\n            radius = calc_neighbor_radius(len(tree))\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge cost and collision free\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                if n.cost + math.dist(n.position, x_new_pos) < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = n.cost + math.dist(n.position, x_new_pos)\n\n            # Attach new node to best parent\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            nodes.append(x_new)\n            tree.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes if can improve cost via x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            try:\n                                n.parent.children.remove(n)\n                            except ValueError:\n                                pass\n                        # Re-parent to x_new\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n            # Check if goal can be connected:\n            dist_to_goal = math.dist(x_new.position, goal)\n            if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node = Node(goal)\n                goal_node.cost = x_new.cost + dist_to_goal\n                goal_node.parent = x_new\n                x_new.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    # Shrink informed sampling ellipsoid parameters for convergence\n                    x_center = (np.array(start) + np.array(goal)) / 2.0\n                    # keep C and a1 updated (redundant here but safe)\n                    unit_vec = np.array(goal) - np.array(start)\n                    unit_vec_norm = np.linalg.norm(unit_vec)\n                    if unit_vec_norm < 1e-10:\n                        unit_vec_norm = 1.0\n                    a1 = unit_vec / unit_vec_norm\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1097.87432,
    "time_improvement": -3625.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 570.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.608111524581909,
            "num_nodes_avg": 3138.5,
            "path_length_avg": 160.50524128461177,
            "smoothness_avg": 0.11022324878331846,
            "success_improvement": -9.999999999999998,
            "time_improvement": -5742.185743314526,
            "length_improvement": 12.024533883598524,
            "smoothness_improvement": 1625.2331970746543,
            "objective_score": -1762.124650232265
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.8152109861373902,
            "num_nodes_avg": 3840.5,
            "path_length_avg": 249.32373787276893,
            "smoothness_avg": 0.004259259399231272,
            "success_improvement": 0.0,
            "time_improvement": -888.2649465800221,
            "length_improvement": 16.76855991218058,
            "smoothness_improvement": 9.593812162763655,
            "objective_score": -263.07780293075666
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.3929309844970703,
            "num_nodes_avg": 4476.1,
            "path_length_avg": 118.76701761604329,
            "smoothness_avg": 0.013753052111040085,
            "success_improvement": 0.0,
            "time_improvement": -4243.397712470627,
            "length_improvement": 21.12060197706096,
            "smoothness_improvement": 74.93780770771956,
            "objective_score": -1268.4205043072373
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified and generalized variant of RRT*, designed to incrementally build an optimized path from start to goal by rewiring nodes for lower-cost connections. It balances planning efficiency and path quality by pruning unnecessary complexity while ensuring collision-free connections and smoother paths.",
    "planning_mechanism": "The planner samples random points with goal biasing, extends the nearest node towards these points, selects the best parent from nearby nodes minimizing cumulative cost, rewires neighbors for better paths, and terminates early when a safe connection to the goal is found. Collision checks ensure robustness and valid path construction.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            # Sample point with goal biasing\n            sample = goal_position if random.random() < self.goal_sample_rate else \\\n                tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            unit_dir = tuple(d / dist for d in direction)\n            new_pos = tuple(nearest_node.position[d] + unit_dir[d] * min(self.step_size, dist) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within radius\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + math.dist(near.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if path improves\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_via_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    edges.remove((near.parent, near))\n                    near.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, near))\n\n            # Early goal check and connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.14339,
    "time_improvement": -54.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 218.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.045577192306518556,
            "num_nodes_avg": 290.1,
            "path_length_avg": 164.59504545029057,
            "smoothness_avg": 0.016911817058357547,
            "success_improvement": 0.0,
            "time_improvement": -65.57957519934726,
            "length_improvement": 9.782847413295771,
            "smoothness_improvement": 164.70666156183543,
            "objective_score": -16.893769769335844
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.26395955085754397,
            "num_nodes_avg": 1168.7,
            "path_length_avg": 224.79959830235856,
            "smoothness_avg": 0.01350253593251018,
            "success_improvement": 0.0,
            "time_improvement": -43.70889853559595,
            "length_improvement": 24.955423589002063,
            "smoothness_improvement": 247.42997502701215,
            "objective_score": -6.884434967743309
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08391327857971191,
            "num_nodes_avg": 610.6,
            "path_length_avg": 114.16670644476169,
            "smoothness_avg": 0.02682451808496583,
            "success_improvement": 0.0,
            "time_improvement": -52.3105950778738,
            "length_improvement": 24.17590961374845,
            "smoothness_improvement": 241.2058900608001,
            "objective_score": -9.651967150308447
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an improved bidirectional RRT* algorithm enhanced with informed ellipsoidal sampling, KD-tree accelerated nearest and radius neighbor queries, adaptive neighbor radius shrinking over iterations, collision caching, incremental rewiring, and aggressive shortcut smoothing. It also applies periodic pruning of nodes unlikely to improve the current best path, which collectively reduce planning time and improve path quality, smoothness, and robustness in 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal positions using informed sampling within an ellipsoidal domain shaped by the best known path cost. It uses KD-trees for efficient nearest and neighbor searches and caches collision checks to avoid redundant computations. After every successful tree connection, the path is shortcut-smoothed, and periodic pruning removes nodes with high heuristic cost to focus the search, thus ensuring faster convergence to shorter, smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            if not tree_a:\n                continue\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            if not tree_b:\n                continue\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.27587,
    "time_improvement": 64.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1367.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010661506652832031,
            "num_nodes_avg": 80.9,
            "path_length_avg": 161.0187212781415,
            "smoothness_avg": 0.04431205004005636,
            "success_improvement": 0.0,
            "time_improvement": 61.26729942712025,
            "length_improvement": 11.743087362533695,
            "smoothness_improvement": 593.5798082836809,
            "objective_score": 23.69670634206122
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026872420310974122,
            "num_nodes_avg": 223.3,
            "path_length_avg": 232.78352009360714,
            "smoothness_avg": 0.08960672573671893,
            "success_improvement": 0.0,
            "time_improvement": 85.36970565630398,
            "length_improvement": 22.29016069063638,
            "smoothness_improvement": 2205.6455943215547,
            "objective_score": 41.09717180662624
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03078179359436035,
            "num_nodes_avg": 190.9,
            "path_length_avg": 125.80694558525701,
            "smoothness_avg": 0.11016254534323518,
            "success_improvement": 0.0,
            "time_improvement": 44.128112030950454,
            "length_improvement": 16.445017025255126,
            "smoothness_improvement": 1301.2594454126868,
            "objective_score": 23.033734241399596
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT*-like tree growth with informed ellipsoidal sampling and adaptive step sizing near obstacles, enhanced node pruning and rewiring for path cost optimization, and integrated path smoothing through shortcutting. It applies goal biasing and intermittent full-space exploration to improve robustness. The planner dynamically prunes nodes unlikely to improve the current best path, ensures collision-free node and edge additions, and alternates tree expansion to connect start and goal efficiently, producing high-quality, smooth paths with reduced search time and improved success rates in cluttered 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal using informed and biased sampling with occasional global exploration. Adaptive step sizes near obstacles prevent collision while extending nodes. Each new node triggers local rewiring within a radius to optimize path costs and pruning of nodes and branches that cannot yield better solutions. Connection attempts between trees update the best path, which is then smoothed using shortcutting. Early termination occurs if near-optimal solutions are found, increasing efficiency and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, rewire_radius: float=15.0,\n                 goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        # Initialize trees at start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path = []\n\n        # Precompute identity for rotation matrix\n        id_mat = np.eye(dim)\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n            e1 = a1 / a1_norm\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            det_term = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det_term]) @ Vt\n\n            r1 = c_best / 2\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.0\n\n            L = np.diag([r1] + [r2] * (dim -1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def goal_biased_sample(current_tree):\n            # With probability goal_sample_rate, sample goal to bias growth\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if current_tree is tree_start else start_pos\n            return informed_sample()\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            steps = max(2, int(dist))\n            for i in range(1, steps +1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def rewire(new_node, tree):\n            for near_node in tree:\n                if near_node is new_node:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    # Small epsilon to avoid floating point issues\n                    if new_cost + 1e-9 < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def prune_tree(tree):\n            # Remove invalid or unpromising nodes (with cost > c_best)\n            to_remove = []\n            for node in tree:\n                est_total = node.cost + math.dist(node.position, goal_pos)\n                if est_total >= c_best:\n                    # Mark node and children invalid for pruning\n                    self._invalidate_subtree(node, edges)\n                    to_remove.append(node)\n            for node in to_remove:\n                if node in tree:\n                    tree.remove(node)\n\n        def connect_trees(new_node, other_tree):\n            # Find nearest node in other tree to try connect\n            nearest_other = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between <= self.base_step:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d)\n                    and not self._is_in_obstacle(nearest_other.position, obstacles, is_3d)):\n                    total_cost = new_node.cost + dist_between + nearest_other.cost\n                    return nearest_other, total_cost\n            return None, float(\"inf\")\n\n        def extract_full_path(meet_start_node, meet_goal_node):\n            path_start = meet_start_node.path_from_root()\n            path_goal = meet_goal_node.path_from_root()\n            full = path_start + path_goal[-2::-1]\n            return full\n\n        def shortcut_path(path, trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num %2 == 0 else (tree_goal, tree_start)\n\n            sample = goal_biased_sample(tree_a)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check new node and edge collision and bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total = new_cost + math.dist(new_pos, goal_pos)\n\n            if est_total >= c_best:\n                continue  # Prune branch unlikely to improve solution\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire surrounding nodes to optimize cost\n            rewire(new_node, tree_a)\n\n            # Prune nodes that cannot improve solution\n            prune_tree(tree_a)\n            prune_tree(tree_b)\n\n            # Try to connect trees\n            nearest_other, total_cost = connect_trees(new_node, tree_b)\n            if nearest_other and total_cost < c_best:\n                c_best = total_cost\n                success_state = True\n\n                # Link trees bidirectionally with connection node (ghost)\n                connection_node = Node(nearest_other.position, new_node,\n                                       new_node.cost + math.dist(new_node.position, nearest_other.position))\n                new_node.add_child(connection_node)\n                nodes.append(connection_node)\n                edges.append((new_node, connection_node))\n\n                # Extract and smooth path\n                if tree_a is tree_start:\n                    best_path = extract_full_path(new_node, nearest_other)\n                else:\n                    best_path = extract_full_path(nearest_other, new_node)\n\n                best_path = shortcut_path(best_path, trials=150)\n\n                # Early exit if near optimal\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _invalidate_subtree(self, node, edges):\n        # Mark node and descendants invalid and remove edges\n        node.valid = False\n        for child in list(node.children):\n            self._invalidate_subtree(child, edges)\n            if (node, child) in edges:\n                edges.remove((node, child))\n            node.remove_child(child)\n        # Also remove node from parent's children if possible\n        if node.parent:\n            node.parent.remove_child(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 829.36714,
    "time_improvement": -2688.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1180.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 1.1848379135131837,
            "num_nodes_avg": 1658.7,
            "path_length_avg": 148.72207728684697,
            "smoothness_avg": 0.03924745158642927,
            "success_improvement": -19.999999999999996,
            "time_improvement": -4204.45467285915,
            "length_improvement": 18.483072786955475,
            "smoothness_improvement": 514.3078445328466,
            "objective_score": -1355.0682480776898
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.12278950214386,
            "num_nodes_avg": 2777.2,
            "path_length_avg": 222.60788497651976,
            "smoothness_avg": 0.07957845577560209,
            "success_improvement": 0.0,
            "time_improvement": -1055.72154970312,
            "length_improvement": 25.687080582137302,
            "smoothness_improvement": 1947.610985151124,
            "objective_score": -301.8409938687529
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.6003721475601196,
            "num_nodes_avg": 2519.0,
            "path_length_avg": 113.90158083598541,
            "smoothness_avg": 0.09254465830039778,
            "success_improvement": 0.0,
            "time_improvement": -2804.827915994097,
            "length_improvement": 24.35199341917283,
            "smoothness_improvement": 1077.1612226449458,
            "objective_score": -831.1921700011699
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a finely tuned Informed RRT* planner with adaptive sampling within a shrinking ellipsoidal subset, enhanced rewiring strategy that dynamically adjusts neighborhood radius for optimal connectivity, and reduced step size for smoother, high-quality trajectories. It incorporates strict collision checking and efficient node reparenting to improve path quality, convergence speed, and success rates in complex environments.",
    "planning_mechanism": "The planner begins with uniform sampling until an initial path to the goal is found. Subsequently, it restricts sampling inside a prolate hyperspheroid defined by the start, goal, and the cost of the current best path to focus exploration on promising regions. For each iteration, it selects the nearest node, extends toward the sampled point by a limited step size, and performs feasibility checks. Near nodes are identified based on an adaptive radius for rewiring to improve path cost. Nodes are connected and rewired only if collision-free, with the goal node attached as soon as it is reachable within a step. The informed set updates as better paths are found, shrinking the sampling region and converging toward an optimal path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_constant = 45.0  # Tuned constant for neighborhood radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False # Path navigation success or not\n        extracted_path: List[Tuple[float, ...]] = [] # Final path from start to goal\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n        unit_vec = np.array(goal_position) - np.array(start_position)\n        unit_vec_norm = np.linalg.norm(unit_vec)\n        if unit_vec_norm < 1e-10:\n            unit_vec_norm = 1.0\n        a1 = unit_vec / unit_vec_norm\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        def calc_neighbor_radius(n_nodes: int) -> float:\n            \u03b3_rrt = self.neighbor_radius_constant\n            radius = \u03b3_rrt * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)\n            return max(radius, self.step_size*1.2)  # radius lower bounded slightly above step size\n\n        for _ in range(self.max_iter):\n            # Sampling: Uniform until path found, then informed sampling inside ellipsoid\n            if best_cost == float(\"inf\"):\n                # Uniform sampling in bounds\n                x_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                r1 = best_cost / 2.0\n                r2 = math.sqrt(best_cost**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim -1))\n                # Sample inside unit ball with uniform distribution\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm > 1e-10:\n                        unit_ball_sample = x_ball / norm * (random.random() ** (1.0 / dim))\n                        x_rand_np = np.dot(C, np.dot(L, unit_ball_sample)) + x_center\n                        # Clamp within bounds\n                        if all(0 <= x_rand_np[d] <= bounds[d] for d in range(dim)):\n                            x_rand = tuple(x_rand_np)\n                            break\n\n            # Find nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n\n            # Steer towards x_rand with max step size\n            dist = math.dist(x_nearest.position, x_rand)\n            if dist <= self.step_size:\n                x_new_pos = x_rand\n            else:\n                ratio = self.step_size / dist\n                x_new_pos = tuple(x_nearest.position[d] + (x_rand[d] - x_nearest.position[d]) * ratio for d in range(dim))\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d, resolution=0.25):\n                continue\n\n            # Create new node\n            x_new = Node(x_new_pos)\n            # Compute neighbors for rewiring\n            radius = calc_neighbor_radius(len(tree))\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge cost and collision free\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                edge_dist = math.dist(n.position, x_new_pos)\n                candidate_cost = n.cost + edge_dist\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d, resolution=0.25):\n                        min_cost = candidate_cost\n                        best_parent = n\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            nodes.append(x_new)\n            tree.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes to improve cost through x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-7 < n.cost:  # Add small tolerance for numerical stability\n                    if not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d, resolution=0.25):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n            # Check if goal can be connected with edge from x_new node\n            dist_to_goal = math.dist(x_new.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(x_new.position, goal_position, obstacles, is_3d, resolution=0.25):\n                    goal_node = Node(goal_position)\n                    goal_node.cost = x_new.cost + dist_to_goal\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    tree.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n                        # Update ellipsoid center and matrix for next informed sampling\n                        x_center = (np.array(start_position) + np.array(goal_position)) / 2.0\n                        unit_vec = np.array(goal_position) - np.array(start_position)\n                        unit_vec_norm = np.linalg.norm(unit_vec)\n                        if unit_vec_norm < 1e-10:\n                            unit_vec_norm = 1.0\n                        a1 = unit_vec / unit_vec_norm\n                        M = np.outer(a1, I[:, 0])\n                        U, _, Vt = np.linalg.svd(M)\n                        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1153.5349,
    "time_improvement": -3808.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 554.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.6804368495941162,
            "num_nodes_avg": 3101.1,
            "path_length_avg": 164.05503695188074,
            "smoothness_avg": 0.10874258734192348,
            "success_improvement": -9.999999999999998,
            "time_improvement": -6004.939896995976,
            "length_improvement": 10.078834628256445,
            "smoothness_improvement": 1602.05763020904,
            "objective_score": -1841.4559140220963
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.7701423168182373,
            "num_nodes_avg": 3742.7,
            "path_length_avg": 264.0912188011822,
            "smoothness_avg": 0.003834546257751223,
            "success_improvement": 0.0,
            "time_improvement": -863.7279718606799,
            "length_improvement": 11.838749719905707,
            "smoothness_improvement": -1.3343628760288935,
            "objective_score": -256.7573134286029
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.5645769834518433,
            "num_nodes_avg": 4500.9,
            "path_length_avg": 122.01995217860642,
            "smoothness_avg": 0.012609523288596741,
            "success_improvement": 0.0,
            "time_improvement": -4554.951553364866,
            "length_improvement": 18.96015772870483,
            "smoothness_improvement": 60.39220549275783,
            "objective_score": -1362.3914734362554
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a bidirectional RRT* with informed sampling to accelerate convergence and improve path quality. It adapts the step size near obstacles, performs local rewiring to optimize paths, prunes non-promising nodes based on cost estimates, and applies shortcut smoothing on the final path to enhance smoothness and reduce length. The approach balances exploration and exploitation using goal biasing and occasional full-space sampling to improve robustness and success rate.",
    "planning_mechanism": "The planner grows two search trees simultaneously from start and goal, sampling mainly in an ellipsoidal informed subset defined by the best-found path cost to focus search. Nodes are extended with adaptive steps to avoid collisions near obstacles. Upon adding a node, local rewiring tries to optimize path costs of nearby nodes. The two trees attempt connection each iteration, and successful connection yields a candidate path. This path is then shortcut-smoothed for improved quality before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]: Position in space\n        self.parent = parent             # Parent node reference or None\n        self.cost = cost                 # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0, goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def sample():\n            # Informed ellipsoidal sampling if a solution exists, else uniform\n            if c_best == float('inf') or random.random() < self.full_sample_rate:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n            e1 = a1 / norm_a1\n            # Rotation matrix from first standard basis vector to e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val)/2 if val > 0 else 0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                point = C @ L @ (x_ball * radius) + center\n                if in_bounds(point):\n                    return tuple(point)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            steps = max(int(dist), 2)\n            for i in range(1, steps+1):\n                interm = tuple(from_p[d] + (to_p[d]-from_p[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interm, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, point):\n            r = self.rewire_radius\n            return [n for n in tree if math.dist(n.position, point) <= r]\n\n        def rewire(new_node, tree):\n            neighbors = near_nodes(tree, new_node.position)\n            for near in neighbors:\n                if near is new_node or near.parent is None:\n                    continue\n                d = math.dist(new_node.position, near.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(n_from, tree_to):\n            nearest_to = nearest(tree_to, n_from.position)\n            dist_c = math.dist(n_from.position, nearest_to.position)\n            if dist_c <= self.step_size:\n                if (not self._is_edge_in_obstacle(n_from.position, nearest_to.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(nearest_to.position, obstacles, is_3d)):\n                    return nearest_to\n            else:\n                step = adaptive_step(n_from.position, nearest_to.position)\n                new_pos = steer(n_from.position, nearest_to.position, step)\n                if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(n_from.position, new_pos, obstacles, is_3d)):\n                    return None\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal if tree_a is tree_start else start\n            else:\n                sample_point = sample()\n\n            nearest_node = nearest(tree_a, sample_point)\n            step_sz = adaptive_step(nearest_node.position, sample_point)\n            new_pos = steer(nearest_node.position, sample_point, step_sz)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, tree_a)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success = True\n                        connect_node = Node(nearest_other.position, new_node, new_node.cost + dist_connect)\n                        new_node.add_child(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n                        best_path = extract_path(new_node, nearest_other) if tree_a is tree_start else extract_path(nearest_other, new_node)\n                        best_path = shortcut(best_path)\n                        if c_best <= c_min * 1.05:\n                            break\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 840.38513,
    "time_improvement": -2671.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1288.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.3037487030029298,
            "num_nodes_avg": 1630.6,
            "path_length_avg": 149.98501157576,
            "smoothness_avg": 0.044665988683405926,
            "success_improvement": 0.0,
            "time_improvement": -4636.4514022301955,
            "length_improvement": 17.79083849072777,
            "smoothness_improvement": 599.1197166421674,
            "objective_score": -1384.3816543877022
        },
        {
            "map_id": 1,
            "success_rate": 0.7,
            "time_avg": 1.806183671951294,
            "num_nodes_avg": 2785.0,
            "path_length_avg": 221.76517271062556,
            "smoothness_avg": 0.07814939769268921,
            "success_improvement": -30.000000000000004,
            "time_improvement": -883.350158029261,
            "length_improvement": 25.968402192620438,
            "smoothness_improvement": 1910.8402913688433,
            "objective_score": -400.25716551341
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.429310917854309,
            "num_nodes_avg": 2564.9,
            "path_length_avg": 112.80878058843521,
            "smoothness_avg": 0.11428536493227788,
            "success_improvement": 0.0,
            "time_improvement": -2494.335486997953,
            "length_improvement": 25.07777931003985,
            "smoothness_improvement": 1353.701406270423,
            "objective_score": -736.5165832060258
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines a bidirectional informed RRT* framework with adaptive ellipsoidal sampling, efficient KD-tree neighbor searches, collision caching, incremental rewiring, pruning of unpromising nodes, and shortcut smoothing to minimize path length and planning time. It balances exploration and exploitation by dynamically focusing sampling within the ellipsoid shaped by the current best path cost, while maintaining robustness via rigorous collision and edge checks. Pruning and smoothing enhance path quality and convergence speed, yielding efficient, high-quality, and smooth paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling points mainly inside an informed ellipsoid around the current best path estimate. It uses KD-trees for fast nearest neighbor and radius searches to enable incremental rewiring that improves path costs locally. Collision checks are cached to avoid redundant computations. Periodically, the planner prunes nodes unlikely to improve the solution based on cost heuristics. When a connection is found, the path is shortcut-smoothed for better smoothness and reduced length. This approach yields faster convergence and higher quality paths compared to vanilla RRT* variants.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # constrain to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # With probability, do goal biasing for quicker connections\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    if random.random() < 0.7:\n                        return goal\n                    else:\n                        return start\n                # uniform random sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            v = a1_np - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sample\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect trees\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Pruning step for efficiency and path quality\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -28.79976,
    "time_improvement": 61.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1406.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009893178939819336,
            "num_nodes_avg": 63.4,
            "path_length_avg": 159.7354750869346,
            "smoothness_avg": 0.03651389690767392,
            "success_improvement": 0.0,
            "time_improvement": 64.0585941492467,
            "length_improvement": 12.446454934271351,
            "smoothness_improvement": 471.52177780133144,
            "objective_score": 24.064478120634938
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025244426727294923,
            "num_nodes_avg": 230.0,
            "path_length_avg": 239.94958884682438,
            "smoothness_avg": 0.09079376374616836,
            "success_improvement": 0.0,
            "time_improvement": 86.256042839306,
            "length_improvement": 19.897920676960013,
            "smoothness_improvement": 2236.188937293608,
            "objective_score": 41.037341673651845
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.036377668380737305,
            "num_nodes_avg": 239.5,
            "path_length_avg": 123.78204617891163,
            "smoothness_avg": 0.12654443792717238,
            "success_improvement": 0.0,
            "time_improvement": 33.971066172174886,
            "length_improvement": 17.789858795601603,
            "smoothness_improvement": 1509.6359098948385,
            "objective_score": 21.297471160246978
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an enhanced RRT* (Rapidly-exploring Random Tree Star) planner leveraging incremental rewiring to optimize path cost and improve path smoothness. It samples free states with dynamic goal biasing, extends nearest nodes toward samples with fixed step size, and rewires the tree locally to shorten the path and enhance robustness. The use of a KD-tree for nearest neighbor queries accelerates the search.",
    "planning_mechanism": "The planner incrementally builds a cost-optimized space-filling tree rooted at the start, adding new nodes by steering towards randomly sampled points and rewiring nearby nodes to reduce the overall path cost. Goal biasing increases chances of reaching the goal quickly. Collision checking for nodes and edges ensure validity. Upon success, path backtracking extracts a smooth, low-cost path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n    \n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # KD-tree like data structure for nearest neighbor queries (simple linear here for clarity)\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = distance(from_pos, to_pos)\n            if length == 0:\n                return from_pos\n            scale = min(self.step_size, length) / length\n            new_pos = tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n            return new_pos\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def near_nodes(new_node):\n            # Return nodes within rewire_radius distance for possible rewiring\n            r = self.rewire_radius\n            return [node for node in nodes if distance(node.position, new_node.position) <= r]\n\n        for iter_idx in range(self.max_iter):\n            # Sample with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            # Find nearest node to sample\n            nearest_node = min(nodes, key=lambda node: distance(node.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            # Bounds check and collision check for node and edge\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n\n            # Choose the best parent in neighborhood (including nearest_node) minimizing cost\n            neighbors = near_nodes(new_node)\n            best_parent = nearest_node\n            best_cost = new_cost\n\n            for node in neighbors:\n                if node == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                    continue\n                cost_through_node = node.cost + distance(node.position, new_node.position)\n                if cost_through_node < best_cost:\n                    best_parent = node\n                    best_cost = cost_through_node\n\n            # Re-assign parent to best parent\n            new_node.parent = best_parent\n            new_node.cost = best_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if this improves their cost\n            for node in neighbors:\n                if node == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    # Rewire: change parent\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        edges.remove((node.parent, node))\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            # Check if goal reached and connect if feasible\n            dist_to_goal = distance(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        # In case no success but best node close to goal - optional improvement (not mandatory):\n        # Could implement post-processing shortcutting/smoothing here if desired\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 161.88658,
    "time_improvement": -557.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 295.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.16529037952423095,
            "num_nodes_avg": 242.7,
            "path_length_avg": 162.80924323252162,
            "smoothness_avg": 0.021238880671299247,
            "success_improvement": 0.0,
            "time_improvement": -500.4913738893633,
            "length_improvement": 10.761673906701933,
            "smoothness_improvement": 232.4346034734026,
            "objective_score": -146.83290436810157
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0429917097091674,
            "num_nodes_avg": 1033.7,
            "path_length_avg": 225.11253302111746,
            "smoothness_avg": 0.017148522774445105,
            "success_improvement": 0.0,
            "time_improvement": -467.8415094173082,
            "length_improvement": 24.850956972553888,
            "smoothness_improvement": 341.24384256817234,
            "objective_score": -133.6760422178408
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.44299213886260985,
            "num_nodes_avg": 550.7,
            "path_length_avg": 116.54548454856338,
            "smoothness_avg": 0.032262676924320506,
            "success_improvement": 0.0,
            "time_improvement": -704.0729360954479,
            "length_improvement": 22.596038462444234,
            "smoothness_improvement": 310.3788690942605,
            "objective_score": -205.1507787906742
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional search with anytime RRT*-style adaptive sampling, vertex rewiring, and informed ellipsoidal sampling. It uses adaptive step sizing near obstacles, goal biasing, and dynamic rewire radius to balance exploration and exploitation efficiently. The planner maintains two trees grown from start and goal, periodically attempting to connect them. Upon finding feasible connections, it incrementally improves path quality using local rewiring and performs shortcut-based path smoothing to enhance path smoothness and reduce length. This approach aims to improve success rate, planning efficiency, and path optimality, especially in cluttered 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal nodes using informed ellipsoidal sampling biased by the current best solution cost and occasional uniform/global sampling. Each iteration samples a point for tree expansion with goal biasing; adaptive step sizing is employed to avoid obstacles. Upon adding new nodes, local rewiring optimizes path cost within a dynamic radius. The planner attempts to connect the two trees whenever possible to form a full path. When a path is found, shortcut-based smoothing refines the final path. The anytime framework allows ongoing improvement of the solution within the iteration budget.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        self.cost = new_cost\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n        self.gamma_rrt_star = 50.0  # tuning parameter for rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Init trees rooted at start and goal\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path_positions = []\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                # Uniform random sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample from prolate hyperspheroid (ellipsoid) defined by current best path cost c_best\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm < 1e-9:\n                return tuple(center)\n\n            e1 = a1 / a1_norm\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-9:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step_size(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            step_size = self.base_step\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step_size = max(self.base_step * 0.3, 1.0)\n                    break\n            return step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def rewire(new_node, tree):\n            r = self.rewire_radius(len(tree), dim)\n            near_ = near_nodes(tree, new_node.position, r)\n            for near_n in near_:\n                if near_n is new_node or near_n.parent is None:\n                    continue\n                dist = math.dist(new_node.position, near_n.position)\n                new_cost = new_node.cost + dist\n                if new_cost + 1e-9 < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        # Rewire: remove old parent edge\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            if (near_n.parent, near_n) in edges:\n                                edges.remove((near_n.parent, near_n))\n                        near_n.parent = new_node\n                        near_n.cost = new_cost\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n                        self._update_children_costs(near_n, obstacles, is_3d)\n\n        def try_connect_trees(node_from, tree_to):\n            # Find closest node in tree_to to node_from\n            closest = nearest_node(tree_to, node_from.position)\n            dist_connect = math.dist(node_from.position, closest.position)\n            if dist_connect <= self.base_step:\n                if not self._is_edge_in_obstacle(node_from.position, closest.position, obstacles, is_3d) and not self._is_in_obstacle(closest.position, obstacles, is_3d):\n                    return closest\n            else:\n                step = adaptive_step_size(node_from.position, closest.position)\n                new_pos = steer(node_from.position, closest.position, step)\n                if not self._is_edge_in_obstacle(node_from.position, new_pos, obstacles, is_3d) and not self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    # Potential connection requires adding a node in tree_to if possible. Delay this decision to add upon confirmed connection\n                    return None\n            return None\n\n        def extract_path(meet_start_node, meet_goal_node):\n            path_start = meet_start_node.path_from_root()\n            path_goal = meet_goal_node.path_from_root()\n            # Connect both tree paths without duplicating meeting node\n            return path_start + path_goal[-2::-1]\n\n        def shortcut_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Adaptive rewiring radius based on number of nodes & dimension\n        def rewire_radius(n_nodes, dim):\n            if n_nodes < 1:\n                return self.base_step * 10\n            return min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 10)\n        self.rewire_radius = rewire_radius\n\n        # Main loop\n        for itr in range(self.max_iter):\n            # Alternate tree expansion each iteration\n            if itr % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Sample point with goal bias\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_position if tree_from is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            nearest_n = nearest_node(tree_from, sample)\n            step = adaptive_step_size(nearest_n.position, sample)\n            new_pos = steer(nearest_n.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_n.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_n.cost + math.dist(nearest_n.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n\n            if est_total_cost >= c_best:\n                # Prune unpromising node\n                continue\n\n            new_node = Node(new_pos, parent=nearest_n, cost=new_cost)\n            nearest_n.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_n, new_node))\n\n            # Rewire nearby nodes for path cost improvement\n            rewire(new_node, tree_from)\n\n            # Attempt to connect trees\n            other_closest = nearest_node(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, other_closest.position)\n\n            if dist_to_other <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_closest.position, obstacles, is_3d):\n                total_cost = new_node.cost + dist_to_other + other_closest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    success_state = True\n\n                    # Connect the two trees by linking nodes\n                    connect_node = Node(other_closest.position, parent=new_node, cost=new_node.cost + dist_to_other)\n                    new_node.add_child(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    # Add connect_node to tree_to for integrity (optional, but keeps structure consistent)\n                    tree_to.append(connect_node)\n\n                    if tree_from is tree_start:\n                        best_path_positions = extract_path(new_node, other_closest)\n                    else:\n                        best_path_positions = extract_path(other_closest, new_node)\n\n                    best_path_positions = shortcut_path(best_path_positions)\n\n                    # Early stop if near-optimal path found\n                    if c_best <= c_min * 1.05:\n                        break\n\n        if success_state:\n            extracted_path = best_path_positions\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_children_costs(self, node, obstacles, is_3d):\n        import math\n        for child in node.children:\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost + 1e-9 < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child, obstacles, is_3d)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 517.49543,
    "time_improvement": -1760.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1238.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.8501445293426514,
            "num_nodes_avg": 1557.5,
            "path_length_avg": 149.7234851541669,
            "smoothness_avg": 0.03589153109696432,
            "success_improvement": 0.0,
            "time_improvement": -2988.530971366406,
            "length_improvement": 17.9341852665543,
            "smoothness_improvement": 461.780401374737,
            "objective_score": -890.6635523497372
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.242191767692566,
            "num_nodes_avg": 2765.9,
            "path_length_avg": 227.80495635612374,
            "smoothness_avg": 0.08702665095423409,
            "success_improvement": 0.0,
            "time_improvement": -576.2930537089206,
            "length_improvement": 23.95214856622004,
            "smoothness_improvement": 2139.258411815469,
            "objective_score": -157.40119434035483
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9999196529388428,
            "num_nodes_avg": 2430.7,
            "path_length_avg": 116.68277122498462,
            "smoothness_avg": 0.09532011613920106,
            "success_improvement": 0.0,
            "time_improvement": -1714.9494328779338,
            "length_improvement": 22.50485918885427,
            "smoothness_improvement": 1112.464841491536,
            "objective_score": -504.4215338181516
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines bidirectional informed RRT* with dynamic step sizing, adaptive rewiring, and heuristic-guided sampling to enhance efficiency, path quality, and success rate. It grows two trees from start and goal within ellipsoidal subsets focusing the search. Local rewiring optimizes paths continuously, while shortcut smoothing refines the final path for smoothness and length reduction. Robust collision checks and adaptive operations ensure efficient, robust, and high-quality planning.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal. Samples are drawn mainly from an informed ellipsoidal subset based on the best path cost. Nodes are extended with adaptive step sizes, rewired locally if better costs are found, and pruned if costs exceed current best. After successful tree connection, the path is shortcut-smoothed. Goal biasing and full-space sampling enhance robustness and convergence speed.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0,\n                 goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def sample_point():\n            if c_best == float('inf') or random.random() < self.full_sample_rate:\n                # Uniform sampling in full space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed ellipsoidal sampling\n            center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n            e1 = a1 / norm_a1\n            # Rotation matrix from first standard basis vector to e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2\n            val = max(c_best**2 - c_min**2, 0)\n            r2 = math.sqrt(val)/2 if val > 0 else 0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                point = C @ L @ (x_ball * radius) + center\n                point = tuple(point)\n                if in_bounds(point):\n                    return point\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p, max_step):\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * max_step / dist for d in range(dim))\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            steps_check = max(int(dist), 2)\n            # Reducing step size near obstacles to improve safety\n            for i in range(1, steps_check+1):\n                interm = tuple(from_p[d] + (to_p[d]-from_p[d])*(i/steps_check) for d in range(dim))\n                if self._is_in_obstacle(interm, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, point):\n            r = self.rewire_radius\n            return [n for n in tree if math.dist(n.position, point) <= r]\n\n        def rewire(new_node, tree):\n            neighbors = near_nodes(tree, new_node.position)\n            for near in neighbors:\n                if near is new_node or near.parent is None:\n                    continue\n                dist_to_near = math.dist(new_node.position, near.position)\n                new_cost = new_node.cost + dist_to_near\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Change parent\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def connect_trees(node_from, tree_to):\n            nearest_to = nearest_node(tree_to, node_from.position)\n            dist_connect = math.dist(node_from.position, nearest_to.position)\n            if dist_connect <= self.step_size:\n                if (not self._is_edge_in_obstacle(node_from.position, nearest_to.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(nearest_to.position, obstacles, is_3d)):\n                    return nearest_to\n            else:\n                step = adaptive_step(node_from.position, nearest_to.position)\n                new_pos = steer(node_from.position, nearest_to.position, step)\n                if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(node_from.position, new_pos, obstacles, is_3d)):\n                    # Can't complete connection this iteration\n                    return None\n            return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Alternate tree to expand\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = sample_point()\n\n            nearest_n = nearest_node(tree_a, sample)\n            step_sz = adaptive_step(nearest_n.position, sample)\n            new_pos = steer(nearest_n.position, sample, step_sz)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_n.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_n.cost + math.dist(nearest_n.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_n, new_cost)\n            nearest_n.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_n, new_node))\n\n            rewire(new_node, tree_a)\n\n            nearest_other = nearest_node(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success = True\n                        connect_node = Node(nearest_other.position, new_node, new_node.cost + dist_connect)\n                        new_node.add_child(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n                        if tree_a is tree_start:\n                            best_path = extract_path(new_node, nearest_other)\n                        else:\n                            best_path = extract_path(nearest_other, new_node)\n                        best_path = shortcut_path(best_path)\n\n                        # Early termination if near-optimal\n                        if c_best <= c_min * 1.05:\n                            break\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 823.57929,
    "time_improvement": -2672.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1341.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.281927752494812,
            "num_nodes_avg": 1626.2,
            "path_length_avg": 148.56376321471743,
            "smoothness_avg": 0.04135583538543686,
            "success_improvement": 0.0,
            "time_improvement": -4557.177021059871,
            "length_improvement": 18.56984723853668,
            "smoothness_improvement": 547.3086294160153,
            "objective_score": -1360.7025937231738
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 1.8719164848327636,
            "num_nodes_avg": 2781.1,
            "path_length_avg": 222.1539114175924,
            "smoothness_avg": 0.08882629098417609,
            "success_improvement": -9.999999999999998,
            "time_improvement": -919.1374220481356,
            "length_improvement": 25.83863002301163,
            "smoothness_improvement": 2185.564446014196,
            "objective_score": -309.64567837976733
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.454066014289856,
            "num_nodes_avg": 2565.9,
            "path_length_avg": 113.36552604047571,
            "smoothness_avg": 0.10926646069609833,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2539.2683454576145,
            "length_improvement": 24.708015490164055,
            "smoothness_improvement": 1289.8613148431946,
            "objective_score": -800.3895939650356
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced Rapidly-exploring Random Tree (RRT) planner with adaptive step size and goal biasing to improve exploration efficiency, path quality, and success rate. It incorporates dynamic sampling strategies, informed steering towards the goal, and stricter boundary checks. It also employs path smoothing post-processing to reduce path length and increase smoothness.",
    "planning_mechanism": "The planner grows a tree rooted at the start by sampling points biased towards the goal with increasing probability, steering from the nearest node with an adaptive step size constrained within boundaries and obstacle-free areas. Upon reaching near the goal, the tree attempts direct connections. Once a path is found, a smoothing step refines the path by shortcutting collision-free segments, yielding a shorter and smoother trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from start to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, goal_sample_rate: float = 0.1, adaptive_step: bool = True):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.adaptive_step = adaptive_step\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        success_state = False\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for it in range(1, self.max_iter + 1):\n            # Increase goal bias probability as iterations progress\n            goal_bias = min(0.1 + 0.9 * (it / self.max_iter), 0.9)\n            if random.random() < goal_bias:\n                sample = goal_position\n            else:\n                # Sample within bounds\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            distance = math.dist(nearest_node.position, sample)\n            if distance == 0:\n                continue\n            unit_direction = tuple(d / distance for d in direction)\n\n            # Adaptive step size: reduce step size when close to goal or obstacles to improve precision\n            step = self.step_size\n            if self.adaptive_step:\n                dist_to_goal = math.dist(nearest_node.position, goal_position)\n                step = min(self.step_size, max(0.5, dist_to_goal / 2.0))\n                \n            # Compute new position with step size, also ensure not to go beyond bounds\n            new_position = tuple(\n                max(0.0, min(bounds[d], nearest_node.position[d] + unit_direction[d] * step))\n                for d in range(len(bounds))\n            )\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Attempt connection to goal if close enough\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.5) and \n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state:\n            # Backtrack from goal to start\n            node = nodes[-1]\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path = path[::-1]\n\n            # Path smoothing by shortcutting\n            smoothed_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if (not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5)):\n                        break\n                    j -= 1\n                smoothed_path.append(path[j])\n                i = j\n            extracted_path = smoothed_path\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.37827,
    "time_improvement": -35.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 2494.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.041107892990112305,
            "num_nodes_avg": 292.8,
            "path_length_avg": 167.63158239363338,
            "smoothness_avg": 0.05258199590070056,
            "success_improvement": 0.0,
            "time_improvement": -49.342842640825,
            "length_improvement": 8.118473397642562,
            "smoothness_improvement": 723.0224194776345,
            "objective_score": -9.564046015330815
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.23439972400665282,
            "num_nodes_avg": 1099.1,
            "path_length_avg": 235.5334773006683,
            "smoothness_avg": 0.20501343740452774,
            "success_improvement": -9.999999999999998,
            "time_improvement": -27.61548519312097,
            "length_improvement": 21.372145821789925,
            "smoothness_improvement": 5175.1434096287885,
            "objective_score": -28.13449934543436
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07028820514678955,
            "num_nodes_avg": 586.6,
            "path_length_avg": 121.08475737819519,
            "smoothness_avg": 0.13241294933485753,
            "success_improvement": 0.0,
            "time_improvement": -27.57978873026107,
            "length_improvement": 19.581269585947048,
            "smoothness_improvement": 1584.2829418321403,
            "objective_score": 3.563732007271791
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified and generalized sampling-based path planner building an incremental tree rooted at the start position. It performs goal biasing and steers new nodes by a fixed step size, checking collisions and obstacles on nodes and edges, while ensuring no expansion beyond map bounds. It optimizes performance by early termination once the goal is reached, avoids unnecessary operations, and collects explored nodes and edges for result analysis.",
    "planning_mechanism": "The planner samples random points biased towards the goal, finds the nearest node in the current tree, steers towards the sample within step limits and map bounds, performs collision and obstacle checks for nodes and edges, connects nodes if valid, and breaks when the goal region is reached to extract the path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of rectangular obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in the tree\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute steer direction and new position within step_size and map bounds\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step = min(self.step_size, dist)\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * step for d in range(len(bounds)))\n\n            if not in_bounds(new_position):\n                continue\n            # Collision and edge checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached by proximity and collision-free connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                        and not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                        and in_bounds(goal_position)):\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    current = goal_node\n                    while current:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.97945,
    "time_improvement": 43.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013660502433776856,
            "num_nodes_avg": 217.0,
            "path_length_avg": 185.12309132095885,
            "smoothness_avg": 0.010703535406416236,
            "success_improvement": 0.0,
            "time_improvement": 50.37210333663052,
            "length_improvement": -1.4688998161204492,
            "smoothness_improvement": 67.53357220956782,
            "objective_score": 15.155518898812906
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09356167316436767,
            "num_nodes_avg": 966.5,
            "path_length_avg": 303.7960368295421,
            "smoothness_avg": 0.006397840565811823,
            "success_improvement": 0.0,
            "time_improvement": 49.061721949757484,
            "length_improvement": -1.4158613777813034,
            "smoothness_improvement": 64.62104593663379,
            "objective_score": 14.758449539054151
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.038941144943237305,
            "num_nodes_avg": 552.2,
            "path_length_avg": 151.42950335833288,
            "smoothness_avg": 0.013261330901099808,
            "success_improvement": 0.0,
            "time_improvement": 29.31811198767521,
            "length_improvement": -0.5722658325337405,
            "smoothness_improvement": 68.68315021236349,
            "objective_score": 9.02439618085763
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates advanced features from bidirectional RRT* and informed sampling heuristics with dynamic neighbor radius rewiring, KD-tree accelerated nearest and near neighbor searches, collision caching, and adaptive pruning strategies. It performs ellipsoidal informed sampling based on the current best path cost to focus exploration in promising regions, balancing exploration and exploitation. The planner incrementally builds two trees rooted at start and goal, always extending the smaller tree with collision and edge feasibility checks, and rewires neighbors to minimize path cost. Aggressive shortcut smoothing enhances path quality, while periodic pruning removes non-promising nodes to reduce computational overhead, collectively improving planning efficiency, success rate, path length, and smoothness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points within an ellipsoidal informed domain shaped by the current best path to bias exploration towards low-cost regions. It leverages KD-tree structures for efficient nearest neighbor and radius queries, employs collision caching to avoid redundant checks, and dynamically adjusts neighbor radius for rewiring. Upon connecting the trees, it applies iterative shortcut smoothing to refine the path, while periodically pruning nodes that cannot improve the solution cost. This structured combination enables fast convergence to high-quality, smooth paths with reduced planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u_norm = u / norm_u\n                rot = id_mat - 2 * np.outer(u_norm, u_norm)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Choose smaller tree to extend for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -33.13213,
    "time_improvement": 74.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1548.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009795570373535156,
            "num_nodes_avg": 73.0,
            "path_length_avg": 167.29335455219524,
            "smoothness_avg": 0.04645463697094636,
            "success_improvement": 0.0,
            "time_improvement": 64.41320100682711,
            "length_improvement": 8.303861437097927,
            "smoothness_improvement": 627.115946454099,
            "objective_score": 24.120312321738215
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022153162956237794,
            "num_nodes_avg": 208.4,
            "path_length_avg": 232.80013235073653,
            "smoothness_avg": 0.10342572773917454,
            "success_improvement": 0.0,
            "time_improvement": 87.93903597283109,
            "length_improvement": 22.28461504104928,
            "smoothness_improvement": 2561.218469269559,
            "objective_score": 43.64472614640698
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016563153266906737,
            "num_nodes_avg": 150.8,
            "path_length_avg": 125.21339572420261,
            "smoothness_avg": 0.12236868277775834,
            "success_improvement": 0.0,
            "time_improvement": 69.93629884152173,
            "length_improvement": 16.839224581160327,
            "smoothness_improvement": 1456.5206126164753,
            "objective_score": 31.63133763177096
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a Rapidly-exploring Random Graph (RRG) with informed sampling and dynamic neighborhood radius for rewiring, combining space-filling graph exploration with continuous local optimization. The planner incrementally builds a graph rooted at start, sampling mostly within an informed ellipsoidal subset to focus search on promising regions. Nearby nodes are checked and rewired to improve path costs. After goal connection, a path is extracted and further refined via shortcut smoothing to enhance smoothness and reduce length, improving path quality and planning efficiency. The approach balances exploration and exploitation with adaptive rewiring and informed sampling to enhance success rate and robustness while reducing search time.",
    "planning_mechanism": "The planner builds a graph by sampling mostly inside an ellipsoidal informed set defined by current best cost, connecting new samples to neighbors within a radius that adapts based on node count and dimension. Each connection is collision-checked. Local rewiring optimizes path costs continuously. Once the goal is connected, the shortest path is extracted and shortcut smoothing is applied to improve smoothness and path length. This approach increases efficiency and path quality by focusing search and leveraging graph connectivity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, gamma_rrg: float=50.0,\n                 goal_sample_rate: float=0.1, full_sample_rate: float=0.1, smooth_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrg = gamma_rrg             # Constant for neighborhood radius scaling in RRG\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n        self.smooth_trials = smooth_trials     # Number of shortcut smoothing trials\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_node = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_node)\n\n        # Helper: informed ellipsoidal sampling\n        def informed_sample():\n            if c_best == float('inf') or random.random() < self.full_sample_rate:\n                # Uniform full space sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed sampling inside ellipsoid defined by start, goal and c_best\n            center = np.array([(start_position[d] + goal_position[d]) / 2.0 for d in range(dim)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n            e1 = a1 / norm_a1\n            # Build orthonormal basis C with first axis e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best**2 - c_min**2, 0.0)\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                point = C @ (L @ (x_ball * radius)) + center\n                if in_bounds(point):\n                    return tuple(point)\n\n        # Steering: return new point towards to_p limited by step_size\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * self.step_size / dist for d in range(dim))\n\n        # Neighborhood radius for rewiring, decaying as graph grows (standard RRG)\n        def neighborhood_radius(n_points):\n            zeta = np.pi if dim == 2 else (4/3)*np.pi if dim == 3 else 1.0\n            return min(self.step_size, self.gamma_rrg * (math.log(n_points) / n_points) ** (1.0 / dim))\n\n        # Find nearest node in nodes to point p\n        def nearest_node(p):\n            return min(nodes, key=lambda n: math.dist(n.position, p))\n\n        # Find all nodes within radius r of point p\n        def near_nodes(p, r):\n            return [n for n in nodes if math.dist(n.position, p) <= r]\n\n        # Rewire neighborhood to attempt path cost improvement\n        def rewire(new_node):\n            r = neighborhood_radius(len(nodes))\n            neighbors = near_nodes(new_node.position, r)\n\n            for near in neighbors:\n                if near is new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(near.position, obstacles, is_3d)):\n                        # Change parent\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        # Extract path by backtracking parents from goal node\n        def extract_path(goal_node):\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        # Shortcut smoothing of path to reduce path length and improve smoothness\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smooth_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            # Find nearest node to sample\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                # Prune samples unlikely to improve current best\n                continue\n\n            # Create new node and connect\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Connect to near neighbors and possibly rewire\n            r = neighborhood_radius(len(nodes))\n            neighbors = near_nodes(new_pos, r)\n\n            # Find parent candidate with least cost + collision-free edge\n            min_parent = nearest\n            min_cost = new_cost\n            for near in neighbors:\n                if near is new_node:\n                    continue\n                cost_through_near = near.cost + math.dist(near.position, new_pos)\n                if cost_through_near + 1e-9 < min_cost:\n                    if (not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d) and\n                            not self._is_in_obstacle(new_pos, obstacles, is_3d)):\n                        min_parent = near\n                        min_cost = cost_through_near\n            if min_parent != nearest:\n                # Reassign parent to better node\n                new_node.parent.remove_child(new_node)\n                if (new_node.parent, new_node) in edges:\n                    edges.remove((new_node.parent, new_node))\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            rewire(new_node)\n\n            # Check connection to goal area\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    c_new = new_node.cost + dist_to_goal\n                    if c_new < c_best:\n                        c_best = c_new\n                        goal_node = Node(goal_position, parent=new_node, cost=c_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        extracted_path = extract_path(goal_node)\n                        extracted_path = shortcut_smooth(extracted_path)\n                        # Early termination if good enough\n                        if c_best <= c_min * 1.05:\n                            break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 905.03629,
    "time_improvement": -3051.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1379.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1370298385620117,
            "num_nodes_avg": 1698.0,
            "path_length_avg": 166.57419360311093,
            "smoothness_avg": 0.03724039373300329,
            "success_improvement": 0.0,
            "time_improvement": -4030.770416745343,
            "length_improvement": 8.69804494912553,
            "smoothness_improvement": 482.89303073084284,
            "objective_score": -1205.0770508801236
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.4175403356552123,
            "num_nodes_avg": 3354.5,
            "path_length_avg": 230.44697391986765,
            "smoothness_avg": 0.08583747551626439,
            "success_improvement": 0.0,
            "time_improvement": -1216.1943095966444,
            "length_improvement": 23.070167057183248,
            "smoothness_improvement": 2108.6600712680615,
            "objective_score": -349.7009591112164
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.2077497482299804,
            "num_nodes_avg": 3087.9,
            "path_length_avg": 119.49717497214752,
            "smoothness_avg": 0.12932205761125962,
            "success_improvement": 0.0,
            "time_improvement": -3907.276126346401,
            "length_improvement": 20.635666227493545,
            "smoothness_improvement": 1544.9670272538697,
            "objective_score": -1160.3308695221522
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes bidirectional RRT* principles with informed ellipsoidal sampling, goal biasing, adaptive step sizing, and robust tree rewiring/pruning for cost-effective paths. It integrates intermittent full-space exploration and enhanced collision-checking to accelerate convergence, while maintaining path quality through shortcut smoothing and dynamic tree pruning. The planner efficiently grows start and goal trees, connects them optimally, and terminates early upon near-optimal path discovery, balancing exploration and exploitation for improved performance in cluttered 2D/3D spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, uses informed sampling biasing towards the current best path, adapts step sizes near obstacles for safer expansions, and rewires nodes within a radius to minimize path costs. It prunes parts of the tree unlikely to improve the solution, tries connecting the two trees at every iteration, applies shortcut smoothing to shorten paths, and terminates early once a near-optimal path is found, thereby improving planning efficiency, success rate, and path smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For pruning or invalidation\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0,\n                 goal_sample_rate: float=0.15, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path = []\n\n        id_mat = np.eye(dim)\n\n        def sample_in_ellipsoid():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                # Uniform random sample in full space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n\n            e1 = a1 / a1_norm\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            det_term = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det_term]) @ Vt\n\n            r1 = c_best / 2\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val)/2 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def biased_sample(current_tree):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if current_tree is tree_start else start_pos\n            return sample_in_ellipsoid()\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist == 0:\n                return self.base_step\n            # Check along path for collision to shrink step near obstacles\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check+1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step size where collision detected\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def rewire(new_node, tree):\n            for near_node in tree:\n                if near_node is new_node or not near_node.valid:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    if new_cost + 1e-9 < near_node.cost:\n                        if (not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)):\n                            # Rewire near_node to new_node\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def prune_tree(tree):\n            # Remove nodes whose cost + heuristic exceeds current best path cost (c_best)\n            to_remove = []\n            for node in tree:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                h = math.dist(node.position, goal_pos if tree is tree_start else start_pos)\n                if node.cost + h >= c_best:\n                    self._invalidate_subtree(node, edges)\n                    to_remove.append(node)\n            for node in to_remove:\n                if node in tree:\n                    tree.remove(node)\n\n        def connect_trees(node_new, other_tree):\n            near_other = nearest_node(other_tree, node_new.position)\n            dist_between = math.dist(node_new.position, near_other.position)\n            if dist_between <= self.base_step:\n                if (not self._is_edge_in_obstacle(node_new.position, near_other.position, obstacles, is_3d)\n                    and not self._is_in_obstacle(near_other.position, obstacles, is_3d)):\n                    total_cost = node_new.cost + dist_between + near_other.cost\n                    return near_other, total_cost\n            return None, float(\"inf\")\n\n        def extract_full_path(meet_start_node, meet_goal_node):\n            path_start = meet_start_node.path_from_root()\n            path_goal = meet_goal_node.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut_path(path, trials=200):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (iter_num % 2 == 0) else (tree_goal, tree_start)\n\n            sample = biased_sample(tree_a)\n            nearest = nearest_node(tree_a, sample)\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total = new_cost + math.dist(new_pos, goal_pos if tree_a is tree_start else start_pos)\n\n            if est_total >= c_best:\n                continue  # Prune branch unlikely to improve solution\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire for local cost improvement\n            rewire(new_node, tree_a)\n\n            # Prune unpromising nodes in both trees to reduce search space\n            prune_tree(tree_a)\n            prune_tree(tree_b)\n\n            # Attempt to connect trees\n            nearest_other, total_cost = connect_trees(new_node, tree_b)\n            if nearest_other and total_cost < c_best:\n                c_best = total_cost\n                success_state = True\n\n                # Create connecting ghost node\n                connection_node = Node(nearest_other.position, new_node,\n                                       new_node.cost + math.dist(new_node.position, nearest_other.position))\n                new_node.add_child(connection_node)\n                nodes.append(connection_node)\n                edges.append((new_node, connection_node))\n\n                if tree_a is tree_start:\n                    best_path = extract_full_path(new_node, nearest_other)\n                else:\n                    best_path = extract_full_path(nearest_other, new_node)\n\n                best_path = shortcut_path(best_path, trials=200)\n\n                # Early termination if near-optimal\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _invalidate_subtree(self, node, edges):\n        node.valid = False\n        for child in list(node.children):\n            self._invalidate_subtree(child, edges)\n            try:\n                edges.remove((node, child))\n            except ValueError:\n                pass\n            node.remove_child(child)\n        if node.parent:\n            node.parent.remove_child(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 848.37046,
    "time_improvement": -2697.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1232.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.3187961816787719,
            "num_nodes_avg": 1682.2,
            "path_length_avg": 147.8527022378876,
            "smoothness_avg": 0.04553896187557954,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4691.118111627536,
            "length_improvement": 18.95959102741933,
            "smoothness_improvement": 612.7836427913129,
            "objective_score": -1450.47959706882
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 1.9628823041915893,
            "num_nodes_avg": 2529.3,
            "path_length_avg": 221.1692018727787,
            "smoothness_avg": 0.07282188715038397,
            "success_improvement": -9.999999999999998,
            "time_improvement": -968.662425640447,
            "length_improvement": 26.167354412363153,
            "smoothness_improvement": 1773.759607864589,
            "objective_score": -326.4964587703385
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.3948854207992554,
            "num_nodes_avg": 2219.3,
            "path_length_avg": 113.91923170036372,
            "smoothness_avg": 0.11087472398157412,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2431.8499301104816,
            "length_improvement": 24.340270555496595,
            "smoothness_improvement": 1310.3183051247993,
            "objective_score": -768.1353333964212
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements a bidirectional, adaptive-step, and informed-sampling tree-growth algorithm combining fast exploration with path quality optimization through rewiring and pruning. It grows two trees from start and goal, uses ellipsoidal informed sampling biased towards the best current path cost, adapts step sizes near obstacles for safer advances, and prunes unpromising branches to reduce search space. After connecting trees for a feasible path, it applies iterative shortcut smoothing for higher path quality. The approach balances planning efficiency, success rate, and path smoothness in 2D/3D cluttered environments.",
    "planning_mechanism": "The planner alternates tree expansions from start and goal with goal and ellipsoidal biasing, steering adaptively to avoid collisions and extending within bounds. It rewires local neighborhoods to improve cost and prunes nodes unlikely to yield better paths. Upon tree connection, the current best path is extracted and smoothed by shortcutting. Early stopping occurs on near-optimal path finding.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (for pruning etc.)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0,\n                 goal_sample_rate: float = 0.1, full_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        best_path = []\n\n        id_mat = np.eye(dim)\n\n        def _is_in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                # Uniform random sampling in full space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n            e1 = a1 / a1_norm\n\n            # Compute rotation matrix C for aligning unit vector e1 with x-axis\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            det_term = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det_term]) @ Vt\n\n            r1 = c_best / 2\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if _is_in_bounds(x_rand):\n                    return tuple(x_rand)\n\n        def goal_biased_sample(current_tree):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if current_tree is tree_start else start_pos\n            return informed_sample()\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            num_checks = max(2, int(dist))\n            for i in range(1, num_checks + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / num_checks) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def rewire(new_node, tree):\n            for near_node in tree:\n                if near_node is new_node:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    if new_cost + 1e-9 < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def prune_tree(tree):\n            to_remove = []\n            for node in tree:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                est_total = node.cost + math.dist(node.position, goal_pos)\n                if est_total >= c_best:\n                    self._invalidate_subtree(node, edges)\n                    to_remove.append(node)\n            for node in to_remove:\n                if node in tree:\n                    tree.remove(node)\n\n        def connect_trees(new_node, other_tree):\n            nearest_other = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between <= self.base_step:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(nearest_other.position, obstacles, is_3d)):\n                    total_cost = new_node.cost + dist_between + nearest_other.cost\n                    return nearest_other, total_cost\n            return None, float(\"inf\")\n\n        def extract_full_path(meet_start_node, meet_goal_node):\n            path_start = meet_start_node.path_from_root()\n            path_goal = meet_goal_node.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut_path(path, trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            sample = goal_biased_sample(tree_a)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not _is_in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total = new_cost + math.dist(new_pos, goal_pos)\n\n            if est_total >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, tree_a)\n            prune_tree(tree_a)\n            prune_tree(tree_b)\n\n            nearest_other, total_cost = connect_trees(new_node, tree_b)\n            if nearest_other and total_cost < c_best:\n                c_best = total_cost\n                success_state = True\n\n                connection_node = Node(nearest_other.position, new_node,\n                                       new_node.cost + math.dist(new_node.position, nearest_other.position))\n                new_node.add_child(connection_node)\n                nodes.append(connection_node)\n                edges.append((new_node, connection_node))\n\n                if tree_a is tree_start:\n                    best_path = extract_full_path(new_node, nearest_other)\n                else:\n                    best_path = extract_full_path(nearest_other, new_node)\n\n                best_path = shortcut_path(best_path, trials=150)\n\n                if c_best <= c_min * 1.05:\n                    break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _invalidate_subtree(self, node, edges):\n        node.valid = False\n        for child in list(node.children):\n            self._invalidate_subtree(child, edges)\n            if (node, child) in edges:\n                edges.remove((node, child))\n            node.remove_child(child)\n        if node.parent:\n            node.parent.remove_child(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 887.14876,
    "time_improvement": -2936.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1155.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.3010753631591796,
            "num_nodes_avg": 1762.6,
            "path_length_avg": 148.14954024500884,
            "smoothness_avg": 0.03938399791294008,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4626.739297265179,
            "length_improvement": 18.796889412016952,
            "smoothness_improvement": 516.4450910578347,
            "objective_score": -1431.680185841861
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.2629435539245604,
            "num_nodes_avg": 2845.1,
            "path_length_avg": 222.48706415903538,
            "smoothness_avg": 0.07581336619992693,
            "success_improvement": 0.0,
            "time_improvement": -1132.0263636083967,
            "length_improvement": 25.72741404864799,
            "smoothness_improvement": 1850.732518484596,
            "objective_score": -325.2087636803664
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.7354685068130493,
            "num_nodes_avg": 2607.5,
            "path_length_avg": 113.21914648067408,
            "smoothness_avg": 0.09424291882179173,
            "success_improvement": 0.0,
            "time_improvement": -3050.0406787289194,
            "length_improvement": 24.805233823938696,
            "smoothness_improvement": 1098.7629711245245,
            "objective_score": -904.5573419982654
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an improved bidirectional RRT planner with goal biasing, adaptive step size control, and enhanced connection strategy to improve efficiency, path quality, and robustness. It grows two trees rooted at start and goal, samples points biased towards the goal, and attempts to connect the trees each iteration. The adaptive step size helps explore faster in open space and slower near obstacles, while rigorous collision and edge checks ensure safe expansions. The algorithm extracts the shortest found path upon success.",
    "planning_mechanism": "The planner alternates expansions of start and goal trees towards goal-biased random samples. It picks nearest nodes, steers incrementally with adaptive step size to reduce unnecessary expansions, and connects the trees via collision-free edges. Early termination occurs once the trees connect within step size threshold. The path is reconstructed by concatenating nodes from start and goal trees, promoting path smoothness and reduced length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.15, connect_dist_factor: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.connect_dist_factor = connect_dist_factor\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Trees\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                # Goal bias sampling towards either start or goal tree direction to balance growth\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(node_a, node_b, tree_b):\n            # Attempt to connect node_a to node_b by incremental steering steps from node_b towards node_a\n            from_pos = node_b.position\n            to_pos = node_a.position\n            total_dist = distance(from_pos, to_pos)\n            step = min(self.step_size, total_dist)\n            curr_pos = from_pos\n            curr_node = node_b\n\n            while True:\n                new_pos = steer(curr_pos, to_pos, step)\n                if not can_connect(curr_pos, new_pos):\n                    return False, None\n                new_cost = curr_node.cost + distance(curr_pos, new_pos)\n                new_node = Node(new_pos, parent=curr_node, cost=new_cost)\n                curr_node.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n                if distance(new_pos, to_pos) <= step * 0.5:\n                    # Final connect close to node_a\n                    if can_connect(new_pos, to_pos):\n                        final_cost = new_node.cost + distance(new_pos, to_pos)\n                        final_node = Node(to_pos, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return True, final_node\n                    else:\n                        return False, None\n                curr_pos = new_pos\n                curr_node = new_node\n\n        for iteration in range(self.max_iter):\n            rnd_point = sample()\n\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rnd_point)\n                dist_to_sample = distance(nearest_node.position, rnd_point)\n                # Adaptive step size: smaller step near obstacles to improve feasibility\n                adaptive_step = self.step_size\n                # simple heuristic to reduce step near obstacles: check mid-point in line\n                mid_point = steer(nearest_node.position, rnd_point, dist_to_sample * 0.5)\n                if self._is_in_obstacle(mid_point, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, mid_point, obstacles, is_3d):\n                    adaptive_step = max(self.step_size * 0.3, self.step_size * (dist_to_sample / 10.0))\n                    adaptive_step = min(adaptive_step, dist_to_sample)\n\n                new_pos = steer(nearest_node.position, rnd_point, adaptive_step)\n                if not can_connect(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Try connecting the opposite tree to the new node if close enough\n                nearest_node_b = nearest(tree_b, new_pos)\n                dist_between_trees = distance(new_pos, nearest_node_b.position)\n\n                if dist_between_trees <= self.step_size * self.connect_dist_factor:\n                    connected, final_node_b = connect_trees(new_node, nearest_node_b, tree_b)\n                    if connected:\n                        # Extract path by tracing parents\n                        path_from_start = []\n                        node_cursor = new_node if tree_a is start_tree else final_node_b\n                        while node_cursor:\n                            path_from_start.append(node_cursor.position)\n                            node_cursor = node_cursor.parent\n                        path_from_start.reverse()\n                        path_from_goal = []\n                        node_cursor = final_node_b if tree_a is start_tree else new_node\n                        while node_cursor:\n                            path_from_goal.append(node_cursor.position)\n                            node_cursor = node_cursor.parent\n                        extracted_path = path_from_start + path_from_goal\n                        success_state = True\n                        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        # Use finer resolution for better collision detection with obstacles\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.16367,
    "time_improvement": 13.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 100.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0408228874206543,
            "num_nodes_avg": 180.7,
            "path_length_avg": 199.20699342092274,
            "smoothness_avg": 0.012024274093646706,
            "success_improvement": 0.0,
            "time_improvement": -48.30743219248206,
            "length_improvement": -9.188509730820975,
            "smoothness_improvement": 88.20600069468841,
            "objective_score": -15.88890160043537
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.026427483558654784,
            "num_nodes_avg": 264.4,
            "path_length_avg": 297.78269418817894,
            "smoothness_avg": 0.008102185955879571,
            "success_improvement": -9.999999999999998,
            "time_improvement": 85.61194493268586,
            "length_improvement": 0.5915654803767291,
            "smoothness_improvement": 108.47508041344184,
            "objective_score": -23.65572802205168
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05334312915802002,
            "num_nodes_avg": 350.4,
            "path_length_avg": 161.21055280280046,
            "smoothness_avg": 0.015945817374183817,
            "success_improvement": 0.0,
            "time_improvement": 3.17713855434722,
            "length_improvement": -7.068373150025112,
            "smoothness_improvement": 102.82962000181224,
            "objective_score": 0.05361503630820463
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with informed sampling and adaptive stepping to efficiently find high-quality, collision-free paths in 2D or 3D spaces. It grows two trees simultaneously from start and goal positions, incrementally extending nodes toward sampled points within bounds and avoiding obstacles using collision checks. The planner rewires locally to optimize costs, prunes paths exceeding the best cost, and connects the two trees when possible. Shortcut smoothing is applied at the end to improve path smoothness and reduce length, balancing speed and robustness.",
    "planning_mechanism": "The planner alternates expanding two trees from start and goal. Samples are drawn using an informed strategy if a path exists or uniformly if not. New nodes are created by steering from nearest nodes with adaptive step sizes considering obstacles. Local rewiring optimizes nearby nodes\u2019 costs. If the two trees connect collision-free within a step, a candidate path is extracted, shortcut-smoothed, and updated as the best. The process continues until max iterations or an acceptable path is found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            dist = distance(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_p, to_p):\n            dist = distance(from_p, to_p)\n            steps = max(int(dist), 2)\n            for i in range(1, steps + 1):\n                interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interm, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        # Informed sampling inside ellipsoid if path found, uniform otherwise\n        c_min = distance(start_pos, goal_pos)\n        c_best = float('inf')\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) * 0.5 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n            e1 = a1 / norm_a1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2\n            val = max(c_best**2 - c_min**2, 0)\n            r2 = math.sqrt(val)/2 if val > 0 else 0\n            L = np.diag([r1] + [r2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x= np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                point = C @ L @ (x_ball * radius) + center\n                p = tuple(point)\n                if in_bounds(p):\n                    return p\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges: List[Tuple[Node, Node]] = []\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def rewire(new_node, tree, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor.parent is None:\n                    continue\n                d = distance(new_node.position, neighbor.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def connect_trees(node_from, tree_to):\n            nearest_node = nearest(tree_to, node_from.position)\n            dist_connect = distance(node_from.position, nearest_node.position)\n            if dist_connect <= self.step_size:\n                if (not self._is_edge_in_obstacle(node_from.position, nearest_node.position, obstacles, is_3d)\n                    and not self._is_in_obstacle(nearest_node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut(path, max_trials=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        REWIRE_RADIUS = self.step_size * 3\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_point = informed_sample()\n\n            nearest_node = nearest(tree_a, sample_point)\n            step_sz = adaptive_step(nearest_node.position, sample_point)\n            new_pos = steer(nearest_node.position, sample_point, step_sz)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            est_total_cost = new_cost + distance(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, tree_a, REWIRE_RADIUS)\n\n            connecting_node = connect_trees(new_node, tree_b)\n            if connecting_node:\n                total_cost = new_node.cost + distance(new_node.position, connecting_node.position) + connecting_node.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    success = True\n                    connect_node = Node(connecting_node.position, new_node, new_node.cost + distance(new_node.position, connecting_node.position))\n                    new_node.add_child(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    if tree_a is tree_start:\n                        path = extract_path(connect_node, connecting_node)\n                    else:\n                        path = extract_path(connecting_node, connect_node)\n                    best_path = shortcut(path)\n                    if c_best <= c_min * 1.05:\n                        break\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1286.36159,
    "time_improvement": -4322.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1113.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.4273491859436036,
            "num_nodes_avg": 1814.6,
            "path_length_avg": 149.4085315917441,
            "smoothness_avg": 0.04088399067477711,
            "success_improvement": 0.0,
            "time_improvement": -5085.485544616889,
            "length_improvement": 18.106816304876812,
            "smoothness_improvement": 539.9232350670013,
            "objective_score": -1519.324683948756
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.2788466930389406,
            "num_nodes_avg": 3073.2,
            "path_length_avg": 222.68558609180968,
            "smoothness_avg": 0.0763276110861402,
            "success_improvement": 0.0,
            "time_improvement": -1140.6845939999894,
            "length_improvement": 25.661141713350926,
            "smoothness_improvement": 1863.9644098024835,
            "objective_score": -327.75332780831417
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.7676620483398438,
            "num_nodes_avg": 2824.5,
            "path_length_avg": 113.49601518695924,
            "smoothness_avg": 0.08126832963053764,
            "success_improvement": 0.0,
            "time_improvement": -6738.665564590466,
            "length_improvement": 24.621350812295127,
            "smoothness_improvement": 933.7271542963271,
            "objective_score": -2012.0067634431991
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates the strengths of bidirectional informed RRT* with adaptive ellipsoidal sampling, dynamic neighbor radius, KD-tree accelerated nearest neighbor queries, collision caching, incremental rewiring, and periodic pruning to optimize both planning speed and path quality. It employs adaptive sampling focused within the current best path ellipsoid to concentrate efforts where improvements are likely, minimizes redundant collision checks via caching, and applies batch shortcut smoothing for smooth final paths. These combined heuristics enhance success rate, reduce path length, and minimize search time in complex 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions using informed, ellipsoidal-biased sampling around the best-known path, leveraging KD-tree for efficient neighbor searches and rewiring to improve cost locally. It caches collision checks to reduce redundant computations and prunes nodes not promising better solutions. Once start and goal trees are connected, batch shortcut smoothing refines the final path for smoothness and minimal length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning flags\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for i, p in enumerate(self.points):\n                    sq_dist = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sq_dist += delta * delta\n                        if sq_dist > r2:\n                            break\n                    if sq_dist <= r2:\n                        results.append(self.nodes[i])\n                return results\n\n        # Ellipsoidal informed sampling centered on current best path\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sample in free space w/ retries\n                for _ in range(10):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - id_mat[0]\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            try:\n                r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            except:\n                r_others = 0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return sample\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic_cost = dist(node.position, goal_pos)\n                if node.cost + heuristic_cost >= best_cost:\n                    to_remove.append(node)\n            for node_rm in to_remove:\n                if node_rm.parent:\n                    try:\n                        node_rm.parent.children.remove(node_rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node_rm)\n                except ValueError:\n                    pass\n                if node_rm in tree_start:\n                    tree_start.remove(node_rm)\n                if node_rm in tree_goal:\n                    tree_goal.remove(node_rm)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth, smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for neighbor in near_nodes:\n                cost_candidate = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(neighbor.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting trees\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            connected = False\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_smoothing(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Early termination if path length is already minimal possible (close to c_min)\n                if c_best <= c_min * 1.02:\n                    break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 322.57146,
    "time_improvement": -1110.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1334.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023105573654174805,
            "num_nodes_avg": 81.2,
            "path_length_avg": 157.45288122237858,
            "smoothness_avg": 0.03915444444210529,
            "success_improvement": 0.0,
            "time_improvement": 16.058649583635766,
            "length_improvement": 13.697580801448913,
            "smoothness_improvement": 512.8520807559299,
            "objective_score": 10.12137143916016
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.225188136100769,
            "num_nodes_avg": 980.1,
            "path_length_avg": 231.40883363396188,
            "smoothness_avg": 0.08533933883646616,
            "success_improvement": 0.0,
            "time_improvement": -567.0356763599154,
            "length_improvement": 22.749070599021792,
            "smoothness_improvement": 2095.8426557035054,
            "objective_score": -155.08167550965274
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.5866850376129151,
            "num_nodes_avg": 1211.6,
            "path_length_avg": 118.42931122389341,
            "smoothness_avg": 0.11748985513420707,
            "success_improvement": 0.0,
            "time_improvement": -2779.984507462816,
            "length_improvement": 21.34489048287659,
            "smoothness_improvement": 1394.4622851081,
            "objective_score": -822.754062716729
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm combines the advantages of RRT* with a heuristic-guided informed sampling to accelerate convergence towards an optimal path. It first grows a rapidly-exploring tree with rewiring (like RRT*) but focuses samples within an ellipsoidal informed region once a feasible path is found, thereby efficiently refining the solution. Additionally, it incorporates a path smoothing subroutine in post-processing to improve path smoothness and quality.",
    "planning_mechanism": "The planner incrementally builds a tree from start towards goal using goal-biased sampling. When a valid path is first found, all subsequent samples are drawn from an ellipsoidal region defined by the current best path cost to efficiently refine and shorten the path. The tree rewires neighbors to optimize cost during expansion. After planning terminates, the extracted path is smoothed by shortcutting collision-free edges, reducing unnecessary waypoints and improving smoothness. Throughout, collision checks ensure robustness and validity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate   # Probability to sample the goal directly\n        self.neighbor_radius = neighbor_radius     # Radius for neighbor searching during rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        dimension = len(bounds)\n\n        def sample_informed_ellipsoid():\n            # Sampling inside an ellipsoid to bias sampling around best solution found\n            # Ellipsoid centered between start and goal with axes based on best_cost\n            c_best = best_cost\n            if c_best == float('inf'):\n                # No solution yet, sample uniformly\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n            c_min = math.dist(start_position, goal_position)\n            if c_min == 0:\n                return goal_position  # start==goal edge case\n\n            # Ellipsoid parameters\n            center = tuple((s + g)/2 for s, g in zip(start_position, goal_position))\n            # Coordinate rotation matrix (for 2D or 3D) to align with start-goal axis\n            def unit_vector(v):\n                mag = math.sqrt(sum(x*x for x in v))\n                return tuple(x/mag for x in v) if mag > 1e-12 else tuple(1.0 if i==0 else 0.0 for i in range(len(v)))\n\n            e1 = unit_vector(tuple(g - s for s, g in zip(start_position, goal_position)))\n            # Attempts for an orthonormal basis via Gram-Schmidt\n            import numpy as np\n            if dimension == 2:\n                # Orthogonal vector to e1\n                e2 = (-e1[1], e1[0])\n                rotation = np.array([e1, e2]).T\n            elif dimension == 3:\n                # Use numpy to form orthonormal matrix using e1 and two orthogonal vectors\n                e1_arr = np.array(e1)\n                # Pick arbitrary vector not colinear with e1\n                arbitrary = np.array([1,0,0]) if abs(e1_arr[0]) < 0.9 else np.array([0,1,0])\n                e2_arr = np.cross(e1_arr, arbitrary)\n                e2_arr /= (np.linalg.norm(e2_arr) + 1e-15)\n                e3_arr = np.cross(e1_arr, e2_arr)\n                rotation = np.array([e1_arr, e2_arr, e3_arr]).T\n            else:\n                # Fallback to uniform sampling\n                return tuple(random.uniform(0,bounds[d]) for d in range(dimension))\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = r3 = 0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                r3 = r2 if dimension == 3 else 0\n\n            while True:\n                # Sample a point within unit n-ball\n                if dimension == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    rho = math.sqrt(random.uniform(0,1))\n                    sample_ball = np.array([rho * math.cos(theta), rho * math.sin(theta)])\n                    sample_point = rotation @ (np.array([r1, r2]) * sample_ball) + np.array(center)\n                    sample_point = tuple(sample_point.tolist())\n                elif dimension == 3:\n                    # Uniform sampling in 3D unit ball\n                    # method: normal distribution and normalize + scaling with radius \n                    while True:\n                        point = np.random.normal(0,1,3)\n                        norm = np.linalg.norm(point)\n                        if norm > 1e-12:\n                            point = point / norm * (random.uniform(0,1) ** (1/3))\n                            break\n                    radii = np.array([r1, r2, r3])\n                    sample_point = rotation @ (radii * point) + np.array(center)\n                    sample_point = tuple(sample_point.tolist())\n                else:\n                    # Fallback uniform sampling\n                    sample_point = tuple(random.uniform(0,bounds[d]) for d in range(dimension))\n\n                # Check bounds\n                if all(0 <= sample_point[d] <= bounds[d] for d in range(dimension)):\n                    return sample_point\n\n        def nearest_node(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        for iter_num in range(self.max_iter):\n            # Informed sampling after first solution found, else uniform + goal bias\n            if best_goal_node:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_informed_ellipsoid()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n            # Nearest node in tree\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            # Validate new node position and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and find neighbors within radius for rewiring\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent among neighbors (including nearest)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_pos)\n                if cost_through_near < min_cost:\n                    # Check edge validity\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Check if new_node can connect to goal\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best if cost is better\n                    if goal_cost < best_cost:\n                        best_cost = goal_cost\n                        best_goal_node = goal_node\n                    success_state = True\n\n            # Optional: Early break if cost is already near optimal (close to straight distance)\n            if best_goal_node and best_cost <= math.dist(start_position, goal_position) * 1.01:\n                break\n\n        # Extract path from best goal node\n        if success_state and best_goal_node:\n            path = best_goal_node.path_from_root()\n\n            # Post-processing: Path smoothing by shortcutting\n            def is_collision_free_path(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = [path[0]]\n            idx = 0\n            while idx < len(path) -1:\n                next_idx = len(path)-1\n                # Find farthest reachable node without collision\n                for j in range(len(path)-1, idx, -1):\n                    if is_collision_free_path(path[idx], path[j]):\n                        next_idx = j\n                        break\n                smoothed_path.append(path[next_idx])\n                idx = next_idx\n            extracted_path = smoothed_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2161.28226,
    "time_improvement": -7237.0,
    "length_improvement": 25.0,
    "smoothness_improvement": 948.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.4180971145629884,
            "num_nodes_avg": 3554.4,
            "path_length_avg": 144.03822751215034,
            "smoothness_avg": 0.03570533474063342,
            "success_improvement": 0.0,
            "time_improvement": -12312.84528856011,
            "length_improvement": 21.050365068815953,
            "smoothness_improvement": 458.866024066299,
            "objective_score": -3687.349183433938
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 3.4278370141983032,
            "num_nodes_avg": 4461.4,
            "path_length_avg": 216.157053852148,
            "smoothness_avg": 0.06371003255057468,
            "success_improvement": 0.0,
            "time_improvement": -1787.3660832841824,
            "length_improvement": 27.840553688331372,
            "smoothness_improvement": 1539.3050260079065,
            "objective_score": -522.9451891175489
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.233368182182312,
            "num_nodes_avg": 5039.5,
            "path_length_avg": 109.38945384294735,
            "smoothness_avg": 0.0743143572488876,
            "success_improvement": 0.0,
            "time_improvement": -7610.828447849084,
            "length_improvement": 27.348733323550285,
            "smoothness_improvement": 845.2731388905871,
            "objective_score": -2273.5524219955623
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional informed sampling, adaptive step sizing near obstacles, rewiring for path quality, and goal biasing to accelerate convergence, improve path optimality, and enhance success rates in cluttered 2D and 3D environments. It incorporates pruning and node rejection to focus computational effort while ensuring smooth, short paths with robust collision avoidance.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions using heuristic-informed samples within an ellipsoidal domain constrained by the current best path cost, adaptively varies step sizes near obstacles for safer progress, rewires tree nodes to optimize local path costs, prunes nodes that cannot improve solutions, attempts connections between the two trees each iteration, and employs informed goal biasing to increase success chances efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start, tree_goal = [Node(start_position)], [Node(goal_position)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1_unit = a1 / norm_a1\n\n            # Build orthonormal basis via SVD\n            M = np.eye(dim)\n            M[0] = a1_unit\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                # Sample uniformly in the unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = C @ L @ x_ball + x_center\n                sample_tuple = tuple(sample)\n                if all(0 <= sample_tuple[d] <= bounds[d] for d in range(dim)):\n                    return sample_tuple\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        for iter_i in range(self.max_iter):\n            # Alternate trees\n            if iter_i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Goal biasing and informed sampling combined\n            if random.random() < self.goal_sample_rate and iter_i % 20 == 0:\n                sample = goal_position if tree_from is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bound check\n            if not all(0 <= new_pos[d] <= bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes that cannot improve best solution\n            if cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in same tree\n            near_nodes = [n for n in tree_from if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                temp_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if temp_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                    near.update_parent(new_node, temp_cost)\n                    edges.append((new_node, near))\n\n            # Attempt to connect to other tree\n            other_nearest = min(tree_to, key=lambda n: math.dist(n.position, new_pos))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_from = new_node.path_from_root()\n                path_to = other_nearest.path_from_root()\n                # Connect two trees and prune nodes outside ellipsoid after new best found\n                best_path = path_from + path_to[::-1]\n                success_state = True\n\n                # Prune nodes that are unlikely to improve the solution\n                prune_radius = c_best\n                def can_improve(node):\n                    dc_start = math.dist(start_position, node.position)\n                    dc_goal = math.dist(node.position, goal_position)\n                    return (dc_start + dc_goal) < prune_radius * 1.02 # small buffer\n\n                pruned_nodes_start = [n for n in tree_start if not can_improve(n)]\n                pruned_nodes_goal = [n for n in tree_goal if not can_improve(n)]\n\n                for n in pruned_nodes_start:\n                    n.valid = False\n                for n in pruned_nodes_goal:\n                    n.valid = False\n\n                # Remove invalid nodes from trees\n                tree_start = [n for n in tree_start if n.valid]\n                tree_goal = [n for n in tree_goal if n.valid]\n\n                # Remove edges related to invalid nodes\n                edges = [(p,c) for (p,c) in edges if p.valid and c.valid]\n\n        # If success not yet true, try to directly connect closest nodes from trees near goal and start\n        if not success_state:\n            candidates_start = [n for n in tree_start if n.valid]\n            candidates_goal = [n for n in tree_goal if n.valid]\n            min_dist = float(\"inf\")\n            connect_nodes = (None, None)\n            for ns in candidates_start:\n                for ng in candidates_goal:\n                    dist_node = math.dist(ns.position, ng.position)\n                    if dist_node < min_dist and not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d):\n                        min_dist = dist_node\n                        connect_nodes = (ns, ng)\n            if connect_nodes[0] and connect_nodes[1]:\n                c = connect_nodes[0].cost + math.dist(connect_nodes[0].position, connect_nodes[1].position) + connect_nodes[1].cost\n                if c < c_best:\n                    c_best = c\n                    path_from = connect_nodes[0].path_from_root()\n                    path_to = connect_nodes[1].path_from_root()\n                    best_path = path_from + path_to[::-1]\n                    success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 752.73651,
    "time_improvement": -2525.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 146.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1013382911682128,
            "num_nodes_avg": 1601.0,
            "path_length_avg": 156.18909394053804,
            "smoothness_avg": 0.012735939785418263,
            "success_improvement": 0.0,
            "time_improvement": -3899.518258388053,
            "length_improvement": 14.390282636616716,
            "smoothness_improvement": 99.34511417769805,
            "objective_score": -1166.4806954182038
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.0146764278411866,
            "num_nodes_avg": 3086.9,
            "path_length_avg": 230.80538747278115,
            "smoothness_avg": 0.011303023729031126,
            "success_improvement": 0.0,
            "time_improvement": -1009.2802671042092,
            "length_improvement": 22.950518296858608,
            "smoothness_improvement": 190.83494178689156,
            "objective_score": -297.2398017629566
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.5182529926300048,
            "num_nodes_avg": 2724.4,
            "path_length_avg": 117.5349638893726,
            "smoothness_avg": 0.01958270655035075,
            "success_improvement": 0.0,
            "time_improvement": -2665.4075579527,
            "length_improvement": 21.9388733982217,
            "smoothness_improvement": 149.09058187542084,
            "objective_score": -794.4890397967883
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced and adaptive RRT* based planner that integrates goal biasing, informed sampling inside ellipsoidal subsets after an initial solution is found, and path smoothing via shortcutting to improve path quality and planning efficiency. It simultaneously balances exploration and exploitation to achieve faster convergence and robust performance in both 2D and 3D environments.",
    "planning_mechanism": "The planner starts sampling uniformly with goal bias to grow a tree. Upon finding the first feasible path, it uses informed sampling focused in a prolate hyperspheroid defined by start, goal, and current best cost to improve path quality. It rewires locally for optimality and applies periodic path smoothing via shortcut attempts between random node pairs on the current best path to enhance smoothness and reduce length. All node and edge additions are carefully checked for collision-free feasibility.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def reset_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 rewire_radius: float = 15.0, smoothing_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        def sample():\n            if best_cost == float(\"inf\"):\n                # Uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                # Informed sampling inside prolate hyperspheroid\n                dim = len(start)\n                L = np.diag([best_cost / 2] + [math.sqrt(best_cost**2 - c_min**2) / 2] * (dim - 1))\n                x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n                a1 = np.array(goal) - np.array(start)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    a1 = np.zeros(dim)\n                else:\n                    a1 = a1 / a1_norm\n                I = np.eye(dim)\n                M = np.outer(a1, I[:, 0])\n                U, _, Vt = np.linalg.svd(M)\n                C_determinant = np.linalg.det(U) * np.linalg.det(Vt)\n                C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [C_determinant]), Vt))\n\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x > 1e-6:\n                        x_ball = x_ball / norm_x * random.random() ** (1.0 / dim)\n                    x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        return tuple(x_rand)\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        def near_nodes(new_pos):\n            return [n for n in tree if math.dist(n.position, new_pos) <= self.rewire_radius]\n\n        def try_path_smoothing(path_nodes: list):\n            # Attempts shortcuts in the path by connecting random pairs of nodes\n            for _ in range(self.smoothing_iters):\n                if len(path_nodes) < 3:\n                    return path_nodes\n                i, j = sorted(random.sample(range(len(path_nodes)), 2))\n                if j - i <= 1:\n                    continue\n                p_start = path_nodes[i]\n                p_end = path_nodes[j]\n                if (not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(p_start, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(p_end, obstacles, is_3d)):\n                    new_path = path_nodes[:i+1] + path_nodes[j:]\n                    path_nodes = new_path\n            return path_nodes\n\n        for iter_count in range(self.max_iter):\n            x_rand = sample()\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near = near_nodes(x_new_pos)\n\n            # Choose best parent minimizing cost + distance and collision free edge\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near:\n                temp_cost = n.cost + math.dist(n.position, x_new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = temp_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewiring neighbors if better through x_new\n            for n in near:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        try:\n                            n.parent.children.remove(n)\n                        except ValueError:\n                            pass\n                    n.reset_parent(x_new, alt_cost)\n                    edges.append((x_new, n))\n\n            # Check for reaching goal\n            if math.dist(x_new.position, goal) <= self.step_size:\n                if (not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                    goal_node = Node(goal, parent=x_new,\n                                     cost=x_new.cost + math.dist(x_new.position, goal))\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n\n                        # Path smoothing on current best path\n                        extracted_path = try_path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1934.10406,
    "time_improvement": -6473.0,
    "length_improvement": 25.0,
    "smoothness_improvement": 534.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.0335252046585084,
            "num_nodes_avg": 3029.1,
            "path_length_avg": 144.23898214109826,
            "smoothness_avg": 0.023788040309866476,
            "success_improvement": 0.0,
            "time_improvement": -10916.269515557033,
            "length_improvement": 20.94032827552893,
            "smoothness_improvement": 272.3344874057351,
            "objective_score": -3269.3311165749756
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.9975845336914064,
            "num_nodes_avg": 4005.6,
            "path_length_avg": 216.90012311800783,
            "smoothness_avg": 0.0339724204515744,
            "success_improvement": 0.0,
            "time_improvement": -1550.4691901139204,
            "length_improvement": 27.592495779324437,
            "smoothness_improvement": 774.1348475644022,
            "objective_score": -455.7515836404892
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.871378517150879,
            "num_nodes_avg": 4588.2,
            "path_length_avg": 109.63720099407465,
            "smoothness_avg": 0.05156373944097783,
            "success_improvement": 0.0,
            "time_improvement": -6951.48579518313,
            "length_improvement": 27.184191462223122,
            "smoothness_improvement": 555.886959649901,
            "objective_score": -2077.229465464245
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner optimizing path quality by rewiring nodes and efficiently connecting two growing trees from start and goal positions, ensuring collision-free nodes and edges. It balances exploration and exploitation via informed sampling within bounds and local neighborhoods to improve planning efficiency and path smoothness.",
    "planning_mechanism": "The planner grows two trees simultaneously, alternating extensions toward sampled free-space points. Each new node rewires nearby nodes to optimize path costs while checking collision-free conditions. After each extension, it attempts to connect the trees directly to form a complete path. Successful connections yield an extracted path. The process repeats until a path is found or maximum iterations are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def sample_free():\n            while True:\n                point = tuple(\n                    min(max(random.uniform(0, bounds[i]), 0), bounds[i]) for i in range(len(bounds))\n                )\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            while node_a:\n                path_a.append(node_a.position)\n                node_a = node_a.parent\n            path_b = []\n            while node_b:\n                path_b.append(node_b.position)\n                node_b = node_b.parent\n            return list(reversed(path_a)) + path_b\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + distance(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                connect_node = nearest(tree_b, new_node.position)\n                if distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        success_state = True\n                        extracted_path = extract_path(new_node, connect_node)\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.79806,
    "time_improvement": 56.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 171.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015959906578063964,
            "num_nodes_avg": 124.3,
            "path_length_avg": 176.18731378118582,
            "smoothness_avg": 0.01661451830973254,
            "success_improvement": -9.999999999999998,
            "time_improvement": 42.041479649793594,
            "length_improvement": 3.4289414498854387,
            "smoothness_improvement": 160.0532905512883,
            "objective_score": -35.90150136232839
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.029958891868591308,
            "num_nodes_avg": 304.4,
            "path_length_avg": 254.75778835924976,
            "smoothness_avg": 0.011133412186201206,
            "success_improvement": 0.0,
            "time_improvement": 83.50464267368856,
            "length_improvement": 14.954517449322442,
            "smoothness_improvement": 186.4707146236214,
            "objective_score": 28.974649865089166
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.032387804985046384,
            "num_nodes_avg": 302.7,
            "path_length_avg": 134.15030350767475,
            "smoothness_avg": 0.021037995824514003,
            "success_improvement": 0.0,
            "time_improvement": 41.0075388450281,
            "length_improvement": 10.903755961195786,
            "smoothness_improvement": 167.60175402449696,
            "objective_score": 15.321021615870071
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This implementation is an enhanced bidirectional RRT* planner employing adaptive informed ellipsoidal sampling to focus search in promising regions, KD-tree accelerated nearest neighbor and radius searches for efficient rewiring, cached collision checks to minimize redundant work, incremental local connections for balanced tree growth, and aggressive pruning of non-promising nodes to sustain computational efficiency. The planner additionally performs iterative shortcut smoothing to refine the path length and smoothness before outputting the final trajectory. This combination improves planning speed, path quality, robustness, and success rate while maintaining search within map bounds and obstacle-free space.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal points with alternated expansions, sampling points biased in an adaptive ellipsoidal region shaped by the current best path cost for focused exploration. Each sampled point extends the smaller tree by steering towards it with step size constraints and validated collision-free node and edges. Rewiring in local neighborhoods identified by KD-tree optimizes the path incrementally. The opposite tree attempts incremental connections towards the newly added node, further refining connectivity. Periodic pruning discards dead-end and costly nodes, and repeated shortcut smoothing improves final path smoothness and length, balancing exploration and exploitation for efficient and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(120):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expansion to keep trees balanced\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = max(1, int(dist(last_b.position, new_node.position) / self.step_size) + 1)\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.11267,
    "time_improvement": 62.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1415.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01557331085205078,
            "num_nodes_avg": 68.3,
            "path_length_avg": 158.3725748297215,
            "smoothness_avg": 0.04314863544165945,
            "success_improvement": 0.0,
            "time_improvement": 43.44540492616297,
            "length_improvement": 13.19348216178646,
            "smoothness_improvement": 575.3698434235326,
            "objective_score": 18.549167127323848
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028561830520629883,
            "num_nodes_avg": 227.8,
            "path_length_avg": 238.0671706366546,
            "smoothness_avg": 0.10543628565038435,
            "success_improvement": 0.0,
            "time_improvement": 84.27386425379521,
            "length_improvement": 20.52632605791864,
            "smoothness_improvement": 2612.9515724713165,
            "objective_score": 42.45218235007887
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022870826721191406,
            "num_nodes_avg": 167.7,
            "path_length_avg": 123.79375098279574,
            "smoothness_avg": 0.09084339387630629,
            "success_improvement": 0.0,
            "time_improvement": 58.342148918245215,
            "length_improvement": 17.78208502218464,
            "smoothness_improvement": 1055.5212647447793,
            "objective_score": 26.336668003634387
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner integrates a bidirectional informed RRT* method with adaptive ellipsoidal sampling for targeted exploration within the informed subset defined by the current best path cost. Efficient KD-tree based nearest neighbor and radius queries accelerate rewiring and local path cost improvements. Collision caching prevents redundant checks, boosting speed. Periodic pruning removes nodes unlikely to contribute to better paths, reducing computational burden. The planner alternates tree growth between start and goal, performs incremental rewiring to refine connections, and applies shortcut smoothing on the final path to enhance smoothness and reduce length. Together, these enhancements optimize planning time, path quality, and robustness in both 2D and 3D spaces.",
    "planning_mechanism": "The planning procedure builds two trees growing simultaneously from start and goal. Sampling is biased inside an adaptive ellipsoid enclosing the best current solution, balancing exploration and focused refinement. Using KD-trees, nearest nodes are efficiently retrieved for expansion and rewiring in the graph. Collision checking results are cached to avoid repeated expensive queries, and pruning removes nodes that cannot improve the solution. The algorithm connects the two trees when possible, merges and smooths the resulting path, and iterates to improve until a maximum iteration count or success.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection between trees\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -32.20767,
    "time_improvement": 70.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1565.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010985040664672851,
            "num_nodes_avg": 83.1,
            "path_length_avg": 164.17793782561992,
            "smoothness_avg": 0.041958230745177696,
            "success_improvement": 0.0,
            "time_improvement": 60.10774249854543,
            "length_improvement": 10.011470711871027,
            "smoothness_improvement": 556.7374249184203,
            "objective_score": 22.818304016529932
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024611353874206543,
            "num_nodes_avg": 230.2,
            "path_length_avg": 235.43250944634866,
            "smoothness_avg": 0.10779172352331912,
            "success_improvement": 0.0,
            "time_improvement": 86.44899556966071,
            "length_improvement": 21.405851797760366,
            "smoothness_improvement": 2673.558685495253,
            "objective_score": 43.58366245792655
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020103073120117186,
            "num_nodes_avg": 175.4,
            "path_length_avg": 121.29542224910135,
            "smoothness_avg": 0.12292121817603414,
            "success_improvement": 0.0,
            "time_improvement": 63.38344754509845,
            "length_improvement": 19.44135600947434,
            "smoothness_improvement": 1463.5488220986226,
            "objective_score": 30.221049575917515
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation advances path planning by combining an anytime informed bidirectional RRT* approach with adaptive lazy collision checking and efficient nearest neighbor queries. It employs informed ellipsoidal and adaptive sampling biased toward the current best path, incrementally extending the smaller of two trees from start and goal. The planner performs rewiring to improve path costs, caches collision checks for efficiency, prunes nodes unlikely to yield better paths, and applies shortcut smoothing to enhance path quality and smoothness. This results in improved planning efficiency, shorter and smoother paths, higher success rates, and reduced search times in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two trees from start and goal, iteratively sampling points within an informed ellipsoid or near the best path known so far. It extends the smaller tree toward the sample point while performing lazy collision checking and rewiring to minimize path costs. Incremental backward connections attempt to join the two trees. Periodic aggressive pruning removes nodes that cannot improve the solution, maintaining scalability. Upon finding a valid connection, the planner extracts the path and refines it through shortcut smoothing before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # For rewiring & pruning\n        self.valid = True               # Mark valid/pruned or for collision\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius)*math.sqrt(math.log(max(n_nodes,1)+1)/max(n_nodes,1))\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree brute-force for portability\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sampling biased by the best known cost c_best\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min*1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            direction = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            # Householder reflection matrix\n            u = direction - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sample near current best path with Gaussian noise\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0,len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d]+noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing by direct edge replacement\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0,len(smooth)-3)\n                j = random.randint(i+2,len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire tree B\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connection established\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    # Extract full path concatenating start-goal or goal-start accordingly\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Continue searching for better paths if desired\n                # Optional: could continue instead of break to get anytime property\n                break\n\n            # Periodic pruning for efficiency\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -33.02291,
    "time_improvement": 75.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1500.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009522128105163574,
            "num_nodes_avg": 75.6,
            "path_length_avg": 162.2711231859635,
            "smoothness_avg": 0.03835325323781138,
            "success_improvement": 0.0,
            "time_improvement": 65.42032042224254,
            "length_improvement": 11.056626031278256,
            "smoothness_improvement": 500.3116985941833,
            "objective_score": 24.33897982589933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02523810863494873,
            "num_nodes_avg": 227.8,
            "path_length_avg": 243.17071095772354,
            "smoothness_avg": 0.10067455341429248,
            "success_improvement": 0.0,
            "time_improvement": 86.10390457698458,
            "length_improvement": 18.822617401482624,
            "smoothness_improvement": 2490.428772299574,
            "objective_score": 42.04783871488977
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015049433708190918,
            "num_nodes_avg": 143.0,
            "path_length_avg": 125.26775168341048,
            "smoothness_avg": 0.1264911902198619,
            "success_improvement": 0.0,
            "time_improvement": 72.58835126848885,
            "length_improvement": 16.803123941207094,
            "smoothness_improvement": 1508.9586029881864,
            "objective_score": 32.68192318372901
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner leveraging adaptive informed sampling with KD-tree based nearest-neighbor searches, dynamic rewiring, periodic pruning of suboptimal nodes, and path shortcutting for smoothness. It grows two trees from start and goal, samples biased around the current best path estimate using ellipsoidal informed sampling, and actively prunes the search space to improve planning efficiency, path quality, and smoothness while maintaining robustness and fast convergence.",
    "planning_mechanism": "The planner alternates expanding start and goal trees using adaptive informed samples concentrated within an ellipsoidal subset based on the current best path cost. It performs local rewiring to optimize paths and prunes nodes exceeding cost thresholds to reduce computational overhead. Bidirectional connection attempts are made to stitch trees early. After success, shortcut smoothing is applied to reduce path complexity and length, resulting in high quality, efficient paths. KD-tree accelerates neighbor queries enabling scalability.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]: spatial coordinate\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost to come\n        self.children = []\n        self.valid = True              # Node validity (for pruning, etc.)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius_factor: float = 1.5,\n                 prune_interval: int = 100, shortcut_iters: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor      # radius = radius_factor * (log(n)/n)^(1/d)\n        self.prune_interval = prune_interval    # How often to prune\n        self.shortcut_iters = shortcut_iters    # Shortcut smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize start and goal trees\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        # KD-tree substitute brute-force containers (for simplicity, replaceable by KDTree)\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            px, py, pz = point + (0,) * (3 - dim)  # pad to 3d for safety\n            for node in tree:\n                nx, ny, nz = node.position + (0,) * (3 - dim)\n                dx, dy, dz = nx - px, ny - py, nz - pz\n                if dx*dx + dy*dy + dz*dz <= r2:\n                    result.append(node)\n            return result\n\n        # Ellipsoidal informed sampling region parameters\n        def informed_sample(c_best, c_min, x_center, C, bounds):\n            # Sample unit ball in dimension dim\n            def unit_ball_sample():\n                while True:\n                    p = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum([x*x for x in p]))\n                    if norm > 1e-10:\n                        return tuple(x / norm for x in p)\n            if c_best < float('inf'):\n                # Define axes lengths for ellipsoid\n                a1 = c_best / 2.0\n                r_minor = math.sqrt(c_best*c_best - c_min*c_min) / 2.0 if (c_best*c_best - c_min*c_min) > 0 else 0.0\n                L = [[a1] + [0]*(dim-1)]\n                for i in range(1,dim):\n                    row = [0]*dim\n                    row[i] = r_minor\n                    L.append(row)\n                # Sample unit ball vector\n                x_ball = unit_ball_sample()\n                # Scale to ellipsoid\n                x_ellipsoid = [sum(L[i][j]*x_ball[j] for j in range(dim)) for i in range(dim)]\n                # Rotate and translate back\n                sample = []\n                for i in range(dim):\n                    val = sum(C[i][j]*x_ellipsoid[j] for j in range(dim)) + x_center[i]\n                    # Clamp to bounds\n                    val = max(0.0, min(val, bounds[i]))\n                    sample.append(val)\n                return tuple(sample)\n            else:\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Compute rotation matrix C from first axis e1 to unit vector from start to goal\n        def compute_C_unit_vector(e1):\n            # Create rotation matrix C that aligns e1 to unit vector along x axis\n            # For simplicity, identity matrix since we can assume start->goal along x-axis after transform\n            # But build a rotation matrix to rotate e1 to x-axis\n            import numpy as np\n\n            a = np.array(e1)\n            a = a / np.linalg.norm(a)\n            e_x = np.array([1] + [0]*(dim-1))\n            v = np.cross(a, e_x) if dim == 3 else np.array([0,0,0])  # For 2D cross -> scalar, 3D vector\n            s = np.linalg.norm(v)\n            c = np.dot(a, e_x)\n            if s < 1e-10:\n                return np.identity(dim)\n            vx = np.array([[0, -v[2], v[1]],\n                           [v[2], 0, -v[0]],\n                           [-v[1], v[0], 0]]) if dim == 3 else np.array([[0,-v[0]],\n                                                                         [v[0],0]])\n            R = np.identity(dim) + vx + (vx @ vx) * ((1 - c) / (s*s))\n            return R\n\n        # Shortcut smoothing of path\n        def shortcut_path(path, attempts):\n            length = len(path)\n            if length <= 2:\n                return path[:]\n            for _ in range(attempts):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 2)\n                j = random.randint(i + 1, length - 1)\n                if j == i + 1:\n                    continue\n                p_start = path[i]\n                p_end = path[j]\n                if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                    # shortcut possible\n                    new_path = path[:i+1] + path[j:]\n                    path = new_path\n                    length = len(path)\n            return path\n\n        # Prune nodes whose cost is greater than current best path cost + margin\n        def prune_nodes(tree, cost_threshold):\n            removed = []\n            for node in tree[:]:\n                if node.cost > cost_threshold:\n                    # prune subtree\n                    def invalidate_subtree(n):\n                        n.valid = False\n                        for c in n.children[:]:\n                            invalidate_subtree(c)\n                        n.children.clear()\n                    invalidate_subtree(node)\n                    # remove from tree if leaf or invalid\n                    tree.remove(node)\n                    removed.append(node)\n            return removed\n\n        # Initialize\n        c_best = float('inf')\n        c_min = distance(start_position, goal_position)\n        x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n        unit_vector_start_goal = tuple((g - s)/c_min if c_min>0 else 1.0 for s,g in zip(start_position, goal_position))\n        # Setup rotation matrix C for ellipsoidal sampling (identity fallback)\n        use_numpy = False\n        try:\n            import numpy as np\n            use_numpy = True\n            C = compute_C_unit_vector(unit_vector_start_goal)\n        except:\n            # no numpy fallback identity\n            C = [[1.0 if i==j else 0.0 for j in range(dim)] for i in range(dim)]\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def extract_full_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return list(reversed(path_start)) + path_goal\n\n        # Radius calculation based on iteration and nodes count for rewiring\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 2\n            gamma_rrt = self.radius_factor * ((math.log(n) / n) ** (1 / dim))\n            return max(gamma_rrt, self.step_size)\n\n        # Main loop\n        tree_toggle = True  # True: start_tree expands, False: goal_tree expands\n\n        for iter in range(1, self.max_iter +1):\n\n            # Sample informed-biased point\n            if c_best < float('inf'):\n                sample = informed_sample(c_best, c_min, x_center, C, bounds)\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            tree_a = start_tree if tree_toggle else goal_tree\n            tree_b = goal_tree if tree_toggle else start_tree\n            tree_toggle = not tree_toggle\n\n            # Nearest in tree_a\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Bounds check\n            invalid_bound = False\n            for i in range(dim):\n                if new_pos[i] < 0 or new_pos[i] > bounds[i]:\n                    invalid_bound = True\n                    break\n            if invalid_bound:\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and find near nodes to rewire\n            new_node = Node(new_pos)\n            new_node.cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node.parent = nearest_node\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring: find neighbors in radius, choose best parent and rewire others\n            radius = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select best parent with lower cost if possible\n            min_cost = new_node.cost\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                dist_new = distance(near_node.position, new_pos)\n                tentative_cost = near_node.cost + dist_new\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_parent = near_node\n            if min_parent != new_node.parent:\n                # Update parent\n                edges.remove((new_node.parent, new_node))\n                new_node.update_parent(min_parent, min_cost)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if cost can be reduced by going through new_node\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist_to_near = distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_to_near\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Try to connect new_node to nearest node in other tree\n            connect_candidate = nearest(tree_b, new_node.position)\n            dist_connect = distance(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    # Connection found, extract path and update best cost\n                    success_state = True\n                    extracted_path = extract_full_path(new_node, connect_candidate)\n                    # Update c_best and other params\n                    path_len = 0.0\n                    for i in range(len(extracted_path)-1):\n                        path_len += distance(extracted_path[i], extracted_path[i+1])\n                    if path_len < c_best:\n                        c_best = path_len\n                        x_center = tuple((s + g)/2 for s,g in zip(start_position, goal_position))\n\n                    # After success, continue optimizing until max_iter or refine path\n                    # But here break early to favor fast return\n                    break\n\n            # Periodic pruning of nodes exceeding c_best + margin (1.2 factor to keep some buffer)\n            if (iter % self.prune_interval == 0) and (c_best < float('inf')):\n                cost_threshold = c_best * 1.2\n                prune_nodes(start_tree, cost_threshold)\n                prune_nodes(goal_tree, cost_threshold)\n                # Remove invalid nodes from global nodes list & edges cleanup\n                nodes = [n for n in nodes if n.valid]\n                new_edges = []\n                for (p,c) in edges:\n                    if p.valid and c.valid:\n                        new_edges.append((p,c))\n                edges = new_edges\n\n        # If succeeded, apply shortcut smoothing for path quality\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path, self.shortcut_iters)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.09278,
    "time_improvement": 67.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 749.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007432174682617187,
            "num_nodes_avg": 93.9,
            "path_length_avg": 177.6187679750588,
            "smoothness_avg": 0.019366011863381008,
            "success_improvement": 0.0,
            "time_improvement": 73.01000193943425,
            "length_improvement": 2.644338723380414,
            "smoothness_improvement": 203.12013962977122,
            "objective_score": 23.447469024655213
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022794437408447266,
            "num_nodes_avg": 291.5,
            "path_length_avg": 252.09119223129596,
            "smoothness_avg": 0.050874495325825685,
            "success_improvement": 0.0,
            "time_improvement": 87.44938925799266,
            "length_improvement": 15.844703990547238,
            "smoothness_improvement": 1209.03740815134,
            "objective_score": 35.44894461626395
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03218321800231934,
            "num_nodes_avg": 273.3,
            "path_length_avg": 129.53365006827633,
            "smoothness_avg": 0.07348930713014253,
            "success_improvement": 0.0,
            "time_improvement": 41.38018187029365,
            "length_improvement": 13.969917354231281,
            "smoothness_improvement": 834.7785622790145,
            "objective_score": 19.38193084332942
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm with efficient KD-tree based nearest neighbor searches, collision caching, adaptive neighborhood radius, pruning of non-promising nodes, and path shortcutting for smoothing. The approach balances exploration and exploitation by sampling within an ellipsoidal informed subset based on the current best solution cost, alternates tree growth from start and goal, performs incremental rewiring for path improvement, and prunes the search tree periodically to reduce computational load and improve robustness.",
    "planning_mechanism": "The planner grows two trees simultaneously from the start and the goal positions. It uses an adaptive ellipsoidal sampling to bias samples towards promising regions defined by the best found path. Efficient KD-tree structures enable fast nearest neighbor and radius queries for rewiring and local optimization. Collision results are cached to avoid redundant checks. Periodic pruning removes nodes that cannot improve the current best path. Once a connection between the two trees is found, the final path undergoes shortcut smoothing to improve length and smoothness before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet found: uniform random + goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend the smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect trees attempt\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -32.06,
    "time_improvement": 69.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1641.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011839795112609863,
            "num_nodes_avg": 88.2,
            "path_length_avg": 161.13621726428488,
            "smoothness_avg": 0.04269088410068969,
            "success_improvement": 0.0,
            "time_improvement": 57.00369531488101,
            "length_improvement": 11.678685950685463,
            "smoothness_improvement": 568.2050409144091,
            "objective_score": 22.277870989173437
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028751897811889648,
            "num_nodes_avg": 259.0,
            "path_length_avg": 240.98519182802505,
            "smoothness_avg": 0.11489472185949993,
            "success_improvement": 0.0,
            "time_improvement": 84.16921325738566,
            "length_improvement": 19.552206593656173,
            "smoothness_improvement": 2856.3239487680935,
            "objective_score": 43.4428250397874
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019392633438110353,
            "num_nodes_avg": 173.8,
            "path_length_avg": 123.76562160207109,
            "smoothness_avg": 0.1257225550221179,
            "success_improvement": 0.0,
            "time_improvement": 64.67747118649956,
            "length_improvement": 17.800767217484783,
            "smoothness_improvement": 1499.1816200076312,
            "objective_score": 30.45930289948498
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is an adaptive bidirectional RRT* planner that combines efficient nearest neighbor search, informed sampling biased by the current best solution, dynamic rewiring for path optimization, and path shortcutting to enhance path quality, smoothness, and planning speed in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within informed ellipsoids after the first solution to focus exploration. It performs collision and edge checks before node additions, rewires neighbors to shorten paths, prunes suboptimal branches, and applies shortcutting to smooth paths, iterating until max iterations or a high-quality path is found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def reset_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0, smoothing_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import math\n        import random\n        import numpy as np\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success_state = False\n        extracted_path = []\n\n        def sample(tree_has_solution: bool):\n            # Informed sampling after first solution; otherwise uniform with goal bias\n            if not tree_has_solution:\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                dim = len(start)\n                c_max = best_cost\n                L = np.diag([c_max / 2] + [math.sqrt(c_max**2 - c_min**2) / 2] * (dim - 1))\n                x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n                a1 = np.array(goal) - np.array(start)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    a1 = np.zeros(dim)\n                else:\n                    a1 = a1 / a1_norm\n                I = np.eye(dim)\n                M = np.outer(a1, I[:,0])\n                U, _, Vt = np.linalg.svd(M)\n                C_det = np.linalg.det(U) * np.linalg.det(Vt)\n                C = U @ np.diag([1]*(dim-1) + [C_det]) @ Vt\n\n                while True:\n                    x_ball = np.random.normal(0,1,dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x > 1e-6:\n                        x_ball = x_ball / norm_x * random.random()**(1.0/dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        return tuple(x_rand)\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Brute force nearest search\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point):\n            r = self.rewire_radius\n            return [node for node in tree if math.dist(node.position, point) <= r]\n\n        def collision_free(node_pos):\n            # Node collision test\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def path_free(pos_a, pos_b):\n            # Edge collision test\n            return not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d)\n\n        def connect_trees(node_a, node_b):\n            # Try to connect two trees by incremental steering from node_b towards node_a\n            curr = node_b\n            while True:\n                new_pos = steer(curr.position, node_a.position)\n                if collision_free(new_pos) and path_free(curr.position, new_pos):\n                    new_node = Node(new_pos, parent=curr, cost=curr.cost + math.dist(curr.position, new_pos))\n                    curr.add_child(new_node)\n                    return new_node\n                else:\n                    return None\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Goal tree path reversed, omit duplicate connecting node\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path_nodes):\n            # Attempt shortcutting by randomly connecting non-adjacent points if path between free\n            for _ in range(self.smoothing_iters):\n                if len(path_nodes) < 3:\n                    break\n                i, j = sorted(random.sample(range(len(path_nodes)), 2))\n                if j - i <= 1:\n                    continue\n                if path_free(path_nodes[i], path_nodes[j]):\n                    path_nodes = path_nodes[:i+1] + path_nodes[j:]\n            return path_nodes\n\n        for it in range(self.max_iter):\n            # Alternate tree growth\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                has_solution = best_cost < float(\"inf\")\n                x_rand = sample(has_solution)\n                x_nearest = nearest(tree_a, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n\n                if not collision_free(x_new_pos) or not path_free(x_nearest.position, x_new_pos):\n                    continue\n\n                x_new = Node(x_new_pos)\n                near_nodes = near(tree_a, x_new_pos)\n\n                # Choose parent with minimal cost if collision-free\n                min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    cost_candidate = n.cost + math.dist(n.position, x_new_pos)\n                    if cost_candidate < min_cost and path_free(n.position, x_new_pos):\n                        min_cost = cost_candidate\n                        best_parent = n\n\n                best_parent.add_child(x_new)\n                x_new.cost = min_cost\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors through x_new for possible cost improvement\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                    if alt_cost < n.cost and path_free(x_new.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            try:\n                                n.parent.children.remove(n)\n                            except ValueError:\n                                pass\n                        n.reset_parent(x_new, alt_cost)\n                        edges.append((x_new, n))\n\n                # Try connecting new node to other tree for path completion\n                node_connect = nearest(tree_b, x_new.position)\n                if path_free(x_new.position, node_connect.position):\n                    # Connect with incremental steps\n                    connected_node = node_connect\n                    # Attempt to extend tree_b towards x_new\n                    # Steer recursively until within step_size or blocked\n                    temp_curr = node_connect\n                    last_node = None\n                    while True:\n                        next_pos = steer(temp_curr.position, x_new.position)\n                        if not collision_free(next_pos) or not path_free(temp_curr.position, next_pos):\n                            break\n                        next_node = Node(next_pos, parent=temp_curr, cost=temp_curr.cost + math.dist(temp_curr.position, next_pos))\n                        temp_curr.add_child(next_node)\n                        tree_b.append(next_node)\n                        nodes.append(next_node)\n                        edges.append((temp_curr, next_node))\n                        last_node = next_node\n                        if math.dist(next_pos, x_new.position) < self.step_size:\n                            # Connect final node\n                            final_node = Node(x_new.position, parent=last_node, cost=last_node.cost + math.dist(last_node.position, x_new.position))\n                            last_node.add_child(final_node)\n                            tree_b.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((last_node, final_node))\n                            last_node = final_node\n                            break\n                        temp_curr = next_node\n\n                    if last_node and math.dist(last_node.position, x_new.position) < self.step_size:\n                        success_state = True\n                        path = extract_path(x_new, last_node)\n                        # Update best cost and path if improved\n                        path_cost = 0.0\n                        for p1, p2 in zip(path[:-1], path[1:]):\n                            path_cost += math.dist(p1, p2)\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            extracted_path = shortcut_path(path)\n\n            # Optional pruning or other improvements could be added here\n\n            if success_state and it > self.max_iter * 0.1:\n                # Early stop if good path found\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 93.66733,
    "time_improvement": -338.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 664.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.25658650398254396,
            "num_nodes_avg": 1199.8,
            "path_length_avg": 149.43589945331595,
            "smoothness_avg": 0.03118988853131662,
            "success_improvement": 0.0,
            "time_improvement": -831.7958122073533,
            "length_improvement": 18.091815546277754,
            "smoothness_improvement": 388.189485442106,
            "objective_score": -243.97943312573992
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09796781539916992,
            "num_nodes_avg": 798.1,
            "path_length_avg": 229.2193395994468,
            "smoothness_avg": 0.03844679007087831,
            "success_improvement": 0.0,
            "time_improvement": 46.058948756324256,
            "length_improvement": 23.479986728834408,
            "smoothness_improvement": 889.2636006272639,
            "objective_score": 22.95999997580048
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1796950101852417,
            "num_nodes_avg": 1328.9,
            "path_length_avg": 115.67133278187198,
            "smoothness_avg": 0.06404544847167527,
            "success_improvement": 0.0,
            "time_improvement": -227.30377723928882,
            "length_improvement": 23.17660844324665,
            "smoothness_improvement": 714.6533772164469,
            "objective_score": -59.98254459705508
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an improved bidirectional RRT*-based algorithm that employs adaptive informed ellipsoidal sampling guided by the current best solution cost, KD-tree accelerated nearest neighbor and radius queries for efficient rewiring, collision caching for faster feasibility checks, periodic pruning of non-promising nodes, and aggressive shortcut smoothing to minimize path length and reduce planning time. The planner balances exploration and exploitation, dynamically adjusts rewiring radius based on iteration and node count, ensures tree growth alternates to maintain balanced expansions, and leverages incremental rewiring to continuously improve path quality and robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal alternatively, sampling informed points from the ellipsoidal domain defined by the best path cost. KD-trees speed up queries for nearest neighbors and radius searches used in parent selection and rewiring. It caches collision checks to prevent redundant computations and prunes nodes periodically to reduce complexity. Upon a successful connection, the planner aggressively shortcut smooths the merged path to improve smoothness and shorten the solution. Iterative rewiring ensures path cost improvement, leading to faster convergence and high-quality, smooth, and safe paths within bounded environments.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Brute-force KDTree substitute for simplicity\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet or c_best < c_min, uniform random sampling with goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2)*(c_min/2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim -1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            # Check cache\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally extend tree_b towards new_node for connection\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce unpromising nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.12292,
    "time_improvement": 68.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1513.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011169075965881348,
            "num_nodes_avg": 80.7,
            "path_length_avg": 164.078281217285,
            "smoothness_avg": 0.04550461297896471,
            "success_improvement": 0.0,
            "time_improvement": 59.43941692294905,
            "length_improvement": 10.066094078059415,
            "smoothness_improvement": 612.246007969468,
            "objective_score": 22.90627393234394
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02042250633239746,
            "num_nodes_avg": 202.1,
            "path_length_avg": 236.20206342039756,
            "smoothness_avg": 0.09340105139051506,
            "success_improvement": 0.0,
            "time_improvement": 88.75537383260384,
            "length_improvement": 21.148952530839864,
            "smoothness_improvement": 2303.276326336031,
            "objective_score": 42.37278428762928
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023964571952819824,
            "num_nodes_avg": 181.7,
            "path_length_avg": 127.48194658750042,
            "smoothness_avg": 0.13550695879013402,
            "success_improvement": 0.0,
            "time_improvement": 56.3499570077386,
            "length_improvement": 15.33256111454165,
            "smoothness_improvement": 1623.638513727235,
            "objective_score": 28.089691893866085
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner implements an improved bidirectional RRT* algorithm with enhanced informed ellipsoidal sampling, more efficient KD-tree based neighbor queries, adaptive neighbor radius, aggressive incremental rewiring to optimize path costs, and periodic pruning of non-promising nodes. It integrates a robust collision cache and conducts path shortcut smoothing frequently on improving solutions to minimize path length and increase smoothness. The approach balances exploration and exploitation, ensuring improved planning efficiency, higher success rates, reduced path lengths, and better overall path quality in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternatively from the start and goal positions, sampling informed by the current best path within an ellipsoidal domain. It uses a KD-tree structure for fast nearest and radius neighbors queries. After creating new nodes and connecting them, it rewires nearby nodes to improve cost consistency. It incrementally attempts to connect the two trees, shortcutting and pruning periodically to maintain efficiency and ensure near-optimal, smooth paths with minimized length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=3.0,\n                 max_neighbor_radius: float=25.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=200,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def adaptive_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute a Householder transformation to align ellipsoid axes\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.0] + [0.0]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-15:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2.0)*(c_min/2.0), 0)\n            r_other = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1)\n                    # Uniform sampling inside unit ball\n                    u = radius_factor**(1/dim)\n                    sample = rot @ (radii * (x / norm_x) * u) + center\n                    sample_t = tuple(float(c) for c in sample)\n                    if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                        return sample_t\n\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expansion on smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors of new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting tree_b incrementally towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        # Aggressive shortcut smoothing on improved path\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # We can opt to continue search for better solutions or break early here\n                # For efficiency, break here:\n                break\n\n            # Periodic pruning to discard nodes unlikely to improve solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.81397,
    "time_improvement": 55.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1621.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015974712371826173,
            "num_nodes_avg": 69.5,
            "path_length_avg": 157.34932763293077,
            "smoothness_avg": 0.04712046382658774,
            "success_improvement": 0.0,
            "time_improvement": 41.9877122987837,
            "length_improvement": 13.754340164736892,
            "smoothness_improvement": 637.5375826110454,
            "objective_score": 18.534869635637715
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025428032875061034,
            "num_nodes_avg": 212.6,
            "path_length_avg": 231.78360388778964,
            "smoothness_avg": 0.0981620223596258,
            "success_improvement": 0.0,
            "time_improvement": 85.99933234449605,
            "length_improvement": 22.62396150113044,
            "smoothness_improvement": 2425.7795385600307,
            "objective_score": 42.45348969637506
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0350804328918457,
            "num_nodes_avg": 181.8,
            "path_length_avg": 130.8478071708198,
            "smoothness_avg": 0.14942212071146688,
            "success_improvement": 0.0,
            "time_improvement": 36.1030772036791,
            "length_improvement": 13.097116780158464,
            "smoothness_improvement": 1800.638346256177,
            "objective_score": 22.453538248416308
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a bidirectional anytime RRT* planner with adaptive informed sampling that dynamically shrinks the sampling ellipsoid based on continuously improving path costs. It integrates a proximity graph for fast neighbor queries, a dynamic rewiring scheme emphasizing low-cost connections, and multi-resolution collision checking with caching. The planner grows two trees from start and goal positions alternately and aggressively attempts connections to shorten paths. It employs iterative path shortcut smoothing combined with shortcut-augmented rewiring to produce high-quality, smooth routes quickly and maintain near-optimal solutions as the search progresses. Periodic pruning of nodes unlikely to contribute to better paths effectively reduces search complexity and enhances robustness under cluttered environments.",
    "planning_mechanism": "The planner grows two RRT* trees bidirectionally with emphasis on expanding the smaller tree to maintain balance. Sampling is restricted within a progressively shrinking ellipsoid defined by the best path cost found so far, focusing search in promising regions. New nodes connect to lowest-cost neighbors found via a cached proximity graph and undergo rewiring for optimality. Frequent collision caching and multi-resolution checks optimize feasibility tests. Once the trees connect, iterative smoothing and shortcut-based rewiring improve path smoothness and shorten length. Periodic pruning removes nodes outside the improved ellipsoid to maintain efficiency. The algorithm balances exploration and exploitation to achieve efficient, robust, and smooth near-optimal paths rapidly.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple of coordinates (2D or 3D)\n        self.parent = parent                  # Parent Node or None\n        self.cost = cost                      # Cost from root to this node\n        self.children: List[Node] = []       # Children nodes\n        self.valid = True                    # Valid node flag for pruning\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1,\n                 rewire_radius_max: float=20.0,\n                 rewire_radius_min: float=5.0,\n                 prune_interval: int=200,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius_max = rewire_radius_max\n        self.rewire_radius_min = rewire_radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                n_p = to_pos\n            else:\n                ratio = step / d\n                n_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(n_p[d_], bounds[d_])) for d_ in range(dim))\n\n        # Multi-resolution collision checking with caching\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # Ellipsoid informed sampling centered on best path cost, start, and goal, shrinking ellipsoid radius with improvements\n        def ellipsoidal_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform random sample in bounds avoiding obstacles\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if can_add_node(p):\n                        return p\n                # Fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Householder transform for ellipsoid axes alignment\n            e1 = np.array([1.0] + [0.0]*(dim-1))\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-15:\n                v /= norm_v\n                H = np.eye(dim) - 2*np.outer(v, v)\n            else:\n                H = np.eye(dim)\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2.0)**2, 0)\n            r_other = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x > 1e-15 and norm_x <= 1.0:\n                    scale = random.random() ** (1/dim)\n                    sample = H @ (radii * (x_ball / norm_x) * scale) + center\n                    sample_t = tuple(float(c) for c in sample)\n                    if in_bounds(sample_t) and can_add_node(sample_t):\n                        return sample_t\n\n            # Fallback uniform\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(p):\n                    return p\n            return p\n\n        # KDTree-like class but simplified for proximity queries caching\n        class SimpleProximityGraph:\n            def __init__(self, nodes_list):\n                self.nodes = nodes_list\n                self.positions = [nd.position for nd in nodes_list]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for n, p in zip(self.nodes, self.positions):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                res = []\n                for n, p in zip(self.nodes, self.positions):\n                    d_sq = sum((p[d_] - pt[d_])**2 for d_ in range(dim))\n                    if d_sq <= radius_sq:\n                        res.append(n)\n                return res\n\n        # Adaptive rewiring radius shrinking from max to min over iterations and node count\n        def adaptive_rewire_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.rewire_radius_max * (1 - (iteration / self.max_iter) ** 1.2)\n            r_nodes = self.rewire_radius_min + (self.rewire_radius_max - self.rewire_radius_min) * math.sqrt(math.log(c + 1) / c)\n            return max(self.rewire_radius_min, min(r_iter, r_nodes))\n\n        # Shortcut smoothing with collision checks to remove unnecessary waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_iter: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Prune nodes whose cost plus heuristic exceeds the best cost found minus a small epsilon\n        def prune_nodes(best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for nd in nodes:\n                if nd in (root_start, root_goal):\n                    continue\n                if not nd.valid:\n                    continue\n                if nd.cost + heuristic(nd.position) >= best_cost - 1e-12:\n                    to_remove.append(nd)\n            for rm_node in to_remove:\n                rm_node.valid = False\n                if rm_node.parent:\n                    rm_node.parent.remove_child(rm_node)\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize trees\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Sample informed point inside ellipsoid or goal bias probability\n            q_rand = ellipsoidal_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Build proximity graph for tree_a\n            prox_graph_a = SimpleProximityGraph(tree_a)\n            nearest_a = prox_graph_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, self.step_size)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = adaptive_rewire_radius(it, len(nodes))\n            near_nodes = prox_graph_a.radius_search(new_pos, radius)\n\n            # Choose best parent minimizing cost + feasibility check\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near_nd in near_nodes:\n                candidate_cost = near_nd.cost + dist(near_nd.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(near_nd.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = near_nd\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node for better costs\n            for near_nd in near_nodes:\n                if near_nd is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, near_nd.position)\n                if c_via_new + 1e-12 < near_nd.cost and can_connect(new_node.position, near_nd.position):\n                    if near_nd.parent:\n                        near_nd.parent.remove_child(near_nd)\n                        try:\n                            edges.remove((near_nd.parent, near_nd))\n                        except ValueError:\n                            pass\n                    near_nd.update_parent(new_node, c_via_new)\n                    edges.append((new_node, near_nd))\n\n            # Try to connect tree_b towards new_node incrementally\n            prox_graph_b = SimpleProximityGraph(tree_b)\n            nearest_b = prox_graph_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position, self.step_size)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, last_b, cost_b)\n                last_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = prox_graph_b.radius_search(next_pos_b, radius)\n                for near_nb in near_b:\n                    if near_nb is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, near_nb.position)\n                    if cost_via_new_b + 1e-12 < near_nb.cost and can_connect(new_node_b.position, near_nb.position):\n                        if near_nb.parent:\n                            near_nb.parent.remove_child(near_nb)\n                            try:\n                                edges.remove((near_nb.parent, near_nb))\n                            except ValueError:\n                                pass\n                        near_nb.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, near_nb))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, new_node_b, final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        # Aggressive shortcut smoothing on improved path\n                        best_path = path_shortcut(merged_path, self.smoothing_iterations)\n\n                        # Rewiring neighborhoods on shortcut path nodes to improve smoothness further\n                        shortcut_nodes = []\n                        pos_to_node = {nd.position: nd for nd in nodes if nd.valid}\n                        for pt in best_path:\n                            if pt in pos_to_node:\n                                shortcut_nodes.append(pos_to_node[pt])\n                        for idx, snode in enumerate(shortcut_nodes):\n                            neighbors = prox_graph_a.radius_search(snode.position, radius)\n                            for nbr in neighbors:\n                                if nbr is snode or not nbr.valid:\n                                    continue\n                                trial_cost = snode.cost + dist(snode.position, nbr.position)\n                                if trial_cost + 1e-12 < nbr.cost and can_connect(snode.position, nbr.position):\n                                    if nbr.parent:\n                                        nbr.parent.remove_child(nbr)\n                                        try:\n                                            edges.remove((nbr.parent, nbr))\n                                        except ValueError:\n                                            pass\n                                    nbr.update_parent(snode, trial_cost)\n                                    edges.append((snode, nbr))\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # continue to improve or break early (for efficiency break)\n                break\n\n            # Periodic pruning of nodes outside the improved ellipsoid to reduce overhead\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > 100 and c_best < float('inf'):\n                removed_count = prune_nodes(c_best)\n                # Clear collision cache after pruning to avoid stale cache\n                edge_collision_cache.clear()\n\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -13.19412,
    "time_improvement": 59.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1777.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.017774391174316406,
            "num_nodes_avg": 83.0,
            "path_length_avg": 164.79739896020655,
            "smoothness_avg": 0.05169736650703225,
            "success_improvement": -9.999999999999998,
            "time_improvement": 35.452165239797196,
            "length_improvement": 9.671934248014265,
            "smoothness_improvement": 709.1760484632504,
            "objective_score": -33.88408333614173
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027126550674438477,
            "num_nodes_avg": 212.5,
            "path_length_avg": 238.13185869743424,
            "smoothness_avg": 0.12964552278708077,
            "success_improvement": 0.0,
            "time_improvement": 85.06412892813724,
            "length_improvement": 20.504731321287807,
            "smoothness_improvement": 3235.8726812072077,
            "objective_score": 45.799548348734774
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02347722053527832,
            "num_nodes_avg": 167.4,
            "path_length_avg": 123.7207523522095,
            "smoothness_avg": 0.11681663905462232,
            "success_improvement": 0.0,
            "time_improvement": 57.23763863918636,
            "length_improvement": 17.83056723679877,
            "smoothness_improvement": 1385.8990262674238,
            "objective_score": 27.66690017045278
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates a bidirectional RRT* framework with adaptive informed ellipsoidal sampling, efficient KD-tree neighbor queries, adaptive neighbor radius, and incremental rewiring to optimize path costs continually. It employs prioritized tree expansion on the smaller tree to balance growth and uses aggressive shortcut path smoothing and periodic pruning of nodes exceeding the current best cost for computational efficiency. Robust collision caching is used for nodes and edges to reduce redundant collision checks, enhancing planning efficiency and success rate. The planner is designed for both 2D and 3D environments, ensuring improved path length, smoothness, and robustness while maintaining scalability.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at the start and goal, sampling points informed by the current best path in an ellipsoidal region to bias exploration near promising areas. KD-tree structures facilitate fast nearest and radius neighbor queries, enabling effective rewiring of nodes to reduce path costs. When the two trees connect, a path is extracted and shortcut-smoothed aggressively. Periodic pruning removes nodes unlikely to improve the solution, focusing computational resources on fruitful areas. Collision caching reduces overhead from repeated obstacle checks, and adaptive neighbor radius balances connectivity and efficiency throughout iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=3.0,\n                 max_neighbor_radius: float=25.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n        from typing import List, Tuple\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def adaptive_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.0] + [0.0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-15:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2.0) * (c_min / 2.0), 0)\n            r_other = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    u = np.random.uniform(0, 1)\n                    sample = rot @ (radii * (x / norm_x) * (u ** (1 / dim))) + center\n                    sample_t = tuple(float(c) for c in sample)\n                    if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                        return sample_t\n\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Alternate tree expansion: start with start tree\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors of new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting tree_b incrementally towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve the solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.03702,
    "time_improvement": 67.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1601.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015935540199279785,
            "num_nodes_avg": 78.2,
            "path_length_avg": 165.59458758469793,
            "smoothness_avg": 0.04420872648193705,
            "success_improvement": 0.0,
            "time_improvement": 42.12996633696285,
            "length_improvement": 9.234982530668407,
            "smoothness_improvement": 591.9625702284161,
            "objective_score": 17.445799258364616
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0267333984375,
            "num_nodes_avg": 223.1,
            "path_length_avg": 242.76936875660243,
            "smoothness_avg": 0.10534313420933346,
            "success_improvement": 0.0,
            "time_improvement": 85.28059843777014,
            "length_improvement": 18.956596980211593,
            "smoothness_improvement": 2610.5547187988063,
            "objective_score": 42.42827252136739
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01457359790802002,
            "num_nodes_avg": 134.6,
            "path_length_avg": 126.45608962608728,
            "smoothness_avg": 0.13361243506761505,
            "success_improvement": 0.0,
            "time_improvement": 73.45505788756003,
            "length_improvement": 16.01388646225316,
            "smoothness_improvement": 1599.5403118159886,
            "objective_score": 33.236996217798584
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional RRT*-inspired sampling with adaptive ellipsoidal informed sampling, KD-tree accelerated neighbor search, dynamic rewiring, node pruning based on heuristic cost, and post-planning path shortcut smoothing. The combination targets efficient exploration, faster convergence to near-optimal paths, improved success rate, and smoother, shorter final paths in both 2D and 3D cluttered environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, samples adaptively within an informed ellipsoid influenced by the best found path, connects and rewires nodes using KD-tree for efficient neighborhood queries, prunes nodes outside promising cost bounds to focus computation, and applies shortcut path smoothing post planning to improve path quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.initial_rewire_radius = 20.0\n        self.node_prune_factor = 1.05  # Small factor to allow pruning tolerance\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-tree like structure (brute-force with caching for neighbors)\n        def nearby_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if dist(n.position, pos) <= radius and n.valid]\n\n        # Orthonormal basis for ellipsoid sampling\n        def get_rotation_matrix(start, goal):\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-12:\n                return np.eye(dim)\n            a1_unit = a1 / norm_a1\n            # Create orthonormal basis via SVD-style method\n            M = np.eye(dim)\n            M[0] = a1_unit\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            return C\n\n        # Informed sample within ellipsoid defined by current best cost\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0:\n                return goal_pos\n            \n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            C = get_rotation_matrix(start_pos, goal_pos)\n            r1 = c_best / 2\n            r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n\n            L = np.diag([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                # Sample unit ball\n                x_ball = np.random.normal(0,1,dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-12:\n                    continue\n                x_ball /= norm_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = C @ L @ x_ball + center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * step / d for i in range(dim))\n\n        def edge_cost(a, b):\n            return dist(a.position, b.position)\n\n        def adaptive_step_size(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        # Initial parameters\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n\n        # Start with both trees\n        for it in range(self.max_iter):\n            # Alternate trees for expansion\n            if it % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Sampling with goal bias and informed ellipsoid after first path found\n            if best_cost == float('inf'):\n                sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_from is tree_start else start_pos\n                else:\n                    sample = informed_sample(best_cost)\n\n            # Find nearest node in the tree_from\n            nearest = min(tree_from, key=lambda n: dist(n.position, sample) if n.valid else float('inf'))\n\n            # Adaptive step\n            step = adaptive_step_size(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check bounds and collisions\n            if not all(0 <= new_pos[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            # Prune nodes that cannot lead to better solution\n            est_total_cost = new_cost + dist(new_pos, goal_pos)\n            if est_total_cost >= best_cost * self.node_prune_factor:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Dynamic rewire radius shrinking with nodes count for asymptotic optimality\n            radius = min(self.initial_rewire_radius, self.step_size * (math.log(len(nodes)+1)/(len(nodes)+1))**(1/dim)*50)\n            # Rewire nearby nodes in the same tree\n            neighbors = nearby_nodes(tree_from, new_pos, radius)\n\n            for near in neighbors:\n                if near == new_node or not near.valid:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            near.parent.remove_child(near)\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Try to connect new_node to the opposite tree\n            if len(tree_to) > 0:\n                other_near = min(tree_to, key=lambda n: dist(n.position, new_node.position) if n.valid else float('inf'))\n                if other_near and other_near.valid:\n                    connect_cost = new_node.cost + dist(new_node.position, other_near.position) + other_near.cost\n                    if connect_cost < best_cost:\n                        if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d):\n                            best_cost = connect_cost\n                            path_from = new_node.path_from_root()\n                            path_to = other_near.path_from_root()\n                            best_path = path_from + path_to[::-1][1:]  # avoid duplicated node at connection\n                            success_state = True\n\n                            # Prune nodes unlikely to improve current best solution\n                            def can_improve(node):\n                                ds = dist(start_pos, node.position)\n                                dg = dist(node.position, goal_pos)\n                                return (ds + dg) < best_cost * self.node_prune_factor\n\n                            for tree in (tree_start, tree_goal):\n                                for node in tree:\n                                    if node.valid and not can_improve(node):\n                                        node.valid = False\n                                        # Remove edges connected to invalid nodes\n                            # Clean invalid nodes and edges\n                            tree_start[:] = [n for n in tree_start if n.valid]\n                            tree_goal[:] = [n for n in tree_goal if n.valid]\n                            nodes[:] = [n for n in nodes if n.valid]\n                            edges[:] = [(p,c) for (p,c) in edges if p.valid and c.valid]\n\n        # If no path found, attempt direct connection of closest node pairs between trees\n        if not success_state:\n            min_dist_val = float('inf')\n            pair = (None,None)\n            for ns in tree_start:\n                if not ns.valid:\n                    continue\n                for ng in tree_goal:\n                    if not ng.valid:\n                        continue\n                    d_ = dist(ns.position, ng.position)\n                    if d_ < min_dist_val and not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d):\n                        min_dist_val = d_\n                        pair = (ns, ng)\n            if pair[0] and pair[1]:\n                c = pair[0].cost + dist(pair[0].position, pair[1].position) + pair[1].cost\n                if c < best_cost:\n                    best_cost = c\n                    path_from = pair[0].path_from_root()\n                    path_to = pair[1].path_from_root()\n                    best_path = path_from + path_to[::-1][1:]\n                    success_state = True\n\n        # Post-processing shortcut smoothing on best path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                farthest = idx + 1\n                for j in range(len(path)-1, idx, -1):\n                    if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                        farthest = j\n                        break\n                smoothed.append(path[farthest])\n                idx = farthest\n            return smoothed\n\n        if success_state and best_path:\n            best_path = shortcut_path(best_path)\n        else:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 976.73991,
    "time_improvement": -3126.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1278.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.3883857011795044,
            "num_nodes_avg": 1663.4,
            "path_length_avg": 148.250885190626,
            "smoothness_avg": 0.04234390644693444,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4941.933079128917,
            "length_improvement": 18.74134064141075,
            "smoothness_improvement": 562.7740871591045,
            "objective_score": -1526.0177851745973
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 2.0928478240966797,
            "num_nodes_avg": 2932.8,
            "path_length_avg": 221.61774061120929,
            "smoothness_avg": 0.08366316850386449,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1052.3214156082,
            "length_improvement": 26.017619271003277,
            "smoothness_improvement": 2052.7135857489734,
            "objective_score": -350.2293328995144
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.9124577999114991,
            "num_nodes_avg": 2788.1,
            "path_length_avg": 113.24352273142593,
            "smoothness_avg": 0.1037432577109159,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3383.4281768675582,
            "length_improvement": 24.789044278861645,
            "smoothness_improvement": 1219.606580552111,
            "objective_score": -1053.9726113017346
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates a highly optimized bidirectional anytime informed RRT* with adaptive ellipsoidal sampling focused on the current best path cost. It uses efficient KD-tree based nearest and radius neighbor queries for dynamic rewiring, lazy collision checking with caching, adaptive neighbor radius scheduling, and periodic pruning to discard nodes unlikely to improve the solution. An enhanced incremental multi-step connection strategy between the two trees expedites convergence. Aggressive shortcut smoothing after each improvement produces smoother, shorter paths. Balanced tree growth and meticulous collision validation ensure robustness and high success rates, minimizing path length and planning time simultaneously in 2D and 3D environments.",
    "planning_mechanism": "The algorithm grows two trees alternately from start and goal within an evolving informed ellipsoid defined by the current best solution cost. Samples are drawn adaptively near the best path or uniformly within the ellipsoid to bias exploration. Nearest neighbor and neighborhood radius queries use a KD-tree for efficiency. New nodes are connected with collision-free edges and rewired locally for cost improvements. Trees incrementally attempt multiple-step connections at each iteration. Periodic pruning removes non-promising nodes, keeping the search space manageable. Aggressive shortcut smoothing refines the best path iteratively. The process repeats until timeout or an optimal path is found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent                # Parent Node or None\n        self.cost = cost                    # Cost from root\n        self.children: List[Node] = []     # Children nodes (for rewiring/pruning)\n        self.valid = True                   # Node validity flag (for pruning, collision, etc.)\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                radius_sq = radius * radius\n                res: List[Node] = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Sample inside ellipsoid of current best path or uniform with goal bias\n            if (c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate):\n                # Uniform sampling with rejection\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d])/2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-15 or norm_x > 1:\n                    continue\n                x_unit = x / norm_x\n                rad_sample = np.random.uniform(0, 1) ** (1/dim)\n                sample = x_unit * rad_sample * radii\n                p = rot @ sample + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            # Sample near best path with gaussian noise (75%) else informed_sample\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    candidate = tuple(base[d] + noise[d] for d in range(dim))\n                    if in_bounds(candidate) and not is_in_obstacle(candidate):\n                        return candidate\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path)-3)\n                j = random.randint(i+2, len(smooth_path)-1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(node_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in node_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Alternate growth by extending smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Choose best parent minimizing cost with collision-free edges\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection to other tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire neighbors in tree_b\n                for nbr in near_nodes_b:\n                    if nbr is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr.position)\n                    if new_cost_b + 1e-12 < nbr.cost and can_connect(new_node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist_to_new\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Aggressive shortcut smoothing on improvement\n                best_path = shortcut_path(best_path)\n                extracted_path = best_path\n                if c_best <= c_min * 1.00001:\n                    # Close to optimal; can break early\n                    break\n\n            # Periodic pruning to remove nodes that cannot improve solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                # Remove corresponding edges linked to pruned nodes\n                edges = [(p, c) for (p, c) in edges if p in nodes and c in nodes]\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.43501,
    "time_improvement": -35.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1220.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010002040863037109,
            "num_nodes_avg": 72.8,
            "path_length_avg": 160.62330588008103,
            "smoothness_avg": 0.04629582648926146,
            "success_improvement": 0.0,
            "time_improvement": 63.67751364530518,
            "length_improvement": 11.959820807968583,
            "smoothness_improvement": 624.6302175532497,
            "objective_score": 24.61836934295152
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.16263303756713868,
            "num_nodes_avg": 700.6,
            "path_length_avg": 228.15752948924705,
            "smoothness_avg": 0.08375814677545615,
            "success_improvement": 0.0,
            "time_improvement": 10.454295856453273,
            "length_improvement": 23.83444950612852,
            "smoothness_improvement": 2055.1574450871103,
            "objective_score": 18.17896588359724
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1529484510421753,
            "num_nodes_avg": 731.2,
            "path_length_avg": 116.11572901668146,
            "smoothness_avg": 0.08486342842026189,
            "success_improvement": 0.0,
            "time_improvement": -178.5865099837585,
            "length_improvement": 22.88146162396088,
            "smoothness_improvement": 979.45654553903,
            "objective_score": -44.102377942640224
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation improves path planning by integrating a bidirectional RRT* framework with adaptive informed sampling inside ellipsoidal domains defined by the current best path cost, dynamic neighbor radius tuning for efficient rewiring, and KD-tree accelerated nearest and radius neighbor lookups. It aggressively prunes nodes unlikely to improve solution quality and caches collision checks to avoid redundant computations. The planner also includes an iterative shortcut smoothing step to enhance path quality after each improvement. These combined enhancements lead to faster convergence, shorter and smoother paths, higher success rates, and reduced computational overhead in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions alternately, sampling points biased inside an ellipsoid shaped from the start to goal with size based on the best path cost found so far. KD-trees enable fast nearest neighbor and neighbor radius queries for rewiring and cost improvements. Collision caching prevents repeated expensive checks. New nodes and edges are only added if collision-free. Periodic pruning eliminates nodes that cannot yield better paths, maintaining manageable search complexity. Shortcut smoothing is applied aggressively to the best path for quality improvement. The process iterates until a feasible path is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...] (2D or 3D)\n        self.parent = parent      # Parent Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []        # Child nodes\n        self.valid = True         # For marking nodes invalid if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp new point to map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution found or cost near minimal, sample uniformly with goal biasing\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling centered on midpoint between start and goal\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_scale = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_scale * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(c) for c in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback to uniform sampling with obstacle rejection\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            removed = 0\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate extension from smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to improve path cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect opposite tree towards new_node incrementally\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        # Aggressive shortcut smoothing to shorten path\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes that cannot improve best path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -33.902,
    "time_improvement": 76.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1534.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009457635879516601,
            "num_nodes_avg": 71.7,
            "path_length_avg": 160.84098456095901,
            "smoothness_avg": 0.04162827845618791,
            "success_improvement": 0.0,
            "time_improvement": 65.65452442301833,
            "length_improvement": 11.84050767363993,
            "smoothness_improvement": 551.5729550928666,
            "objective_score": 24.82232363709782
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02208542823791504,
            "num_nodes_avg": 210.8,
            "path_length_avg": 234.84358221750236,
            "smoothness_avg": 0.10484556196583543,
            "success_improvement": 0.0,
            "time_improvement": 87.8397695052615,
            "length_improvement": 21.602452658079653,
            "smoothness_improvement": 2597.751826586801,
            "objective_score": 43.66118051612838
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01340172290802002,
            "num_nodes_avg": 130.7,
            "path_length_avg": 125.86643563572306,
            "smoothness_avg": 0.12208423969260673,
            "success_improvement": 0.0,
            "time_improvement": 75.58955852592997,
            "length_improvement": 16.405506566347363,
            "smoothness_improvement": 1452.9025175687516,
            "objective_score": 33.222481458892226
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional anytime informed RRT* with adaptive ellipsoidal and Gaussian-biased sampling, dynamic neighbor radius adjustment, aggressive rewiring, incremental connection attempts, collision caching, periodic pruning, and shortcut smoothing. It balances exploration and exploitation to rapidly discover and refine high-quality, smooth, and short paths in 2D/3D spaces with obstacles.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal, sampling adaptively within informed ellipsoids or near the best path found, extending trees toward samples via collision-checked steering. It performs aggressive rewiring among neighbors to lower path costs, incrementally connects bidirectional trees in small steps to increase connection success, and prunes nodes unlikely to improve solutions. Shortcut smoothing refines the resulting path before outputting, achieving efficient, robust, and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_trials: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Collision and edge checks\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree brute force for nearest neighbor search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Informed sampling within ellipsoid + adaptive sampling near best path\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                # Uniform random with rejection\n                for _ in range(20):\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = direction - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2.0) ** 2, 0.0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # Fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling near best path with Gaussian noise\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n\n        # Initialize trees and core containers\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Balanced tree selection: extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Aggressive rewiring to optimize paths\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            radius_b = neighbor_radius(it, len(nodes))\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Continue to allow anytime improvement OR break for fastest solution\n                # break  # Optional: uncomment to stop at first found path\n\n            # Prune periodically to improve efficiency in large tree\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            if connected and it > self.max_iter * 0.5:\n                # After halfway, stop to return best found path early\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 181.83032,
    "time_improvement": -640.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1118.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.40352795124053953,
            "num_nodes_avg": 2985.5,
            "path_length_avg": 152.57611657242552,
            "smoothness_avg": 0.03341115275004204,
            "success_improvement": 0.0,
            "time_improvement": -1365.4147791815585,
            "length_improvement": 16.370612783369264,
            "smoothness_improvement": 422.95709401761343,
            "objective_score": -404.23552572770564
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4473849058151245,
            "num_nodes_avg": 2096.7,
            "path_length_avg": 224.51151035199717,
            "smoothness_avg": 0.07747639954297861,
            "success_improvement": 0.0,
            "time_improvement": -146.33000166323149,
            "length_improvement": 25.051595638984576,
            "smoothness_improvement": 1893.523564235816,
            "objective_score": -29.421063549993445
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2785142660140991,
            "num_nodes_avg": 2294.0,
            "path_length_avg": 111.71509343344042,
            "smoothness_avg": 0.08952820485670754,
            "success_improvement": 0.0,
            "time_improvement": -407.29717640723663,
            "length_improvement": 25.80415424260157,
            "smoothness_improvement": 1038.7921574926388,
            "objective_score": -111.83436128618747
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an advanced bidirectional RRT*-based path planning algorithm that incorporates adaptive informed ellipsoidal sampling, KDTree-accelerated nearest neighbor and radius queries, collision caching, dynamic neighbor radius adjustment for rewiring, periodic pruning of non-promising nodes, and aggressive shortcut smoothing. It grows two trees alternately from start and goal, focusing sampling within an ellipsoidal informed set guided by the current best path cost to improve convergence speed and path quality. The planner also incorporates incremental rewiring and pruning to balance exploration and exploitation, reduce computational load, and produce smoother, shorter, and robust paths efficiently within bounded obstacle environments.",
    "planning_mechanism": "The planning mechanism alternates tree expansions from the start and goal positions using informed sampling constrained to an ellipsoidal region defined by the best path found so far. It employs KDTree for efficient nearest neighbor and radius searches during node expansion and rewiring, caches collision checks for efficiency, and dynamically adjusts the neighbor radius balancing connectivity. Once a connection between the two trees is found, it shortcut smooths the combined path to further reduce length. The algorithm prunes nodes periodically to remove nodes unlikely to contribute to better paths, maintaining efficiency over iterations.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Simple brute-force KDTree substitute for demonstration\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet or no improvement, uniform sampling with goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            heuristic = lambda pos: dist(pos, goal_pos)\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expansion: always grow smaller tree to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost to new node\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path via new_node is found\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Extend other tree toward new_node incrementally to attempt connection\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce graph size\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.47759,
    "time_improvement": 70.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1452.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011630678176879882,
            "num_nodes_avg": 80.5,
            "path_length_avg": 166.27345657380965,
            "smoothness_avg": 0.04051418144804288,
            "success_improvement": 0.0,
            "time_improvement": 57.763105034217155,
            "length_improvement": 8.862883680368745,
            "smoothness_improvement": 534.1349176150213,
            "objective_score": 21.772182834414004
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027401995658874512,
            "num_nodes_avg": 247.1,
            "path_length_avg": 234.58129637209225,
            "smoothness_avg": 0.0997182662715921,
            "success_improvement": 0.0,
            "time_improvement": 84.9124689981925,
            "length_improvement": 21.690011222757015,
            "smoothness_improvement": 2465.8228153321056,
            "objective_score": 42.14085702066968
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017815279960632324,
            "num_nodes_avg": 155.3,
            "path_length_avg": 124.35565502515435,
            "smoothness_avg": 0.11435293724061271,
            "success_improvement": 0.0,
            "time_improvement": 67.55052676376837,
            "length_improvement": 17.408895112245233,
            "smoothness_improvement": 1354.5609210447733,
            "objective_score": 30.519741656803426
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a bidirectional informed RRT* planner with adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor and radius queries, collision caching, incremental rewiring, pruning, and extensive path shortcut smoothing to improve planning efficiency, solution quality, and success rate in 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, samples configurations biasing inside an adaptive ellipsoid when a solution exists, extends nodes with collision checks and rewiring for path cost optimization, prunes non-promising nodes periodically, attempts multi-step incremental connections between trees, and applies intensive shortcut smoothing to yield shorter and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet or c_best very close to c_min, sample uniformly + goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-12:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            val = r1 * r1 - (c_min / 2) ** 2\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(120):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling outside informed set, check obstacle\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n            # last fallback\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection between trees incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.76083,
    "time_improvement": 60.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1449.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.014272522926330567,
            "num_nodes_avg": 69.1,
            "path_length_avg": 157.1967171030201,
            "smoothness_avg": 0.04176427963644518,
            "success_improvement": -9.999999999999998,
            "time_improvement": 48.16922602720749,
            "length_improvement": 13.837988414449532,
            "smoothness_improvement": 553.7016688951827,
            "objective_score": -30.013126164471924
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03840062618255615,
            "num_nodes_avg": 272.3,
            "path_length_avg": 240.77836885315907,
            "smoothness_avg": 0.09893108955097332,
            "success_improvement": 0.0,
            "time_improvement": 78.85662616582088,
            "length_improvement": 19.621250055735693,
            "smoothness_improvement": 2445.56819133011,
            "objective_score": 39.809078817543956
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.025709700584411622,
            "num_nodes_avg": 184.2,
            "path_length_avg": 126.26042619486427,
            "smoothness_avg": 0.11385927187576395,
            "success_improvement": -9.999999999999998,
            "time_improvement": 53.17130896236657,
            "length_improvement": 16.143836796780118,
            "smoothness_improvement": 1348.2815340424838,
            "objective_score": -24.078432281721582
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements an efficient bidirectional RRT* algorithm enhanced with informed sampling to focus exploration within an ellipsoidal subset between start and goal. It employs dynamic neighbor radius adjustment, nearest neighbor searches, and rewiring to continuously improve path quality, while enforcing collision-free nodes and edges. The planner alternates tree growth from start and goal, performs periodic node pruning for efficiency, and applies path shortcutting to smooth and shorten the final path.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased within an informed ellipsoid based on current best path cost to balance exploration and exploitation. KD-tree like nearest and radius searches identify optimal parents and rewire neighbors to minimize path cost. Collision checks and pruning maintain safety and computational efficiency. On successful tree connection, the merged path is shortcut-smoothed before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_radius: float=5.0, max_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iters: int=150,\n                 collision_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                new_p = to\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(frm[d] + ratio * (to[d] - frm[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        # Simple KDTree replacement for nearest and radius searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                attempts = 0\n                while attempts < 20:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2)**2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim -1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform sampling\n            attempts = 0\n            while attempts < 20:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n                attempts += 1\n            return p\n\n        edge_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_cache:\n                return not edge_cache[(p1, p2)]\n            if (p2, p1) in edge_cache:\n                return not edge_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            heuristic = lambda p: dist(p, goal_pos)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: always extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near in near_nodes:\n                cand_cost = near.cost + dist(near.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(near.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -34.07274,
    "time_improvement": 76.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1636.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011541318893432618,
            "num_nodes_avg": 86.5,
            "path_length_avg": 163.6856560006271,
            "smoothness_avg": 0.04234256122223933,
            "success_improvement": 0.0,
            "time_improvement": 58.08761394176156,
            "length_improvement": 10.281298180854305,
            "smoothness_improvement": 562.7530314714239,
            "objective_score": 22.296308976056448
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024851250648498534,
            "num_nodes_avg": 227.1,
            "path_length_avg": 233.824438735564,
            "smoothness_avg": 0.11054451542193082,
            "success_improvement": 0.0,
            "time_improvement": 86.31690847409213,
            "length_improvement": 21.942672086769313,
            "smoothness_improvement": 2744.390003802393,
            "objective_score": 44.00555697859347
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009233689308166504,
            "num_nodes_avg": 114.4,
            "path_length_avg": 128.30725041528075,
            "smoothness_avg": 0.1337281694172663,
            "success_improvement": 0.0,
            "time_improvement": 83.18138391655158,
            "length_improvement": 14.784433608875073,
            "smoothness_improvement": 1601.0124442009317,
            "objective_score": 35.91636411774515
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is a refined bidirectional informed RRT* algorithm leveraging adaptive ellipsoidal sampling focused around the current best path estimate, augmented with efficient KD-tree nearest neighbor and radius searches, collision caching, incremental multi-step tree connections, and aggressive pruning strategies. It emphasizes precise rewiring with tight tolerance, extensive shortcut smoothing both during and after planning, and mannered tree growth balancing to accelerate convergence to high-quality, smooth, and minimal-length paths while minimizing computational overhead and planning time.",
    "planning_mechanism": "The planner builds start and goal trees alternately expanding the smaller one using informed samples constrained within an adaptive ellipsoid around the best-known path cost. Using a KD-tree accelerates neighbor searching for rewiring and extension. Each extension carefully applies collision checks, relies on cached results to avoid redundant computations, and rewires neighbors within a dynamic radius with strict precision. Incremental multi-step connections between trees improve early linking chances. Periodic pruning removes nodes that cannot improve the current best path. Shortcut smoothing refines the path continuously and finally, producing shorter and smoother solutions efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Adaptive informed sampling within ellipsoid around current best path\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            # If no solution yet or trivial best solution, sample uniformly\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):  # increased attempts for better sample quality\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(120):  # increased attempts for ellipsoid sampling\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(15):  # fallback uniform sampling attempts\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback sample\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed_count = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node_rm in to_remove:\n                if node_rm.parent:\n                    try:\n                        node_rm.parent.children.remove(node_rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node_rm)\n                except ValueError:\n                    pass\n                if node_rm in tree_start:\n                    tree_start.remove(node_rm)\n                if node_rm in tree_goal:\n                    tree_goal.remove(node_rm)\n                removed_count += 1\n            return removed_count\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansions, always grow smaller tree for better balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-13 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors within radius for improved cost - tight epsilon tolerance\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-13 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            # Multi-step incremental connection from tree_b to new_node (tree_a)\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-13 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-13 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Continue to improve: still run additional smoothing for better path shortening\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Aggressive pruning of nodes that cannot improve best solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        # Final fallback shortcut smoothing if success but no smoothing done yet\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        if extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.35288,
    "time_improvement": 61.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1580.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01390371322631836,
            "num_nodes_avg": 79.6,
            "path_length_avg": 169.6387679064946,
            "smoothness_avg": 0.04662551153542334,
            "success_improvement": 0.0,
            "time_improvement": 49.50856121685646,
            "length_improvement": 7.018303212153527,
            "smoothness_improvement": 629.7905044482195,
            "objective_score": 19.405181529728736
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027298569679260254,
            "num_nodes_avg": 235.5,
            "path_length_avg": 236.02123753107276,
            "smoothness_avg": 0.11066077176042603,
            "success_improvement": 0.0,
            "time_improvement": 84.96941531309774,
            "length_improvement": 21.20931741748112,
            "smoothness_improvement": 2747.381363127931,
            "objective_score": 43.4695948930652
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02833099365234375,
            "num_nodes_avg": 190.1,
            "path_length_avg": 121.59068526609826,
            "smoothness_avg": 0.11502841038130258,
            "success_improvement": 0.0,
            "time_improvement": 48.396779488782926,
            "length_improvement": 19.24525637249897,
            "smoothness_improvement": 1363.1528895361073,
            "objective_score": 25.183849568815205
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with informed sampling confined to an ellipsoidal region guided by the current best solution cost, adaptive neighbor radius recalculated dynamically, cached collision checking to reduce redundant computations, periodic pruning of unproductive nodes, and incremental connection attempts between the two trees. Aggressive rewiring with dynamic radius improves continuous path optimality, and shortcut smoothing refines the final path. These combined heuristics focus search efficiently within promising regions, reduce computation overhead, and robustly generate shorter, smoother paths faster.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal points, sampling points primarily within an informed ellipsoid region to bias towards lower-cost solutions. Each extension rewires nearby nodes dynamically within an adaptive radius to optimize path costs. Incremental connections between trees increase merge success, while caching collision results speeds up obstacle checks. Periodic pruning removes dead-end or stale nodes, maintaining manageable tree size and quicker iterations. Finally, shortcut smoothing is applied on the merged path to ensure path smoothness and reduced length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children: List[Node] = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_const: float=18.0,\n                 radius_min: float=5.0, prune_interval: int=120,\n                 prune_threshold: int=120, smoothing_iters: int=40,\n                 collision_cache_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_cache_resolution = collision_cache_resolution\n        self._edge_collision_cache: Dict[Tuple[Tuple[float, ...], Tuple[float, ...]], bool] = {}\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b): return math.dist(a,b)\n\n        # Cached collision checking to save time on repeated queries\n        def cache_key(p1, p2):\n            return tuple(sorted((p1, p2)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        # Edge collision check with caching\n        def is_edge_in_obstacle(p1, p2):\n            key = cache_key(p1, p2)\n            if key in self._edge_collision_cache:\n                return self._edge_collision_cache[key]\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_cache_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    self._edge_collision_cache[key] = True\n                    return True\n            self._edge_collision_cache[key] = False\n            return False\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        # Adaptive radius based on node count\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_const * math.sqrt(math.log(n+1)/(n+1))\n            return max(val, self.radius_min)\n\n        # Heuristic: Euclidean distance as cost\n        def cost_line(p1, p2):\n            return dist(p1, p2)\n\n        # Steer from from_pos towards to_pos at step_size\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Nearest node in tree to the point\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        # Nodes within radius to pos in tree\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        # Check if a node position is valid (in bounds and collision free)\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Check if the edge between two positions is collision free\n        def can_connect(p1, p2):\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        # Informed sampling inside ellipse defined by current best cost\n        def sample_informed(best_cost):\n            # If no best_cost, sample uniformly\n            if best_cost is None or best_cost == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            # Ellipsoid parameters\n            c_min = dist(start_pos, goal_pos)\n            if best_cost < c_min:\n                best_cost = c_min * 1.1  # numerical safety margin\n\n            # Compute center and rotation matrix (only along vector start -> goal)\n            center = tuple((start_pos[d] + goal_pos[d])/2 for d in range(dim))\n            a1 = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))  # unit vector along main axis\n\n            # For 2D or 3D, create orthonormal basis\n            basis = [a1]\n            # Use Gram-Schmidt for extending to basis vectors in 2D/3D\n            def gram_schmidt(vecs):\n                ortho = []\n                for v in vecs:\n                    w = list(v)\n                    for b in ortho:\n                        proj = sum(v[i]*b[i] for i in range(dim))\n                        w = [w[i] - proj*b[i] for i in range(dim)]\n                    norm = math.sqrt(sum(w[i]*w[i] for i in range(dim)))\n                    if norm > 1e-10:\n                        w = [w[i]/norm for i in range(dim)]\n                        ortho.append(tuple(w))\n                return ortho\n\n            random_dirs = []\n            for _ in range(dim-1):\n                random_vec = tuple(random.uniform(-1,1) for _ in range(dim))\n                random_dirs.append(random_vec)\n            ortho_basis = gram_schmidt([a1]+random_dirs)[1:]  # exclude a1\n            basis.extend(ortho_basis)\n\n            # Ellipse radii: a = best_cost/2 along main axis, b,c,... smaller along others\n            radii = [best_cost/2] + [math.sqrt(best_cost**2 - c_min**2)/2]*(dim-1)\n\n            # Sample random point inside unit ball (dim-dim)\n            while True:\n                # Sample in unit ball\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = (r*math.cos(theta), r*math.sin(theta))\n                elif dim == 3:\n                    phi = random.uniform(0, 2*math.pi)\n                    costheta = random.uniform(-1,1)\n                    u = random.uniform(0,1)\n                    sintheta = math.sqrt(1 - costheta**2)\n                    r = u ** (1/3)\n                    x_ball = (\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    )\n                else:\n                    # For higher dims, fallback uniform sampling without bias\n                    sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # Map unit ball to ellipsoid\n                coord = [radii[i]*x_ball[i] for i in range(dim)]\n                # Rotate and translate point back to space\n                sample = [center[i] for i in range(dim)]\n                for i in range(dim):\n                    for j in range(dim):\n                        sample[i] += basis[j][i] * coord[j]\n                sample_t = tuple(sample)\n                if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                    return sample_t\n\n        # Extend tree towards sample point with RRT* style rewiring\n        def try_extend(tree, sample_pt, all_nodes):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            # Determine dynamic radius\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + cost_line(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + cost_line(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + cost_line(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n            return new_node\n\n        # Incrementally try to connect two trees from node_start to tree_goal\n        def try_connect(tree_goal, node_start):\n            if not tree_goal or node_start is None:\n                return None\n            last_node = nearest(tree_goal, node_start.position)\n            dist_to_goal = dist(last_node.position, node_start.position)\n            # Walk from last_node toward node_start in steps\n            direction = tuple(node_start.position[d] - last_node.position[d] for d in range(dim))\n            length = dist_to_goal\n            steps = max(1, int(length / self.step_size))\n            curr_pos = last_node.position\n            prev_node = last_node\n            for i in range(1, steps+1):\n                interp_pos = tuple(last_node.position[d] + direction[d]*i/steps for d in range(dim))\n                if not can_add_node(interp_pos) or not can_connect(prev_node.position, interp_pos):\n                    return None\n                cost = prev_node.cost + cost_line(prev_node.position, interp_pos)\n                new_node = Node(interp_pos, parent=prev_node, cost=cost)\n                prev_node.children.append(new_node)\n                tree_goal.append(new_node)\n                prev_node = new_node\n            # Finally add node_start if last connection free\n            if can_connect(prev_node.position, node_start.position):\n                final_cost = prev_node.cost + cost_line(prev_node.position, node_start.position)\n                final_node = Node(node_start.position, parent=prev_node, cost=final_cost)\n                prev_node.children.append(final_node)\n                tree_goal.append(final_node)\n                return final_node\n            return None\n\n        # Prune dead-end leaf nodes periodically to reduce tree size\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in all_nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    all_nodes.remove(node)\n                except Exception:\n                    continue\n            return removed\n\n        # Shortcut smoothing to reduce path length and sharp turns\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def path_length(path):\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # Initialize trees and data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        all_nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        all_nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Iteratively grow trees with balanced alternation\n        for itr in range(self.max_iter):\n            # Alternate trees: always extend smaller tree to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Sample according to informed sampling if we have a solution; else uniform\n            sample_pt = sample_informed(best_cost if best_cost != float('inf') else None)\n\n            new_node_start = try_extend(tree_start, sample_pt, all_nodes)\n            if new_node_start is None:\n                # No new node added this iteration\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path connected, extract paths\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                raw_len = path_length(raw_path)\n\n                # If better than previous best, update\n                if raw_len + 1e-12 < best_cost:\n                    smoothed = shortcut_smoothing(raw_path)\n                    smooth_len = path_length(smoothed)\n                    # Accept smoothed if better\n                    if smooth_len + 1e-12 < raw_len:\n                        best_path = smoothed\n                        best_cost = smooth_len\n                    else:\n                        best_path = raw_path\n                        best_cost = raw_len\n\n                extracted_path = best_path\n                # Continue searching for better\n                # Optional: can break early here to save time when first found\n                break\n\n            # Periodic pruning to maintain performance\n            if itr > 0 and itr % self.prune_interval == 0 and len(all_nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=[(n.parent, n) for n in all_nodes if n.parent is not None]\n        )",
    "objective": -32.86271,
    "time_improvement": 86.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 816.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004988551139831543,
            "num_nodes_avg": 43.5,
            "path_length_avg": 164.39067468540324,
            "smoothness_avg": 0.025012236766874835,
            "success_improvement": 0.0,
            "time_improvement": 81.88403914886543,
            "length_improvement": 9.894866267992525,
            "smoothness_improvement": 291.4958203430712,
            "objective_score": 28.00166409997349
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.015923357009887694,
            "num_nodes_avg": 166.3,
            "path_length_avg": 249.00201342950126,
            "smoothness_avg": 0.05814769178814951,
            "success_improvement": 0.0,
            "time_improvement": 91.23260416758285,
            "length_improvement": 16.87596079166798,
            "smoothness_improvement": 1396.1819917985952,
            "objective_score": 37.725883367601426
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.008422565460205079,
            "num_nodes_avg": 89.9,
            "path_length_avg": 123.05281211931307,
            "smoothness_avg": 0.06773801094629509,
            "success_improvement": 0.0,
            "time_improvement": 84.65879778003597,
            "length_improvement": 18.2741813355926,
            "smoothness_improvement": 761.6224993370007,
            "objective_score": 32.860588097814315
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner implements an enhanced bidirectional anytime informed RRT* algorithm incorporating informed ellipsoidal and adaptive Gaussian-biased sampling. It leverages a KD-tree for rapid nearest neighbor and radius searches, employs dynamic neighbor radius control, aggressive incremental rewiring on both trees, and periodic pruning of non-promising nodes. By balancing exploration and exploitation with focused sampling, caching collision checks, and applying shortcut smoothing, it efficiently finds shorter, smoother paths while maintaining robustness and high success rate in 2D/3D environments with obstacles.",
    "planning_mechanism": "The planning mechanism grows two balanced trees simultaneously from start and goal, using informed sampling within an ellipsoid around the best known solution and Gaussian perturbations near the current best path to bias exploration. New nodes are connected with consideration of collision-free constraints, nearest neighbors are found via KD-tree, and aggressive rewiring optimizes the path costs dynamically. Incremental connection attempts between the two trees ensure higher connection success. Periodic pruning removes nodes unlikely to improve the best path, and post-processing smoothing reduces path complexity, resulting in faster convergence to high-quality paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 120, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        import numpy as np\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = direction - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2.0) ** 2, 0.0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Alternate tree growth: extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Aggressive rewiring for tree_a neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            radius_b = neighbor_radius(it, len(nodes))\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n\n            # Periodic pruning of non-promising nodes to reduce overhead\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            # Early stopping after half progress if path found\n            if connected and it > self.max_iter * 0.5:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 174.83526,
    "time_improvement": -614.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1002.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.3491420030593872,
            "num_nodes_avg": 2653.2,
            "path_length_avg": 149.92572812928194,
            "smoothness_avg": 0.029589631554052365,
            "success_improvement": 0.0,
            "time_improvement": -1167.911800764691,
            "length_improvement": 17.823332687148728,
            "smoothness_improvement": 363.1419887342747,
            "objective_score": -344.9931637483062
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3376143932342529,
            "num_nodes_avg": 1811.9,
            "path_length_avg": 225.4200016358965,
            "smoothness_avg": 0.06823586059754275,
            "success_improvement": 0.0,
            "time_improvement": -85.89038871439033,
            "length_improvement": 24.748315098947266,
            "smoothness_improvement": 1655.7578414785737,
            "objective_score": -12.538664387134773
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.37848970890045164,
            "num_nodes_avg": 2621.4,
            "path_length_avg": 113.59068118147775,
            "smoothness_avg": 0.08542982978114777,
            "success_improvement": 0.0,
            "time_improvement": -589.3965015590122,
            "length_improvement": 24.558478166246175,
            "smoothness_improvement": 986.6611290420991,
            "objective_score": -166.97394918924397
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner is a hybrid bidirectional RRT* variant that integrates dynamic informed sampling combining ellipsoidal and path-guided Gaussian sampling, a multi-resolution collision checking strategy for efficient feasibility verification, and prioritized rewiring with adaptive neighbor radius to accelerate convergence. It maintains balanced tree expansions from start and goal with incremental connections, employs a progressive pruning mechanism focusing on nodes unlikely to improve current best paths, and uses iterative hierarchical shortcut smoothing for improved path quality and smoothness. The planner is designed to efficiently navigate complex 2D/3D environments with reduced search time, enhanced success rates, and high-quality short, smooth trajectories.",
    "planning_mechanism": "The planner alternately grows two search trees from start and goal positions, sampling new candidate points biased dynamically by the evolving best path cost and known solution path via combined ellipsoidal and adaptive Gaussian sampling. It performs collision checks at multiple resolutions, caching results to minimize repeated expensive computations. Rewiring uses an adaptive radius computed from iteration and node count, prioritizing neighbors by cost-to-go heuristic to improve path quality incrementally. After successful tree connection, the planner applies multi-level shortcut smoothing that tries to bypass multiple intermediate nodes in progressively coarser resolution for path simplification. Periodic pruning discards nodes whose combined cost and heuristic exceed the current best path cost, maintaining efficiency and scalability.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # Collision validity mark\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_self(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        for c in self.children:\n            c.parent = None\n        self.children.clear()\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0,\n                 min_radius: float = 4.0, max_radius: float = 25.0,\n                 prune_interval: int = 150, prune_threshold: int = 250,\n                 smoothing_passes: int = 3, smoothing_trials_per_pass: int = 60,\n                 collision_resolutions: tuple = (2.0, 1.0, 0.5),\n                 goal_sample_rate: float = 0.12,\n                 adaptive_gaussian_prob: float = 0.7):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_passes = smoothing_passes\n        self.smoothing_trials_per_pass = smoothing_trials_per_pass\n        self.collision_resolutions = collision_resolutions  # tuple descending order coarse->fine\n        self.goal_sample_rate = goal_sample_rate\n        self.adaptive_gaussian_prob = adaptive_gaussian_prob\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_check(from_pos, to_pos, resolution):\n            return self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution)\n\n        # Multi-resolution collision checking with memoization\n        edge_collision_cache = {}\n        node_collision_cache = {}\n\n        def check_node_collision(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            collision = is_in_obstacle(pos)\n            node_collision_cache[pos] = collision\n            return collision\n\n        def check_edge_collision(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n            # Check from coarse to fine resolution for efficiency\n            collision = False\n            for res in self.collision_resolutions:\n                if edge_collision_check(p1, p2, res):\n                    collision = True\n                    break\n            edge_collision_cache[key] = collision\n            return collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not check_node_collision(pos))\n\n        def can_connect(p1, p2):\n            return not check_edge_collision(p1, p2)\n\n        # Adaptive neighbor radius with logarithmic decay and node count influence\n        def neighbor_radius(n_nodes, iteration):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.92)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Informed sampling combining ellipsoidal and Gaussian near best path points\n        def sample_ellipsoid_and_gaussian(c_best, c_min, start, goal, best_path):\n            # With goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal\n            # If no valid path yet or too optimistic, uniform sampling and check\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not check_node_collision(p):\n                        return p\n                # fallback random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # 75% chance Gaussian sample near best path points if available\n            if best_path and random.random() < self.adaptive_gaussian_prob:\n                for _ in range(50):\n                    base_pt = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.45, dim)\n                    sample = tuple(base_pt[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample) and not check_node_collision(sample):\n                        return sample\n\n            # Ellipsoidal informed sampling\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            eye = np.eye(dim)\n            u = direction - eye[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-15:\n                u /= norm_u\n                rot = eye - 2 * np.outer(u, u)\n            else:\n                rot = eye\n\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(max(r1 * r1 - (c_min / 2.0)**2, 0.0))\n            except:\n                r2 = 0.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-15 or norm_x > 1.0:\n                    continue\n                x = x / norm_x\n                x *= np.power(np.random.uniform(0, 1), 1.0 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not check_node_collision(p_tuple):\n                    return p_tuple\n\n            # fallback uniform random sample\n            for _ in range(25):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not check_node_collision(p):\n                    return p\n            return p\n\n        # KD-tree like structures for nearest and radius queries (brute-force implementation)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                found = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        found.append(self.nodes[i])\n                return found\n\n        # Prune nodes whose cost + estimated heuristic exceeds best known path cost\n        def prune_nodes(trees, best_cost, root_start, root_goal):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            removed_count = 0\n            for tree in trees:\n                to_remove = []\n                for node in tree:\n                    if node in (root_start, root_goal):\n                        continue\n                    if node.cost + heuristic(node.position) >= best_cost - 1e-10:\n                        to_remove.append(node)\n                for node in to_remove:\n                    node.remove_self()\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n                    removed_count += 1\n            return removed_count\n\n        # Multi-level hierarchical shortcut smoothing\n        def multi_level_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = list(path)\n            for level in range(self.smoothing_passes):\n                trials = self.smoothing_trials_per_pass // (level + 1)\n                max_skip = min(len(new_path) - 2, 6 + 3 * level)\n                for _ in range(trials):\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path) - max_skip - 1)\n                    j = i + random.randint(2, max_skip)\n                    p1, p2 = new_path[i], new_path[j]\n                    if can_connect(p1, p2):\n                        new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_ellipsoid_and_gaussian(c_best, c_min, start_pos, goal_pos, best_path)\n\n            # Balanced extension: grow smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(len(nodes), iteration)\n            neighbors = kdtree_a.radius_search(new_pos, radius)\n\n            # Choose parent minimizing cost with feasibility check\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for n in neighbors:\n                candidate_cost = n.cost + dist(n.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(n.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to possibly improve their costs\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental extension from opposite tree towards new_node to connect trees\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                new_cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=new_cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr in near_b:\n                    if nbr is last_node_b:\n                        continue\n                    new_cost_nbr = new_node_b.cost + dist(new_node_b.position, nbr.position)\n                    if new_cost_nbr + 1e-12 < nbr.cost and can_connect(new_node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node_b, new_cost_nbr)\n                        edges.append((new_node_b, nbr))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    # Assemble full path according to which tree is which\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = multi_level_shortcut(merged_path)\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Break early on connection found\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve path\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes([tree_start, tree_goal], c_best, root_start, root_goal)\n                # Clear caches to avoid stale entries\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -10.06113,
    "time_improvement": 8.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 883.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020488715171813963,
            "num_nodes_avg": 104.1,
            "path_length_avg": 158.1218524390865,
            "smoothness_avg": 0.03218866750110998,
            "success_improvement": 0.0,
            "time_improvement": 25.595077300307544,
            "length_improvement": 13.330907077044019,
            "smoothness_improvement": 403.82254520261904,
            "objective_score": 12.363817331514163
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05030002593994141,
            "num_nodes_avg": 337.8,
            "path_length_avg": 238.5476162566834,
            "smoothness_avg": 0.062136255799376594,
            "success_improvement": 0.0,
            "time_improvement": 72.30482005003871,
            "length_improvement": 20.365939481092617,
            "smoothness_improvement": 1498.810616654004,
            "objective_score": 33.25868699450016
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09556100368499756,
            "num_nodes_avg": 374.4,
            "path_length_avg": 127.62308917080955,
            "smoothness_avg": 0.06652136652309212,
            "success_improvement": 0.0,
            "time_improvement": -74.05868660812772,
            "length_improvement": 15.2388209311953,
            "smoothness_improvement": 746.1468720772089,
            "objective_score": -15.43910743581321
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT*-based exploration with informed ellipsoidal and adaptive sampling biased near the current best path. It uses efficient KDTree-based nearest neighbor and radius searches, incremental rewiring in both trees, lazy collision checking with caching, periodic pruning of non-promising nodes, and aggressive shortcut smoothing. The tree expansions alternate intelligently based on tree sizes for balanced growth, and dynamic neighbor radius adapts over iterations and node counts to balance exploration and path refinement. This algorithm aims to optimize path quality, smoothness, success rate, and computational efficiency robustly in both 2D and 3D bounded obstacle environments.",
    "planning_mechanism": "The planner iteratively samples points within an informed ellipsoid or near the best current path using a hybrid adaptive sampling strategy. It grows the smaller of two RRT* trees (from start and goal) toward the samples with KDTree-accelerated nearest neighbor and neighbor searches. New nodes are added only if collision-free and edges connecting nodes respect collision constraints. Local rewiring improves path costs continuously. An incremental extension attempts to connect the two trees after each new node addition. Periodic pruning removes nodes unlikely to contribute to better paths, and shortcut smoothing refines the final planned path for length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []                # Child nodes for rewiring/pruning\n        self.valid = True                 # For collision or pruning marks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_trials: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * \\\n                      math.sqrt(math.log(max(n_nodes, 1) + 1) / max(n_nodes, 1))\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Brute force KDTree substitute for demonstration\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        def can_connect(p1, p2) -> bool:\n            key = edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Informed ellipsoidal sampling focused on best path\n        def informed_sample(c_best, c_min, start, goal):\n            # Occasionally biased to goal to avoid overfitting\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = direction - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x_normalized = x / norm_x\n                radius_factor = np.power(np.random.uniform(0, 1), 1 / dim)\n                sample = x_normalized * radius_factor\n                p = rot @ (sample * radii) + center\n                p_t = tuple(float(coord) for coord in p)\n                if in_bounds(p_t) and not is_in_obstacle(p_t):\n                    return p_t\n\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling near best path for focused exploration\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing on the path by edge replacement\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        # Prune nodes unlikely to improve current best cost\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Expand smaller tree first for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent with minimal cost connection\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors of new_node in tree_a\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect from tree_b towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire tree_b around new_node_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if cost_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check connection to new_node from tree_a side\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    total_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=total_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    if total_cost + 1e-12 < c_best:\n                        c_best = total_cost\n                        best_path = shortcut_path(candidate_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Continue searching for even better solutions if desired\n                # (For anytime property, comment 'break' below)\n                break\n\n            # Periodic pruning to maintain efficiency\n            if (iteration > 0 and iteration % self.prune_interval == 0 and\n                    len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not best_path:\n            extracted_path = best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.75043,
    "time_improvement": 52.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1617.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016561174392700197,
            "num_nodes_avg": 103.9,
            "path_length_avg": 166.28594506413575,
            "smoothness_avg": 0.04083684954834616,
            "success_improvement": 0.0,
            "time_improvement": 39.85797107472363,
            "length_improvement": 8.856038540928221,
            "smoothness_improvement": 539.1853740697625,
            "objective_score": 16.424525900951544
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021656179428100587,
            "num_nodes_avg": 208.9,
            "path_length_avg": 240.83497028185576,
            "smoothness_avg": 0.11255789064999464,
            "success_improvement": 0.0,
            "time_improvement": 88.07611377763449,
            "length_improvement": 19.602354869654945,
            "smoothness_improvement": 2796.1955985960353,
            "objective_score": 44.32428310020151
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.039133429527282715,
            "num_nodes_avg": 229.5,
            "path_length_avg": 125.70967196120891,
            "smoothness_avg": 0.1271128017481722,
            "success_improvement": 0.0,
            "time_improvement": 28.72078480418979,
            "length_improvement": 16.509621534675656,
            "smoothness_improvement": 1516.8654557457025,
            "objective_score": 19.50248702692058
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional informed sampling with adaptive ellipsoidal sampling, dynamic neighbor radius, collision caching, incremental rewiring, node pruning, and path shortcutting to enhance efficiency, path quality, and robustness in 2D/3D spaces.",
    "planning_mechanism": "The algorithm grows two trees alternately from start and goal towards sampled states biased inside an adaptive ellipsoid enclosing the current best path cost. It uses dynamic neighbor radius for rewiring, caches collision checks to avoid redundant computations, prunes nodes unlikely to improve the solution periodically, and smooths the final path via shortcutting. Efficient nearest neighbor queries and incremental connection attempts between trees accelerate convergence to high-quality paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For pruning / collision status\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius*radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection between trees incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -30.31136,
    "time_improvement": 66.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1422.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008923959732055665,
            "num_nodes_avg": 65.7,
            "path_length_avg": 158.40615739090762,
            "smoothness_avg": 0.03733972735710829,
            "success_improvement": 0.0,
            "time_improvement": 67.59257335217355,
            "length_improvement": 13.175075027850603,
            "smoothness_improvement": 484.4478176545034,
            "objective_score": 25.3350260994947
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023128032684326172,
            "num_nodes_avg": 210.5,
            "path_length_avg": 238.2465608663746,
            "smoothness_avg": 0.10278213625175017,
            "success_improvement": 0.0,
            "time_improvement": 87.26571179414891,
            "length_improvement": 20.466440435776633,
            "smoothness_improvement": 2544.6583967379192,
            "objective_score": 42.9962936090896
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.031948184967041014,
            "num_nodes_avg": 215.0,
            "path_length_avg": 121.36816223222081,
            "smoothness_avg": 0.10505830687616682,
            "success_improvement": 0.0,
            "time_improvement": 41.80828057010345,
            "length_improvement": 19.393045576192172,
            "smoothness_improvement": 1236.3339088672706,
            "objective_score": 22.60276283060582
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a balanced bidirectional RRT* algorithm with informed ellipsoidal sampling, dynamic neighbor radius, edge collision caching, periodic pruning of leaf nodes, and path shortcut smoothing. It focuses search within an ellipsoidal region defined by the current best solution, incrementally rewires for path cost optimization, and prunes unproductive nodes to ensure efficiency and robustness.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal, alternately extending the smaller tree towards informed samples biased inside an ellipsoid. It dynamically adjusts neighbor radius for rewiring, caches collision checks for efficiency, incrementally attempts to connect two trees, prunes dead-end nodes periodically, and applies shortcut smoothing on the best found path before termination.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent            # Parent node or None\n        self.cost = cost                # Cost from root node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.15, radius_const: float = 16.0,\n                 radius_min: float = 4.0, prune_interval: int = 100,\n                 prune_threshold: int = 150, smoothing_iters: int = 50,\n                 collision_cache_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_cache_resolution = collision_cache_resolution\n        self._edge_collision_cache = {}\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def cache_key(p1, p2):\n            return tuple(sorted((p1, p2)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = cache_key(p1, p2)\n            if key in self._edge_collision_cache:\n                return self._edge_collision_cache[key]\n            distance_ = dist(p1, p2)\n            steps = max(1, int(distance_ / self.collision_cache_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    self._edge_collision_cache[key] = True\n                    return True\n            self._edge_collision_cache[key] = False\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (sum((n.position[d]-point[d])**2 for d in range(dim))) <= r_sq]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            return not is_edge_in_obstacle(p1, p2)\n\n        def sample_informed(best_cost):\n            if best_cost is None or best_cost == float('inf'):\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # fallback to start if no valid\n                return start_pos\n            c_min = dist(start_pos, goal_pos)\n            if best_cost < c_min:\n                best_cost = c_min * 1.05  # small margin\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            a1 = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Gram-Schmidt orthonormal basis (extend a1)\n            def gram_schmidt(vecs):\n                ortho = []\n                for v in vecs:\n                    w = list(v)\n                    for b in ortho:\n                        proj = sum(v[i]*b[i] for i in range(dim))\n                        w = [w[i] - proj*b[i] for i in range(dim)]\n                    norm = math.sqrt(sum(w[i]*w[i] for i in range(dim)))\n                    if norm > 1e-12:\n                        w = [w[i]/norm for i in range(dim)]\n                        ortho.append(tuple(w))\n                return ortho\n\n            random_dirs = [tuple(random.uniform(-1,1) for _ in range(dim)) for _ in range(dim-1)]\n            ortho_basis = gram_schmidt([a1] + random_dirs)[1:]\n            basis = [a1] + ortho_basis\n\n            radii = [best_cost/2] + [math.sqrt(max(best_cost*best_cost - c_min*c_min, 0))/2]*(dim-1)\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = (r*math.cos(theta), r*math.sin(theta))\n                elif dim == 3:\n                    phi = random.uniform(0, 2*math.pi)\n                    costheta = random.uniform(-1,1)\n                    sintheta = math.sqrt(1 - costheta*costheta)\n                    u = random.uniform(0,1)\n                    r = u ** (1/3)\n                    x_ball = (\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    )\n                else:\n                    # fallback uniform\n                    s = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(s):\n                        return s\n\n                coord = [radii[i]*x_ball[i] for i in range(dim)]\n                sample = [center[i] for i in range(dim)]\n                for i in range(dim):\n                    for j in range(dim):\n                        sample[i] += basis[j][i] * coord[j]\n                sample_t = tuple(sample)\n\n                if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                    return sample_t\n\n        def try_extend(tree, sample_pt, all_nodes):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nbr in neighbors:\n                temp_cost = nbr.cost + dist(nbr.position, new_pos)\n                if temp_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def try_connect(tree_goal, node_start):\n            if not tree_goal or node_start is None:\n                return None\n            last_node = nearest(tree_goal, node_start.position)\n            dist_to_goal = dist(last_node.position, node_start.position)\n            direction = tuple(node_start.position[d] - last_node.position[d] for d in range(dim))\n            steps = max(1, int(dist_to_goal / self.step_size))\n            prev_node = last_node\n\n            for i in range(1, steps + 1):\n                interp_pos = tuple(last_node.position[d] + direction[d] * i / steps for d in range(dim))\n                if not can_add_node(interp_pos) or not can_connect(prev_node.position, interp_pos):\n                    return None\n                cost = prev_node.cost + dist(prev_node.position, interp_pos)\n                new_node = Node(interp_pos, parent=prev_node, cost=cost)\n                prev_node.children.append(new_node)\n                tree_goal.append(new_node)\n                prev_node = new_node\n\n            if can_connect(prev_node.position, node_start.position):\n                final_cost = prev_node.cost + dist(prev_node.position, node_start.position)\n                final_node = Node(node_start.position, parent=prev_node, cost=final_cost)\n                prev_node.children.append(final_node)\n                tree_goal.append(final_node)\n                return final_node\n\n            return None\n\n        def prune_dead_nodes():\n            to_remove = [n for n in all_nodes if n not in (start_root, goal_root) and not n.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    all_nodes.remove(node)\n                except Exception:\n                    pass\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def path_length(pth):\n            return sum(dist(pth[i], pth[i+1]) for i in range(len(pth)-1))\n\n        success_state = False\n        extracted_path = []\n        all_nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        all_nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for itr in range(self.max_iter):\n            # Balance trees by extending smaller\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Sample: goal bias or informed\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos\n                if is_in_obstacle(goal_pos):\n                    sample_pt = sample_informed(best_cost if best_cost != float('inf') else None)\n            else:\n                sample_pt = sample_informed(best_cost if best_cost != float('inf') else None)\n\n            new_node_start = try_extend(tree_start, sample_pt, all_nodes)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                raw_len = path_length(raw_path)\n\n                if raw_len + 1e-12 < best_cost:\n                    smoothed = shortcut_smoothing(raw_path)\n                    smooth_len = path_length(smoothed)\n                    if smooth_len + 1e-12 < raw_len:\n                        best_path = smoothed\n                        best_cost = smooth_len\n                    else:\n                        best_path = raw_path\n                        best_cost = raw_len\n\n                extracted_path = best_path\n                # For better solutions, continue; else break\n                if itr > self.max_iter // 3:\n                    break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(all_nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        edges = [(n.parent, n) for n in all_nodes if n.parent is not None]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
    "objective": 487.3801,
    "time_improvement": -1654.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1111.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0647427558898925,
            "num_nodes_avg": 397.8,
            "path_length_avg": 157.29522608820935,
            "smoothness_avg": 0.02312555325884566,
            "success_improvement": 0.0,
            "time_improvement": -3766.621297758568,
            "length_improvement": 13.78399407869254,
            "smoothness_improvement": 261.96512644360223,
            "objective_score": -1125.919764879614
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.42332658767700193,
            "num_nodes_avg": 300.1,
            "path_length_avg": 247.20847343730262,
            "smoothness_avg": 0.07363325186354196,
            "success_improvement": 0.0,
            "time_improvement": -133.08349855159713,
            "length_improvement": 17.47469606525018,
            "smoothness_improvement": 1794.6366063365251,
            "objective_score": -27.456927320746473
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6382006645202637,
            "num_nodes_avg": 307.0,
            "path_length_avg": 123.56558638884034,
            "smoothness_avg": 0.10822444899251711,
            "success_improvement": 0.0,
            "time_improvement": -1062.4445660387191,
            "length_improvement": 17.93362108145939,
            "smoothness_improvement": 1276.6070028869449,
            "objective_score": -308.7636105808891
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a bidirectional RRT* inspired planner with simplified informed sampling within a dynamically adjusted ellipsoidal subset, balanced tree growth, adaptive neighbor radius for rewiring, and periodic pruning to improve efficiency and path quality. It integrates robust collision checks and basic shortcut smoothing to produce feasible, efficient paths in 2D or 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased within an ellipsoid centered on the current best path. Each expansion step steers towards sampled points, performs collision checks, and inserts new nodes with rewiring of nearby nodes to optimize path cost. Trees attempt connection bidirectionally for early solution discovery. Periodic pruning removes nodes unlikely to improve the path. Upon success, shortcut smoothing refines the final path for smoothness and shorter length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start tree root\n        self.children = []\n        self.valid = True              # For pruning or obstacle invalidation\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, prune_interval: int = 100, shortcut_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                if distance(node.position, point) <= radius:\n                    result.append(node)\n            return result\n\n        def unit_ball_sample():\n            while True:\n                p = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in p))\n                if norm > 1e-10:\n                    return tuple(x / norm for x in p)\n\n        def compute_rotation_matrix(a):\n            # Rotate unit vector a to x-axis\n            import numpy as np\n            a = np.array(a)\n            a = a / np.linalg.norm(a)\n            e_x = np.zeros_like(a)\n            e_x[0] = 1.0\n            v = np.cross(a, e_x) if dim == 3 else np.array([0, 0, 0])\n            s = np.linalg.norm(v)\n            c = np.dot(a, e_x)\n            if s < 1e-10:\n                return np.identity(dim)\n            vx = np.array([[0, -v[2], v[1]],\n                           [v[2], 0, -v[0]],\n                           [-v[1], v[0], 0]]) if dim ==3 else np.array([[0, -v[0]], [v[0],0]])\n            R = np.eye(dim) + vx + (vx @ vx) * ((1 - c) / (s * s))\n            return R\n\n        def informed_sample(c_best, c_min, x_center, C):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            a1 = c_best / 2.0\n            r_minor = 0.0\n            diff = c_best**2 - c_min**2\n            if diff > 0:\n                r_minor = math.sqrt(diff) / 2.0\n            L = [a1] + [r_minor] * (dim -1)\n            x_ball = unit_ball_sample()\n            x_scaled = tuple(L[i] * x_ball[i] for i in range(dim))\n            import numpy as np\n            x_scaled = np.array(x_scaled)\n            sample = C @ x_scaled + np.array(x_center)\n            sample = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return sample\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            length = len(path)\n            if length <= 2:\n                return path[:]\n            for _ in range(self.shortcut_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length-2)\n                j = random.randint(i+1, length-1)\n                if j == i + 1:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 2\n            import math\n            gamma = self.step_size * 2 * (math.log(n) / n) ** (1 / dim)\n            return max(gamma, self.step_size)\n\n        def prune(tree, cost_thresh):\n            removed_nodes = []\n            for node in tree[:]:\n                if node.cost > cost_thresh:\n                    def invalidate(n):\n                        n.valid = False\n                        for c in n.children[:]:\n                            invalidate(c)\n                        n.children.clear()\n                    invalidate(node)\n                    tree.remove(node)\n                    removed_nodes.append(node)\n            return removed_nodes\n\n        # Precompute for ellipsoid\n        c_min = distance(start, goal)\n        x_center = tuple((s + g) / 2 for s,g in zip(start, goal))\n        unit_vec = tuple((g - s) / c_min if c_min > 0 else 1.0 for s,g in zip(start, goal))\n        try:\n            import numpy as np\n            C = compute_rotation_matrix(unit_vec)\n        except:\n            C = np.identity(dim)\n\n        trees = [start_tree, goal_tree]\n        toggle = 0\n\n        for iter in range(1, self.max_iter + 1):\n            c_best_use = best_cost if success else float('inf')\n            sample = informed_sample(c_best_use, c_min, x_center, C)\n\n            curr_tree = trees[toggle]\n            other_tree = trees[1 - toggle]\n            toggle = 1 - toggle\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check bounds\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n            # Check collision of node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            radius = adaptive_radius(len(curr_tree))\n            near_nodes = near(curr_tree, new_pos, radius)\n\n            # Rewire: select best parent\n            min_cost = new_node.cost\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                tentative_cost = near_node.cost + distance(near_node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_parent = near_node\n            if min_parent != new_node.parent:\n                edges.remove((new_node.parent, new_node))\n                new_node.update_parent(min_parent, min_cost)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors through new_node\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                new_cost_to_near = new_node.cost + distance(new_node.position, near_node.position)\n                if new_cost_to_near < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, new_cost_to_near)\n                    edges.append((new_node, near_node))\n\n            # Attempt connection between trees\n            connect_candidate = nearest(other_tree, new_node.position)\n            dist_connect = distance(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    # Extract path\n                    path = extract_path(new_node, connect_candidate)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += distance(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n                        success = True\n                        x_center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n                    # Optionally break early on first connection\n                    break\n\n            # Periodic pruning\n            if success and iter % self.prune_interval == 0:\n                threshold_cost = best_cost * 1.2\n                prune(start_tree, threshold_cost)\n                prune(goal_tree, threshold_cost)\n                nodes = [n for n in nodes if n.valid]\n                new_edges = []\n                for e in edges:\n                    p, c = e\n                    if p.valid and c.valid:\n                        new_edges.append(e)\n                edges = new_edges\n\n        # Shortcut smoothing of final path\n        if success and best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -25.69587,
    "time_improvement": 74.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 435.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007315301895141601,
            "num_nodes_avg": 103.6,
            "path_length_avg": 186.1036822404301,
            "smoothness_avg": 0.014870050228711542,
            "success_improvement": 0.0,
            "time_improvement": 73.4344263430582,
            "length_improvement": -2.0063772375401063,
            "smoothness_improvement": 132.74857691023996,
            "objective_score": 22.29279533996064
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.016515016555786133,
            "num_nodes_avg": 247.3,
            "path_length_avg": 260.19866422003076,
            "smoothness_avg": 0.022418754592300284,
            "success_improvement": 0.0,
            "time_improvement": 90.90683659019959,
            "length_improvement": 13.138196480065398,
            "smoothness_improvement": 476.8507032361293,
            "objective_score": 32.283943789253605
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02378501892089844,
            "num_nodes_avg": 306.6,
            "path_length_avg": 135.26174771677307,
            "smoothness_avg": 0.06249480817049128,
            "success_improvement": 0.0,
            "time_improvement": 56.67700218001164,
            "length_improvement": 10.165587638798554,
            "smoothness_improvement": 694.9293470417477,
            "objective_score": 22.510864916971943
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines bidirectional RRT* with informed ellipsoidal sampling, KD-tree accelerated nearest neighbor searches, adaptive and dynamically shrinking neighbor radius, collision caching, incremental rewiring, periodic pruning of non-promising nodes, and aggressive shortcut smoothing. The algorithm balances exploration and exploitation to reduce planning time and minimize path length in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions guided by informed sampling inside an ellipsoidal domain defined by the current best path cost. It uses KD-trees for fast nearest neighbor and radius queries and caches collision checks to avoid redundancy. Nodes are rewired locally for incremental path cost improvement. Periodic pruning removes nodes unlikely to contribute to better solutions, keeping the search space efficient. Upon successful connections, shortcut smoothing aggressively reduces path length, producing smooth, high-quality paths quickly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i,p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n\n            # Calculate rotation matrix via Householder transform\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2)*(c_min/2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree expansion: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.70108,
    "time_improvement": 64.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1406.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009754037857055664,
            "num_nodes_avg": 69.6,
            "path_length_avg": 162.66289483423094,
            "smoothness_avg": 0.0426969691186878,
            "success_improvement": 0.0,
            "time_improvement": 64.57813842019229,
            "length_improvement": 10.84188978284383,
            "smoothness_improvement": 568.3002846599074,
            "objective_score": 24.383320905925988
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02883005142211914,
            "num_nodes_avg": 242.7,
            "path_length_avg": 233.40466166708998,
            "smoothness_avg": 0.0918010817854352,
            "success_improvement": 0.0,
            "time_improvement": 84.12618190186252,
            "length_improvement": 22.08280575483892,
            "smoothness_improvement": 2262.1079559858003,
            "objective_score": 40.96495550145554
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030414462089538574,
            "num_nodes_avg": 183.8,
            "path_length_avg": 124.66796157247536,
            "smoothness_avg": 0.11688931448183011,
            "success_improvement": 0.0,
            "time_improvement": 44.601865603585296,
            "length_improvement": 17.2014759739543,
            "smoothness_improvement": 1386.823452337165,
            "objective_score": 23.754972137552272
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm is an optimized bidirectional informed RRT* planner that integrates efficient nearest neighbor searches using a KDTree, adaptive ellipsoidal informed sampling biased by the current best path cost, dynamic neighbor radius adjustments, caching for collision checks, node pruning based on heuristic cost estimates, and path shortcut smoothing. These enhancements target reduced planning time and improved path quality while maintaining robustness and high success rates.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal, alternating expansions. Sampling is focused inside an ellipsoidal informed subset that shrinks as better paths are found, promoting fast convergence. A KDTree accelerates neighbor queries for rewiring and connecting nodes. Pruning discards nodes unlikely to contribute better solutions, collision caching avoids redundant checks, and shortcut smoothing refines the resulting path for length and smoothness improvements.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=20.0,\n                 prune_interval: int=150, prune_threshold: int=250,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            c = n_nodes\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                # Using basic KDTree for speed-up\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for idx, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[idx]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                result = []\n                for idx, p in enumerate(self.points):\n                    sqd = 0.0\n                    for i in range(self.dim):\n                        delta = p[i] - pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[idx])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution found or improvement negligible: uniform + goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute rotation matrix for ellipse alignment\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform samples if ellipsoid sampling fails\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost * 1.05:  # slight tolerance\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: grow smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-15 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors in radius\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-15 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-15 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-15 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        # If no break but success from some improvement found\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -32.30236,
    "time_improvement": 71.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1528.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00790090560913086,
            "num_nodes_avg": 66.2,
            "path_length_avg": 159.28513148253467,
            "smoothness_avg": 0.038545797806017315,
            "success_improvement": 0.0,
            "time_improvement": 71.30780206688277,
            "length_improvement": 12.693295399994028,
            "smoothness_improvement": 503.3254392038283,
            "objective_score": 26.447626896082777
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02948789596557617,
            "num_nodes_avg": 271.4,
            "path_length_avg": 245.5992997289007,
            "smoothness_avg": 0.1048269616761363,
            "success_improvement": 0.0,
            "time_improvement": 83.76397288368237,
            "length_improvement": 18.011884566611798,
            "smoothness_improvement": 2597.2732277355954,
            "objective_score": 41.71793491710505
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02283213138580322,
            "num_nodes_avg": 204.9,
            "path_length_avg": 121.97728299091303,
            "smoothness_avg": 0.12452931218991647,
            "success_improvement": 0.0,
            "time_improvement": 58.41263017101367,
            "length_improvement": 18.9884965714824,
            "smoothness_improvement": 1484.003659258053,
            "objective_score": 28.741506661890845
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* path planning algorithm enhanced by adaptive informed sampling inside an ellipsoidal subset, aggressive rewiring with dynamic neighbor radius adjustment, KD-tree accelerated neighbor queries, collision caching, and periodic pruning of non-promising nodes. It uses repeated shortcut smoothing on candidate paths to minimize path length and improve smoothness, ensuring efficient convergence to high-quality feasible paths in both 2D and 3D cluttered environments.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal alternately. Sampling is biased adaptively within an ellipsoid defined by the current best path cost to focus exploration on promising regions. It efficiently selects nearest and near nodes via a KD-tree proxy. New nodes are expanded using a steering function constrained by step size and validated by collision checks on points and edges. The rewiring step incrementally optimizes local connections to reduce costs. When trees approach each other, incremental connections are attempted with thorough collision checking. Periodic pruning removes dead-end or costly nodes. Final shortcut smoothing iteratively improves the path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute a rotation matrix that aligns the first axis to a1\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            elif reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius*radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff*diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency & robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -13.18731,
    "time_improvement": 61.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1631.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016665434837341307,
            "num_nodes_avg": 71.8,
            "path_length_avg": 161.7264313152474,
            "smoothness_avg": 0.05259602837673424,
            "success_improvement": 0.0,
            "time_improvement": 39.479348488626606,
            "length_improvement": 11.355180276812774,
            "smoothness_improvement": 723.2420581995709,
            "objective_score": 17.731050892948392
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.023481059074401855,
            "num_nodes_avg": 195.0,
            "path_length_avg": 236.88260187535707,
            "smoothness_avg": 0.11146814675527048,
            "success_improvement": -9.999999999999998,
            "time_improvement": 87.07133556436516,
            "length_improvement": 20.921769206361052,
            "smoothness_improvement": 2768.155703273982,
            "objective_score": -5.8534669730483255
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02395205497741699,
            "num_nodes_avg": 165.7,
            "path_length_avg": 122.23987147766532,
            "smoothness_avg": 0.11807795288455045,
            "success_improvement": 0.0,
            "time_improvement": 56.37275593423487,
            "length_improvement": 18.81409780170158,
            "smoothness_improvement": 1401.9428450836074,
            "objective_score": 27.68436056602881
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements a cost-aware RRT* variant with rewiring, goal biasing, and informed sampling. It incrementally builds a tree from the start node, optimizes paths by rewiring nearby nodes to achieve lower costs, and applies path smoothing after an initial feasible path is found to improve path quality and length.",
    "planning_mechanism": "The planner samples points in the free space with goal bias and informed sampling after the first solution, finds nearby nodes within a radius to determine the optimal parent minimizing cost, adds the new node while ensuring collision-free edges, rewires neighboring nodes if better paths through the new node exist, and finally performs shortcut smoothing on the extracted path to reduce unnecessary detours.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def ball_near_nodes(nodes, new_pos, radius):\n            return [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n        def choose_parent(neighbors, nearest_node, new_pos):\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            parent = nearest_node\n            for node in neighbors:\n                if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    candidate_cost = node.cost + dist(node.position, new_pos)\n                    if candidate_cost < min_cost:\n                        min_cost = candidate_cost\n                        parent = node\n            return parent, min_cost\n\n        def rewire(nodes, new_node, neighbors):\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    # Rewire: remove from old parent's children\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    self._propagate_cost_to_leaves(node)\n\n        def path_to_root(node):\n            path = []\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                # Try to connect i to furthest reachable point skipping intermediate nodes\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize root node\n        root = Node(start_position, parent=None, cost=0.0)\n        nodes: list[Node] = [root]\n        edges: list[tuple[Node, Node]] = []\n\n        solution_node = None\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = ball_near_nodes(nodes, new_pos, self.neighbor_radius)\n            parent, cost = choose_parent(neighbors, nearest_node, new_pos)\n\n            new_node = Node(new_pos, parent=parent, cost=cost)\n            parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n\n            rewire(nodes, new_node, neighbors)\n\n            # Check if new_node can connect to goal with collision-free edge\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    solution_node = goal_node\n                    break\n\n        success_state = solution_node is not None\n        extracted_path: list[tuple[float, ...]] = []\n        if success_state:\n            extracted_path = path_to_root(solution_node)\n            extracted_path = shortcut_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _propagate_cost_to_leaves(self, node):\n        from collections import deque\n        import math\n        queue = deque([node])\n        while queue:\n            current = queue.popleft()\n            for child in current.children:\n                old_cost = child.cost\n                new_cost = current.cost + math.dist(current.position, child.position)\n                if new_cost < old_cost:\n                    child.cost = new_cost\n                    queue.append(child)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 183.17124,
    "time_improvement": -644.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1221.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2881009101867676,
            "num_nodes_avg": 312.2,
            "path_length_avg": 166.70330599123756,
            "smoothness_avg": 0.05268764749226411,
            "success_improvement": 0.0,
            "time_improvement": -1026.0337032163798,
            "length_improvement": 8.62727640327661,
            "smoothness_improvement": 724.6760963117072,
            "objective_score": -302.4612752027001
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7660973787307739,
            "num_nodes_avg": 887.4,
            "path_length_avg": 220.94102224593308,
            "smoothness_avg": 0.07313926255641115,
            "success_improvement": 0.0,
            "time_improvement": -364.43637150974814,
            "length_improvement": 26.243527339590617,
            "smoothness_improvement": 1781.9259056579333,
            "objective_score": -95.17257645671664
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3233975648880005,
            "num_nodes_avg": 503.0,
            "path_length_avg": 115.86243484080157,
            "smoothness_avg": 0.09874712603756688,
            "success_improvement": 0.0,
            "time_improvement": -540.9003133089936,
            "length_improvement": 23.049687555007775,
            "smoothness_improvement": 1156.0561544431912,
            "objective_score": -151.8798757094806
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm combines the strengths of RRT* and informed sampling by incorporating a heuristic-based informed subset to focus sampling within an ellipsoidal region likely containing the optimal path. It incrementally builds and rewires a tree from start to goal with goal biasing and adaptive rewiring radius for better efficiency. Post-planning, path smoothing is applied using shortcutting to reduce unnecessary detours and improve path quality.",
    "planning_mechanism": "The planner performs an informed RRT*-style search: it samples points biased within an ellipsoidal informed set defined by the current best path cost, steering towards these samples while checking collision for nodes and edges. It rewires nearby nodes for optimality using a dynamically scaled neighborhood radius. Upon successfully reaching the goal, a path smoothing post-process attempts shortcut connections along the path to improve smoothness and shorten the path length, improving robustness and success rate while reducing search time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # tuning parameter for neighbor radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Track best goal node to use in informed sampling & path extraction\n        best_goal_node = None\n        best_cost = float('inf')\n\n        dim = len(bounds)\n\n        # Precompute heuristic distance function for informed sampling\n        def heuristic(p1, p2):\n            return math.dist(p1, p2)\n\n        def informed_sample():\n            # When best_cost is known, sample inside ellipsoidal region defined by foci start & goal and radius best_cost\n            if best_cost == float('inf'):\n                # No solution found yet: uniform random (with goal bias)\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Ellipsoidal sampling inside informed set\n                c_min = heuristic(start_position, goal_position)\n                if best_cost < c_min:\n                    # Numerical robustness: fallback to uniform sampling when best_cost smaller than c_min\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                # Coordinate transformation units\n                a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n\n                # Create rotation matrix to align unit vector with x-axis\n                # For 2D or 3D we construct orthonormal basis via Gram-Schmidt\n                def unit_vector(v):\n                    norm = math.sqrt(sum(x * x for x in v))\n                    return tuple(x / norm for x in v)\n\n                def build_rotation_matrix(a1):\n                    # Build rotation matrix from a1 to [1,0,...]\n                    # Only 2D or 3D considered here\n                    if dim == 2:\n                        # rotate vector a1 to x-axis\n                        cos_theta = a1[0]\n                        sin_theta = a1[1]\n                        return [\n                            [cos_theta, sin_theta],\n                            [-sin_theta, cos_theta],\n                        ]\n                    elif dim == 3:\n                        # Create orthonormal basis with a1 as first col\n                        x_axis = a1\n                        # arbitrary vector not colinear with x_axis\n                        if abs(x_axis[0]) < 0.9:\n                            v = (1, 0, 0)\n                        else:\n                            v = (0, 1, 0)\n                        # compute y_axis orthogonal to x_axis\n                        y_axis = (x_axis[1] * v[2] - x_axis[2] * v[1],\n                                  x_axis[2] * v[0] - x_axis[0] * v[2],\n                                  x_axis[0] * v[1] - x_axis[1] * v[0])\n                        norm_y = math.sqrt(sum(y * y for y in y_axis))\n                        y_axis = tuple(y / norm_y for y in y_axis)\n                        # z_axis is cross product x_axis x y_axis\n                        z_axis = (x_axis[1] * y_axis[2] - x_axis[2] * y_axis[1],\n                                  x_axis[2] * y_axis[0] - x_axis[0] * y_axis[2],\n                                  x_axis[0] * y_axis[1] - x_axis[1] * y_axis[0])\n                        return [x_axis, y_axis, z_axis]\n\n                rotation = build_rotation_matrix(a1)\n\n                # Radii of ellipse axes\n                r1 = best_cost / 2\n                r_rest = math.sqrt(best_cost ** 2 - c_min ** 2) / 2\n                if dim == 2:\n                    r2 = r_rest\n                elif dim == 3:\n                    r2 = r_rest\n                    r3 = r_rest\n\n                def sample_unit_ball():\n                    # sample uniformly on unit ball in dim dimensions\n                    while True:\n                        if dim == 2:\n                            x = random.uniform(-1, 1)\n                            y = random.uniform(-1, 1)\n                            if x * x + y * y <= 1:\n                                return (x, y)\n                        else:\n                            # 3D case\n                            x = random.uniform(-1, 1)\n                            y = random.uniform(-1, 1)\n                            z = random.uniform(-1, 1)\n                            if x * x + y * y + z * z <= 1:\n                                return (x, y, z)\n\n                # sample point in unit ball\n                u = sample_unit_ball()\n\n                # scale unit ball by ellipse axes lengths\n                if dim == 2:\n                    point_ball = (u[0] * r1, u[1] * r2)\n                    # rotate and translate\n                    x = rotation[0][0] * point_ball[0] + rotation[0][1] * point_ball[1]\n                    y = rotation[1][0] * point_ball[0] + rotation[1][1] * point_ball[1]\n                    sample = (center[0] + x, center[1] + y)\n                else:  # 3D\n                    point_ball = (u[0] * r1, u[1] * r2, u[2] * r3)\n                    x = sum(rotation[0][i] * point_ball[i] for i in range(3))\n                    y = sum(rotation[1][i] * point_ball[i] for i in range(3))\n                    z = sum(rotation[2][i] * point_ball[i] for i in range(3))\n                    sample = (center[0] + x, center[1] + y, center[2] + z)\n\n                # Clip sample to map bounds\n                clipped = tuple(min(max(sample[d], 0), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(clipped, obstacles, is_3d):\n                    return clipped\n                else:\n                    # fallback uniform sampling on collision in informed set\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(sample_pos):\n            return min(nodes, key=lambda n: heuristic(n.position, sample_pos))\n\n        def near_nodes(new_pos, radius):\n            return [n for n in nodes if heuristic(n.position, new_pos) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = heuristic(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def extract_path(goal_node: Node) -> List[Tuple[float, ...]]:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def smooth_path(path: List[Tuple[float, ...]], iterations=50):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut path segment\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = informed_sample()\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + heuristic(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.parent = nearest\n            new_node.cost = new_cost\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Adaptive radius for rewiring according to RRT* theory:\n            radius = min(\n                self.gamma_rrt_star * (math.log(len(nodes)) / len(nodes)) ** (1 / dim),\n                self.step_size * 5\n            )\n\n            neighbors = near_nodes(new_pos, radius)\n\n            # Choose best parent from neighbors (including nearest)\n            min_cost = new_node.cost\n            best_parent = nearest\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                tentative_cost = neighbor.cost + heuristic(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent != new_node.parent:\n                # Update parent and cost\n                new_node.update_parent(best_parent, min_cost)\n                # Update edges list accordingly\n                try:\n                    edges.remove((nearest, new_node))\n                except ValueError:\n                    pass\n                edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Check if close enough to goal to connect\n            dist_to_goal = heuristic(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # If better than best found so far, update best_goal_node and best_cost\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n                    success_state = True\n                    break\n\n        if success_state and best_goal_node is not None:\n            path = extract_path(best_goal_node)\n            path = smooth_path(path, iterations=100)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 41.91639,
    "time_improvement": -115.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1271.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05174500942230224,
            "num_nodes_avg": 325.5,
            "path_length_avg": 172.4563046999091,
            "smoothness_avg": 0.028019873900187498,
            "success_improvement": -9.999999999999998,
            "time_improvement": -102.24380598099768,
            "length_improvement": 5.473966648955463,
            "smoothness_improvement": 338.5718726679847,
            "objective_score": -77.88548910116829
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2333299398422241,
            "num_nodes_avg": 1114.2,
            "path_length_avg": 236.48404480458436,
            "smoothness_avg": 0.09128961090955336,
            "success_improvement": 0.0,
            "time_improvement": -41.45318027904815,
            "length_improvement": 21.05481902841419,
            "smoothness_improvement": 2248.9474419517796,
            "objective_score": 3.019746931727294
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15271944999694825,
            "num_nodes_avg": 759.0,
            "path_length_avg": 122.10876741269149,
            "smoothness_avg": 0.10429132946912616,
            "success_improvement": 0.0,
            "time_improvement": -202.65516496798165,
            "length_improvement": 18.90117087915249,
            "smoothness_improvement": 1226.5780128620963,
            "objective_score": -50.88342525025351
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the rapid exploration strength of RRT (Algorithm 1) with the path optimality and local rewiring features of RRT* (Algorithm 2), enhanced by adaptive goal biasing and dynamic neighbor radius scaling to improve planning efficiency, path quality, and success rate. It employs informed sampling once a path is found to focus search within an ellipsoidal subset, and uses parent selection and rewiring for local path cost optimization while maintaining robustness and collision safety checks.",
    "planning_mechanism": "The planner incrementally samples points in the configuration space with goal biasing. Before a solution path is found, it performs uniform random sampling; afterward, it samples within an ellipsoid around the start and goal to focus search. For each sample, it finds the nearest node and steers toward the sample. It selects the best parent from nodes within a dynamically scaled radius to minimize path cost, adds the new node if valid, and then attempts to rewire neighbors to improve their paths. When a path to goal is found, it extracts and returns the optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_factor: float = 20.0, resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Factor to compute neighbor radius: r = neighbor_factor * (log(n)/n)^(1/d)\n        self.resolution = resolution  # Collision check interpolation step size\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, extend_length):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return from_pos\n            scale = min(extend_length, length) / length\n            new_pos = tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n            # Clamp within bounds\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return new_pos\n\n        def line_cost(pos1, pos2):\n            return dist(pos1, pos2)\n\n        def compute_neighbor_radius(n_nodes):\n            # Scaled radius per RRT* theory: gamma * (log(n)/n)^(1/d)\n            if n_nodes <= 1:\n                return self.step_size * 2.0  # At least twice step size for initial growth\n            gamma = self.neighbor_factor\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return min(r, self.step_size * 30)  # Clamp max radius to avoid excess computation\n\n        def is_sample_in_bounds(sample):\n            return all(0.0 <= sample[d] <= bounds[d] for d in range(dim))\n\n        def ellipsoid_sampling(start, goal, c_best):\n            # Sample inside prolate hyperspheroid (ellipsoid) between start and goal with cost c_best\n            # Reference: Informed RRT*\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / dist(start, goal) if dist(start, goal) > 1e-9 else 0.0 for d in range(dim))\n\n            import numpy as np\n\n            # Create rotation matrix that aligns x-axis to a1\n            def unit_vector(vector):\n                norm = np.linalg.norm(vector)\n                if norm < 1e-10:\n                    return np.zeros_like(vector)\n                return vector / norm\n\n            def rotation_to_x_axis(v):\n                # Generate rotation matrix to align v with x-axis\n                v = unit_vector(v)\n                if np.allclose(v, np.array([1.0] + [0.0]*(dim-1))):\n                    return np.identity(dim)\n                # Householder transformation\n                e1 = np.zeros(dim)\n                e1[0] = 1.0\n                u = v - e1\n                u = u / np.linalg.norm(u)\n                H = np.identity(dim) - 2 * np.outer(u, u)\n                return H\n\n            c_min = dist(start, goal)\n            if c_best < float('inf'):\n                a = c_best / 2.0\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n            else:\n                a = float('inf')\n                b = 0.0\n\n            if a == float('inf'):\n                # No solution found yet, sample uniformly in bounds\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            # Radii for ellipsoid axes: (a, b, b, ...)\n            radii = np.array([a] + [b] * (dim - 1))\n\n            # Sample random point in unit n-ball\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                r = np.random.uniform(0, 1) ** (1.0 / dim)\n                x_ball *= r\n\n                # Scale by radii\n                sample_ellipsoid = radii * x_ball\n\n                # Rotation matrix to map x-axis to a1\n                R = rotation_to_x_axis(np.array(a1))\n\n                # Transform to world coordinates\n                sample_world = R.T.dot(sample_ellipsoid) + np.array(center)\n\n                # Check bounds\n                if np.all(sample_world >= 0) and np.all(sample_world <= np.array(bounds)):\n                    return tuple(float(c) for c in sample_world)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        c_best = float('inf')  # Current best path cost found\n\n        for i in range(self.max_iter):\n            # Decide on sampling method: uniform or informed ellipsoid sampling\n            if success_state:\n                sample = ellipsoid_sampling(start_position, goal_position, c_best)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not is_sample_in_bounds(sample):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n\n            new_position = steer(nearest_node.position, sample, self.step_size)\n\n            if new_position == nearest_node.position:\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, self.resolution):\n                continue\n\n            # Find neighbors within radius (dynamic radius)\n            radius = compute_neighbor_radius(len(nodes))\n            near_nodes = [n for n in nodes if dist(n.position, new_position) <= radius]\n\n            # Choose best parent to minimize cost + collision check required\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_position)\n                if temp_cost < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, self.resolution):\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            new_node = Node(new_position)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if beneficial\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.resolution):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal can be connected directly\n            dist_to_goal = dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and \n                    not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, self.resolution)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Update best path cost & success flag\n                    if goal_cost < c_best:\n                        c_best = goal_cost\n                    success_state = True\n\n        # Extract path if success\n        if success_state:\n            # Find goal node (last node at goal_position)\n            goal_candidates = [node for node in nodes if all(abs(node.position[d] - goal_position[d]) < 1e-6 for d in range(dim))]\n            if goal_candidates:\n                node = min(goal_candidates, key=lambda node: node.cost)\n                path = []\n                while node:\n                    path.append(node.position)\n                    node = node.parent\n                extracted_path = path[::-1]\n\n                # Optional smoothing: simple shortcutting to improve path smoothness\n                def shortcut_path(path):\n                    if len(path) < 3:\n                        return path\n                    smoothed = [path[0]]\n                    i = 0\n                    while i < len(path)-1:\n                        j = len(path)-1\n                        while j > i+1:\n                            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.resolution):\n                                break\n                            j -= 1\n                        smoothed.append(path[j])\n                        i = j\n                    return smoothed\n\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1544.547,
    "time_improvement": -5189.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1917.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 2.0179049253463743,
            "num_nodes_avg": 3141.1,
            "path_length_avg": 174.78377857752835,
            "smoothness_avg": 0.05158332795418008,
            "success_improvement": 0.0,
            "time_improvement": -7786.920434764781,
            "length_improvement": 4.19824133544863,
            "smoothness_improvement": 707.3910974724328,
            "objective_score": -2331.6995266749823
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.9570345640182496,
            "num_nodes_avg": 4030.1,
            "path_length_avg": 244.2963496244792,
            "smoothness_avg": 0.12669863239484255,
            "success_improvement": 0.0,
            "time_improvement": -1692.6629714055941,
            "length_improvement": 18.446846814807014,
            "smoothness_improvement": 3160.0470688555633,
            "objective_score": -488.30928671443894
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.122752547264099,
            "num_nodes_avg": 4531.9,
            "path_length_avg": 124.01480212205732,
            "smoothness_avg": 0.1559134147511153,
            "success_improvement": 0.0,
            "time_improvement": -6088.584278985334,
            "length_improvement": 17.635273380811213,
            "smoothness_improvement": 1883.2071273030194,
            "objective_score": -1813.6321933829229
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an Improved Bidirectional RRT* planner that grows two trees from start and goal positions, rewiring nodes for optimal cost paths, and uses adaptive sampling with goal biasing for efficiency. It incorporates collision checks both for nodes and edges, enforces map bounds, and performs path smoothing after connecting the trees to enhance path quality.",
    "planning_mechanism": "The planner incrementally grows two trees towards random samples (with goal biasing) and attempts to connect them. Each new node addition considers rewiring nearby nodes to improve cost, ensuring more optimal and smoother running paths. On successful connection of the two trees, the path is extracted and smoothed by shortcutting collision-free edges to reduce unnecessary waypoints and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        def in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            dist = distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def near(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def collision_free(node_pos):\n            return (not self._is_in_obstacle(node_pos, obstacles, is_3d)) and in_bounds(node_pos)\n\n        def edge_collision_free(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                if not edge_collision_free(new_node.position, neighbor.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n                    \n                    # Update costs downstream\n                    self._update_child_costs(neighbor, distance)\n\n        def attempt_connection(node_a, tree_b):\n            closest = nearest(tree_b, node_a.position)\n            if distance(node_a.position, closest.position) <= self.step_size:\n                if edge_collision_free(node_a.position, closest.position):\n                    # Connect nodes\n                    connect_node = Node(closest.position, parent=node_a, cost=node_a.cost + distance(node_a.position, closest.position))\n                    node_a.add_child(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((node_a, connect_node))\n                    return connect_node, closest\n            else:\n                # Try to extend from node_a towards closest in tree_b stepwise\n                new_pos = steer(node_a.position, closest.position, self.step_size)\n                if collision_free(new_pos) and edge_collision_free(node_a.position, new_pos):\n                    new_node = Node(new_pos, parent=node_a, cost=node_a.cost + distance(node_a.position, new_pos))\n                    node_a.add_child(new_node)\n                    nodes.append(new_node)\n                    edges.append((node_a, new_node))\n                    # Attempt connection recursively from new_node\n                    return attempt_connection(new_node, tree_b)\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def path_smoothing(path):\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1 :\n                j = len(path) -1\n                while j > i+1:\n                    if edge_collision_free(path[i], path[j]):\n                        smoothed.append(path[j])\n                        i = j\n                        break\n                    j -=1\n                else:\n                    smoothed.append(path[i+1])\n                    i +=1\n            return smoothed\n\n        for iter_count in range(self.max_iter):\n            # Sample with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                    continue\n\n                new_node_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_node_cost)\n                add_node(tree_a, new_node, nearest_node)\n\n                neighbors = near(tree_a, new_node.position, self.rewire_radius)\n                rewire(tree_a, new_node, neighbors)\n\n                connection = attempt_connection(new_node, tree_b)\n                if connection:\n                    node_start, node_goal = connection\n                    success_state = True\n                    extracted_path = extract_path(node_start, node_goal)\n                    # Smooth path to improve quality\n                    extracted_path = path_smoothing(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _update_child_costs(self, node, distance_func):\n        # Recursive cost update\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + distance_func(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-6:\n                self._update_child_costs(child, distance_func)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.01137,
    "time_improvement": -35.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1917.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05620908737182617,
            "num_nodes_avg": 357.7,
            "path_length_avg": 173.08128084890672,
            "smoothness_avg": 0.05334933165684479,
            "success_improvement": 0.0,
            "time_improvement": -119.69151977575918,
            "length_improvement": 5.131407318309048,
            "smoothness_improvement": 735.0328903575561,
            "objective_score": -31.20601001727816
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07505955696105956,
            "num_nodes_avg": 991.9,
            "path_length_avg": 236.16966571201405,
            "smoothness_avg": 0.12871211635594515,
            "success_improvement": 0.0,
            "time_improvement": 54.49613945960963,
            "length_improvement": 21.15976781841461,
            "smoothness_improvement": 3211.8554614286113,
            "objective_score": 36.640072708708864
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07125420570373535,
            "num_nodes_avg": 829.9,
            "path_length_avg": 120.8657177617101,
            "smoothness_avg": 0.1496483445919962,
            "success_improvement": 0.0,
            "time_improvement": -41.20960612651143,
            "length_improvement": 19.726745269670754,
            "smoothness_improvement": 1803.5158973184,
            "objective_score": 0.6000467025727225
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner that grows two trees from the start and goal positions. It uses adaptive step sizing, goal biasing, early connection attempts, rewiring for path optimization, and informed sampling within an ellipsoidal informed set to improve planning efficiency, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner alternates expanding the start and goal trees by sampling points that are increasingly biased toward the goal region. It steers towards samples using an adaptive step size and attempts to connect the two trees whenever new nodes are added. Rewiring of nearby nodes is performed to smooth paths and reduce overall cost. The search space is constrained adaptively using an informed sampling ellipsoid after the first solution is found, concentrating exploration around the optimal path corridor.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 4.0, goal_sample_rate: float = 0.1, rewire_radius: float = 8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # bias to sample goal\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            for i, v in enumerate(pos):\n                if v < 0 or v > bounds[i]:\n                    return False\n            return True\n\n        def sample_informed(start, goal, c_max):\n            # Sample within ellipsoidal informed set (only after first solution)\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))  # fallback\n            import numpy as np\n\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n\n            e1 = a1 / norm_a1\n            dim = len(bounds)\n            # Build the rotation matrix C using SVD to rotate unit vector along x-axis to e1\n            U = np.eye(dim)\n            U[:, 0] = e1\n            try:\n                import scipy.linalg\n                M = np.zeros((dim, dim))\n                M[0, 0] = 1.0\n                C, _, _ = scipy.linalg.svd(np.dot(U.T, M))\n            except:\n                C = np.eye(dim)\n\n            r1 = c_max / 2.0\n            r_rest = math.sqrt(c_max * c_max - c_min * c_min) / 2.0\n\n            if is_3d:\n                L = np.diag([r1] + [r_rest]*(dim-1))\n            else:\n                L = np.diag([r1, r_rest])\n\n            while True:\n                # Sample random point in unit ball\n                rnd = np.random.normal(size=dim)\n                norm_rnd = np.linalg.norm(rnd)\n                if norm_rnd == 0:\n                    continue\n                rnd = rnd / norm_rnd * (random.random() ** (1/dim))\n                sample = center + np.dot(C, np.dot(L, rnd))\n                sample_t = tuple(sample)\n                if within_bounds(sample_t) and (not self._is_in_obstacle(sample_t, obstacles, is_3d)):\n                    return sample_t\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def neighbors(tree, new_node, radius):\n            res = []\n            n = len(tree)\n            r = min(radius, self.step_size * (math.log(n + 1) / (n + 1)) ** (1.0 / (len(bounds))))\n            for node in tree:\n                if dist(node.position, new_node.position) <= r:\n                    res.append(node)\n            return res\n\n        def steer(from_pos, to_pos, max_step):\n            distance = dist(from_pos, to_pos)\n            if distance <= max_step:\n                return to_pos\n            ratio = max_step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def new_parent_rewire(new_node, tree):\n            # Rewire nearby nodes to parent via new_node if cheaper and feasible\n            neighbors_nodes = neighbors(tree, new_node, self.rewire_radius)\n            for neighbor in neighbors_nodes:\n                if neighbor == new_node.parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        # Remove neighbor from old parent children\n                        if neighbor.parent is not None:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = c_new\n                        new_node.add_child(neighbor)\n                        # Update costs downstream recursively\n                        self._update_descendants_cost(neighbor, dist)\n\n        def connect_trees(node_a, node_b, tree_b):\n            # Try connecting node_a from tree_a with node_b from tree_b by extending incremental steps\n            from_pos = node_a.position\n            to_pos = node_b.position\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n\n            new_node = Node(to_pos, parent=node_a, cost=node_a.cost + dist(from_pos, to_pos))\n            node_a.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((node_a, new_node))\n            return new_node\n\n        def extract_path(connect_node_start, connect_node_goal):\n            path_start = []\n            node = connect_node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = connect_node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        c_best = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        for iter in range(self.max_iter):\n            # Sample point with goal biasing and informed sampling if solution found\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif c_best < float('inf'):\n                sample = sample_informed(start_position, goal_position, c_best)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                while self._is_in_obstacle(sample, obstacles, is_3d):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not within_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node and add edge\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire for path improvement\n                new_parent_rewire(new_node, tree_a)\n\n                # Attempt to connect to opposite tree\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_to_new.position)\n                if dist_to_other <= self.step_size * 1.5:  # increased tolerance\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                        # Connect trees\n                        connect_node = connect_trees(new_node, nearest_to_new, tree_b)\n                        if connect_node:\n                            # Mark success if better path found\n                            total_cost = connect_node.cost + nearest_to_new.cost - dist(new_node.position, nearest_to_new.position)\n                            if total_cost < c_best:\n                                c_best = total_cost\n                                solution_node_start = new_node if tree_a is start_tree else nearest_to_new\n                                solution_node_goal = nearest_to_new if tree_b is goal_tree else new_node\n                                success_state = True\n                                extracted_path = extract_path(solution_node_start, solution_node_goal)\n\n            # Early stop if solution found and stable\n            if success_state and iter > self.max_iter * 0.25:\n                break\n\n        # Post-processing: Smooth path by shortcutting\n        if success_state:\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_descendants_cost(self, node, dist):\n        # Recursively update cost of descendants after rewiring\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + dist(node.position, child.position)\n            if child.cost < old_cost:\n                self._update_descendants_cost(child, dist)\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        import random\n        import math\n        if len(path) < 3:\n            return path\n\n        max_trials = 100\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p1 = path[i]\n            p2 = path[j]\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # shortcut possible: remove intermediate nodes between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 702.85465,
    "time_improvement": -2262.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1147.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.2252166986465454,
            "num_nodes_avg": 3457.5,
            "path_length_avg": 158.36504232921865,
            "smoothness_avg": 0.035258208629907375,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4688.722449801143,
            "length_improvement": 13.197610844672173,
            "smoothness_improvement": 451.8675294835464,
            "objective_score": -1451.7178751239908
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.6489976167678833,
            "num_nodes_avg": 1961.3,
            "path_length_avg": 239.70766135427425,
            "smoothness_avg": 0.07393479979123571,
            "success_improvement": -9.999999999999998,
            "time_improvement": -293.4461944635837,
            "length_improvement": 19.97868303747002,
            "smoothness_improvement": 1802.3956517122788,
            "objective_score": -125.0261434730197
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9610860109329223,
            "num_nodes_avg": 2898.0,
            "path_length_avg": 123.11566062498534,
            "smoothness_avg": 0.10109588471159485,
            "success_improvement": 0.0,
            "time_improvement": -1804.6535670023402,
            "length_improvement": 18.232440350649323,
            "smoothness_improvement": 1185.9321914094953,
            "objective_score": -531.8199210735246
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "An improved RRT* inspired planner that integrates bidirectional tree growth with goal biasing and dynamic rewiring for path cost optimization. It balances exploration and exploitation by sampling both randomly and toward the goal, grows two trees from start and goal, rewires neighbors to minimize cost, and connects the trees when close, ensuring collision-free nodes and edges. It emphasizes efficient sampling, local rewiring for path quality, and robust termination on corridor connection.",
    "planning_mechanism": "The planner iteratively samples points biased by the goal, extends each tree toward the sample with steering respecting step size, avoids obstacle collisions both for nodes and edges, rewires nearby nodes to optimize path cost, and tries to connect the two trees when near. Upon connection, it extracts the combined path from start to goal. The use of bidirectional growth, rewiring, and goal biasing improves path quality, success rate and planning efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    edges.remove((nbr.parent, nbr))\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n\n            return new_node\n\n        def try_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for nbr in neighbors:\n                    cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        edges.remove((nbr.parent, nbr))\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        for _ in range(self.max_iter):\n            sample = sample_point()\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                # Connection successful, merge path\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start  # Swap trees to alternate growth\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -28.36491,
    "time_improvement": 80.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 226.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005290818214416504,
            "num_nodes_avg": 74.9,
            "path_length_avg": 154.59755396885018,
            "smoothness_avg": 0.017965400641529433,
            "success_improvement": 0.0,
            "time_improvement": 79.32099685779568,
            "length_improvement": 15.26263091466356,
            "smoothness_improvement": 181.1975325318453,
            "objective_score": 27.75481290293064
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028932642936706544,
            "num_nodes_avg": 358.4,
            "path_length_avg": 246.63050103511983,
            "smoothness_avg": 0.013848569538816316,
            "success_improvement": 0.0,
            "time_improvement": 82.45996908908187,
            "length_improvement": 17.66763988911198,
            "smoothness_improvement": 256.3336689552014,
            "objective_score": 29.553187049322965
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01090552806854248,
            "num_nodes_avg": 185.0,
            "path_length_avg": 127.41581585955632,
            "smoothness_avg": 0.02665303953484971,
            "success_improvement": 0.0,
            "time_improvement": 78.38772732147979,
            "length_improvement": 15.37648199523525,
            "smoothness_improvement": 239.02469556055303,
            "objective_score": 27.786738073293755
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid planner combining bidirectional Rapidly-exploring Random Graph (RRG) exploration with a heuristic-informed sampling strategy and local path smoothing to rapidly find high-quality, collision-free paths. It grows two graphs (not just trees) from start and goal, enabling cycles and multiple connection candidates for better robustness and path optimization. Informed heuristic sampling guides growth towards the goal to improve efficiency. The planner rewires connections locally to maintain low-cost paths and applies path smoothing after finding a feasible route for improved smoothness and length reduction.",
    "planning_mechanism": "The planner initializes two graphs from start and goal points and iteratively samples states biased towards the goal region or informed ellipsoidal region (after first solution). Nodes attempt connection to nearby nodes in both graphs to form cycles, allowing multiple alternatives and graph rewiring to optimize paths. Once the two graphs connect, the shortest path is extracted. A local smoothing procedure optimizes the path by shortcutting collision-free node sequences, improving path quality and smoothness. Comprehensive collision and edge checks ensure path safety and feasibility throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(new_cost + self.distance_to(c.position))\n\n    def distance_to(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        import heapq\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two graphs: G_start and G_goal\n        G_start = []\n        G_goal = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n        G_start.append(start_node)\n        G_goal.append(goal_node)\n        nodes.extend([start_node, goal_node])\n\n        # Variables to track best connection between graphs\n        connected_node_start = None\n        connected_node_goal = None\n        best_cost = float('inf')\n\n        def sample_free():\n            # Heuristic biased sampling with informed region after one solution\n            if success:\n                # Informed sampling within prolate hyperspheroid bbox\n                c_best = best_cost\n                c_min = math.dist(start_pos, goal_pos)\n                if c_best < float('inf'):\n                    # Use ellipse sampling\n                    import numpy as np\n                    L = np.diag([c_best / 2] + [math.sqrt(max(c_best**2 - c_min**2, 0)) / 2] * (dim - 1))\n                    x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n                    a1 = np.array(goal_pos) - np.array(start_pos)\n                    a1_norm = np.linalg.norm(a1)\n                    if a1_norm == 0:\n                        a1_norm = 1e-6\n                    a1 /= a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:,0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, np.dot(np.diag([1]*(dim-1)+[np.linalg.det(U)*np.linalg.det(Vt)]), Vt))\n                    for _ in range(100):  # Trial limit\n                        x_ball = np.random.normal(0,1,dim)\n                        norm = np.linalg.norm(x_ball)\n                        if norm < 1e-10:\n                            continue\n                        x_ball = x_ball / norm * random.random()**(1.0/dim)\n                        x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                        if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                            if not self._is_in_obstacle(tuple(x_rand), obstacles, is_3d):\n                                return tuple(x_rand)\n                # Fallback uniform sampling\n            for _ in range(100):  # sample with rejection max 100 tries\n                if random.random() < 0.1:\n                    # 10% goal bias to speed convergence\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # Last fallback (likely in obstacle)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(graph, point):\n            return min(graph, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(graph, point, radius):\n            return [n for n in graph if math.dist(n.position, point) <= radius]\n\n        def rewire(graph, new_node, near_nodes_list):\n            for near in near_nodes_list:\n                edge_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + edge_cost\n                if potential_cost < near.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near's parent\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                            near.parent.children.remove(near)\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = potential_cost\n                    new_node.children.append(near)\n                    edges.append((new_node, near))\n                    # Update downstream children's cost recursively\n                    def update_subtree_costs(node):\n                        for c in node.children:\n                            c.cost = node.cost + math.dist(node.position, c.position)\n                            update_subtree_costs(c)\n                    update_subtree_costs(near)\n\n        def attempt_connect(g1, g2, new_node_g1):\n            # Try to connect new_node_g1 to any node in g2 within step_size\n            candidates = near_nodes(g2, new_node_g1.position, self.step_size)\n            best_connect = None\n            best_connect_cost = float('inf')\n            for node_g2 in candidates:\n                # Check collision free edge both sides\n                if not self._is_edge_in_obstacle(new_node_g1.position, node_g2.position, obstacles, is_3d):\n                    total_cost = new_node_g1.cost + math.dist(new_node_g1.position, node_g2.position) + node_g2.cost\n                    if total_cost < best_connect_cost:\n                        best_connect_cost = total_cost\n                        best_connect = node_g2\n            return best_connect, best_connect_cost\n\n        def add_edge(parent_node, child_node):\n            parent_node.add_child(child_node)\n            edges.append((parent_node, child_node))\n\n        # Main loop\n        for iter_i in range(self.max_iter):\n            sample = sample_free()\n\n            # Alternate expanding from start graph and goal graph\n            if iter_i % 2 == 0:\n                graph_front = G_start\n                graph_other = G_goal\n            else:\n                graph_front = G_goal\n                graph_other = G_start\n\n            near_node = nearest_node(graph_front, sample)\n            new_pos = steer(near_node.position, sample)\n            if new_pos == near_node.position:\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.children.append(new_node)\n            graph_front.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n\n            # Rewiring locally for better costs in graph_front\n            neighbors = near_nodes(graph_front, new_pos, self.neighbor_radius)\n            min_parent = near_node\n            min_cost = new_cost\n            # Find best parent from neighbors\n            for n in neighbors:\n                if n == new_node or n == near_node:\n                    continue\n                edge_cost = math.dist(n.position, new_pos)\n                potential_cost = n.cost + edge_cost\n                if potential_cost < min_cost and \\\n                   not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    min_parent = n\n            if min_parent != near_node:\n                # Re-assign parent and edges accordingly\n                edges.remove((near_node, new_node))\n                near_node.children.remove(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for n in neighbors:\n                if n == new_node:\n                    continue\n                edge_cost = math.dist(new_node.position, n.position)\n                potential_cost = new_node.cost + edge_cost\n                if potential_cost < n.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                            n.parent.children.remove(n)\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = potential_cost\n                    new_node.children.append(n)\n                    edges.append((new_node, n))\n                    # Update children recursively\n                    def update_children_cost(node):\n                        for c in node.children:\n                            c.cost = node.cost + math.dist(node.position, c.position)\n                            update_children_cost(c)\n                    update_children_cost(n)\n\n            # Attempt connect between graphs\n            connect_node, cost_connect = attempt_connect(graph_front, graph_other, new_node)\n            if connect_node is not None:\n                total_cost = cost_connect\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    # Determine start-to-goal path\n                    if graph_front is G_start:\n                        connected_node_start = new_node\n                        connected_node_goal = connect_node\n                    else:\n                        connected_node_start = connect_node\n                        connected_node_goal = new_node\n\n                    # Construct path by backtracking parents\n                    path_start = connected_node_start.path_from_root()\n                    path_goal = connected_node_goal.path_from_root()\n                    path_goal.reverse()\n                    final_path = path_start + path_goal\n\n                    # Run smoothing on path to improve quality\n                    final_path = self._smooth_path(final_path, obstacles, is_3d, bounds)\n\n                    # Early stopping for better speed\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_iter=100):\n        import math\n        if len(path) < 3:\n            return path\n        def is_collision_free(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        path = list(path)\n        length = len(path)\n        for _ in range(max_iter):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 2)\n            j = random.randint(i + 1, length - 1)\n            if j == i + 1:\n                continue\n            if is_collision_free(path[i], path[j]):\n                # Shortcut path segment by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n                length = len(path)\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.20533,
    "time_improvement": 55.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1262.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016167187690734865,
            "num_nodes_avg": 114.4,
            "path_length_avg": 168.80817139135868,
            "smoothness_avg": 0.03929113881779504,
            "success_improvement": 0.0,
            "time_improvement": 35.597439477258256,
            "length_improvement": 7.473566323743554,
            "smoothness_improvement": 514.9916445720623,
            "objective_score": 14.748903330786499
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02590622901916504,
            "num_nodes_avg": 271.1,
            "path_length_avg": 231.4569193626975,
            "smoothness_avg": 0.08693996472640893,
            "success_improvement": 0.0,
            "time_improvement": 84.29384561168787,
            "length_improvement": 22.733018198698883,
            "smoothness_improvement": 2137.0279127359618,
            "objective_score": 40.51989688692595
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027752995491027832,
            "num_nodes_avg": 307.4,
            "path_length_avg": 117.58853829807958,
            "smoothness_avg": 0.09700755852266033,
            "success_improvement": 0.0,
            "time_improvement": 44.322927926807566,
            "length_improvement": 21.90329182689772,
            "smoothness_improvement": 1133.9289840550973,
            "objective_score": 23.347181663697302
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed elliptical sampling, dynamic adaptive step sizing near obstacles, node rewiring for cost optimization, and pruning of inefficient nodes. It grows two trees from start and goal, alternates expansion, employs sampling within an informed subset to focus search towards promising regions, adapts step sizes considering obstacle proximity to safely explore narrow passages, applies rewiring to improve path cost continuously, and prunes branches unlikely to yield better solutions.",
    "planning_mechanism": "The planner iteratively samples random points within an ellipsoidal informed subset defined by the current best path cost to goal, steers from the nearest node with an adaptive step size, validates node and edge collisions rigorously, attempts to rewire neighbors within a radius to minimize costs, prunes nodes with costs exceeding the current best, and tries to connect two trees to update the best path. The process stops upon success or iteration limit, returning an optimized, feasible path with improved efficiency and quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_with_heuristic(node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        for iter_num in range(self.max_iter):\n            # Alternate trees\n            if iter_num % 2 == 0:\n                active_tree, other_tree = tree_a, tree_b\n            else:\n                active_tree, other_tree = tree_b, tree_a\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Do not exceed bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes with cost + heuristic worse than best known path\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius to reduce cost\n            neighbors = [node for node in active_tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                    # Add new edge\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes in active tree that have cost + heuristic worse than c_best\n            to_remove = []\n            for node in active_tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node != new_node and node != start_root and node != goal_root:\n                        to_remove.append(node)\n            for node in to_remove:\n                # Remove from parent's children\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                # Remove children links to avoid dangling references\n                node.children = []\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Try to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            # Early termination if found a path\n            if success_state:\n                # Optionally continue to improve path or break to return first good path\n                # Here, break after first path found\n                break\n\n        # Path smoothing: shortcut path by removing unnecessary nodes if possible\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shorten_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            # Start and goal are basically the same point, return it\n            return tuple(x_center)\n\n        a1 = diff / norm_diff\n\n        # Create rotation matrix C to rotate the unit vector to a1 direction\n        # Reference: https://arxiv.org/pdf/1109.4115.pdf\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim -1) + [det]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample uniformly inside unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            radius = random.random() ** (1 / dim)\n            x_ball = x_ball * radius\n\n            # Transform to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacles, but at least 1.0\n                return max(self.base_step * 0.25, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shorten_path(self, path, obstacles, is_3d):\n        # Attempts to shortcut the path by removing intermediate nodes when the\n        # straight-line path between non-adjacent nodes is collision-free.\n        import math\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.35232,
    "time_improvement": 6.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1549.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04930014610290527,
            "num_nodes_avg": 240.5,
            "path_length_avg": 169.95054568747466,
            "smoothness_avg": 0.05415383468147165,
            "success_improvement": 0.0,
            "time_improvement": -96.38886514516909,
            "length_improvement": 6.84741286996326,
            "smoothness_improvement": 747.6251096992462,
            "objective_score": -23.80905142106184
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.047037577629089354,
            "num_nodes_avg": 372.1,
            "path_length_avg": 237.86859110536346,
            "smoothness_avg": 0.09317261083841849,
            "success_improvement": 0.0,
            "time_improvement": 71.4825551897902,
            "length_improvement": 20.59261762125851,
            "smoothness_improvement": 2297.3983863915073,
            "objective_score": 37.0502820131463
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028564262390136718,
            "num_nodes_avg": 258.8,
            "path_length_avg": 128.01701657407608,
            "smoothness_avg": 0.13383198531076218,
            "success_improvement": 0.0,
            "time_improvement": 42.6953931395489,
            "length_improvement": 14.977193106752848,
            "smoothness_improvement": 1602.332974703307,
            "objective_score": 23.815721436731774
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm combines bidirectional RRT with adaptive informed sampling and dynamic rewiring to efficiently explore the space, improve path quality, and quickly converge to near-optimal solutions. It incorporates adaptive step size based on obstacle proximity, node pruning, and smoothing after path extraction to enhance path smoothness and reduce length.",
    "planning_mechanism": "The planner grows two trees from start and goal with goal biasing and informed sampling within an ellipsoidal heuristic region limiting samples to promising areas; it dynamically adjusts step size near obstacles to safely extend nodes; performs rewiring to reduce path cost; prunes unpromising branches; and upon successful connection, extracts the path and applies smoothing for improved quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        # Rotation matrix for ellipse sampling\n        def rotation_to_world(unit_vec):\n            # Constructs a rotation matrix that aligns the x-axis with unit_vec\n            # For 2D and 3D only\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                # Use Householder reflection to rotate unit_vec to x-axis\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    return p\n            else:\n                r1 = c_best / 2.0\n                if c_best**2 - c_min**2 < 0:\n                    r2 = 0\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball = x_ball / norm_x_ball\n                    # Scale by random radius within unit ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            # Find nearest node in other tree to new_node\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            # Check edge collision\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                # Connect the two paths\n                path_from_start = new_node.path_from_root() if tree_source is tree_start else nearest_other.path_from_root()\n                path_from_goal = nearest_other.path_from_root() if tree_source is tree_start else new_node.path_from_root()\n                # Reverse goal tree path except start node duplication\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        # Main loop\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            # Find nearest node in tree_a\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step based steering\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            # Prune nodes that cannot improve solution\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes for optimality\n            rewire(tree_a, new_node)\n\n            # Try to connect with other tree\n            try_connect(tree_a, tree_b, new_node)\n\n            # Early stop if path found with close to minimal cost\n            if success_state and best_cost <= c_min * 1.01:\n                break\n\n        # If success, smooth path\n        if success_state and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int = 15):\n        if len(path) < 3:\n            return path[:]\n        import random\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # Shortcut path\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 574.45011,
    "time_improvement": -1878.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 309.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.8320957899093628,
            "num_nodes_avg": 1549.5,
            "path_length_avg": 153.74607634589862,
            "smoothness_avg": 0.017201347478274894,
            "success_improvement": 0.0,
            "time_improvement": -3214.6828313910974,
            "length_improvement": 15.729339292329675,
            "smoothness_improvement": 169.23844135891187,
            "objective_score": -960.4127893520687
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 1.272113823890686,
            "num_nodes_avg": 2684.4,
            "path_length_avg": 228.69847223546608,
            "smoothness_avg": 0.021039148225681644,
            "success_improvement": -9.999999999999998,
            "time_improvement": -671.2437075559052,
            "length_improvement": 23.653867247266973,
            "smoothness_improvement": 441.35243773273106,
            "objective_score": -244.4355766286545
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9213220596313476,
            "num_nodes_avg": 2213.8,
            "path_length_avg": 117.31109101069724,
            "smoothness_avg": 0.03266645968614169,
            "success_improvement": 0.0,
            "time_improvement": -1748.323534419919,
            "length_improvement": 22.087559104556973,
            "smoothness_improvement": 315.51495602048266,
            "objective_score": -518.5019737249619
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned and enhanced bidirectional RRT* planner incorporating informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, and efficient rewiring to improve path quality and planning speed across 2D and 3D maps. It balances exploration and exploitation for robust navigation in cluttered spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately using informed elliptical sampling within a heuristic cost-bound, adaptively adjusts step size to avoid obstacles, prunes nodes unlikely to improve the solution, rewires neighbors to reduce path cost, and connects the two trees when proximity and collision-free conditions are met. The best path is updated dynamically to optimize both quality and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        a1_unit = a1 / norm_a1\n\n        # Precompute rotation matrix C for informed sampling\n        # Construct orthonormal basis via SVD for rotation\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune branch if potential cost worse than current best\n            heuristic_remaining = math.dist(new_pos, goal)\n            if cost + heuristic_remaining >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes within radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection between trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connection_dist = math.dist(new_node.position, other_nearest.position)\n            if connection_dist <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + connection_dist + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # Remove duplicate connecting node position\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            if success and (i % 100 == 0):\n                # Early stop if path found and improved recently\n                if c_best < float(\"inf\"):\n                    break\n\n        # Optional path smoothing (simple shortcut)\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:  # numerical issues if c_best < c_min due to float rounding\n            r2 = 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance * 1.5))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.35, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut path segment between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.79647,
    "time_improvement": -65.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 917.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0779529094696045,
            "num_nodes_avg": 434.8,
            "path_length_avg": 167.29084808809012,
            "smoothness_avg": 0.01983996215756792,
            "success_improvement": 0.0,
            "time_improvement": -210.52815530292239,
            "length_improvement": 8.305235269791412,
            "smoothness_improvement": 210.53849093333312,
            "objective_score": -60.44470708225177
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08757963180541992,
            "num_nodes_avg": 652.5,
            "path_length_avg": 239.06042775471852,
            "smoothness_avg": 0.06625774840202739,
            "success_improvement": 0.0,
            "time_improvement": 46.90314760246064,
            "length_improvement": 20.19474824258794,
            "smoothness_improvement": 1604.8595899113393,
            "objective_score": 26.13419187881248
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06488139629364013,
            "num_nodes_avg": 509.2,
            "path_length_avg": 125.80514296258566,
            "smoothness_avg": 0.08145784525964582,
            "success_improvement": 0.0,
            "time_improvement": -30.162748695657164,
            "length_improvement": 16.446214241401773,
            "smoothness_improvement": 936.1377791099944,
            "objective_score": -1.0788928648668232
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm presents an enhanced bidirectional RRT with goal biasing and simplified structure to improve efficiency and path quality. It grows two trees simultaneously\u2014from start and goal\u2014and attempts to connect them, alternating expansion in each iteration. Goal biasing increases convergence speed toward the goal. The approach includes collision checks for nodes and edges, pruning redundant exploration, and incremental connection attempts to improve robustness and success rate. Path extraction merges the two trees into a smooth, feasible path.",
    "planning_mechanism": "The planner alternates growing start and goal trees by steering towards samples, employs goal biasing to guide exploration, performs collision-free extension checks, and attempts to connect the two trees incrementally. Upon connecting, it extracts a final path by tracing parents from both trees, ensuring a feasible, smooth solution with reduced search overhead.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for itr in range(self.max_iter):\n            # Alternate start and goal tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try connecting trees\n                near_connect = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_connect = math.dist(new_pos, near_connect.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, near_connect.position, obstacles, is_3d):\n                        conn_node = Node(near_connect.position, parent=new_node, cost=new_node.cost + dist_connect)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Reconstruct path\n                        path = self._extract_path(conn_node, near_connect)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        # Extract path from node_a up to root start tree\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        # Extract path from node_b up to root goal tree\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        # Since node_b belongs to opposite tree, append its reversed path (excluding first duplicate node)\n        return path_a + path_b[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.73192,
    "time_improvement": 85.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 64.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0071019411087036135,
            "num_nodes_avg": 114.7,
            "path_length_avg": 183.5187018824448,
            "smoothness_avg": 0.010997871352320374,
            "success_improvement": 0.0,
            "time_improvement": 71.70916792508382,
            "length_improvement": -0.5895085416933348,
            "smoothness_improvement": 72.14056892370422,
            "objective_score": 21.755551513805
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.011534762382507325,
            "num_nodes_avg": 259.9,
            "path_length_avg": 309.6814971266057,
            "smoothness_avg": 0.0064039069277323805,
            "success_improvement": 0.0,
            "time_improvement": 93.00682632435114,
            "length_improvement": -3.3805974285229334,
            "smoothness_improvement": 64.77713779827361,
            "objective_score": 27.549814100592123
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.004734683036804199,
            "num_nodes_avg": 190.4,
            "path_length_avg": 169.66580872434636,
            "smoothness_avg": 0.01221306295668852,
            "success_improvement": 0.0,
            "time_improvement": 90.50144735658925,
            "length_improvement": -12.68395153709525,
            "smoothness_improvement": 55.34925933454292,
            "objective_score": 24.89039019623044
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates bidirectional RRT* with informed ellipsoidal sampling and adaptive neighbor radius, accelerated by a KD-tree for nearest neighbor and radius queries. It features collision caching to reduce redundant checks and aggressively smooths the best found path with shortcut smoothing. Periodic pruning removes nodes that cannot improve the current best path, which keeps the tree size manageable and improves efficiency. By always extending the smaller tree and carefully rewiring neighbors, it balances exploration and exploitation, resulting in faster convergence, higher success rates, shorter and smoother paths, and reduced planning time, suitable for both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points informed by the current best path cost within an ellipsoidal domain to focus exploration. Using KD-trees, it efficiently finds nearest nodes and neighbors within an adaptive radius for rewiring to maintain optimal path costs. Collision checks are cached to minimize redundant calculations. After successful tree connection, shortcut smoothing aggressively improves path quality. Periodic pruning removes nodes unlikely to yield better results, enhancing planner responsiveness and reducing search complexity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for dd in range(self.dim):\n                        delta = p[dd] - pt[dd]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.40642,
    "time_improvement": 68.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1539.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010012316703796386,
            "num_nodes_avg": 77.1,
            "path_length_avg": 163.0821224658909,
            "smoothness_avg": 0.04769419985049942,
            "success_improvement": 0.0,
            "time_improvement": 60.11558442791882,
            "length_improvement": 10.61210447484407,
            "smoothness_improvement": 646.5177972729804,
            "objective_score": 23.389685209709363
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0197650671005249,
            "num_nodes_avg": 197.0,
            "path_length_avg": 233.3702395381908,
            "smoothness_avg": 0.09661650476292852,
            "success_improvement": 0.0,
            "time_improvement": 88.01704427353981,
            "length_improvement": 22.094296852251514,
            "smoothness_improvement": 2386.01225760568,
            "objective_score": 42.75403394054065
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02242281436920166,
            "num_nodes_avg": 161.2,
            "path_length_avg": 123.1020374820916,
            "smoothness_avg": 0.13242855699368858,
            "success_improvement": 0.0,
            "time_improvement": 55.01614763993824,
            "length_improvement": 18.241488193494988,
            "smoothness_improvement": 1584.4814701004334,
            "objective_score": 28.07554928118264
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an enhanced RRT* planner which incrementally builds a single tree from the start toward the goal. It improves upon traditional RRT by rewiring nodes nearby newly added nodes to reduce path cost and improve path quality. The algorithm uses goal biasing for faster convergence and employs informed sampling after an initial solution to focus exploration within an ellipsoidal informed subset of the search space, thereby improving planning efficiency and success rates.",
    "planning_mechanism": "The planner samples random points in free space with goal biasing. If a solution is found, it switches to informed sampling (an ellipsoidal region constrained by current best path cost) to refine the solution. Each new node connects to the best parent from its neighbors minimizing cost, and nearby nodes are rewired if the new node can provide a lower cost path. Collision checks are performed for nodes and their edges. The process continues until max iterations or convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius    # Radius for rewiring neighbors\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def sample():\n            # If a solution found, use informed sampling inside ellipsoid\n            if success_state:\n                c_best = best_cost\n                c_min = math.dist(start_position, goal_position)\n                if c_best < float('inf'):\n                    # Informed sampling ellipsoid parameters\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    a1 = [(goal_position[d] - start_position[d]) / c_min for d in range(dim)]\n                    import numpy as np\n                    L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n                    # Rotation matrix aligning x-axis to a1\n                    def rotation_matrix(vec):\n                        import numpy as np\n                        e1 = np.array([1] + [0]*(dim-1))\n                        v = np.array(vec)\n                        v_norm = np.linalg.norm(v)\n                        if v_norm == 0:\n                            return np.eye(dim)\n                        v = v / v_norm\n                        if np.allclose(v, e1):\n                            return np.eye(dim)\n                        if np.allclose(v, -e1):\n                            # 180 deg rotation\n                            R = -np.eye(dim)\n                            R[0,0] = 1\n                            return R\n                        axis = np.cross(e1, v) if dim == 3 else ((e1 - v) / np.linalg.norm(e1 - v))\n                        s = np.linalg.norm(np.cross(e1, v)) if dim == 3 else 0\n                        c = np.dot(e1, v)\n                        # Rodrigues formula for 3D else identity\n                        if dim == 3:\n                            K = np.array([[0, -axis[2], axis[1]],\n                                          [axis[2], 0, -axis[0]],\n                                          [-axis[1], axis[0], 0]])\n                            R = np.eye(3) + K + K @ K * ((1 - c) / (s**2))\n                            return R\n                        else:\n                            return np.eye(dim)\n                    try:\n                        R = rotation_matrix(a1)\n                    except Exception:\n                        R = np.eye(dim)\n\n                    while True:\n                        # Sample unit ball\n                        sample_ball = np.random.normal(0,1,dim)\n                        sample_ball /= np.linalg.norm(sample_ball)\n                        # scale by random radius in unit ball\n                        r = random.random()\n                        sample_ball = sample_ball * (r ** (1/dim))\n                        # Scale by L and rotate and translate by center\n                        pt = R @ (L @ sample_ball) + np.array(center)\n                        pt_tuple = tuple(float(pt[d]) for d in range(dim))\n                        # Check bounds and obstacles\n                        if all(0 <= pt_tuple[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(pt_tuple, obstacles, is_3d):\n                            return pt_tuple\n                # If no proper informed sampling possible fallback to uniform\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near(nodes_list, new_node_pos, radius):\n            return [node for node in nodes_list if math.dist(node.position, new_node_pos) <= radius]\n\n        for _ in range(self.max_iter):\n            sample_point = sample()\n\n            nearest_node = nearest(nodes, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find near neighbors for RRT* rewiring\n            neighbor_nodes = near(nodes, new_pos, self.neighbor_radius)\n\n            # Choose the best parent minimizing cost to new_pos\n            best_parent = nearest_node\n            best_cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            for neighbor in neighbor_nodes:\n                cost_to_new = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_to_new < best_cost_to_new:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        best_parent = neighbor\n                        best_cost_to_new = cost_to_new\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire the neighbors if going through new_node is cheaper\n            for neighbor in neighbor_nodes:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except Exception:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_via_new\n                        new_node.children.append(neighbor)\n\n            # Check if new_node can connect to goal with collision-free edge\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best goal node if cost improves\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1889.64293,
    "time_improvement": -6318.0,
    "length_improvement": 25.0,
    "smoothness_improvement": 163.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.134256386756897,
            "num_nodes_avg": 4621.6,
            "path_length_avg": 145.17747491397782,
            "smoothness_avg": 0.015451391233048662,
            "success_improvement": 0.0,
            "time_improvement": -12385.420501277411,
            "length_improvement": 20.425925515343994,
            "smoothness_improvement": 141.84782603031226,
            "objective_score": -3710.8317261500024
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.1785389184951782,
            "num_nodes_avg": 4265.0,
            "path_length_avg": 216.89395587738153,
            "smoothness_avg": 0.01101867112745796,
            "success_improvement": 0.0,
            "time_improvement": -1220.7815220624732,
            "length_improvement": 27.594554581759674,
            "smoothness_improvement": 183.5183445375136,
            "objective_score": -359.7979539797024
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.715884828567505,
            "num_nodes_avg": 4800.3,
            "path_length_avg": 109.67961211616895,
            "smoothness_avg": 0.02080417819421633,
            "success_improvement": 0.0,
            "time_improvement": -5348.511509019911,
            "length_improvement": 27.156024014328693,
            "smoothness_improvement": 164.6276110257328,
            "objective_score": -1598.2991098479786
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional growth and connection of RRT trees with informed elliptical sampling, adaptive step sizing near obstacles, cost-based node pruning, and efficient rewiring to optimize path quality and computational efficiency. It balances exploration and exploitation by alternating between start and goal trees while guiding sampling within an informed ellipsoidal region that shrinks with better solutions. The planner dynamically adjusts step size near obstacles to navigate cluttered spaces robustly, prunes unpromising branches early based on heuristic cost bounds, and rewires nodes to improve path costs. Post-planning, the path is smoothed by shortcutting to enhance path quality and smoothness.",
    "planning_mechanism": "The planner starts two trees from start and goal points, alternately sampling points mostly within an informed ellipsoidal space defined by the current best solution cost. Each sampled point is connected by an adaptive step that shrinks near obstacles, ensuring collision-free growth. Branches unlikely to improve the current best cost are pruned. Nearby nodes are rewired if a lower-cost path is found. When the two trees can be connected collision-free within a proximity threshold, the path is updated. Finally, a shortcut smoothing step improves the path\u2019s smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n            except Exception:\n                r2 = 0.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n            for _ in range(100):  # limit tries to avoid infinite loop\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback random sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicated connecting position\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune nodes that cannot improve best cost\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Early stop if a good path is found\n            if success and i % 100 == 0 and c_best < float(\"inf\"):\n                break\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.12117,
    "time_improvement": -35.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1039.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06026041507720947,
            "num_nodes_avg": 332.6,
            "path_length_avg": 166.996413064366,
            "smoothness_avg": 0.016269651188625004,
            "success_improvement": 0.0,
            "time_improvement": -140.04948191203425,
            "length_improvement": 8.466619771916111,
            "smoothness_improvement": 154.6553712150155,
            "objective_score": -39.54824376315197
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06673438549041748,
            "num_nodes_avg": 500.6,
            "path_length_avg": 237.0038545493059,
            "smoothness_avg": 0.07697310282156793,
            "success_improvement": 0.0,
            "time_improvement": 59.54098295254645,
            "length_improvement": 20.88129157373222,
            "smoothness_improvement": 1880.5733770839436,
            "objective_score": 31.441420085930098
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06200351715087891,
            "num_nodes_avg": 431.8,
            "path_length_avg": 123.09804183051456,
            "smoothness_avg": 0.09294490050814501,
            "success_improvement": 0.0,
            "time_improvement": -24.389249957430696,
            "length_improvement": 18.244141915019977,
            "smoothness_improvement": 1082.2522739846838,
            "objective_score": 1.7433147656982069
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates bidirectional RRT* with informed sampling, adaptive step sizing, dynamic rewiring, node pruning, and post-processing path smoothing. It focuses on rapidly exploring promising regions via ellipsoidal informed sampling, optimizing path cost using rewiring, adapting step sizes near obstacles for safe extensions, and improving path smoothness and length with shortcut smoothing.",
    "planning_mechanism": "The planner alternates between growing two trees from start and goal positions, samples points inside an ellipsoidal heuristic region considering the current best path cost, steers adaptively with collision-aware step sizes, rewires nearby nodes for optimality, prunes nodes unlikely to improve the solution, and attempts connection between trees at each iteration. Once connected, the planner extracts, shortcuts, and returns the optimized and smoothed path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges: List[Tuple[\"Node\", \"Node\"]]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        def rotation_to_world(unit_vec):\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    return p\n            else:\n                r1 = c_best / 2.0\n                if c_best**2 - c_min**2 < 0:\n                    r2 = 0\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball = x_ball / norm_x_ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                path_from_start = new_node.path_from_root() if tree_source is tree_start else nearest_other.path_from_root()\n                path_from_goal = nearest_other.path_from_root() if tree_source is tree_start else new_node.path_from_root()\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        def prune_nodes(tree, best_cost):\n            # Remove nodes with heuristic cost > best_cost\n            for node in tree[:]:\n                heuristic = node.cost + math.dist(node.position, goal if tree is tree_start else start)\n                if heuristic >= best_cost and node.parent:\n                    node.remove_from_parent(edges)\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n\n        # Main loop\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n            try_connect(tree_a, tree_b, new_node)\n            prune_nodes(tree_a, best_cost)\n\n            if success_state and best_cost <= c_min * 1.01:\n                break\n\n        if success_state and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int = 20) -> List[Tuple[float, ...]]:\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 631.59921,
    "time_improvement": -2070.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 403.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.8705846548080445,
            "num_nodes_avg": 1312.3,
            "path_length_avg": 152.93352302094502,
            "smoothness_avg": 0.017624281799916444,
            "success_improvement": 0.0,
            "time_improvement": -3368.004577789175,
            "length_improvement": 16.17471264546813,
            "smoothness_improvement": 175.8582819091813,
            "objective_score": -1006.287139398113
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.4767683029174805,
            "num_nodes_avg": 2606.3,
            "path_length_avg": 229.84137329304548,
            "smoothness_avg": 0.030802338742556466,
            "success_improvement": 0.0,
            "time_improvement": -795.3194594330506,
            "length_improvement": 23.27233397766403,
            "smoothness_improvement": 692.5663618738082,
            "objective_score": -230.47853922501332
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.070005440711975,
            "num_nodes_avg": 2068.6,
            "path_length_avg": 118.59917910232939,
            "smoothness_avg": 0.03464946658341625,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2046.6068432320533,
            "length_improvement": 21.232072326258557,
            "smoothness_improvement": 340.73865738347155,
            "objective_score": -658.031945217447
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner combining informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, efficient rewiring, and aggressive path smoothing to improve path quality, success rate, and planning efficiency in both 2D and 3D spaces. It dynamically tunes parameters such as step size and rewiring radius to balance exploration and exploitation optimally.",
    "planning_mechanism": "The planner alternately grows two trees initialized at start and goal by sampling points using an informed elliptical distribution confined by the best current solution cost. Nodes are extended with adaptive step sizes that shrink near obstacles to enhance collision avoidance. Each new node is pruned if it cannot improve the current best path based on a heuristic cost bound. Nearby nodes are rewired to minimize path cost. When trees are sufficiently close and connected without collisions, the best path is updated. Finally, a robust path smoothing is performed to yield a shorter, smoother feasible route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        # Adaptive rewire radius tuned for balanced rewiring and computation time\n        self.rewire_radius = 10.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        best_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        for itr in range(self.max_iter):\n            # Alternate trees for balanced growth\n            tree_a, tree_b = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            # Sampling with goal bias and informed ellipsoidal bounds\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is not tree_b else start  # bias towards opposite tree goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size reduces near obstacles, maintaining minimum scale for progress\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal)\n            if new_cost + heuristic_remain >= c_best:\n                # Prune nodes that cannot improve current best solution\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors in radius to lower cost paths where possible\n            neighbors = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connection between trees \u2013 if close enough and collision free\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_conn = math.dist(new_node.position, other_nearest.position)\n            if dist_conn <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # remove duplicate node at connection\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            # Early stopping if a path is found with good cost and no improvements will likely happen\n            if success and itr > 200 and itr % 100 == 0:\n                if c_best < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d, max_trials=75)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:\n            r2 = 0.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps_eval = max(4, int(distance * 2.0))  # increased sampling for finer obstacle proximity\n        for i in range(1, steps_eval + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_eval) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Shrink step when close to obstacles but not less than a threshold\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=75):\n        import random\n\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 45.31364,
    "time_improvement": -70.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1153.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.09132659435272217,
            "num_nodes_avg": 446.0,
            "path_length_avg": 163.18307516793513,
            "smoothness_avg": 0.02216380666201768,
            "success_improvement": -9.999999999999998,
            "time_improvement": -263.8026991860653,
            "length_improvement": 10.556770699155697,
            "smoothness_improvement": 246.91170373708226,
            "objective_score": -125.79489709730304
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07148153781890869,
            "num_nodes_avg": 579.2,
            "path_length_avg": 237.82330371688914,
            "smoothness_avg": 0.08623212393261678,
            "success_improvement": 0.0,
            "time_improvement": 56.66292967350841,
            "length_improvement": 20.60773585505644,
            "smoothness_improvement": 2118.8146592745734,
            "objective_score": 31.71449936943668
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.05156354904174805,
            "num_nodes_avg": 448.4,
            "path_length_avg": 122.63782065239172,
            "smoothness_avg": 0.09375835259243642,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3.444957401990151,
            "length_improvement": 18.549798908151658,
            "smoothness_improvement": 1092.5993244540837,
            "objective_score": -41.86053081669629
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "A bidirectional RRT* planner incorporating informed sampling within an elliptical heuristic region, adaptive step sizing near obstacles, branch pruning based on current best path cost, and rewiring to improve path optimality. The planner efficiently explores the search space to find asymptotically optimal paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from the start and goal positions by sampling points inside an informed ellipsoidal subset to focus search around promising regions. Adaptive step size reduces step length near obstacles, preventing collisions. New nodes that cannot lead to better solutions are discarded. Nearby nodes are rewired to reduce path costs while ensuring collision-free connections. Whenever the two trees connect via an obstacle-free edge with a lower cost, the current best path updates accordingly.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        for i in range(self.max_iter):\n            # Alternate tree expansion\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue  # Prune nodes that cannot improve path\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring near nodes for path cost improvement\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_pos) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire node\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            if not self._is_edge_in_obstacle(new_pos, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_pos, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_from_start = new_node.path_from_root() if tree_a is tree_start else other_nearest.path_from_root()\n                    path_from_goal = other_nearest.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                    best_path = path_from_start + path_from_goal[::-1]\n                    success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        import numpy as np\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return tuple(x_center)\n        a1 = a1 / norm_a1\n\n        # Create rotation matrix C aligning unit vector a1 with first axis\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.step_size * 0.3, 1.0)\n        return self.step_size\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
    "objective": 784.83187,
    "time_improvement": -2632.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 153.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1159339189529418,
            "num_nodes_avg": 1776.4,
            "path_length_avg": 153.90446328974247,
            "smoothness_avg": 0.014004260415998549,
            "success_improvement": 0.0,
            "time_improvement": -4345.361996751859,
            "length_improvement": 15.642524898607125,
            "smoothness_improvement": 119.19708624861136,
            "objective_score": -1299.8841086145933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.6665050506591796,
            "num_nodes_avg": 3076.7,
            "path_length_avg": 230.88634558573963,
            "smoothness_avg": 0.011678293031371662,
            "success_improvement": 0.0,
            "time_improvement": -910.3510470470864,
            "length_improvement": 22.923492148502987,
            "smoothness_improvement": 200.49089123166658,
            "objective_score": -267.518161228267
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.3661439180374146,
            "num_nodes_avg": 2805.9,
            "path_length_avg": 117.23608224498957,
            "smoothness_avg": 0.01874205820490164,
            "success_improvement": 0.0,
            "time_improvement": -2640.7093195223824,
            "length_improvement": 22.137376355206406,
            "smoothness_improvement": 138.39759697151447,
            "objective_score": -787.0933326008159
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner fuses bidirectional RRT* with adaptive informed ellipsoidal sampling and efficient KD-tree based neighbor searching. It incorporates collision caching to minimize redundant checks, dynamic neighbor radius scaling for balanced rewiring, and aggressive pruning of non-promising and dead-end nodes. The planner incrementally connects trees with stepwise collision-checked expansions and applies iterative shortcut smoothing to refine the path for minimal length and smoothness, all designed to improve planning efficiency, path quality, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling preferentially inside an ellipsoidal informed subset shaped by the current best known path cost, thus biasing search towards promising regions. KD-tree accelerates nearest and neighbor searches. Nodes and edges are added only after rigorous collision validations, followed by dynamic rewiring for cost improvements. Incremental incremental connection attempts link the two trees. Periodic pruning of dead-end and high-cost nodes prevents tree bloat, keeping computations efficient. Final paths undergo repeated shortcut smoothing to yield minimal, smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio*(to_pos[d]-from_pos[d]) for d in range(dim))\n            # Clamp to bounds to avoid out-of-map issues\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / max(1, self.max_iter)) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Sampling inside the ellipsoidal informed set, or uniform if no current solution\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            # Fallback uniform random sampling if informed fails\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        # Cache collision for edges to avoid redundant expensive checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            elif reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff*diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            dist_to_goal = lambda node: dist(node.position, goal_pos)\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # prune dead-end nodes\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                # prune nodes with cost + heuristic >= best_cost to focus search\n                if node.cost + dist_to_goal(node) >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_point = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally attempt connection from tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, radius)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_target = dist(new_node_b.position, new_node.position)\n                if dist_to_target <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_target\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Recover and merge paths according to expansion order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path if improvement found\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to keep runtime manageable & encourage convergence\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            # Final iterative smoothing for improved path quality\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -30.04994,
    "time_improvement": 66.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1445.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013722515106201172,
            "num_nodes_avg": 91.3,
            "path_length_avg": 163.55318032812008,
            "smoothness_avg": 0.04320394005128221,
            "success_improvement": 0.0,
            "time_improvement": 45.3358786600944,
            "length_improvement": 10.353910196166764,
            "smoothness_improvement": 576.2354806600108,
            "objective_score": 18.552723040561727
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018545889854431154,
            "num_nodes_avg": 195.6,
            "path_length_avg": 233.51848845224814,
            "smoothness_avg": 0.09766944154417989,
            "success_improvement": 0.0,
            "time_improvement": 88.75619415288735,
            "length_improvement": 22.044807097630777,
            "smoothness_improvement": 2413.1050793869867,
            "objective_score": 43.1013450623273
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018517684936523438,
            "num_nodes_avg": 161.2,
            "path_length_avg": 128.60151640215642,
            "smoothness_avg": 0.11356707149264793,
            "success_improvement": 0.0,
            "time_improvement": 62.850479359145325,
            "length_improvement": 14.588996151832761,
            "smoothness_improvement": 1344.5647667372366,
            "objective_score": 28.495766871796334
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm integrates a hybrid approach combining informed sampling, bidirectional growth, and heuristic-driven rewiring to improve convergence speed, path quality, and robustness. It grows two trees from start and goal simultaneously using informed sampling within ellipsoidal informed sets when solutions exist, aggressively rewires locally to optimize paths during bidirectional expansions, and uses dynamic goal biasing. This approach balances exploration and exploitation efficiently for faster, smoother, and shorter paths with high success rates.",
    "planning_mechanism": "The planner alternates expansions of two trees rooted at start and goal. Initially, uniform random samples guide exploration; after a valid path is found, sampling is restricted inside an ellipsoidal informed subset around the best path to focus search. Each new node connects to the best local parent and triggers rewiring to reduce path costs. The two trees attempt connection after each expansion, producing a refined, smooth path by merging. Collision and boundary checks prevent invalid nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Initialize cost and solution tracking\n        best_cost = float(\"inf\")\n        c_min = self._euclidean(start_pos, goal_pos)\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Helper: check if pos within map bounds\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Ellipsoidal informed sampling: sample in unit ball scaled and rotated\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            import random\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute ellipse parameters\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            length = np.linalg.norm(a1)\n            a1 = a1 / length\n\n            L = np.diag([c_best / 2.0] + [((c_best ** 2 - c_min ** 2) ** 0.5) / 2.0] * (dim - 1))\n\n            # Rotation matrix via SVD\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            while True:\n                # Sample from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball = x_ball / norm * (random.random() ** (1.0 / dim))\n                x_rand = C @ (L @ x_ball) + center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n\n        # Find nearest node in a tree to given point\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: self._euclidean(n.position, point))\n\n        # Find nodes near a position within a radius\n        def near_nodes(tree, pos, radius=15.0):\n            return [node for node in tree if self._euclidean(node.position, pos) <= radius]\n\n        # Rewire nodes in near_nodes to new_node if cheaper and collision free\n        def rewire(tree, new_node, near_n):\n            for node in near_n:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + self._euclidean(new_node.position, node.position)\n                if potential_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        # Merge paths from two nodes, stitching start and goal trees\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal[1:]\n\n        for itr in range(self.max_iter):\n            # Alternate between start_tree and goal_tree for expansion\n            for tree_a, tree_b, is_start_tree_expansion in [(start_tree, goal_tree, True), (goal_tree, start_tree, False)]:\n\n                # Determine sampling strategy: informed sampling if solution found else uniform\n                if best_cost < float(\"inf\"):\n                    sample = informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if is_start_tree_expansion else start_pos\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                # Find nearest node & steer towards sample\n                nearest = nearest_node(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest.cost + self._euclidean(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire near nodes to new_node in tree_a\n                near_n = near_nodes(tree_a, new_pos, radius=20.0)\n                rewire(tree_a, new_node, near_n)\n\n                # Attempt connection to opposite tree\n                near_in_b = near_nodes(tree_b, new_pos, radius=self.step_size * 1.5)\n                connect_node = None\n                min_connect_cost = float(\"inf\")\n                for nbr in near_in_b:\n                    dist = self._euclidean(new_pos, nbr.position)\n                    if dist <= self.step_size and not self._is_edge_in_obstacle(new_pos, nbr.position, obstacles, is_3d):\n                        total_cost = new_node.cost + dist + nbr.cost\n                        if total_cost < min_connect_cost:\n                            min_connect_cost = total_cost\n                            connect_node = nbr\n\n                if connect_node is not None:\n                    # Connect trees by adding edge and update solution if better\n                    if is_start_tree_expansion:\n                        # Connect connect_node parent rewritten to new_node\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in start tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        # Update solution path if cost improved\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = conn_node\n                            solution_node_goal = connect_node\n                            success = True\n                    else:\n                        # Connecting from goal tree expansion\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in goal tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = connect_node\n                            solution_node_goal = conn_node\n                            success = True\n\n            if success and solution_node_start and solution_node_goal:\n                extracted_path = extract_path(solution_node_start, solution_node_goal)\n                break\n\n        # Post-process path smoothing via shortcutting (optional, simple straight-line shortcuts)\n        if success and len(extracted_path) > 3:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _euclidean(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._euclidean(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _smooth_path(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            p_start = smoothed[i]\n            p_end = smoothed[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = self._euclidean(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.36588,
    "time_improvement": 33.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1240.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022878527641296387,
            "num_nodes_avg": 149.4,
            "path_length_avg": 180.38439431350918,
            "smoothness_avg": 0.02957517506587525,
            "success_improvement": 0.0,
            "time_improvement": 8.862580847365873,
            "length_improvement": 1.128455103121995,
            "smoothness_improvement": 362.9157133015363,
            "objective_score": 4.699043841341842
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03743283748626709,
            "num_nodes_avg": 288.3,
            "path_length_avg": 237.52161712099596,
            "smoothness_avg": 0.08105711587400938,
            "success_improvement": 0.0,
            "time_improvement": 77.30561540558567,
            "length_improvement": 20.708447524332772,
            "smoothness_improvement": 1985.6579745189633,
            "objective_score": 37.26166399913707
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.044042229652404785,
            "num_nodes_avg": 294.7,
            "path_length_avg": 129.5781252975168,
            "smoothness_avg": 0.11565553498213739,
            "success_improvement": 0.0,
            "time_improvement": 11.644045940418264,
            "length_improvement": 13.940379024652591,
            "smoothness_improvement": 1371.1298681692033,
            "objective_score": 13.136938927902015
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional RRT* with informed sampling and adaptive rewiring. It alternates expanding two trees from start and goal while focusing search inside an ellipsoidal informed set around the best solution cost. Adaptive step sizing ensures safe exploration near obstacles. Continuous rewiring optimizes costs, and pruning discards inefficient nodes. A final smoothing step improves path quality and smoothness.",
    "planning_mechanism": "The planner grows two trees bidirectionally, samples points inside an informed ellipsoid to bias search toward promising areas, uses adaptive stepping to navigate safely near obstacles, performs rewiring of neighbors to optimize costs in both trees, prunes nodes unlikely to improve the solution, attempts to connect the two trees for path updates, and performs path shortcutting for smoothness before returning the optimized path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_heuristic(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy as np\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample in unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            # Check points along the path; reduce step if near obstacle\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            # Try connect trees\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                # Optional: continue to improve path, here break for speed\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -13.0185,
    "time_improvement": 4.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1743.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.049403262138366696,
            "num_nodes_avg": 268.8,
            "path_length_avg": 165.4484773217101,
            "smoothness_avg": 0.05793713667543628,
            "success_improvement": 0.0,
            "time_improvement": -96.79963149746891,
            "length_improvement": 9.315067881077315,
            "smoothness_improvement": 806.8420014765672,
            "objective_score": -23.142665865642375
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03950042724609375,
            "num_nodes_avg": 352.3,
            "path_length_avg": 238.45172325330878,
            "smoothness_avg": 0.1098670141892697,
            "success_improvement": 0.0,
            "time_improvement": 76.0520989653694,
            "length_improvement": 20.397951325746124,
            "smoothness_improvement": 2726.957409101609,
            "objective_score": 40.530007000268085
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0327894926071167,
            "num_nodes_avg": 291.8,
            "path_length_avg": 128.51545696165562,
            "smoothness_avg": 0.14109008407790408,
            "success_improvement": 0.0,
            "time_improvement": 34.21888661639979,
            "length_improvement": 14.646152734503213,
            "smoothness_improvement": 1694.655455284229,
            "objective_score": 21.668173808241725
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned bidirectional informed RRT* planner with adaptive step sizing, dynamic rewiring, informed sampling within an ellipsoidal heuristic, goal biasing, node pruning, and post-processing path smoothing. The tuning improves planning efficiency, path quality, robustness, success rate, and reduces search time through parameter adjustment and code refinements.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling points focused within an ellipsoidal informed region defined by the current best path cost, adapts step sizes near obstacles for safer expansions, rewires nodes to improve path cost, prunes unpromising nodes, attempts early connection between trees, and smooths the final path via shortcut shortcuts.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position  \n        self.parent = parent      \n        self.cost = cost          \n        self.children = []\n        self.valid = True         \n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges: List[Tuple[\"Node\", \"Node\"]]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=6.0, rewire_radius: float=10.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            c_min = 1e-6 # to avoid division by zero\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        def rotation_to_world(unit_vec):\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                norm_v = np.linalg.norm(v)\n                if norm_v < 1e-10:\n                    return np.identity(3)\n                v = v / norm_v\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in whole space\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                r1 = c_best / 2.0\n                val = c_best**2 - c_min**2\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                for _ in range(100):  # max trials for valid sample\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball /= norm_x_ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        tup_sample = tuple(sample)\n                        if not self._is_in_obstacle(tup_sample, obstacles, is_3d):\n                            return tup_sample\n                # fallback uniform sampling\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            # Denser checks for collisions on longer expansions\n            steps_check = max(3, int(dist * 3))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step size on obstacle proximity\n                    return max(self.base_step * 0.4, 1.5)\n            return min(self.base_step, dist)\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=0.5):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d, resolution=0.5):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                if tree_source is tree_start:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = nearest_other.path_from_root()\n                else:\n                    path_from_start = nearest_other.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        def prune_nodes(tree, best_cost):\n            # Remove nodes with heuristic cost >= best_cost to reduce tree size\n            heuristic_limit = best_cost if best_cost != float(\"inf\") else float(\"inf\")\n            to_remove = []\n            for node in tree:\n                heuristic = node.cost + math.dist(node.position, goal if tree is tree_start else start)\n                if heuristic >= heuristic_limit and node.parent is not None:\n                    to_remove.append(node)\n            for node in to_remove:\n                node.remove_from_parent(edges)\n                tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations: int=30) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Enforce map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n            try_connect(tree_a, tree_b, new_node)\n            prune_nodes(tree_a, best_cost)\n\n            # Early termination if solution is near optimal\n            if success_state and best_cost <= c_min * 1.005:\n                break\n\n        if success_state and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 822.0677,
    "time_improvement": -2596.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 515.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.2337754011154174,
            "num_nodes_avg": 1490.8,
            "path_length_avg": 151.75212631964249,
            "smoothness_avg": 0.017597088539586338,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4814.7876836576725,
            "length_improvement": 16.822254897880757,
            "smoothness_improvement": 175.4326483339052,
            "objective_score": -1490.1946908760563
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.5396240234375,
            "num_nodes_avg": 2565.2,
            "path_length_avg": 229.6466576607132,
            "smoothness_avg": 0.038857983083720946,
            "success_improvement": 0.0,
            "time_improvement": -833.4269605265401,
            "length_improvement": 23.337335660315265,
            "smoothness_improvement": 899.8438930180606,
            "objective_score": -240.86140156080867
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 1.1164541721343995,
            "num_nodes_avg": 1972.7,
            "path_length_avg": 117.14830796645765,
            "smoothness_avg": 0.04482812544376626,
            "success_improvement": -19.999999999999996,
            "time_improvement": -2139.790635516773,
            "length_improvement": 22.195671851645315,
            "smoothness_improvement": 470.21044677667885,
            "objective_score": -735.1470040508194
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with informed elliptical sampling, adaptive step sizing near obstacles, dynamic rewiring for path cost optimization, and path smoothing. It balances exploration and exploitation by sampling within an ellipsoidal informed subset based on the current best path cost, grows two trees from start and goal alternately, and connects them efficiently when possible. It prunes unpromising nodes to improve performance and applies shortcut smoothing to enhance path quality and reduce length.",
    "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling new points from an ellipsoidal informed subset centered between start and goal. Adaptive step sizing reduces step length near obstacles, ensuring safe exploration through narrow passages. Upon adding new nodes, nearby nodes are rewired to reduce path cost incrementally. When two trees connect without collision, the best path is updated. After search, path smoothing shortcuts unnecessary nodes to produce a smooth, optimized path. The process respects bounds and obstacles strictly, terminating early once a near-optimal path is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = diff / norm_diff\n\n        # Rotation matrix to align x-axis with unit_vec\n        def rotation_to_world(vector):\n            if dim == 2:\n                angle = math.atan2(vector[1], vector[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                a = vector\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.eye(3)\n                v /= np.linalg.norm(v)\n                H = np.eye(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.eye(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = rotation_matrix @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d]-from_pos[d])/dist for d in range(dim))\n            return tuple(from_pos[d] + direction[d]*step for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            checks = max(3, int(dist))\n            for i in range(1, checks+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/checks) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_a, tree_b, new_node):\n            nonlocal c_best\n            if not tree_b:\n                return None\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return None\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < c_best:\n                c_best = total_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else nearest_other.path_from_root()\n                path_goal = nearest_other.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                return path_start + path_goal[::-1][1:]\n            return None\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            path = try_connect(tree_a, tree_b, new_node)\n            if path:\n                extracted_path = path\n                success_state = True\n                # Early stop if near optimal\n                if c_best <= c_min * 1.01:\n                    break\n\n        if success_state and extracted_path:\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, iterations=15):\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 582.98385,
    "time_improvement": -1907.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 324.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.8374725103378295,
            "num_nodes_avg": 1537.6,
            "path_length_avg": 153.29053691440865,
            "smoothness_avg": 0.02027216892882408,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3236.10118623624,
            "length_improvement": 15.97902767321355,
            "smoothness_improvement": 217.30346545551785,
            "objective_score": -1016.5480330089518
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.3020658493041992,
            "num_nodes_avg": 2675.2,
            "path_length_avg": 226.33134727867179,
            "smoothness_avg": 0.01992788664063618,
            "success_improvement": 0.0,
            "time_improvement": -689.4027045692981,
            "length_improvement": 24.444081691759003,
            "smoothness_improvement": 412.75887674014433,
            "objective_score": -199.8682006487369
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9451454877853394,
            "num_nodes_avg": 2232.9,
            "path_length_avg": 116.03641363004617,
            "smoothness_avg": 0.03479643616259932,
            "success_improvement": 0.0,
            "time_improvement": -1796.117248319708,
            "length_improvement": 22.93413912717119,
            "smoothness_improvement": 342.60809958251434,
            "objective_score": -532.5353061725656
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an enhanced bidirectional informed RRT* algorithm combining adaptive ellipsoidal sampling focused on the current best solution, incremental rewiring with efficient KD-tree nearest and radius search, collision check caching, and periodic pruning of non-promising nodes. It dynamically balances exploration and exploitation to quickly find and iteratively improve the shortest collision-free path in 2D/3D environments. Shortcut smoothing is applied on the final path to enhance smoothness and reduce length.",
    "planning_mechanism": "The planning mechanism alternates tree growth from start and goal, sampling points within an adaptive ellipsoid bounding the best-known path to bias search in promising regions. New nodes are connected with collision-free edges, and local rewiring optimizes path costs. KD-tree accelerates neighbor queries. Periodic pruning removes nodes that cannot improve the current best path. The two trees connect to form candidate solutions, and the best path is shortcut-smoothed to improve quality before final output.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 100\n        self.collision_check_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius_by_iter_nodes(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Collision checking caching for edges\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            key = (from_pos, to_pos)\n            rev_key = (to_pos, from_pos)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return edge_collision_cache[rev_key]\n\n            distance_ = dist(from_pos, to_pos)\n            steps = max(1, int(distance_ / self.collision_check_resolution))\n            for i in range(steps + 1):\n                ip = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(ip):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        # KDTree simplified but efficient for neighbor search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    else:\n                        results.append(self.nodes[i])\n                return results\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_in_obstacle(p1) or is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        import numpy as np\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling until free space found\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback random sampling (may be in obstacle)\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1] + [0]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v = v / norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            term = r1 * r1 - (c_min / 2.0)**2\n            r_others = math.sqrt(term) if term > 0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(c) for c in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for iter_ in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend the smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = radius_by_iter_nodes(iter_, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node for path cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            connected = False\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                # Rewire neighbors in tree_b around new_node_b\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        # Shortcut smoothing to improve path quality\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes that cannot improve solution\n            if iter_ > 0 and iter_ % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -30.34849,
    "time_improvement": 65.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1528.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013902497291564942,
            "num_nodes_avg": 75.2,
            "path_length_avg": 163.68833241771875,
            "smoothness_avg": 0.04172426716572618,
            "success_improvement": 0.0,
            "time_improvement": 44.618913297432826,
            "length_improvement": 10.27983119423582,
            "smoothness_improvement": 553.0753868399595,
            "objective_score": 18.20701716227681
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02517390251159668,
            "num_nodes_avg": 224.8,
            "path_length_avg": 237.28469089026026,
            "smoothness_avg": 0.10520832079036553,
            "success_improvement": 0.0,
            "time_improvement": 84.73783277716892,
            "length_improvement": 20.78754031969578,
            "smoothness_improvement": 2607.085872426581,
            "objective_score": 42.614287259222735
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016747236251831055,
            "num_nodes_avg": 145.8,
            "path_length_avg": 126.6153910088497,
            "smoothness_avg": 0.11984134293395717,
            "success_improvement": 0.0,
            "time_improvement": 66.40229051594005,
            "length_improvement": 15.908086068939046,
            "smoothness_improvement": 1424.3730363521465,
            "objective_score": 30.224169550330558
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a Hybrid Informed PRM-RRT Planner that combines Probabilistic Roadmap (PRM) sampling within an informed ellipsoidal heuristic to focus node generation around the promising region and a bidirectional RRT for fast tree growth between the start and goal. It adaptively refines the roadmap connections with collision-free edge rewiring to improve path quality. A shortcut smoothing step post planning reduces unnecessary turns, improving path smoothness while maintaining feasibility. This integration leverages heuristic guidance, roadmap efficiency, and RRT explorative strength to enhance planning efficiency, robustness, and path optimality.",
    "planning_mechanism": "The planner initially samples nodes biased within an ellipsoidal region defined by start, goal, and the best current solution cost, constructing a dense roadmap with collision-free connections. Two trees (start and goal) are grown simultaneously using RRT extensions connected via the roadmap nodes. When a connection between the two trees occurs via roadmap nodes, the path is reconstructed and subsequently smoothed by iterative random shortcutting checks. Collision checks are strictly enforced for nodes and edges. The strategy reduces the search space smartly and improves convergence speed and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def reconstruct_path(node_from_start, node_from_goal):\n        # Path from start tree root to node_from_start\n        path_start = []\n        node = node_from_start\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        # Path from goal tree root to node_from_goal\n        path_goal = []\n        node = node_from_goal\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        # Merge paths with no duplication at connection point\n        return path_start + path_goal[1:]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 6.0, roadmap_node_count: int = 150,\n                 connection_radius: float = 25.0, shortcut_trials: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.roadmap_node_count = roadmap_node_count         # Number of PRM nodes sampled\n        self.connection_radius = connection_radius           # Radius for PRM connections and rewiring\n        self.shortcut_trials = shortcut_trials               # Number of shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        # --- Helper: Euclidean distance ---\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        # --- Build informed ellipsoid for heuristic sampling ---\n        def informed_sample(c_best):\n            # If no path found yet, sample entire space uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Ellipsoidal heuristic sampling between start and goal\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # No path shorter than c_min possible so fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(bounds)))\n\n            # Rotation matrix aligns the ellipsoid with start-goal vector\n            dx = [goal_pos[d] - start_pos[d] for d in range(len(bounds))]\n            length = dist(start_pos, goal_pos)\n            if length == 0:\n                return center\n\n            unit_vec = tuple(x / length for x in dx)\n\n            # Construct orthonormal basis (QR or Gram-Schmidt)\n            # For 2D or 3D, construct orthogonal basis via cross products or perpendicular vectors.\n\n            def ortho_basis_2d(vec):\n                # vec is unit vector in 2D\n                return (-vec[1], vec[0])\n\n            def ortho_basis_3d(vec):\n                import numpy as np\n                v = np.array(vec)\n                # Find one vector orthogonal to v:\n                if abs(v[0]) < 1e-6 and abs(v[1]) < 1e-6:\n                    ortho1 = np.array([0,1,0])\n                else:\n                    ortho1 = np.array([-v[1], v[0], 0])\n                ortho1 /= np.linalg.norm(ortho1)\n                # Second orthogonal vector:\n                ortho2 = np.cross(v, ortho1)\n                ortho2 /= np.linalg.norm(ortho2)\n                return ortho1, ortho2\n\n            # Axes lengths of ellipsoid\n            a1 = c_best / 2\n            if is_3d:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n                a3 = a2\n            else:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n            import numpy as np\n\n            if is_3d:\n                # Sample random point in unit ball\n                while True:\n                    sample = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(sample) <= 1:\n                        break\n                # Scale by ellipsoid axis lengths\n                sample[0] *= a1\n                sample[1] *= a2\n                sample[2] *= a3\n\n                # Rotation matrix\n                ex = np.array(unit_vec)\n                ey, ez = ortho_basis_3d(unit_vec)\n                R = np.column_stack((ex, ey, ez))  # 3x3 rotation\n\n                mapped = R.dot(sample) + np.array(center)\n                m = tuple(mapped.tolist())\n\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n            else:\n                # 2D case\n                # Sample random point in ellipse\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x**2 + y**2 <= 1:\n                        break\n                sample_local = (x * a1, y * a2)\n\n                orth = ortho_basis_2d(unit_vec)\n                mapped = (center[0] + unit_vec[0] * sample_local[0] + orth[0] * sample_local[1],\n                          center[1] + unit_vec[1] * sample_local[0] + orth[1] * sample_local[1])\n                m = mapped\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n        # --- Roadmap Sampling ---\n        # Initialize nodes list with start and goal nodes\n        nodes = [Node(start_pos, cost=0.0), Node(goal_pos, cost=0.0)]\n        edges = []\n\n        # Roadmap nodes sampled inside the informed ellipsoid or whole space early\n        c_best = float('inf')\n\n        # Sample roadmap nodes\n        for _ in range(self.roadmap_node_count):\n            p = informed_sample(c_best)\n            if not in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            # Add roadmap node with no parent (initially disconnected)\n            nodes.append(Node(p, parent=None, cost=float('inf')))\n\n        # Connect roadmap nodes if within radius and collision free\n        def near_nodes_rd(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        # Build connection edges in roadmap with rewiring (similar to PRM*)\n        for n in nodes[2:]:\n            near = near_nodes_rd(nodes, n.position, self.connection_radius)\n            best_parent = None\n            best_cost = float('inf')\n            for other in near:\n                if other == n:\n                    continue\n                # Check collision of edge\n                if other.cost == float('inf'):\n                    # Not connected yet, ignore as parent candidate\n                    continue\n                if self._is_edge_in_obstacle(other.position, n.position, obstacles, is_3d):\n                    continue\n                cost_through_other = other.cost + dist(other.position, n.position)\n                if cost_through_other < best_cost:\n                    best_cost = cost_through_other\n                    best_parent = other\n            if best_parent:\n                n.parent = best_parent\n                n.cost = best_cost\n                best_parent.add_child(n)\n                edges.append((best_parent, n))\n\n        # Try rewiring for better costs after initial connections\n        improved = True\n        while improved:\n            improved = False\n            for n in nodes[2:]:\n                near = near_nodes_rd(nodes, n.position, self.connection_radius)\n                for other in near:\n                    if other == n or n.parent is None:\n                        continue\n                    cost_through_n = n.cost + dist(n.position, other.position)\n                    if cost_through_n + 1e-6 < other.cost and not self._is_edge_in_obstacle(n.position, other.position, obstacles, is_3d):\n                        # Rewire other under n\n                        if other.parent:\n                            try:\n                                edges.remove((other.parent, other))\n                                other.parent.children.remove(other)\n                            except ValueError:\n                                pass\n                        other.parent = n\n                        other.cost = cost_through_n\n                        n.add_child(other)\n                        edges.append((n, other))\n                        improved = True\n\n        # --- Bidirectional RRT growing on roadmap nodes ---\n        start_tree = [nodes[0]]   # start node\n        goal_tree = [nodes[1]]    # goal node\n\n        tree_nodes_set_start = {nodes[0]}\n        tree_nodes_set_goal = {nodes[1]}\n\n        def nearest(tree_nodes, p):\n            return min(tree_nodes, key=lambda n: dist(n.position, p))\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Heuristic: always try connecting through roadmap nodes for faster path\n        connected = False\n        connecting_node_start = None\n        connecting_node_goal = None\n\n        for itr in range(self.max_iter):\n            # Alternate trees\n            for tree_a, tree_b, set_a, set_b in [(start_tree, goal_tree, tree_nodes_set_start, tree_nodes_set_goal),\n                                                 (goal_tree, start_tree, tree_nodes_set_goal, tree_nodes_set_start)]:\n                # Sample in informed space\n                sample = informed_sample(c_best)\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_a = nearest(tree_a, sample)\n                new_pos = steer(nearest_a.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n                new_node.parent = nearest_a\n                nearest_a.add_child(new_node)\n                tree_a.append(new_node)\n                # Add to set for quick search\n                set_a.add(new_node)\n\n                # Try connect with nodes in tree_b via roadmap filtering for efficiency:\n                # Check roadmap nodes near new_node with radius\n                candidates_b = [n for n in tree_b if dist(n.position, new_node.position) <= self.connection_radius]\n                candidates_b.sort(key=lambda nn: dist(nn.position, new_node.position))\n\n                for candidate_b in candidates_b:\n                    d_connect = dist(new_node.position, candidate_b.position)\n                    if d_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, candidate_b.position, obstacles, is_3d):\n                        # Connect found, build connecting nodes in tree_a and tree_b appropriately\n                        connect_node_b = Node(candidate_b.position, parent=new_node,\n                                              cost=new_node.cost + d_connect)\n                        new_node.add_child(connect_node_b)\n                        tree_a.append(connect_node_b)\n                        set_a.add(connect_node_b)\n                        edges.append((new_node, connect_node_b))\n\n                        connected = True\n                        connecting_node_start = connect_node_b if tree_a is start_tree else candidate_b\n                        connecting_node_goal = candidate_b if tree_b is goal_tree else connect_node_b\n                        break\n                if connected:\n                    break\n            if connected:\n                break\n\n        if not connected:\n            # No path found\n            return PlannerResult(False, [], nodes, edges)\n\n        # Reconstruct path using Node static method\n        path = Node.reconstruct_path(connecting_node_start, connecting_node_goal)\n\n        # Append all nodes from start_tree and goal_tree plus roadmap nodes to nodes list\n        # (Avoid duplicates)\n        all_tree_nodes = set(start_tree + goal_tree + nodes[2:])\n\n        # Update edges with parent-child in the tree expansions\n        # We track edges from roadmap plus tree expansions\n        # Edges between roadmap nodes already added\n        # Add tree expansions edges\n        def update_edges(tree):\n            for n in tree:\n                if n.parent is not None and (n.parent, n) not in edges:\n                    edges.append((n.parent, n))\n\n        update_edges(start_tree)\n        update_edges(goal_tree)\n\n        # --- Shortcut smoothing ---\n        # Iteratively attempt random shortcuts on path\n        def path_smoothing(path):\n            smoothed_path = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                a = smoothed_path[i]\n                b = smoothed_path[j]\n                if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                    # Shortcut possible: replace intermediate points\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        path = path_smoothing(path)\n\n        return PlannerResult(True, path, list(all_tree_nodes), edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.83708,
    "time_improvement": -32.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1518.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.056850218772888185,
            "num_nodes_avg": 212.3,
            "path_length_avg": 173.14105868688912,
            "smoothness_avg": 0.03300778700001848,
            "success_improvement": 0.0,
            "time_improvement": -126.46484504848468,
            "length_improvement": 5.0986421380704305,
            "smoothness_improvement": 416.64354410699883,
            "objective_score": -34.83650736639632
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06818621158599854,
            "num_nodes_avg": 375.5,
            "path_length_avg": 239.8833934812037,
            "smoothness_avg": 0.11265474635194206,
            "success_improvement": 0.0,
            "time_improvement": 58.66078519063724,
            "length_improvement": 19.92001859533215,
            "smoothness_improvement": 2798.687765569485,
            "objective_score": 35.57567810410502
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06357545852661133,
            "num_nodes_avg": 394.7,
            "path_length_avg": 125.41948934045914,
            "smoothness_avg": 0.1131210894393732,
            "success_improvement": 0.0,
            "time_improvement": -27.542822814089774,
            "length_improvement": 16.702347014366147,
            "smoothness_improvement": 1338.891907938553,
            "objective_score": 1.7720820983390633
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional tree growth, informed ellipsoidal sampling, dynamic adaptive step sizing near obstacles, continuous rewiring, pruning of suboptimal nodes, and enhanced path smoothing. It balances exploration and exploitation to improve planning efficiency, path quality, and robustness in both 2D and 3D environments, while maintaining collision-free connectivity and ensuring path smoothness and optimality.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternates their expansion, samples points inside an informed ellipsoid focused by the best path cost, dynamically adapts step sizes based on obstacle proximity, performs rewiring within a radius to minimize path costs, prunes nodes unlikely to improve solutions, attempts tree connection to update optimal paths, and finally applies iterative shortcutting smoothing to produce high-quality, feasible paths with improved efficiency and reduced search time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision or pruning\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_heuristic_cost(node: Node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            check_points = max(3, int(distance))\n            for i in range(1, check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.25, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # Update edges list\n                        for idx, (p, c) in enumerate(edges):\n                            if c == neighbor:\n                                edges[idx] = (new_node, neighbor)\n                                break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best and node not in (start_root, goal_root):\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                # Remove children refs to avoid dangling\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def smooth_path(path: List[Tuple[float, ...]], max_iterations=30) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # Remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes with cost + heuristic worse than best path\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire for cost improvement in active tree\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            # Try connect trees for path update\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                # Continue searching for improved path during ~10% iterations after first success for refinement\n                if iter_num > self.max_iter * 0.1:\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = smooth_path(extracted_path, max_iterations=50)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 48.82624,
    "time_improvement": -81.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1155.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.08209874629974365,
            "num_nodes_avg": 303.7,
            "path_length_avg": 170.44144427040257,
            "smoothness_avg": 0.022151278185213445,
            "success_improvement": -9.999999999999998,
            "time_improvement": -227.04324206247443,
            "length_improvement": 6.578343577874637,
            "smoothness_improvement": 246.71560586907316,
            "objective_score": -115.56372587382204
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06626441478729247,
            "num_nodes_avg": 388.7,
            "path_length_avg": 239.2952953485226,
            "smoothness_avg": 0.08159828958003063,
            "success_improvement": 0.0,
            "time_improvement": 59.82591181717605,
            "length_improvement": 20.116342679487285,
            "smoothness_improvement": 1999.582763766555,
            "objective_score": 31.968955899883046
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.08724985122680665,
            "num_nodes_avg": 469.9,
            "path_length_avg": 123.9109441615802,
            "smoothness_avg": 0.10356134308770629,
            "success_improvement": -9.999999999999998,
            "time_improvement": -75.0375470893114,
            "length_improvement": 17.704250892975484,
            "smoothness_improvement": 1217.2926399724256,
            "objective_score": -62.88395074833618
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a novel hybrid RRT* planner incorporating bidirectional trees, adaptive informed sampling, dynamic step sizing near obstacles, cost-based pruning, and integrated path smoothing. It balances exploration and exploitation by growing two trees from start and goal, biases sampling inside an informed ellipsoid that shrinks as better paths are found, rewires nodes for cost improvement, prunes suboptimal branches early, and performs shortcut smoothing to enhance path quality and efficiency. This structure aims to improve planning success, robustness, and path optimality with reduced computational effort.",
    "planning_mechanism": "The planner alternates between expanding two RRT* trees from start and goal using adaptive step sizes and informed elliptical sampling. Nodes are connected only if collision checks pass, and rewiring optimizes the cost locally. Suboptimal nodes are pruned using heuristic cost bounds to speed up convergence. When trees connect, the solution path is extracted and shortcut smoothed to reduce unnecessary detours and ensure smoother, shorter paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_step) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (max_step/dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire_tree(tree: List[Node], new_node: Node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                heuristic_remain = distance(near_node.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                    new_node.add_child(near_node)\n                    near_node.cost = new_cost\n                    edges.append((new_node, near_node))\n\n        def extract_path(node_start: Node, node_goal: Node):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicated connection node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(tree: List[Node]):\n            # Remove nodes that cannot possibly improve solution cost\n            retained = []\n            for node in tree:\n                heuristic = distance(node.position, goal)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    # Disconnect subtree\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        for iteration in range(self.max_iter):\n            # Alternate growth direction\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire_tree(tree_a, new_node)\n\n            # Attempt to connect opposite tree\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Prune suboptimal nodes every 200 iterations to improve search speed\n            if iteration > 0 and iteration % 200 == 0 and success:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early stop\n            if success and iteration % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.4129,
    "time_improvement": -61.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 784.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06880130767822265,
            "num_nodes_avg": 374.2,
            "path_length_avg": 166.806844724353,
            "smoothness_avg": 0.014419319321817486,
            "success_improvement": 0.0,
            "time_improvement": -174.07242784283554,
            "length_improvement": 8.57052518297982,
            "smoothness_improvement": 125.69365943951777,
            "objective_score": -49.87915501905711
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06566660404205323,
            "num_nodes_avg": 490.7,
            "path_length_avg": 243.85745597358306,
            "smoothness_avg": 0.04399399704507752,
            "success_improvement": 0.0,
            "time_improvement": 60.18834618972689,
            "length_improvement": 18.59336214832944,
            "smoothness_improvement": 1031.997231565094,
            "objective_score": 26.93516244440943
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08384654521942139,
            "num_nodes_avg": 497.1,
            "path_length_avg": 126.5300559409724,
            "smoothness_avg": 0.10181377497082089,
            "success_improvement": 0.0,
            "time_improvement": -68.20995567051928,
            "length_improvement": 15.96476155780388,
            "smoothness_improvement": 1195.0637025177039,
            "objective_score": -11.294715877006485
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm improves bidirectional RRT by integrating goal biasing, adaptive neighborhood rewiring for asymptotic optimality, and incremental connection attempts. It dynamically adjusts search radius for rewiring based on the current tree size, promoting better path quality and smoother solution convergence while maintaining computational efficiency.",
    "planning_mechanism": "The planner grows two trees simultaneously\u2014from start and goal\u2014alternating expansion with goal biasing to accelerate convergence. At each iteration, it samples free points biased towards the opposite tree\u2019s root, extends the tree towards the sample with collision checks, and rewires neighbors within an adaptive radius to optimize path cost. Incremental connections are attempted to link the two trees. On success, the combined path is extracted, ensuring a smooth, collision-free solution with reduced planning time and improved robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = 50.0  # Base radius factor for rewiring; adaptive with tree size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def get_rewire_radius(tree_size):\n            # Adaptive radius: decreases as tree grows, promoting efficiency & quality\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)  # never too small\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-6 < neighbor.cost:  # small tolerance for floating\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor's parent link to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass  # safety\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def steer_and_add(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # Rewire neighbors for optimization\n            rewire(tree, new_node)\n            return new_node\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_pos), (goal_tree, start_tree, start_pos)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = steer_and_add(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Try incrementally connecting tree_b to new_node\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n                connection_made = False\n                min_cost_connect = float('inf')\n                best_node_b = None\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_cost_connect:\n                            min_cost_connect = total_cost\n                            best_node_b = nb\n                if best_node_b is not None:\n                    # Connect best_node_b to new_node\n                    # Attach new connection node in tree_b to unify paths\n                    conn_pos = best_node_b.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n                    # Rewire around conn_node\n                    rewire(tree_a, conn_node)\n\n                    # Extract path\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    path_goal = []\n                    cur = best_node_b\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    extracted_path = path_start + path_goal[1:]\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # Failed to find path\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.73056,
    "time_improvement": 73.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 121.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009549236297607422,
            "num_nodes_avg": 121.2,
            "path_length_avg": 192.66512918026064,
            "smoothness_avg": 0.013418041999981825,
            "success_improvement": 0.0,
            "time_improvement": 61.96028150554178,
            "length_improvement": -5.602810278041514,
            "smoothness_improvement": 110.0214950442843,
            "objective_score": 18.01762987127565
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.011700725555419922,
            "num_nodes_avg": 221.2,
            "path_length_avg": 276.3360727399123,
            "smoothness_avg": 0.009187848167700855,
            "success_improvement": 0.0,
            "time_improvement": 92.90620792811096,
            "length_improvement": 7.751065026579014,
            "smoothness_improvement": 136.40995109448716,
            "objective_score": 30.104125139221527
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017450571060180664,
            "num_nodes_avg": 268.9,
            "path_length_avg": 150.66020077595874,
            "smoothness_avg": 0.017056656809840934,
            "success_improvement": 0.0,
            "time_improvement": 64.9912852488248,
            "length_improvement": -0.06133168757321738,
            "smoothness_improvement": 116.95941562973272,
            "objective_score": 20.06991631528146
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified, generalized RRT* variant combining bidirectional growth with informed sampling and adaptive rewiring to efficiently find high-quality collision-free paths in 2D or 3D environments with rectangular obstacles. It balances exploration and exploitation, gradually improving path cost and smoothness while pruning unpromising branches, ensuring robustness and efficiency.",
    "planning_mechanism": "The planner grows trees from the start and goal positions alternately, sampling within the environment and preferentially within an ellipsoidal informed region defined by the current best path cost. It adaptively steers towards samples with collision checks on nodes and edges, connects the two trees when close enough, rewires nearby nodes for cost improvements, and performs optional path smoothing before returning the solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=4.0, rewire_radius: float=8.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g)*0.5 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix for informed sampling\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U)*np.linalg.det(Vt)\n        C = U @ np.diag([1]*(dim-1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost/2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0))/2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(50):\n                x_ball = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback: uniform random in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (step/dist) for d in range(dim))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if distance(n.position, pos) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            near = near_nodes(tree, new_node.position)\n            for n in near:\n                if n == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Rewire n\n                        if n.parent:\n                            try:\n                                n.parent.children.remove(n)\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.children.append(n)\n                        edges.append((new_node, n))\n\n        def connect_trees(node_from, tree_to):\n            near = near_nodes(tree_to, node_from.position)\n            candidates = []\n            for node_to in near:\n                if not self._is_edge_in_obstacle(node_from.position, node_to.position, obstacles, is_3d):\n                    total_cost = node_from.cost + distance(node_from.position, node_to.position) + node_to.cost\n                    candidates.append((total_cost, node_to))\n            if not candidates:\n                return None, float('inf')\n            best = min(candidates, key=lambda x: x[0])\n            return best[1], best[0]\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # remove duplicate middle point in connection\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path, iterations=50):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            # boundary and collision check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            other_nearest, path_cost = connect_trees(new_node, tree_b)\n            if other_nearest and path_cost < best_cost:\n                best_cost = path_cost\n                best_path = extract_full_path(new_node, other_nearest)\n                success = True\n\n            # Early stop if path good enough\n            if success and best_cost <= c_min * 1.05:\n                break\n\n        if success and best_path:\n            best_path = shortcut_smooth(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1859.55005,
    "time_improvement": -6227.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 881.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 2.989866328239441,
            "num_nodes_avg": 3144.7,
            "path_length_avg": 154.4392574740913,
            "smoothness_avg": 0.025566789662919632,
            "success_improvement": 0.0,
            "time_improvement": -11810.23762714762,
            "length_improvement": 15.349395731809375,
            "smoothness_improvement": 300.1757773970605,
            "objective_score": -3538.5005301109386
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.0897408723831177,
            "num_nodes_avg": 3427.1,
            "path_length_avg": 225.14461365841584,
            "smoothness_avg": 0.05006709022360285,
            "success_improvement": 0.0,
            "time_improvement": -1166.9459823324446,
            "length_improvement": 24.840247532433743,
            "smoothness_improvement": 1188.2622933207579,
            "objective_score": -339.1744337266428
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.8933794021606447,
            "num_nodes_avg": 3939.9,
            "path_length_avg": 115.66018672338116,
            "smoothness_avg": 0.0985297979543922,
            "success_improvement": 0.0,
            "time_improvement": -5704.594807117972,
            "length_improvement": 23.18401112457798,
            "smoothness_improvement": 1153.2917572667,
            "objective_score": -1700.9751811241424
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is a refined bidirectional informed RRT* algorithm integrating adaptive ellipsoidal sampling, efficient nearest neighbor queries with KD-tree, collision caching, incremental rewiring, and periodic pruning. It focuses on accelerating convergence to high-quality, smooth paths by dynamically tuning the neighbor radius and sampling within the informed subset defined by the current best path estimate. Shortcut smoothing refines the final path. Collision checks ensure validity, and pruning ensures computational efficiency.",
    "planning_mechanism": "The planner maintains two trees growing from start and goal alternately. Sampling is biased inside an ellipsoid focusing on the current best path cost to reduce exploration space. Each extension rewires neighbors in a dynamically adapting radius to improve path cost. KD-tree accelerates neighbor queries. Collision caching avoids redundant checks. Periodic pruning removes nodes that can't improve the solution, and shortcut smoothing post-processes the found path for smoothness and minimal length. The search stops early upon successful connection.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import random\n        import math\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uninformed sampling fallback\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - id_mat[0]\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node_near in near_nodes:\n                candidate_cost = node_near.cost + dist(node_near.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node_near.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node_near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, radius)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    conn_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(conn_node)\n                    tree_b.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node_b, conn_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = conn_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.34846,
    "time_improvement": 57.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1407.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014626717567443848,
            "num_nodes_avg": 103.8,
            "path_length_avg": 164.89824450750302,
            "smoothness_avg": 0.03931344230469192,
            "success_improvement": 0.0,
            "time_improvement": 41.73395636854052,
            "length_improvement": 9.61665920554111,
            "smoothness_improvement": 515.3407425747955,
            "objective_score": 17.020222464544354
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023404502868652345,
            "num_nodes_avg": 230.0,
            "path_length_avg": 237.3231437500523,
            "smoothness_avg": 0.0978198226950587,
            "success_improvement": 0.0,
            "time_improvement": 85.81056566878928,
            "length_improvement": 20.774703648292995,
            "smoothness_improvement": 2416.9744947142635,
            "objective_score": 41.9829829038667
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028589391708374025,
            "num_nodes_avg": 198.3,
            "path_length_avg": 121.95752733868389,
            "smoothness_avg": 0.10925166630355647,
            "success_improvement": 0.0,
            "time_improvement": 42.644979595428914,
            "length_improvement": 19.001617335029927,
            "smoothness_improvement": 1289.6731312620705,
            "objective_score": 23.042183001945013
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid bidirectional RRT* with intelligent sampling bias using Gaussian mixture models around current best path segments to concentrate exploration around promising corridors. It adaptively adjusts step size and rewiring radius based on local density and obstacle proximity. The planner implements an efficient nearest neighbor caching structure for rapid node queries, aggressive yet safe rewiring, focused node pruning using an admissible heuristic, and iterative multi-stage path smoothing with shortcutting and Bezier curve fitting for superior path smoothness and length reduction. The approach targets performance gains in success rate, planning speed, and path quality in both 2D and 3D environments.",
    "planning_mechanism": "The planner starts trees from start and goal, samples new points biased by a Gaussian mixture centered on segments of the current best path (or uniform if no path exists), and grows the tree by steering adaptively with dynamic step size. It caches nearest neighbors to speed up distance calculations. New nodes are added only if collision checks for positions and edges pass. It rewires neighbors within an adaptive radius to reduce cost and prunes nodes unlikely to yield better paths. Connection attempts between trees trigger path updates. After finding a valid path, multi-stage smoothing is applied involving both shortcutting and Bezier smoothing, iterating until no further improvements are possible or max iterations reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            self.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursive(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.min_step = step_size * 0.25\n        self.max_step = step_size * 1.5\n        self.initial_rewire_radius = step_size * 2.5\n        self.min_rewire_radius = step_size * 1.0\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        dist_start_goal = math.dist(start_position, goal_position)\n        if dist_start_goal == 0:\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # Data structures\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Nearest neighbor cache for faster queries (brute force but can be optimized)\n        def nearest_node(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = math.dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best, best_dist\n\n        # Adaptive rewire radius (shrinks as better path cost found)\n        def rewire_radius(current_cost):\n            if current_cost == float('inf'):\n                return self.initial_rewire_radius\n            decay = (self.initial_rewire_radius - self.min_rewire_radius) * (dist_start_goal / current_cost)\n            val = max(self.min_rewire_radius, min(self.initial_rewire_radius, decay))\n            return val\n\n        # Adaptive step size: smaller near obstacles or densely populated area\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            step = min(self.max_step, max(self.min_step, distance))\n            # Sample points between from_pos and to_pos to check obstacle nearness:\n            check_steps = max(3, int(step))\n            for i in range(1, check_steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / check_steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Shrink step close to obstacle, but do not go below min_step\n                    return max(self.min_step, step * 0.3)\n            return step\n\n        # Gaussian mixture sampling centered along current best path segments if available,\n        # else uniform random in bounds\n        def informed_gaussian_sample():\n            if best_cost == float('inf') or len(best_path) < 2:\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample around segments of best_path with weighted Gaussian mixture\n                segments = []\n                weights = []\n                total_len = 0.0\n                for i in range(len(best_path)-1):\n                    p1 = np.array(best_path[i])\n                    p2 = np.array(best_path[i+1])\n                    seg_len = np.linalg.norm(p2 - p1)\n                    segments.append((p1, p2, seg_len))\n                    total_len += seg_len\n                # Avoid division by zero\n                if total_len == 0:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                weights = [seg[2]/total_len for seg in segments]\n\n                # Select segment by weights\n                seg_idx = np.random.choice(len(segments), p=weights)\n                p1, p2, seg_len = segments[seg_idx]\n                # Generate sample along the segment with Gaussian offset normal to segment direction\n                direction = p2 - p1\n                norm_dir = direction / (np.linalg.norm(direction) + 1e-9)\n                # Build orthogonal basis for Gaussian offsets\n                if dim == 2:\n                    ortho_vec = np.array([-norm_dir[1], norm_dir[0]])\n                    offset_scale = self.base_step * 1.5\n                    base_point = p1 + norm_dir * random.uniform(0, seg_len)\n                    offset = np.random.normal(scale=offset_scale) * ortho_vec\n                    sample = base_point + offset\n                elif dim == 3:\n                    # Find two orthogonal vectors to norm_dir\n                    if abs(norm_dir[0]) < 1e-6 and abs(norm_dir[1]) < 1e-6:\n                        ortho1 = np.array([1,0,0])\n                    else:\n                        ortho1 = np.array([-norm_dir[1], norm_dir[0], 0])\n                    ortho1 /= (np.linalg.norm(ortho1) + 1e-9)\n                    ortho2 = np.cross(norm_dir, ortho1)\n                    offset_scale = self.base_step * 1.5\n                    base_point = p1 + norm_dir * random.uniform(0, seg_len)\n                    offset = (np.random.normal(scale=offset_scale) * ortho1 +\n                              np.random.normal(scale=offset_scale) * ortho2)\n                    sample = base_point + offset\n                else:\n                    sample = np.array([random.uniform(0, bounds[d]) for d in range(dim)])\n                # Clamp sample inside bounds\n                sample_clamped = np.clip(sample, [0]*dim, np.array(bounds))\n                return tuple(sample_clamped)\n\n        # Steer function that moves from from_pos towards to_pos by step size max, no overshoot\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d]-from_pos[d])/dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d]*step for d in range(dim))\n            return new_pos\n\n        # Rewire to improve path cost\n        def rewire(tree, new_node, radius):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    # Check edge collision before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.remove_from_parent()\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Propagate updated costs down subtree\n                        near.update_cost_recursive(potential_cost)\n\n        # Prune nodes unlikely to improve best path by heuristic cost (g + h)\n        def prune(tree):\n            nonlocal nodes, edges\n            new_tree = []\n            for node in tree:\n                if node is None:\n                    continue\n                # Heuristic estimate cost to goal/start depending on tree\n                other_goal = goal_position if tree is tree_start else start_position\n                heuristic = node.cost + math.dist(node.position, other_goal)\n                if heuristic < best_cost * 1.05 or node is tree[0]:  # keep root always\n                    new_tree.append(node)\n                else:\n                    if node.parent:\n                        node.remove_from_parent()\n                    if node in nodes:\n                        nodes.remove(node)\n            return new_tree\n\n        # Attempt to connect two trees if possible\n        def try_connect(new_node, other_tree):\n            nonlocal best_cost, best_path, success\n            nearest, dist_near = nearest_node(other_tree, new_node.position)\n            if nearest is None or dist_near > self.base_step * 1.1:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest.position, obstacles, is_3d):\n                return\n            candidate_cost = new_node.cost + dist_near + nearest.cost\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                path_from_start = new_node.path_from_root() if tree_start[0] in new_node.path_from_root() else nearest.path_from_root()\n                # Determine from which tree is new_node and nearest\n                if new_node in tree_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest.path_from_root()\n                else:\n                    path_start = nearest.path_from_root()\n                    path_goal = new_node.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                best_path.clear()\n                best_path.extend(combined_path)\n                success = True\n\n        # Multi-stage smoothing: shortcut + bezier curve smoothing iterations to improve smoothness & length\n        def multi_stage_smoothing(path, max_iter=50):\n            # Shortcut smoothing\n            def shortcut_smooth(path, trials=30):\n                smoothed = path[:]\n                for _ in range(trials):\n                    if len(smoothed) < 3:\n                        break\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) -1)\n                    if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                        smoothed = smoothed[:i+1] + smoothed[j:]\n                return smoothed\n\n            # Bezier smoothing with simple quadratic Bezier for segments \n            def bezier_smooth(path, interpolation_steps=5):\n                if len(path) < 3:\n                    return path[:]\n                new_path = [path[0]]\n                for i in range(1, len(path)-1):\n                    p0 = np.array(path[i-1])\n                    p1 = np.array(path[i])\n                    p2 = np.array(path[i+1])\n                    for t in np.linspace(0,1, interpolation_steps):\n                        # Quadratic Bezier formula\n                        point = (1 - t)**2 * p0 + 2*(1 - t)*t*p1 + t**2*p2\n                        # Clamp inside bounds\n                        clamped = np.clip(point, [0]*dim, np.array(bounds))\n                        if not self._is_in_obstacle(tuple(clamped), obstacles, is_3d):\n                            new_path.append(tuple(clamped))\n                        else:\n                            # If obstacle hit, fallback to linear interpolation\n                            new_path.append(tuple(clamped))\n                    # skip adding p1 again (already added) \n                new_path.append(path[-1])\n                # Remove duplicates and keep monotonicity\n                filtered_path = []\n                last = None\n                for p in new_path:\n                    if last is None or math.dist(p, last) > 1e-4:\n                        filtered_path.append(p)\n                    last = p\n                return filtered_path\n\n            current_path = path[:]\n            for _ in range(max_iter):\n                prev_len = sum(math.dist(current_path[i], current_path[i+1]) for i in range(len(current_path)-1))\n                trial_path = shortcut_smooth(current_path, trials=30)\n                trial_path = bezier_smooth(trial_path, interpolation_steps=4)\n                curr_len = sum(math.dist(trial_path[i], trial_path[i+1]) for i in range(len(trial_path)-1))\n                if curr_len < prev_len - 1e-3:\n                    current_path = trial_path\n                else:\n                    break\n            return current_path\n\n        # Main loop\n        for itr in range(self.max_iter):\n            # Alternate trees each iteration\n            if itr % 2 == 0:\n                growth_tree, other_tree = tree_start, tree_goal\n            else:\n                growth_tree, other_tree = tree_goal, tree_start\n\n            # Sample point biased by informed Gaussian mixture if path available, else uniform\n            sample_point = informed_gaussian_sample()\n\n            # Reject samples outside bounds\n            if any(sample_point[d] < 0 or sample_point[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample_point, obstacles, is_3d):\n                continue\n\n            nearest, nearest_dist = nearest_node(growth_tree, sample_point)\n            if nearest is None:\n                continue\n\n            # Compute adaptive step and steer\n            step = adaptive_step(nearest.position, sample_point)\n            new_pos = steer(nearest.position, sample_point, step)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Heuristic cost estimate to goal/start on other tree side\n            heuristic_est = math.dist(new_pos, goal_position if growth_tree is tree_start else start_position)\n            if new_cost + heuristic_est >= best_cost:\n                # Prune futile expansions early\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            growth_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Adaptive rewire radius depending on current best cost\n            radius = rewire_radius(best_cost)\n            rewire(growth_tree, new_node, radius)\n\n            try_connect(new_node, other_tree)\n\n            # Periodically prune nodes on the growth tree that are unlikely to improve path\n            if itr % 150 == 0 and best_cost < float('inf'):\n                if growth_tree is tree_start:\n                    tree_start = prune(tree_start)\n                else:\n                    tree_goal = prune(tree_goal)\n\n            # Early termination if path cost close to theoretical minimum distance\n            if success and best_cost <= dist_start_goal * 1.01:\n                break\n\n        # Post-processing: Apply multi-stage smoothing if path found\n        if success and best_path:\n            best_path = multi_stage_smoothing(best_path, max_iter=50)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1088.73777,
    "time_improvement": -3585.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.5526947259902955,
            "num_nodes_avg": 2040.3,
            "path_length_avg": 159.2131313628575,
            "smoothness_avg": 0.007862089501747728,
            "success_improvement": -9.999999999999998,
            "time_improvement": -6085.214025890152,
            "length_improvement": 12.732759806503994,
            "smoothness_improvement": 23.058773502964627,
            "objective_score": -1872.90236193823
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.125580358505249,
            "num_nodes_avg": 3187.3,
            "path_length_avg": 250.93100984338835,
            "smoothness_avg": 0.005134387300156232,
            "success_improvement": 0.0,
            "time_improvement": -1188.67436672276,
            "length_improvement": 16.232006265629252,
            "smoothness_improvement": 32.111483382711825,
            "objective_score": -353.1953513467886
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.7852933883666993,
            "num_nodes_avg": 2638.2,
            "path_length_avg": 118.19738078234873,
            "smoothness_avg": 0.00884037378783912,
            "success_improvement": 0.0,
            "time_improvement": -3481.5920731159017,
            "length_improvement": 21.49892763880975,
            "smoothness_improvement": 12.448902052797358,
            "objective_score": -1040.1155918967445
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines bidirectional growth with informed and adaptive sampling, dynamic rewiring, and node pruning for efficiency. It uses ellipsoidal informed sampling to limit exploration to promising regions, adaptive step sizing near obstacles for safety and speed, and rewiring to continuously optimize path costs. Upon successful tree connection, it extracts and smooths the path to enhance path quality and reduce length. This design balances rapid convergence with asymptotic optimality and robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternating expansion. Sampling is guided by goal bias and informed sampling within an ellipsoid around best current solution. Step sizes adapt near obstacles to avoid collisions safely. Trees are rewired dynamically to reduce costs, and pruning discards nodes unlikely to improve the best path found. When trees connect, the best path is extracted and then smoothed iteratively by shortcutting collision-free segments. The approach strives for fast convergence and higher-quality, smooth paths with robust collision avoidance.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        def rotation_to_world(u_vec):\n            if dim == 2:\n                angle = math.atan2(u_vec[1], u_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = u_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rot_mat = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                r1 = c_best / 2.0\n                val = c_best**2 - c_min**2\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                for _ in range(100):  # max trials\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x == 0:\n                        continue\n                    x_ball /= norm_x\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball *= radius\n                    sample = rot_mat @ L @ x_ball + x_center\n                    sample_t = tuple(sample)\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n                # fallback if no sample found\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            return tuple(from_pos[d] + direction[d] * step for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            near = near_nodes(tree, new_node.position, self.rewire_radius)\n            for n in near:\n                if n == new_node:\n                    continue\n                c_new = new_node.cost + math.dist(new_node.position, n.position)\n                if c_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    n.remove_from_parent(edges)\n                    n.parent = new_node\n                    n.cost = c_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n        def try_connect(tree_src, tree_tgt, new_node):\n            nonlocal best_cost, best_path, success, c_best\n            if not tree_tgt:\n                return\n            nearest_other = min(tree_tgt, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return\n            total_c = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_c < best_cost:\n                best_cost = total_c\n                c_best = total_c\n                path_start = new_node.path_from_root() if tree_src is tree_start else nearest_other.path_from_root()\n                path_goal = nearest_other.path_from_root() if tree_src is tree_start else new_node.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                best_path.clear()\n                best_path.extend(combined_path)\n                success = True\n\n        def prune_nodes(tree, limit_cost):\n            # Remove nodes that cannot improve path below limit_cost\n            to_remove = []\n            for n in tree:\n                h_cost = n.cost + math.dist(n.position, goal if tree is tree_start else start)\n                if h_cost >= limit_cost:\n                    to_remove.append(n)\n            for n in to_remove:\n                # remove edges and detach node from tree\n                n.remove_from_parent(edges)\n                if n in tree:\n                    tree.remove(n)\n\n        def smooth_path(path, iterations=20):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Main iteration loop\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n            try_connect(tree_a, tree_b, new_node)\n\n            # Prune unpromising branches to reduce tree size\n            prune_nodes(tree_start, best_cost)\n            prune_nodes(tree_goal, best_cost)\n\n            if success and best_cost <= c_min * 1.01:\n                break\n\n        if success and best_path:\n            best_path = smooth_path(best_path, iterations=25)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 833.73549,
    "time_improvement": -2744.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 418.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.254822325706482,
            "num_nodes_avg": 2190.0,
            "path_length_avg": 154.11609406792797,
            "smoothness_avg": 0.019039596543996583,
            "success_improvement": 0.0,
            "time_improvement": -4898.628847669792,
            "length_improvement": 15.526526715579367,
            "smoothness_improvement": 198.0110310591938,
            "objective_score": -1465.4932938025258
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.7514490365982056,
            "num_nodes_avg": 2906.9,
            "path_length_avg": 228.40803237502888,
            "smoothness_avg": 0.03201065566938639,
            "success_improvement": 0.0,
            "time_improvement": -961.8499879593271,
            "length_improvement": 23.75082443252877,
            "smoothness_improvement": 723.6572267166462,
            "objective_score": -280.18654536770913
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.2321613788604737,
            "num_nodes_avg": 2442.0,
            "path_length_avg": 117.57186058740874,
            "smoothness_avg": 0.034056662410531104,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2371.9183166659336,
            "length_improvement": 21.914368368218057,
            "smoothness_improvement": 333.19823206062495,
            "objective_score": -755.5266301658332
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid path planner combining the strengths of bidirectional RRT* with informed sampling and adaptive exploration. It employs two trees growing from the start and goal using ellipsoidal informed sampling for focused search, adaptive step sizing near obstacles for safer exploration, dynamic rewiring for path cost minimization, and post-processing path smoothing for improved path quality. The planner prunes unpromising nodes to maintain performance and stops early when near-optimal solutions are found.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling new points preferentially within an informed ellipsoidal subset defined by the current best path cost. New nodes are connected if collision-free, rewiring nearby nodes to reduce costs. Adaptive step sizing avoids obstacle collisions by reducing step size near obstacles. When the two trees connect, the best path is updated and shortcut smoothing is applied to improve path smoothness and shorten path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = diff / norm_diff\n\n        def rotation_to_world(vector):\n            if dim == 2:\n                angle = math.atan2(vector[1], vector[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                a = vector\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.eye(3)\n                v /= np.linalg.norm(v)\n                H = np.eye(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.eye(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = rotation_matrix @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d]-from_pos[d])/dist for d in range(dim))\n            return tuple(from_pos[d] + direction[d]*step for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            checks = max(3, int(dist))\n            for i in range(1, checks+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/checks) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_a, tree_b, new_node):\n            nonlocal c_best\n            if not tree_b:\n                return None\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return None\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < c_best:\n                c_best = total_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else nearest_other.path_from_root()\n                path_goal = nearest_other.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                return path_start + path_goal[::-1][1:]\n            return None\n\n        def prune_tree(tree):\n            # Remove nodes with cost exceeding current best to improve efficiency\n            for node in tree[:]:\n                if node.cost > c_best + 1e-5:\n                    # Remove subtree rooted at node\n                    def remove_subtree(n):\n                        for c in n.children[:]:\n                            remove_subtree(c)\n                        if n in tree:\n                            tree.remove(n)\n                            try:\n                                edges.remove((n.parent, n))\n                            except Exception:\n                                pass\n                    remove_subtree(node)\n\n        def path_smoothing(path, iterations=20):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bound check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            path = try_connect(tree_a, tree_b, new_node)\n            if path:\n                extracted_path = path\n                success_state = True\n                prune_tree(tree_start)\n                prune_tree(tree_goal)\n                if c_best <= c_min * 1.01:\n                    break\n\n        if success_state and extracted_path:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 742.57971,
    "time_improvement": -2330.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 445.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.055659532546997,
            "num_nodes_avg": 1527.0,
            "path_length_avg": 152.2870785722894,
            "smoothness_avg": 0.023583408548382107,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4105.256859560646,
            "length_improvement": 16.529039091344078,
            "smoothness_improvement": 269.1315559735223,
            "objective_score": -1276.9255922700575
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 1.4386967897415162,
            "num_nodes_avg": 2628.1,
            "path_length_avg": 226.3751578612443,
            "smoothness_avg": 0.03001769589856008,
            "success_improvement": -19.999999999999996,
            "time_improvement": -772.237865299995,
            "length_improvement": 24.429456458278594,
            "smoothness_improvement": 672.3769363423845,
            "objective_score": -323.4235836166309
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.1029405355453492,
            "num_nodes_avg": 2264.8,
            "path_length_avg": 117.07628725578267,
            "smoothness_avg": 0.038763682887796205,
            "success_improvement": 0.0,
            "time_improvement": -2112.6800586212903,
            "length_improvement": 22.24350457841793,
            "smoothness_improvement": 393.07118509532614,
            "objective_score": -627.3899607452269
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with tuned parameters for improved efficiency and path quality. It employs informed ellipsoidal sampling biased by the best current solution cost, adaptive step sizes that decrease near obstacles, dynamic rewiring within a radius optimized for balanced computation and path improvement, and path smoothing for shorter, smoother trajectories. The planning balances exploration and exploitation and efficiently prunes nodes unlikely to yield better paths, enhancing success rate and reducing search time.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately using informed sampling within an ellipse defined by the current best cost. It dynamically adapts step sizes near obstacles to improve collision avoidance, rewires neighbors to reduce path cost, aggressively prunes nodes that cannot improve the best solution, attempts connections between trees when close, and performs path smoothing on the best path found before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        # Tuned rewiring radius for efficient trade-off between runtime and path improvement\n        self.rewire_radius = 12.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        best_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling aligned with start-goal vector\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        for itr in range(self.max_iter):\n            # Alternate trees to grow\n            tree_a, tree_b = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            # Goal biasing with improved rate to increase success\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is not tree_b else start\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size shrinks near obstacles to improve collision avoidance while ensuring progress\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal)\n            # Prune expansions that cannot improve best known path to optimize search\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire close neighbors within a tuned radius to reduce overall path cost\n            neighbors = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if potential_cost < near.cost:\n                    # Verify safe rewiring path before changing parent\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connecting to the opposite tree if close and collision free\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_conn = math.dist(new_node.position, other_nearest.position)\n            if dist_conn <= self.base_step * 1.25:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # Avoid path node duplication at connection\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            # Early exit if stable good path found to save time\n            if success and itr > 300 and itr % 100 == 0:\n                break\n\n        # Aggressive path smoothing with more trials for better path quality\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d, max_trials=100)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import math\n        import numpy as np\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:\n            r2 = 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        for _ in range(100):\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n        # Fallback in rare case no valid sample found\n        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps_eval = max(5, int(distance * 2.5))  # Increased density for better obstacle detection\n        for i in range(1, steps_eval + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_eval) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Shrink step but not below reasonable minimum to maintain progress\n                return max(self.base_step * 0.25, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 61.37097,
    "time_improvement": -182.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1323.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.1378922700881958,
            "num_nodes_avg": 594.0,
            "path_length_avg": 162.70169661011022,
            "smoothness_avg": 0.04076399652675485,
            "success_improvement": -9.999999999999998,
            "time_improvement": -449.29870549239723,
            "length_improvement": 10.820621914630912,
            "smoothness_improvement": 538.0450660789899,
            "objective_score": -179.93526193439803
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11409411430358887,
            "num_nodes_avg": 727.3,
            "path_length_avg": 232.64849575143438,
            "smoothness_avg": 0.08738323807676239,
            "success_improvement": 0.0,
            "time_improvement": 30.828227731476517,
            "length_improvement": 22.335235702513845,
            "smoothness_improvement": 2148.4336553174453,
            "objective_score": 24.45768373653295
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11369383335113525,
            "num_nodes_avg": 680.2,
            "path_length_avg": 125.08247681573741,
            "smoothness_avg": 0.10858514669342194,
            "success_improvement": 0.0,
            "time_improvement": -128.08852312231073,
            "length_improvement": 16.92617468647442,
            "smoothness_improvement": 1281.1950510185193,
            "objective_score": -28.63534674430574
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm combines bidirectional RRT* with informed sampling and dynamic rewiring to efficiently explore the search space. It adaptively samples within an ellipsoidal region shaped by the current best solution, grows two trees simultaneously from start and goal, checks collisions thoroughly, rewires nodes to optimize path cost, prunes suboptimal nodes, and performs path smoothing to enhance final path quality.",
    "planning_mechanism": "The planner alternates expanding two trees towards each other, samples points biased towards the goal and informed subset, adaptively steers with collision-aware step sizes, connects trees when possible, rewires neighbors for cost improvement, prunes non-promising nodes, and applies shortcut smoothing to obtain a shorter, smoother path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision check bookkeeping\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges: List[Tuple['Node', 'Node']]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start: List[Node] = [Node(start)]\n        tree_goal: List[Node] = [Node(goal)]\n        nodes: List[Node] = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_u = np.linalg.norm(unit_vec)\n        if norm_u < 1e-10:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_u\n\n        def rotation_matrix_to_world(vec):\n            if dim == 2:\n                angle = math.atan2(vec[1], vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rot_W = rotation_matrix_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                r1 = c_best / 2.0\n                r2 = max(0.0, math.sqrt(c_best**2 - c_min**2) / 2.0)\n                L = np.diag([r1] + [r2] * (dim - 1))\n                for _ in range(100):\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x < 1e-10:\n                        continue\n                    x_ball /= norm_x\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball *= radius\n                    sample = rot_W @ L @ x_ball + x_center\n                    sample_tuple = tuple(sample[d] for d in range(dim))\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n                # fallback uniform\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * max_step for d in range(dim))\n            return new_pos\n\n        def collision_free_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree: List[Node], new_node: Node, radius: float):\n            neighbors = [node for node in tree if node != new_node and math.dist(node.position, new_node.position) <= radius]\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if collision_free_edge(new_node.position, neighbor.position):\n                        neighbor.remove_from_parent(edges)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(tree_a: List[Node], tree_b: List[Node], new_node: Node):\n            nonlocal best_cost, best_path, success, c_best\n\n            if not tree_b:\n                return\n\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            if not collision_free_edge(new_node.position, nearest_b.position):\n                return\n\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else nearest_b.path_from_root()\n                path_goal = nearest_b.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                best_path = path_start + path_goal[::-1][1:]\n                success = True\n\n        def prune(tree: List[Node], threshold: float):\n            for node in tree[:]:\n                heuristic = node.cost + math.dist(node.position, goal if tree is tree_start else start)\n                if heuristic >= threshold and node.parent:\n                    node.remove_from_parent(edges)\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n\n        goal_sample_rate = 0.1\n        rewire_radius = max(10.0, self.step_size * 2)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step decreasing near obstacles for safety\n            step = self.step_size\n            direction_dist = math.dist(nearest_node.position, sample)\n            # Check intermediate points to adapt step size\n            if direction_dist > step:\n                steps_check = max(2, int(direction_dist / step * 2))\n                collision_found = False\n                for k in range(1, steps_check + 1):\n                    interp = tuple(nearest_node.position[d] + (sample[d] - nearest_node.position[d]) * k / steps_check for d in range(dim))\n                    if self._is_in_obstacle(interp, obstacles, is_3d):\n                        collision_found = True\n                        break\n                if collision_found:\n                    step *= 0.3\n\n            new_pos = steer(nearest_node.position, sample, step)\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node, rewire_radius)\n            try_connect(tree_a, tree_b, new_node)\n            prune(tree_a, best_cost)\n\n            if success and best_cost <= c_min * 1.01:\n                break\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations=20) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 695.78655,
    "time_improvement": -2338.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 313.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.075361680984497,
            "num_nodes_avg": 1806.1,
            "path_length_avg": 152.77796370645564,
            "smoothness_avg": 0.01569619337984434,
            "success_improvement": 0.0,
            "time_improvement": -4183.7410604895,
            "length_improvement": 16.259977170734842,
            "smoothness_improvement": 145.67951122403488,
            "objective_score": -1251.141925156583
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.5328828811645507,
            "num_nodes_avg": 2747.0,
            "path_length_avg": 228.72880264925115,
            "smoothness_avg": 0.022089103816380202,
            "success_improvement": 0.0,
            "time_improvement": -829.3400121245094,
            "length_improvement": 23.643742082132963,
            "smoothness_improvement": 468.368551333849,
            "objective_score": -241.73141246425698
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.0474236726760864,
            "num_nodes_avg": 2125.9,
            "path_length_avg": 118.35137077794903,
            "smoothness_avg": 0.033421366334885384,
            "success_improvement": 0.0,
            "time_improvement": -2001.3041036816237,
            "length_improvement": 21.39665481594764,
            "smoothness_improvement": 325.1173128710899,
            "objective_score": -594.4863135769422
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner enhances bidirectional RRT* by integrating adaptive ellipsoidal informed sampling focused on the current best path cost and dynamic neighbor radius for rewiring, accelerated with KD-tree structures for nearest neighbor lookups. Collision checks are aggressively cached for efficiency. It extends the smaller tree each iteration for balance, rewires neighbors incrementally to minimize costs, prunes nodes unlikely to yield improvements to control tree size, and applies an adaptive shortcut smoothing strategy after new best paths are found. Enhanced heuristic pruning and focused sampling improve convergence speed and path quality, suitable for both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees rooted at the start and goal, extending towards samples drawn from an ellipsoidal informed distribution shaped by the best known path cost. It utilizes an adaptive radius for neighbor rewiring to optimize path costs, while KD-trees accelerate the nearest and radius neighbor searches. Connections between trees are attempted incrementally with collision-checked steering steps. Periodic pruning removes nodes inefficient for improvement. Upon each successful connection reducing the path cost, shortcut smoothing refines the path. The process iterates up to a maximum number, yielding fast, smooth, and shorter paths with high success rates.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int=5000,\n                 step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for dd in range(self.dim):\n                        delta = p[dd] - pt[dd]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos): return False\n            if is_in_obstacle(pos): return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0  # Restart smoothing after successful shortcut\n                else:\n                    iteration += 1\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                # If estimated total cost worse than current best, prune\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node (incremental rewiring)\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to remove non-promising nodes and clear cache\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -28.25497,
    "time_improvement": 60.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1317.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00900564193725586,
            "num_nodes_avg": 63.0,
            "path_length_avg": 151.69834772037143,
            "smoothness_avg": 0.04453127831816461,
            "success_improvement": 0.0,
            "time_improvement": 64.12570875003563,
            "length_improvement": 16.85173180031766,
            "smoothness_improvement": 597.0112068979007,
            "objective_score": 25.593115019563722
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023708391189575195,
            "num_nodes_avg": 208.9,
            "path_length_avg": 234.62240315440553,
            "smoothness_avg": 0.08518834511573278,
            "success_improvement": 0.0,
            "time_improvement": 85.62632747334646,
            "length_improvement": 21.676288595627717,
            "smoothness_improvement": 2091.9574785126547,
            "objective_score": 40.482943353692754
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03448154926300049,
            "num_nodes_avg": 209.4,
            "path_length_avg": 127.04224516556198,
            "smoothness_avg": 0.107180391233064,
            "success_improvement": 0.0,
            "time_improvement": 30.82434275852964,
            "length_improvement": 15.62458986266144,
            "smoothness_improvement": 1263.3266652510288,
            "objective_score": 18.688854126346325
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm employs a unidirectional RRT* approach enhanced with informed sampling around an ellipse defined by the current best path cost to improve path quality and efficiency. It integrates dynamic adaptive step sizing near obstacles, rewiring of nodes within a radius to optimize path costs, pruning of nodes unlikely to improve the solution, and iterative bidirectional shortcut smoothing to derive high-quality, smooth feasible paths. The approach balances exploration and exploitation, maintains collision-free connectivity, and reduces computation time by focusing samples and adaptively stepping near obstacles.",
    "planning_mechanism": "The planner incrementally grows a single tree from the start towards the goal using informed ellipsoidal sampling once a feasible path is found. At each iteration, it dynamically adjusts step size based on obstacle proximity, extends the tree towards sampled points, rewires near neighbors to optimize path cost, prunes nodes unpromising for better solutions, and attempts early termination upon convergence. After planning, it applies an iterative bidirectional shortcut smoothing method to enhance path smoothness and quality while ensuring collision-free validity.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position          # Tuple of coordinates, 2D or 3D\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root node (start)\n        self.children: List['Node'] = []  # List of child nodes\n        self.valid = True                 # Validity flag (collision/pruning)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_root = Node(start_position, None, 0.0)\n        nodes: List[Node] = [start_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def node_heuristic_cost(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample() -> Tuple[float, ...]:\n            # If no solution yet, sample uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling centered on start/goal\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return tuple(x_center)\n\n            # Rotation matrix from unit vector along world x-axis to diff vector\n            a1 = diff / norm_diff\n            I = np.eye(dim)\n            b = np.zeros(dim)\n            b[0] = 1.0\n            v = np.cross(b, a1) if dim == 3 else np.array([b[1] - a1[1], a1[0] - b[0]])\n            s = np.linalg.norm(v)\n            c = np.dot(b, a1)\n            if s < 1e-12:\n                R = np.eye(dim)\n            else:\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]]) if dim == 3 else np.array([[0, -v[1]], [v[0], 0]])\n                vx = vx if dim==3 else vx\n                R = I + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n\n            r1 = c_best / 2.0\n            r2_val = max(0.0, (c_best ** 2 - c_min ** 2)) ** 0.5 / 2.0\n            L_diag = [r1] + [r2_val] * (dim - 1)\n            L = np.diag(L_diag)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-12:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = x_center + R @ L @ x_ball\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> float:\n            dist = math.dist(from_pos, to_pos)\n            check_points = max(3, int(dist))\n            for i in range(1, check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.25, 1.0)\n            return self.base_step\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbors(new_node: Node, tree: List[Node]) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n\n        def rewire(new_node: Node, tree: List[Node]):\n            for neighbor in neighbors(new_node, tree):\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly\n                        for i, (p, c) in enumerate(edges):\n                            if c == neighbor:\n                                edges[i] = (new_node, neighbor)\n                                break\n\n        def prune(tree: List[Node]):\n            to_remove = []\n            for node in tree:\n                if node is start_root:\n                    continue\n                # Heuristic cost check: cost + distance to goal >= c_best means no improvement possible\n                heuristic = node.cost + math.dist(node.position, goal_position)\n                if heuristic >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                # Remove related edges\n                edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n\n        def backtrack_path(node: Node) -> List[Tuple[float, ...]]:\n            return node.path_from_root()\n\n        def smooth_path(path: List[Tuple[float, ...]], max_iterations: int = 40) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree = [start_root]\n\n        for iter_num in range(self.max_iter):\n            sample = informed_sample()\n            nearest_node = nearest(tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            # Check map bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            # Prune by path cost heuristic (cost + distance to goal)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, tree)\n            prune(tree)\n\n            # Check if new node can connect directly to goal with collision-free edge\n            if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, goal_position)\n                if total_cost < c_best:\n                    c_best = total_cost\n                    goal_node = Node(goal_position, new_node, total_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = backtrack_path(goal_node)\n                    success_state = True\n\n            # Early stopping if path found and refinement iteration exceeded 10% of max_iter\n            if success_state and iter_num > int(self.max_iter * 0.1):\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = smooth_path(extracted_path, max_iterations=60)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 40.50034,
    "time_improvement": -116.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1685.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.1048241376876831,
            "num_nodes_avg": 337.2,
            "path_length_avg": 173.864390017431,
            "smoothness_avg": 0.04871676734839817,
            "success_improvement": -9.999999999999998,
            "time_improvement": -317.5706375663637,
            "length_improvement": 4.702172773882019,
            "smoothness_improvement": 662.5231991559585,
            "objective_score": -141.0181407193529
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11400318145751953,
            "num_nodes_avg": 526.5,
            "path_length_avg": 233.599946600063,
            "smoothness_avg": 0.11331323165824762,
            "success_improvement": 0.0,
            "time_improvement": 30.883357535134053,
            "length_improvement": 22.017614023247393,
            "smoothness_improvement": 2815.6310667885223,
            "objective_score": 27.746685399132307
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08095321655273438,
            "num_nodes_avg": 389.0,
            "path_length_avg": 130.90691041082647,
            "smoothness_avg": 0.13176971072222415,
            "success_improvement": 0.0,
            "time_improvement": -62.40546264710329,
            "length_improvement": 13.057863222339888,
            "smoothness_improvement": 1576.100994158379,
            "objective_score": -8.229561178871112
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT growth with informed elliptical sampling, adaptive step sizing near obstacles, continuous rewiring, cost-based pruning, and aggressive path shortcut smoothing. It uses dynamic tree alternation and prunes suboptimal nodes early to enhance search efficiency. The planner balances exploration and exploitation within a shrinking informed ellipsoid region guided by the current best path cost, and adaptively adjusts step sizes to better navigate near obstacles for robust collision avoidance. Continuous rewiring ensures improved path quality during the search, while iterative shortcut smoothing at the end further optimizes path length and smoothness.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, samples new nodes mostly inside an informed ellipsoidal region defined by the current best solution cost, performs adaptive stepping to avoid obstacles, prunes nodes unlikely to lead to better solutions, rewires nearby nodes for cheaper paths, attempts to connect trees when close, and finally applies iterative shortcut smoothing on the best path found. This approach enhances planning efficiency, robust collision avoidance, and optimality in both 2D and 3D spaces.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # For collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize roots and trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n\n        def rotation_matrix(a1):\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            return U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            val = max(0.0, c_best**2 - c_min**2)\n            r1 = c_best / 2.0\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            C = rotation_matrix(a1)\n\n            for _ in range(200):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n            # fallback random sample if none valid\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps_check = max(3, int(dist * 2))\n            reduce_step = self.base_step\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduce_step = max(self.base_step * 0.3, 1.0)\n                    break\n            return reduce_step\n\n        def rewire(tree, new_node):\n            near_nodes = [node for node in tree if node != new_node and distance(node.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_to_goal = distance(near.position, goal_position)\n                if potential_cost + heuristic_to_goal >= c_best:\n                    continue\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # Update edges list\n                        try:\n                            idx = next(i for i,(p,c) in enumerate(edges) if c == near)\n                            edges[idx] = (new_node, near)\n                        except StopIteration:\n                            edges.append((new_node, near))\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node in (start_root, goal_root):\n                    continue\n                est_total = node.cost + distance(node.position, goal_position)\n                if est_total >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicate connecting position\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smooth(path: List[Tuple[float, ...]], iterations=50):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remaining = distance(new_pos, goal_position)\n            if new_cost + heuristic_remaining >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(active_tree, new_node)\n            prune(active_tree)\n\n            # Attempt connection with other tree\n            other_nearest = min(other_tree, key=lambda n: distance(n.position, new_node.position))\n            dist_between_trees = distance(new_node.position, other_nearest.position)\n            if dist_between_trees <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + dist_between_trees + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success_state = True\n\n            # Early stop if good path is found and after some refinement\n            if success_state and iter_num > int(self.max_iter * 0.9):\n                break\n\n        if success_state and best_path:\n            best_path = path_smooth(best_path, iterations=70)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1055.59875,
    "time_improvement": -3439.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1022.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.4102678298950195,
            "num_nodes_avg": 1496.2,
            "path_length_avg": 152.02175389103334,
            "smoothness_avg": 0.03773365418583821,
            "success_improvement": -9.999999999999998,
            "time_improvement": -5517.851478283994,
            "length_improvement": 16.674467753479146,
            "smoothness_improvement": 490.61362794992675,
            "objective_score": -1699.5674817947527
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 2.217709445953369,
            "num_nodes_avg": 2630.1,
            "path_length_avg": 223.24132140655948,
            "smoothness_avg": 0.06489566450726487,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1244.5294149447152,
            "length_improvement": 25.475621269333327,
            "smoothness_improvement": 1569.8121902297255,
            "objective_score": -410.41463927839925
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.8217164516448974,
            "num_nodes_avg": 2363.5,
            "path_length_avg": 116.27826538532084,
            "smoothness_avg": 0.08694980932638743,
            "success_improvement": 0.0,
            "time_improvement": -3554.662726693541,
            "length_improvement": 22.773512707060764,
            "smoothness_improvement": 1005.995156664328,
            "objective_score": -1056.8141396833287
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an advanced bidirectional informed RRT* planner that combines adaptive step sizing, dynamic rewire radius, and cost-based pruning with lazy collision checking and incremental path shortcut smoothing. It grows two trees from start and goal, alternates expansions with focused ellipsoidal sampling constrained by the best current solution cost, adaptively adjusts step size near obstacles to improve extension success, rewires neighbors inside a dynamically shrinking radius to optimize cost efficiently, prunes branches that cannot improve the best cost early, and incrementally smooths the path to improve path quality and smoothness while accelerating convergence.",
    "planning_mechanism": "The planner initializes two trees from the start and goal positions, sampling points primarily inside an informed ellipsoidal region that shrinks with better solution cost. For each iteration, a sample is drawn, and the nearest node is steered toward the sample with an adaptive step size accounting for proximity to obstacles. New nodes are added if collision checks pass, followed by rewiring within a radius that decreases as the tree grows. The two trees attempt to connect when nodes are close, updating the best path and cost dynamically. Periodic pruning removes nodes unlikely to improve the solution, and incremental shortcut smoothing refines the path. The planning ends early if a sufficiently optimal path is found or the maximum iterations are reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position       # Tuple[float, ...]: position in 2D or 3D space\n        self.parent = parent           # Node or None\n        self.cost = cost               # cost from root to this node\n        self.children: List['Node'] = []\n        self.valid = True              # validity flag for pruning or collision\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, \n                 goal_sample_rate: float = 0.1, initial_rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_rewire_radius = initial_rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(False, [], nodes, edges)\n\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float(\"inf\"):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball = x_ball * radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (max_step / dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            samples = max(10, int(dist * 5))\n            for i in range(1, samples + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / samples for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire_radius(n_nodes):\n            return min(self.initial_rewire_radius,\n                       self.initial_rewire_radius * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float):\n            return [node for node in tree if distance(node.position, position) <= radius]\n\n        def rewire(tree: List[Node], new_node: Node):\n            radius = rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor.parent is None:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                heuristic = distance(neighbor.position, goal)\n                if tentative_cost + heuristic >= best_cost:\n                    continue\n                if tentative_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = tentative_cost\n                    edges.append((new_node, neighbor))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicated connection node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]], iterations: int = 40) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune(tree: List[Node]):\n            # Prune nodes that cannot improve best cost\n            retained = []\n            for node in tree:\n                heuristic = distance(node.position, goal)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    node.valid = False\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n            return retained\n\n        # Lazy incremental smoothing on improvements\n        smoothing_interval = 50\n        pruning_interval = 200\n\n        for iteration in range(self.max_iter):\n            # Alternate growth trees to keep balanced expansions\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            if tentative_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt to connect to opposite tree if close enough\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n                    # Incremental shortcut smoothing on found path for better quality\n                    if iteration % smoothing_interval == 0:\n                        best_path = shortcut_smoothing(best_path, iterations=20)\n\n            # Prune trees to improve search speed\n            if success and iteration > 0 and iteration % pruning_interval == 0:\n                tree_start = prune(tree_start)\n                tree_goal = prune(tree_goal)\n\n            # Early stop if sufficiently good path found\n            if success and best_cost <= c_min * 1.05:\n                break\n\n        if success and best_path:\n            # Final smoothing\n            best_path = shortcut_smoothing(best_path, iterations=50)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 730.11916,
    "time_improvement": -2458.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 841.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0707659721374512,
            "num_nodes_avg": 1744.8,
            "path_length_avg": 160.75934589825567,
            "smoothness_avg": 0.014217740923573984,
            "success_improvement": 0.0,
            "time_improvement": -4165.433892735371,
            "length_improvement": 11.885255118315026,
            "smoothness_improvement": 122.538519772509,
            "objective_score": -1246.6404241980856
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.500438380241394,
            "num_nodes_avg": 3051.5,
            "path_length_avg": 242.6305049043843,
            "smoothness_avg": 0.05331132296012099,
            "success_improvement": 0.0,
            "time_improvement": -809.6699034346706,
            "length_improvement": 19.002953731056373,
            "smoothness_improvement": 1271.7387383577584,
            "objective_score": -232.7416865924011
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.2459922313690186,
            "num_nodes_avg": 2702.4,
            "path_length_avg": 125.90465330364518,
            "smoothness_avg": 0.09667044498957914,
            "success_improvement": 0.0,
            "time_improvement": -2399.6652808522285,
            "length_improvement": 16.380124211043277,
            "smoothness_improvement": 1129.6409247974373,
            "objective_score": -710.9753547894726
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced hybrid informed PRM-RRT planner tuned with optimized parameters for improved planning efficiency, path quality, and success rate. It incorporates heuristic ellipsoidal sampling to focus node generation on promising regions, adaptive roadmap connections with rewiring for better path cost, bidirectional RRT tree expansions for fast exploration, and iterative shortcutting to smooth the final path and reduce unnecessary turns.",
    "planning_mechanism": "The planner initializes by sampling a roadmap within an informed ellipsoid based on known best path cost, connecting roadmap nodes with collision-free edges, and improving connections via rewiring. It then grows two RRT trees from start and goal positions toward sampled points biased in the informed region, attempting to connect the trees through roadmap nodes. Upon connection, the path is reconstructed and smoothed with randomized shortcut attempts. Rigorous collision and edge checks ensure feasibility and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def reconstruct_path(node_from_start, node_from_goal):\n        path_start = []\n        node = node_from_start\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        path_goal = []\n        node = node_from_goal\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        return path_start + path_goal[1:]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, roadmap_node_count: int = 120,\n                 connection_radius: float = 20.0, shortcut_trials: int = 100):\n        self.max_iter = max_iter               # Reduced for faster termination balancing performance\n        self.step_size = step_size             # Smaller step size for finer exploration\n        self.roadmap_node_count = roadmap_node_count  # Reduced roadmap nodes to decrease overhead\n        self.connection_radius = connection_radius    # Tighter connection radius for efficient rewiring\n        self.shortcut_trials = shortcut_trials         # More smoothing trials for path quality\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(bounds)))\n            dx = [goal_pos[d] - start_pos[d] for d in range(len(bounds))]\n            length = dist(start_pos, goal_pos)\n            if length == 0:\n                return center\n\n            unit_vec = tuple(x / length for x in dx)\n\n            def ortho_basis_2d(vec):\n                return (-vec[1], vec[0])\n\n            def ortho_basis_3d(vec):\n                import numpy as np\n                v = np.array(vec)\n                if abs(v[0]) < 1e-6 and abs(v[1]) < 1e-6:\n                    ortho1 = np.array([0, 1, 0])\n                else:\n                    ortho1 = np.array([-v[1], v[0], 0])\n                ortho1 /= np.linalg.norm(ortho1)\n                ortho2 = np.cross(v, ortho1)\n                ortho2 /= np.linalg.norm(ortho2)\n                return ortho1, ortho2\n\n            a1 = c_best / 2\n            if is_3d:\n                a2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2\n                a3 = a2\n            else:\n                a2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2\n\n            import numpy as np\n\n            if is_3d:\n                while True:\n                    sample = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(sample) <= 1:\n                        break\n                sample[0] *= a1\n                sample[1] *= a2\n                sample[2] *= a3\n\n                ex = np.array(unit_vec)\n                ey, ez = ortho_basis_3d(unit_vec)\n                R = np.column_stack((ex, ey, ez))\n\n                mapped = R.dot(sample) + np.array(center)\n                m = tuple(mapped.tolist())\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n            else:\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x**2 + y**2 <= 1:\n                        break\n                sample_local = (x * a1, y * a2)\n                orth = ortho_basis_2d(unit_vec)\n                mapped = (\n                    center[0] + unit_vec[0] * sample_local[0] + orth[0] * sample_local[1],\n                    center[1] + unit_vec[1] * sample_local[0] + orth[1] * sample_local[1]\n                )\n                m = mapped\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n        # Roadmap Initialization\n        nodes = [Node(start_pos, cost=0.0), Node(goal_pos, cost=0.0)]\n        edges = []\n        c_best = float('inf')\n\n        # Sample roadmap nodes within informed ellipsoid biased area\n        samples_added = 0\n        trials_max = self.roadmap_node_count * 5\n        trials = 0\n        while samples_added < self.roadmap_node_count and trials < trials_max:\n            p = informed_sample(c_best)\n            trials += 1\n            if not in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            nodes.append(Node(p, parent=None, cost=float('inf')))\n            samples_added += 1\n\n        def near_nodes(rd_nodes, pos, radius):\n            radius_squared = radius*radius\n            return [n for n in rd_nodes if (n.position[0]-pos[0])**2 + (n.position[1]-pos[1])**2 <= radius_squared] if not is_3d else [n for n in rd_nodes if sum((n.position[d]-pos[d])**2 for d in range(3)) <= radius_squared]\n\n        # Connect roadmap nodes using PRM* style connection + rewiring\n        for n in nodes[2:]:\n            near = near_nodes(nodes, n.position, self.connection_radius)\n            best_parent = None\n            best_cost = float('inf')\n            for other in near:\n                if other == n or other.cost == float('inf'):\n                    continue\n                if self._is_edge_in_obstacle(other.position, n.position, obstacles, is_3d):\n                    continue\n                cost_through_other = other.cost + dist(other.position, n.position)\n                if cost_through_other < best_cost:\n                    best_cost = cost_through_other\n                    best_parent = other\n            if best_parent:\n                n.parent = best_parent\n                n.cost = best_cost\n                best_parent.add_child(n)\n                edges.append((best_parent, n))\n\n        # Rewiring for improving path cost estimates\n        improved = True\n        while improved:\n            improved = False\n            for n in nodes[2:]:\n                if n.parent is None or n.cost == float('inf'):\n                    continue\n                near = near_nodes(nodes, n.position, self.connection_radius)\n                for other in near:\n                    if other == n:\n                        continue\n                    cost_through_n = n.cost + dist(n.position, other.position)\n                    if cost_through_n + 1e-6 < other.cost:\n                        if self._is_edge_in_obstacle(n.position, other.position, obstacles, is_3d):\n                            continue\n                        # Rewire other under n\n                        if other.parent:\n                            try:\n                                other.parent.children.remove(other)\n                                edges.remove((other.parent, other))\n                            except ValueError:\n                                pass\n                        other.parent = n\n                        other.cost = cost_through_n\n                        n.add_child(other)\n                        edges.append((n, other))\n                        improved = True\n\n        # Initialize bidirectional trees\n        start_tree = [nodes[0]]\n        goal_tree = [nodes[1]]\n        tree_nodes_start = set([nodes[0]])\n        tree_nodes_goal = set([nodes[1]])\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        connected = False\n        connecting_node_start = None\n        connecting_node_goal = None\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, set_a, set_b in [(start_tree, goal_tree, tree_nodes_start, tree_nodes_goal),\n                                                 (goal_tree, start_tree, tree_nodes_goal, tree_nodes_start)]:\n                sample = informed_sample(c_best)\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_a = nearest(tree_a, sample)\n                new_pos = steer(nearest_a.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n                new_node.parent = nearest_a\n                nearest_a.add_child(new_node)\n                tree_a.append(new_node)\n                set_a.add(new_node)\n\n                candidates_b = [n for n in tree_b if dist(n.position, new_node.position) <= self.connection_radius]\n                candidates_b.sort(key=lambda nn: dist(nn.position, new_node.position))\n\n                for candidate_b in candidates_b:\n                    d_connect = dist(new_node.position, candidate_b.position)\n                    if d_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, candidate_b.position, obstacles, is_3d):\n                        connect_node_b = Node(candidate_b.position, parent=new_node,\n                                              cost=new_node.cost + d_connect)\n                        new_node.add_child(connect_node_b)\n                        tree_a.append(connect_node_b)\n                        set_a.add(connect_node_b)\n                        edges.append((new_node, connect_node_b))\n\n                        connected = True\n                        if tree_a is start_tree:\n                            connecting_node_start = connect_node_b\n                            connecting_node_goal = candidate_b\n                        else:\n                            connecting_node_start = candidate_b\n                            connecting_node_goal = connect_node_b\n                        break\n                if connected:\n                    break\n            if connected:\n                break\n\n        if not connected:\n            all_nodes = list(tree_nodes_start) + list(tree_nodes_goal) + nodes[2:]\n            return PlannerResult(False, [], all_nodes, edges)\n\n        path = Node.reconstruct_path(connecting_node_start, connecting_node_goal)\n\n        all_tree_nodes = set(start_tree + goal_tree + nodes[2:])\n\n        def update_edges(tree):\n            for n in tree:\n                if n.parent is not None and (n.parent, n) not in edges:\n                    edges.append((n.parent, n))\n\n        update_edges(start_tree)\n        update_edges(goal_tree)\n\n        def path_smoothing(path):\n            smoothed_path = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                a = smoothed_path[i]\n                b = smoothed_path[j]\n                if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        path = path_smoothing(path)\n\n        return PlannerResult(True, path, list(all_tree_nodes), edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 89.74086,
    "time_improvement": -57.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1601.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.07186486721038818,
            "num_nodes_avg": 290.6,
            "path_length_avg": 176.7948545619505,
            "smoothness_avg": 0.03840202827761762,
            "success_improvement": -9.999999999999998,
            "time_improvement": -186.27622493850376,
            "length_improvement": 3.09593872084858,
            "smoothness_improvement": 501.07513388384524,
            "objective_score": -102.75830406796217
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.058352994918823245,
            "num_nodes_avg": 425.7,
            "path_length_avg": 235.23467491265433,
            "smoothness_avg": 0.11029955388124839,
            "success_improvement": -19.999999999999996,
            "time_improvement": 64.62236373586377,
            "length_improvement": 21.471894659458858,
            "smoothness_improvement": 2738.0869669219683,
            "objective_score": -62.62847711273923
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.07408218383789063,
            "num_nodes_avg": 553.9,
            "path_length_avg": 128.52231048540128,
            "smoothness_avg": 0.13085283810943618,
            "success_improvement": -19.999999999999996,
            "time_improvement": -48.62104129318873,
            "length_improvement": 14.641600950361076,
            "smoothness_improvement": 1564.4384422002126,
            "objective_score": -103.83579998688333
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* with informed elliptical sampling focused on efficient exploration and exploitation. It uses adaptive step sizing to safely navigate near obstacles, rewires nearby nodes dynamically to optimize path costs, prunes unpromising nodes to enhance performance, and applies path smoothing to produce shorter, smoother paths. The design balances simplicity and effectiveness to improve success rate, planning speed, and path quality across 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal locations simultaneously, alternating expansions each iteration. Samples are drawn from an informed ellipsoidal subset that shrinks as better paths are found, biasing search towards promising areas. New nodes are only accepted if collision-free and within bounds. After adding a new node, neighbors within a rewiring radius are reconnected if it reduces cost and remains collision-free. The trees attempt to connect when possible to form a complete path. Early termination occurs upon near-optimal path discovery. Finally, the path is smoothed via shortcuts that bypass unnecessary nodes while ensuring collision-free traversal.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges: List[Tuple['Node', 'Node']]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0, goal_sample_rate: float=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        import math\n        import random\n        import numpy as np\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n        diff = np.array(goal_pos) - np.array(start_pos)\n        norm_diff = np.linalg.norm(diff)\n        unit_vec = diff / norm_diff if norm_diff > 1e-10 else np.array([1.0] + [0.0] * (dim - 1))\n\n        def rotation_to_world(vec):\n            if dim == 2:\n                angle = math.atan2(vec[1], vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                a = vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.eye(3)\n                v /= np.linalg.norm(v)\n                H = np.eye(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.eye(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = rotation_matrix @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            direction = tuple((to_p[d]-from_p[d])/dist for d in range(dim))\n            return tuple(from_p[d] + direction[d]*step for d in range(dim))\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            checks = max(3, int(dist))\n            for i in range(1, checks+1):\n                interp = tuple(from_p[d] + (to_p[d]-from_p[d])*(i/checks) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def rewire(tree: List[Node], new_node: Node):\n            neighbors = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.remove_from_parent(edges)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(tree_a: List[Node], tree_b: List[Node], new_node: Node):\n            nonlocal c_best\n            if not tree_b:\n                return None\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return None\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < c_best:\n                c_best = total_cost\n                if tree_a is tree_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                else:\n                    path_start = nearest_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n                return path_start + path_goal[::-1][1:]\n            return None\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Bias sampling towards goal/start occasionally\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is tree_start else start_pos\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bounds and collision checks\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic = new_cost + math.dist(new_pos, goal_pos if tree_a is tree_start else start_pos)\n            if heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            path = try_connect(tree_a, tree_b, new_node)\n            if path:\n                extracted_path = path\n                success_state = True\n                if c_best <= c_min * 1.01:\n                    break\n\n        if success_state and extracted_path:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int=20) -> List[Tuple[float, ...]]:\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed)-3)\n            j = random.randint(i+2, len(smoothed)-1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 780.3453,
    "time_improvement": -2404.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 585.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0770920991897583,
            "num_nodes_avg": 1585.9,
            "path_length_avg": 149.16292550355192,
            "smoothness_avg": 0.022852474649559435,
            "success_improvement": 0.0,
            "time_improvement": -4190.634242242927,
            "length_improvement": 18.241436893692462,
            "smoothness_improvement": 257.6908532085815,
            "objective_score": -1252.2535310280966
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 1.5311737775802612,
            "num_nodes_avg": 2784.7,
            "path_length_avg": 223.26793488218604,
            "smoothness_avg": 0.038454596709315794,
            "success_improvement": -9.999999999999998,
            "time_improvement": -828.3038348892735,
            "length_improvement": 25.466736925142758,
            "smoothness_improvement": 889.4644710571546,
            "objective_score": -288.9504807264677
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 1.1427916049957276,
            "num_nodes_avg": 2398.5,
            "path_length_avg": 113.52957395677304,
            "smoothness_avg": 0.05560802635874482,
            "success_improvement": -30.000000000000004,
            "time_improvement": -2192.627856209476,
            "length_improvement": 24.5990626752817,
            "smoothness_improvement": 607.3299907256892,
            "objective_score": -799.831894374158
        }
    ],
    "success_rate": 0.8666666666666666
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm is a refined bidirectional RRT*-inspired planner that combines the graph exploration and rewiring benefits of RRG with KD-tree accelerated nearest-neighbor search, adaptive informed ellipsoidal sampling, collision caching, incremental connection attempts, and aggressive pruning. It maintains two balanced trees grown alternately from start and goal and dynamically adjusts neighbor radius for rewiring. It applies repeated shortcut smoothing on discovered paths for improved smoothness and length reduction, while leveraging efficient collision checking to speed up planning. The planner aims at minimizing path length, enhancing success rate, and reducing planning time in both 2D and 3D cluttered spaces.",
    "planning_mechanism": "The planner grows two trees grown alternately from start and goal, sampling adaptively inside an informed ellipsoidal subset biased by the current best path cost. KD-tree accelerated neighbor searches quickly find near nodes for incremental rewiring and path improvement. Collision checks are cached for efficiency. When nodes from opposite trees are near enough, incremental connection attempts link and merge the trees. Periodic pruning removes dead-end and non-promising nodes to boost performance. Finally, repeated shortcut smoothing optimizes the path for smoothness and minimal length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Parent node\n        self.cost = cost                # Cost from root/start to this node\n        self.children = []             # List of children\n        self.valid = True              # Validity flag for pruning or collision\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update costs of descendants\n        def update_subtree_costs(node: 'Node'):\n            for c in node.children:\n                c.cost = node.cost + self._dist(node.position, c.position)\n                update_subtree_costs(c)\n        update_subtree_costs(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio*(to_pos[d]-from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            # Goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # KD-tree substitute\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff*diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balanced tree expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge paths according to tree expanded first\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed = prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            # Final smoothing of extracted path\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.09917,
    "time_improvement": 57.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1667.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008378410339355468,
            "num_nodes_avg": 71.1,
            "path_length_avg": 159.56674529009743,
            "smoothness_avg": 0.048735754695091886,
            "success_improvement": 0.0,
            "time_improvement": 66.62430787056823,
            "length_improvement": 12.538938409612532,
            "smoothness_improvement": 662.8203923633984,
            "objective_score": 25.809182004909967
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02695586681365967,
            "num_nodes_avg": 219.9,
            "path_length_avg": 230.86123561249104,
            "smoothness_avg": 0.11261887917233264,
            "success_improvement": 0.0,
            "time_improvement": 83.65748231697816,
            "length_improvement": 22.93187458032387,
            "smoothness_improvement": 2797.7648772040493,
            "objective_score": 43.67244399717847
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0388695240020752,
            "num_nodes_avg": 220.6,
            "path_length_avg": 124.14041333040817,
            "smoothness_avg": 0.12891746570135657,
            "success_improvement": 0.0,
            "time_improvement": 22.02134396577618,
            "length_improvement": 17.55184839718756,
            "smoothness_improvement": 1539.8206480237714,
            "objective_score": 17.81587610928922
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges bidirectional informed RRT* with adaptive step sizing, dynamic rewire radius, lazy collision checking, incremental and batch path smoothing, and aggressive pruning strategies. It balances exploration and exploitation by alternating tree expansions, sampling within an informed ellipsoidal subset refined by the current best solution cost, and shrinkage of rewire neighborhoods. The planner incorporates robust collision checking at nodes and edges, dynamically adjusts step sizes near obstacles to handle narrow passages, continuously rewires neighbors to optimize path cost, and applies both incremental and periodic shortcut smoothing to enhance path quality and smoothness. Pruning removes unpromising nodes early to improve efficiency and success rate. Early stopping is triggered by reaching near-optimal solutions, thus reducing search time.",
    "planning_mechanism": "The planner initializes two bidirectional trees from start and goal, samples points primarily inside an informed ellipsoid that shrinks with better path costs. Each iteration alternates tree expansions: samples a point, selects nearest node, computes adaptive step toward the sample, and validates node and edge collisions. It adds valid nodes, rewires neighbor nodes within a dynamically decreasing radius, and attempts to connect the two trees when close. Pruning of costly nodes occurs periodically. Incremental shortcut smoothing refines the path on improvements, with heavier smoothing at termination. The process stops early on sufficiently optimal paths or max iterations, returning a high-quality, feasible, and smooth path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []             # List of child nodes\n        self.valid = True               # Flag for pruning and collision\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 initial_rewire_radius: float=20.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.initial_rewire_radius = initial_rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle boxes\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start_position, goal_position)\n        if c_min == 0:\n            return PlannerResult(False, [], nodes, edges)\n\n        best_cost = float(\"inf\")\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n        a1 = np.array(goal_position) - np.array(start_position)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 < 1e-10:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1]*(dim-1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _attempt in range(100):  # Limit attempts for valid sampling\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback: uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            samples = max(10, int(dist * 5))\n            for i in range(1, samples + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / samples) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire_radius(n_nodes):\n            # Shrinking rewire radius to balance exploration and exploitation\n            if n_nodes <= 1:\n                return self.initial_rewire_radius\n            return min(self.initial_rewire_radius,\n                       self.initial_rewire_radius * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def near_nodes(tree_nodes, position, radius):\n            return [node for node in tree_nodes if distance(node.position, position) <= radius]\n\n        def rewire(tree_nodes, new_node):\n            radius = rewire_radius(len(tree_nodes))\n            neighbors = near_nodes(tree_nodes, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor.parent is None:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                heuristic = distance(neighbor.position, goal_position)\n                if tentative_cost + heuristic >= best_cost:\n                    continue\n                if tentative_cost < neighbor.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.cost = tentative_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicate connection node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_smoothing(path, iterations=40):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune(tree_nodes):\n            retained = []\n            for node in tree_nodes:\n                heuristic = distance(node.position, goal_position)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    node.valid = False\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n            return retained\n\n        smoothing_interval = 50\n        pruning_interval = 150\n\n        for iteration in range(self.max_iter):\n            # Alternate growth trees to balance expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal_position)\n            if tentative_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect opposite tree if close enough\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    extracted_path = extract_path(new_node, other_nearest)\n                    success_state = True\n\n                    # Incremental smoothing on improvement every smoothing_interval iterations\n                    if iteration % smoothing_interval == 0:\n                        extracted_path = shortcut_smoothing(extracted_path, iterations=20)\n\n            # Periodic pruning to discard nodes unlikely to improve solution\n            if success_state and iteration > 0 and iteration % pruning_interval == 0:\n                tree_start = prune(tree_start)\n                tree_goal = prune(tree_goal)\n\n            # Early stop near-optimal solution\n            if success_state and best_cost <= c_min * 1.05:\n                break\n\n        # Final smoothing of best path\n        if success_state and extracted_path:\n            extracted_path = shortcut_smoothing(extracted_path, iterations=50)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 755.82757,
    "time_improvement": -2491.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 979.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.131708288192749,
            "num_nodes_avg": 1830.1,
            "path_length_avg": 161.57713682112697,
            "smoothness_avg": 0.012797547600505577,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4408.199751165816,
            "length_improvement": 11.43701095476283,
            "smoothness_improvement": 100.30941026732624,
            "objective_score": -1369.6709761074555
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.4733556032180786,
            "num_nodes_avg": 2990.2,
            "path_length_avg": 237.7932334578079,
            "smoothness_avg": 0.0727571213047198,
            "success_improvement": 0.0,
            "time_improvement": -793.2504439727109,
            "length_improvement": 20.617774173062177,
            "smoothness_improvement": 1772.0931360066966,
            "objective_score": -224.99111267716734
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.1819845676422118,
            "num_nodes_avg": 2611.2,
            "path_length_avg": 126.19165066843186,
            "smoothness_avg": 0.09148016404302269,
            "success_improvement": 0.0,
            "time_improvement": -2271.255383343824,
            "length_improvement": 16.18951422669788,
            "smoothness_improvement": 1063.6209342639274,
            "objective_score": -672.820607486488
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* (Rapidly-exploring Random Tree Star) planner that grows two trees simultaneously from start and goal configurations and attempts to connect them via rewiring to improve path quality. It integrates goal biasing, informed sampling within an ellipsoidal heuristic for faster convergence, and local rewiring to optimize the path cost and smoothness progressively. Collision checks are enforced for nodes and edges, and bounded sampling prevents exploration outside the map. The algorithm balances exploration and exploitation to achieve improved efficiency, robustness, and final path quality.",
    "planning_mechanism": "The planner alternately expands the start and goal trees by sampling configurations using a goal-biased informed sampler that focuses exploration on an ellipsoidal region between start and goal when a tentative solution exists. It extends nodes towards these samples using fixed step sizes, adds new nodes only if they are collision-free, and performs local rewiring within a radius to reduce path costs and smooth the solution. Trees are connected when close enough without obstacles in between, and the final path is extracted by merging the trees from start to goal.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def path(self):\n        node, p = self, []\n        while node:\n            p.append(node.position)\n            node = node.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        start_tree: List[Node] = [Node(start_position)]\n        goal_tree: List[Node] = [Node(goal_position)]\n        nodes: List[Node] = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        # Track best solution and goal node reached from start tree\n        best_cost = math.inf\n        connection_node_start = None\n        connection_node_goal = None\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample_in_ellipsoid():\n            # Informed sampling within ellipsoid when a solution found, else uniform random\n            if best_cost == math.inf:\n                # No solution yet: uniform random in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                c_min = math.dist(start_position, goal_position)\n                if best_cost < c_min:\n                    # Numerical stability guard\n                    c_max = c_min + 1e-6\n                else:\n                    c_max = best_cost\n\n                # Ellipsoid parameters\n                center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n\n                # Unit vector from start to goal\n                line_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n                length = math.dist(start_position, goal_position)\n                if length == 0:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                e_axis = tuple(v / length for v in line_vec)\n\n                # Radii of ellipsoid: major axis = best cost / 2, minor axes = sqrt(best_cost^2 - c_min^2)/2\n                r1 = c_max / 2\n                r2 = math.sqrt(abs(c_max**2 - c_min**2)) / 2 if c_max > c_min else 0.0\n\n                # Sample random point in unit n-ball\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x**2 for x in sample))\n                    if norm <= 1 and norm > 0:\n                        unit_ball = [x / norm for x in sample]\n                        break\n\n                # Scale by ellipsoid radii\n                scaled = [0.0]*dim\n                scaled[0] = unit_ball[0] * r1\n                for i in range(1, dim):\n                    scaled[i] = unit_ball[i] * r2\n\n                # Rotating scaled point to align with major axis e_axis\n                # Create rotation matrix via Gram-Schmidt for 2D and 3D\n                # For 2D: just rotate\n                if dim == 2:\n                    # Rotation matrix: first col = e_axis, second perpendicular\n                    ex, ey = e_axis\n                    perp = (-ey, ex)\n                    point = tuple(center[d] + scaled[0]*ex + scaled[1]*perp[d] for d in range(dim))\n                elif dim == 3:\n                    # Build orthonormal basis with e_axis as x-axis\n                    ex = list(e_axis)\n                    # Find a vector not parallel to ex for y-axis\n                    if abs(ex[0]) < 0.9:\n                        temp = [1,0,0]\n                    else:\n                        temp = [0,1,0]\n                    # y-axis\n                    ey = [temp[i] - sum(temp[j]*ex[j] for j in range(dim))*ex[i] for i in range(dim)]\n                    ey_norm = math.sqrt(sum(x**2 for x in ey))\n                    if ey_norm == 0:\n                        # Degenerate case: fallback uniform sample\n                        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    ey = [x/ey_norm for x in ey]\n                    # z-axis = cross product\n                    ez = [ex[1]*ey[2] - ex[2]*ey[1],\n                          ex[2]*ey[0] - ex[0]*ey[2],\n                          ex[0]*ey[1] - ex[1]*ey[0]]\n                    point = [center[d] + scaled[0]*ex[d] + scaled[1]*ey[d] + scaled[2]*ez[d] for d in range(dim)]\n                    point = tuple(point)\n                else:\n                    # Higher dims fallback uniform\n                    point = tuple(center[d] + scaled[d] for d in range(dim))\n\n                # Clamp inside bounds to avoid overshoot\n                clamped = tuple(min(max(point[d],0), bounds[d]) for d in range(dim))\n                return clamped\n\n        def get_nearby_nodes(tree, new_node, radius):\n            return [node for node in tree if node.position and node.distance(new_node) <= radius]\n\n        def can_connect(pos_a, pos_b):\n            if not in_bounds(pos_b):\n                return False\n            if self._is_in_obstacle(pos_b, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d):\n                return False\n            return True\n\n        # Core planning loop\n        for itr in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Sample selection: goal biasing and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = sample_in_ellipsoid()\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if not can_connect(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewiring step for path quality improvement\n                neighbors = get_nearby_nodes(tree_a, new_node, self.rewire_radius)\n                for neighbor in neighbors:\n                    if neighbor is new_node.parent:\n                        continue\n                    potential_cost = new_node.cost + new_node.distance(neighbor)\n                    if potential_cost < neighbor.cost:\n                        # Check edge collision before rewiring\n                        if can_connect(new_node.position, neighbor.position):\n                            # Rewire neighbor\n                            if neighbor.parent:\n                                try:\n                                    neighbor.parent.children.remove(neighbor)\n                                except ValueError:\n                                    pass\n                            neighbor.parent = new_node\n                            neighbor.cost = potential_cost\n                            new_node.add_child(neighbor)\n\n                # Attempt connecting tree_a's new_node and tree_b\n                nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_to_b = math.dist(new_pos, nearest_b.position)\n                if dist_to_b <= self.step_size:\n                    if can_connect(new_pos, nearest_b.position):\n                        # Create bridging node from new_node to nearest_b.position in tree_a\n                        conn_node = Node(nearest_b.position, parent=new_node, cost=new_node.cost + dist_to_b)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n\n                        # Path cost from start to goal candidate\n                        start_root_node = conn_node if tree_a is start_tree else nearest_b\n                        goal_root_node = nearest_b if tree_b is goal_tree else conn_node\n\n                        total_cost = start_root_node.cost + goal_root_node.cost\n\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            connection_node_start = conn_node if tree_a is start_tree else nearest_b\n                            connection_node_goal = nearest_b if tree_b is goal_tree else conn_node\n\n            if best_cost < math.inf:\n                # Early termination if desired: can comment out to run full iterations\n                break\n\n        success_state = best_cost < math.inf and connection_node_start is not None and connection_node_goal is not None\n        extracted_path: List[Tuple[float, ...]] = []\n\n        if success_state:\n            # Extract and merge paths from the connection nodes\n            path_start = []\n            node = connection_node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = connection_node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            extracted_path = path_start + path_goal[1:]  # Avoid duplicate connection node position\n\n            # Optional smoothing pass: shortcutting using collision checks to reduce path points\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, in_bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, in_bounds_func):\n        # Iteratively try to shortcut path by bypassing intermediate points\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if in_bounds_func(path[next_idx]) and not self._is_edge_in_obstacle(path[idx], path[next_idx], obstacles, is_3d):\n                    break\n                next_idx -= 1\n            new_path.append(path[next_idx])\n            idx = next_idx\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.33973,
    "time_improvement": 63.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1868.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011190104484558105,
            "num_nodes_avg": 97.8,
            "path_length_avg": 161.1620230922186,
            "smoothness_avg": 0.05472672809917546,
            "success_improvement": 0.0,
            "time_improvement": 55.42382539818218,
            "length_improvement": 11.664541367475485,
            "smoothness_improvement": 756.5921357442793,
            "objective_score": 22.74301657167115
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020419549942016602,
            "num_nodes_avg": 254.8,
            "path_length_avg": 235.80324501747978,
            "smoothness_avg": 0.1275134196451924,
            "success_improvement": 0.0,
            "time_improvement": 87.6202513421809,
            "length_improvement": 21.282089593085054,
            "smoothness_improvement": 3181.0121316746,
            "objective_score": 46.447553979644276
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0274456262588501,
            "num_nodes_avg": 313.9,
            "path_length_avg": 127.84138573400858,
            "smoothness_avg": 0.13880540213502912,
            "success_improvement": 0.0,
            "time_improvement": 44.93956114388044,
            "length_improvement": 15.093838748083796,
            "smoothness_improvement": 1665.5944696085385,
            "objective_score": 24.828608440823583
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid adaptive informed bidirectional RRT* variant that leverages dynamic adaptive sampling control, focused heuristic-driven sampling within an evolving ellipsoidal informed set, and efficient lazy collision checking for nodes and edges. It incorporates incremental rewiring with selective pruning based on heuristic cost thresholds, dynamic step size adjustment near obstacles, and adaptive smoothing of paths post-planning. The approach balances exploration and exploitation effectively to accelerate convergence, increase path quality, and improve success rates in cluttered 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal with heuristic-guided ellipsoidal informed sampling refined progressively by the best path cost found. It dynamically adjusts step sizes near obstacles for better feasibility and collision avoidance. Nodes are rewired within a cost radius to optimize path cost while pruning suboptimal branches to reduce computational overhead. Attempts to connect the two trees with lazy collision checking are performed frequently. Upon successful connection, an adaptive shortcut smoothing routine enhances the final path's smoothness and reduces length, giving efficient, high-quality paths quickly.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, rewire_radius: float=25.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def heuristic(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def compute_informed_bounds():\n            x_center = np.array([(s + g)/2 for s,g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return x_center, np.eye(dim)\n            a1 = diff / norm_diff\n\n            # Create rotation matrix C via SVD to align x-axis with vector a1\n            id1 = np.zeros(dim)\n            id1[0] = 1.0\n            M = np.outer(a1, id1)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best/2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            return x_center, C, L\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            x_center, C, L = compute_informed_bounds()\n            for _ in range(100):\n                # Sample unit ball surface with random radius^(1/dim)\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            # fallback uniform\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step size when near obstacle but clamp minimum step\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def add_node(tree: List[Node], parent: Node, pos: Tuple[float, ...], cost: float) -> Node:\n            node = Node(pos, parent, cost)\n            parent.add_child(node)\n            tree.append(node)\n            nodes.append(node)\n            edges.append((parent, node))\n            return node\n\n        def rewire(new_node: Node, tree: List[Node]):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + math.dist(neighbor.position, goal_position) >= c_best:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if potential_cost < neighbor.cost:\n                        neighbor.update_parent(new_node, potential_cost)\n                        # Update edges list\n                        for idx, (p, c) in enumerate(edges):\n                            if c == neighbor:\n                                edges[idx] = (new_node, neighbor)\n                                break\n\n        def prune_nodes(tree: List[Node]):\n            remove_candidates = []\n            for node in tree:\n                if node in (start_root, goal_root):\n                    continue\n                est_total_cost = node.cost + math.dist(node.position, goal_position)\n                if est_total_cost > c_best * 1.05:  # small tolerance margin\n                    remove_candidates.append(node)\n\n            for node in remove_candidates:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[bool, Node, Node]:\n            other_near = nearest_node(other_tree, new_node.position)\n            if self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d):\n                return False, None, None\n            return True, new_node, other_near\n\n        def reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def shortcut_smooth(path: List[Tuple[float, ...]], max_iter: int=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = nearest_node(active_tree, sample)\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check (parent to new_pos)\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            # Prune unpromising expansions early based on heuristic\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = add_node(active_tree, nearest, new_pos, new_cost)\n            rewire(new_node, active_tree)\n            prune_nodes(active_tree)\n\n            connected, node_from, node_to = try_connect(new_node, other_tree)\n\n            if connected:\n                total_cost = node_from.cost + math.dist(node_from.position, node_to.position) + node_to.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    extracted_path = reconstruct_path(node_from, node_to)\n                    success_state = True\n\n                    # Swap trees after connection to continue refinement\n                    tree_a, tree_b = tree_b, tree_a\n\n            if success_state and iter_num > self.max_iter * 0.15:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_smooth(extracted_path, max_iter=75)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 625.68661,
    "time_improvement": -2121.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1478.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0332437753677368,
            "num_nodes_avg": 393.1,
            "path_length_avg": 160.8803637989501,
            "smoothness_avg": 0.03869824186248343,
            "success_improvement": 0.0,
            "time_improvement": -4015.9629028122063,
            "length_improvement": 11.818923289293059,
            "smoothness_improvement": 505.71151972509017,
            "objective_score": -1199.896528587178
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.495072078704834,
            "num_nodes_avg": 437.1,
            "path_length_avg": 238.91021492301698,
            "smoothness_avg": 0.09976668372652113,
            "success_improvement": 0.0,
            "time_improvement": -200.1470609917178,
            "length_improvement": 20.244893609446542,
            "smoothness_improvement": 2467.0686313211127,
            "objective_score": -43.659796419020466
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.1205172300338746,
            "num_nodes_avg": 558.0,
            "path_length_avg": 123.64599192503272,
            "smoothness_avg": 0.1226892470812185,
            "success_improvement": 0.0,
            "time_improvement": -2147.941797706806,
            "length_improvement": 17.880219552820606,
            "smoothness_improvement": 1460.5981668948932,
            "objective_score": -633.5035045670032
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional RRT's dual-tree growth and adaptive rewiring for path quality and convergence speed with single-tree incremental extension and goal biasing from classic RRT. It uses adaptive neighborhood rewiring, incremental attempts to connect the two trees, and refined collision checks to improve path smoothness, robustness, and planning efficiency. The planner dynamically adjusts rewiring radius, integrates both exploration and exploitation, and ensures collision-free nodes and edges, aiming for shorter, smoother paths with higher success rates and reduced computation time.",
    "planning_mechanism": "The planner grows two trees simultaneously, rooted at start and goal, alternately expanding them with goal biasing towards the opposite root to accelerate convergence. It incrementally extends each tree towards sampled points, performs adaptive rewiring around new nodes, and attempts to connect the two trees within an adaptive radius. On successful connection, it extracts a smooth, optimized path. The connection attempts are collision-checked for both nodes and edges, and rewiring dynamically refines the path quality during search.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, rewire_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # base factor for adaptive rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def get_rewire_radius(tree_size):\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            # Adaptive radius shrinks as tree grows, remains above step_size*1.5\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def extend(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        # Initialize trees and data\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Alternate growing start and goal trees\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                # Sampling with goal biasing towards opposite root to accelerate connection\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = extend(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Attempt incremental connection from opposite tree within rewiring radius\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node is not None:\n                    # Link the two trees by connecting new_node and best_connect_node\n                    # Attach best_connect_node as child of new_node to unify paths directionally\n                    conn_pos = best_connect_node.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire around new connecting node for further optimization\n                    rewire(tree_a, conn_node)\n\n                    # Extract path from start tree root to conn_node\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    # Extract path from goal tree root to best_connect_node\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    # Merge and finalize path (avoid duplicate connecting node)\n                    extracted_path = path_start + path_goal[1:]\n                    success = True\n                    break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.52794,
    "time_improvement": 65.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 77.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.014651799201965332,
            "num_nodes_avg": 146.2,
            "path_length_avg": 190.64801818491756,
            "smoothness_avg": 0.011628860455521643,
            "success_improvement": -9.999999999999998,
            "time_improvement": 41.63404279568054,
            "length_improvement": -4.497199778324836,
            "smoothness_improvement": 82.01691860357275,
            "objective_score": -37.999142523942936
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021097254753112794,
            "num_nodes_avg": 292.1,
            "path_length_avg": 307.3481346225392,
            "smoothness_avg": 0.006738894083969708,
            "success_improvement": 0.0,
            "time_improvement": 87.20937964082658,
            "length_improvement": -2.601653862549766,
            "smoothness_improvement": 73.39659860975604,
            "objective_score": 26.0094661127868
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0170501708984375,
            "num_nodes_avg": 233.7,
            "path_length_avg": 154.6829914042549,
            "smoothness_avg": 0.013864129032996206,
            "success_improvement": 0.0,
            "time_improvement": 65.79455380665306,
            "length_improvement": -2.7330776781827977,
            "smoothness_improvement": 76.35069795615588,
            "objective_score": 19.573504096140137
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed ellipsoidal sampling biased by the current best solution cost to guide exploration efficiently. It incorporates adaptive step sizing near obstacles to improve safety during expansions, continuous rewiring within a dynamic radius for cost optimization, pruning of nodes unlikely to yield better paths, and bidirectional tree connection attempts to quickly discover feasible trajectories. Post-processing uses iterative shortcut smoothing that respects collision constraints to enhance path smoothness and reduce length, resulting in improved planning efficiency, path quality, and success rate.",
    "planning_mechanism": "The planner alternately expands two trees rooted at start and goal positions by sampling points within an ellipsoidal informed set once a feasible path exists. Each sampled point is connected via safe, adaptively-sized steps considering obstacle proximity. Neighboring nodes within a rewiring radius are re-evaluated for better parent connections to optimize costs. Nodes that cannot improve the solution are pruned to focus computational effort. The planner tries to connect the two trees when nodes are close. Once a path is found, an iterative shortcut smoothing is applied to improve path quality while ensuring collision-free validity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size                # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...]\n        goal_position = map.goal         # Tuple[float, ...]\n        obstacles = map.obstacles        # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-12:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbors(tree, node):\n            radius = min(self.rewire_radius, 50.0 * (math.log(len(tree)+1) / (len(tree)+1))**(1/dim))\n            return [nd for nd in tree if math.dist(nd.position, node.position) <= radius]\n\n        def rewire(new_node, tree):\n            for neighbor in neighbors(tree, new_node):\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + math.dist(neighbor.position, goal_position) >= c_best:\n                    continue\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges\n                    for i, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges[i] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node in (start_root, goal_root):\n                    continue\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def connect_trees(node_new, tree_other):\n            nearest_other = nearest(tree_other, node_new.position)\n            if not self._is_edge_in_obstacle(node_new.position, nearest_other.position, obstacles, is_3d):\n                total_cost = node_new.cost + math.dist(node_new.position, nearest_other.position) + nearest_other.cost\n                return total_cost, nearest_other\n            return float('inf'), None\n\n        def backtrack_path(node_a, node_b) -> list:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b:\n                path_b.reverse()\n            return path_a + path_b\n\n        def smooth_path(path, max_iter=60):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if (iter_num % 2 == 0) else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest_node = nearest(active_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            # Heuristic pruning\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            total_cost, connecting_node = connect_trees(new_node, other_tree)\n            if total_cost < c_best:\n                c_best = total_cost\n                if active_tree is tree_a:\n                    extracted_path = backtrack_path(new_node, connecting_node)\n                else:\n                    extracted_path = backtrack_path(connecting_node, new_node)\n                success_state = True\n\n            # Early stop if path found and iterated sufficiently to refine\n            if success_state and iter_num > int(self.max_iter * 0.15):\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = smooth_path(extracted_path, max_iter=80)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.45856,
    "time_improvement": -130.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1353.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10019102096557617,
            "num_nodes_avg": 397.2,
            "path_length_avg": 169.02609650410264,
            "smoothness_avg": 0.020410635067261866,
            "success_improvement": 0.0,
            "time_improvement": -299.114454226857,
            "length_improvement": 7.354118116204196,
            "smoothness_improvement": 219.47076120610146,
            "objective_score": -87.16615883878575
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06587653160095215,
            "num_nodes_avg": 434.8,
            "path_length_avg": 236.23318488013552,
            "smoothness_avg": 0.0948845070674083,
            "success_improvement": 0.0,
            "time_improvement": 60.061073530784945,
            "length_improvement": 21.13856329179778,
            "smoothness_improvement": 2341.4467093924295,
            "objective_score": 33.95326826455719
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12576160430908204,
            "num_nodes_avg": 631.8,
            "path_length_avg": 127.65621057843518,
            "smoothness_avg": 0.12552540358739323,
            "success_improvement": 0.0,
            "time_improvement": -152.29845583410025,
            "length_improvement": 15.216823269322303,
            "smoothness_improvement": 1496.6738683101385,
            "objective_score": -35.162802754814926
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced single-tree RRT* planner with informed ellipsoidal sampling, adaptive step sizing near obstacles, dynamic rewiring, and heuristic pruning. It integrates focused sampling to accelerate convergence, continuous optimization of paths via rewiring, and iterative smoothing to produce high-quality feasible paths with reduced planning times and improved robustness.",
    "planning_mechanism": "The planner grows a single tree from the start towards the goal using informed sampling constrained within an ellipsoid defined by the current best solution length. It dynamically adjusts step sizes near obstacles to safely extend the tree, rewires the tree within a radius to improve path costs, prunes nodes unlikely to lead to improvements, and attempts early termination on convergence. Finally, the obtained path undergoes iterative shortcut smoothing to further enhance smoothness and path length while ensuring collision-free validity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_root = Node(start_position, None, 0.0)\n        nodes = [start_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def node_heuristic_cost(node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            I = np.eye(dim)\n            b = np.zeros(dim)\n            b[0] = 1.0\n            if dim == 3:\n                v = np.cross(b, a1)\n            else:\n                v = np.array([b[1] - a1[1], a1[0] - b[0]])\n            s = np.linalg.norm(v)\n            c = np.dot(b, a1)\n            if s < 1e-12:\n                R = np.eye(dim)\n            else:\n                if dim == 3:\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                else:\n                    vx = np.array([[0, -v[1]],\n                                   [v[0], 0]])\n                R = I + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n\n            r1 = c_best / 2.0\n            r2_val = max(0.0, (c_best ** 2 - c_min ** 2)) ** 0.5 / 2.0\n            L_diag = [r1] + [r2_val] * (dim - 1)\n            L = np.diag(L_diag)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-12:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = x_center + R @ L @ x_ball\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            steps_to_check = max(4, int(dist_ * 1.2))\n            reduction_factor = 1.0\n            for i in range(1, steps_to_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_to_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction_factor = 0.3\n                    break\n            return max(self.base_step * reduction_factor, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbors(new_node, tree):\n            return [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n\n        def rewire(new_node, tree):\n            for neighbor in neighbors(new_node, tree):\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        for i, (p, c) in enumerate(edges):\n                            if c == neighbor:\n                                edges[i] = (new_node, neighbor)\n                                break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node is start_root:\n                    continue\n                heuristic = node.cost + math.dist(node.position, goal_position)\n                if heuristic >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n\n        def backtrack_path(node):\n            return node.path_from_root()\n\n        def smooth_path(path, max_iterations=60):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree = [start_root]\n\n        for iter_num in range(self.max_iter):\n            sample = informed_sample()\n            nearest_node = nearest(tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, tree)\n            prune(tree)\n\n            # Attempt connection to goal\n            if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, goal_position)\n                if total_cost < c_best:\n                    c_best = total_cost\n                    goal_node = Node(goal_position, new_node, total_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = backtrack_path(goal_node)\n                    success_state = True\n\n            if success_state and iter_num > int(self.max_iter * 0.12):\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = smooth_path(extracted_path, max_iterations=80)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 62.90124,
    "time_improvement": -191.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1624.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.14448068141937256,
            "num_nodes_avg": 417.1,
            "path_length_avg": 174.72544430154161,
            "smoothness_avg": 0.06568001227073955,
            "success_improvement": 0.0,
            "time_improvement": -475.5438736454208,
            "length_improvement": 4.230215276482717,
            "smoothness_improvement": 928.034818466535,
            "objective_score": -137.176944945997
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.17148849964141846,
            "num_nodes_avg": 671.4,
            "path_length_avg": 232.28250230915933,
            "smoothness_avg": 0.10768388932360284,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3.968232859964802,
            "length_improvement": 22.45741484808239,
            "smoothness_improvement": 2670.784033866719,
            "objective_score": -33.345066719039366
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09644808769226074,
            "num_nodes_avg": 401.3,
            "path_length_avg": 124.27004095807658,
            "smoothness_avg": 0.1080565419985458,
            "success_improvement": 0.0,
            "time_improvement": -93.4907218033317,
            "length_improvement": 17.46575589909451,
            "smoothness_improvement": 1274.4712383172348,
            "objective_score": -18.18170916959443
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a bidirectional informed RRT* style planner with simplified adaptive sampling, collision checking, rewiring, and path smoothing to efficiently find high-quality paths. It balances exploration and exploitation inside an ellipsoidal informed subset around the current best path cost, employs collision-aware node and edge validations to ensure feasibility and robustness, and refines the solution with rewiring and shortcutting to minimize path length and unnecessary turns.",
    "planning_mechanism": "The planner initializes with start and goal nodes, then iteratively samples points within an informed ellipsoid defined by the current best path cost. It grows two trees bidirectionally towards these samples using an adaptive step size that respects obstacle proximity and bounds. Nodes and edges are collision-checked before addition. Nearby nodes are rewired to improve path costs. The trees try to connect when close enough to form a feasible path, which is then smoothed by shortcutting. The process repeats until success or iteration limit, returning the optimized path along with explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        c_best = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path = []\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n\n            # Create rotation matrix C to align x-axis with a1\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim -1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = 0.0 if c_best**2 - c_min**2 < 0 else math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            steps = max(3, int(d))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[j] + (to_pos[j] - from_pos[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.25, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = sum((node.position[d] - pos[d])**2 for d in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_pos)\n\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            neighbors = near_nodes(active_tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes with costs exceeding best path cost in active tree\n            to_remove = []\n            for node in active_tree:\n                if node is start_root or node is goal_root or node is new_node:\n                    continue\n                if node.cost + dist(node.position, goal_pos) >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Attempt connection to other tree\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_start = new_node.path_from_root()\n                        path_goal = other_nearest.path_from_root()\n                        best_path = path_start + path_goal[::-1][1:]\n                        success = True\n\n            if success:\n                break\n\n        def path_shortcut(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = path_shortcut(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.63367,
    "time_improvement": -37.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1558.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05051796436309815,
            "num_nodes_avg": 271.3,
            "path_length_avg": 161.6651415840813,
            "smoothness_avg": 0.044095160834522154,
            "success_improvement": -9.999999999999998,
            "time_improvement": -101.2400869969893,
            "length_improvement": 11.388774149662845,
            "smoothness_improvement": 590.1850212346226,
            "objective_score": -75.1433461629911
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07712218761444092,
            "num_nodes_avg": 437.4,
            "path_length_avg": 236.53986249586342,
            "smoothness_avg": 0.09541272410526459,
            "success_improvement": 0.0,
            "time_improvement": 53.24317620520197,
            "length_improvement": 21.03618547644208,
            "smoothness_improvement": 2355.038114235826,
            "objective_score": 31.955380528028137
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0808384895324707,
            "num_nodes_avg": 365.9,
            "path_length_avg": 125.75606212823922,
            "smoothness_avg": 0.14377095677032287,
            "success_improvement": 0.0,
            "time_improvement": -62.17530138115893,
            "length_improvement": 16.478811394596494,
            "smoothness_improvement": 1728.7559580503575,
            "objective_score": -6.713048345176592
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This implementation presents an enhanced bidirectional informed RRT* planner with adaptive ellipsoidal sampling, efficient KD-tree based nearest and radius neighbor searches, collision caching, incremental rewiring, dynamic pruning of non-promising nodes, and iterative shortcut smoothing. These combined heuristics aim to minimize path length, reduce planning time, and improve robustness and smoothness in both 2D and 3D spaces. The planner carefully balances exploration and exploitation by alternating tree growth, focusing sampling within an informed ellipsoid based on the best current path, and pruning nodes unlikely to yield better solutions. Efficient data structures and collision caching optimize repeated geometric queries, while smoothing refines the final extracted path.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal alternatively, sampling points focused in an adaptive ellipsoid aligned with the current best path estimate. It uses KD-tree accelerated nearest neighbor and range queries for rewiring. Each new candidate node undergoes strict collision and edge feasibility checks before insertion. Incremental rewiring improves path costs locally. When trees connect, the path is merged and shortcut smoothing applied for enhanced smoothness. Periodic pruning removes nodes that cannot improve the solution, enabling faster convergence and reduced memory usage. Collision checks are cached to avoid recomputation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # clamp inside bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # With chance, sample goal directly for bias\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal):\n                    return goal\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            c1 = np.array(goal) - np.array(start)\n            a1 = c1 / c_min if c_min > 0 else np.eye(dim)[0]\n\n            id_mat = np.eye(dim)\n            v = a1 - id_mat[0]\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            term = r1 * r1 - (c_min / 2.0) ** 2\n            r_others = math.sqrt(term) if term > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback random sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree to extend\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -32.37329,
    "time_improvement": 75.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1327.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007973003387451171,
            "num_nodes_avg": 64.5,
            "path_length_avg": 158.96560648359613,
            "smoothness_avg": 0.036767044759826374,
            "success_improvement": 0.0,
            "time_improvement": 68.23926071554074,
            "length_improvement": 12.868432115109856,
            "smoothness_improvement": 475.48409140687687,
            "objective_score": 25.422885094718573
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021977162361145018,
            "num_nodes_avg": 216.2,
            "path_length_avg": 234.28490089341858,
            "smoothness_avg": 0.08598966024461106,
            "success_improvement": 0.0,
            "time_improvement": 86.67591856746924,
            "length_improvement": 21.788956564809112,
            "smoothness_improvement": 2112.575893942651,
            "objective_score": 40.923446352915846
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015529942512512208,
            "num_nodes_avg": 151.6,
            "path_length_avg": 126.8496145105463,
            "smoothness_avg": 0.1174493013310511,
            "success_improvement": 0.0,
            "time_improvement": 68.8443819031639,
            "length_improvement": 15.75252597163677,
            "smoothness_improvement": 1393.9464437253262,
            "objective_score": 30.773551983903157
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm proposes a Anytime Informed RRT* Planner that incrementally builds a tree biased towards the informed ellipsoidal region defined by the current best path cost. It integrates rewiring to continually improve path optimality and includes a dynamic step-size adaptation to accelerate convergence while maintaining robustness. Post-planning, an adaptive shortcut smoothing enhances path smoothness without sacrificing feasibility. This approach combines the fast exploration of RRT*, heuristic-guided sampling, and iterative path refinement to optimize planning efficiency, path quality, and success rate.",
    "planning_mechanism": "The planner begins with an initial tree rooted at the start node. It samples points biased within an ellipsoid shaped by the start, goal, and best known path cost, steering toward sampled points with an adaptive step size. Upon adding nodes, it rewires the tree locally to reduce path costs, effectively improving path quality continuously. When a path to the goal is found, the cost updates the informed sampling ellipsoid, focusing the search in a smaller promising region. After reaching max iterations or time budget, the planner reconstructs the lowest-cost path and applies iterative shortcut smoothing to reduce unnecessary deviations, resulting in a smooth, feasible, and near-optimal path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample the goal directly to bias tree growth\n        self.shortcut_trials = shortcut_trials      # Shortcut smoothing attempts\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  \n        start_position = map.start         \n        goal_position = map.goal           \n        obstacles = map.obstacles          \n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Informed ellipsoid sampling around start-goal for Anytime RRT*\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in whole space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                # No better path possible, uniform sampling fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n            dx = [goal_position[d] - start_position[d] for d in range(dim)]\n            length = dist(start_position, goal_position)\n            if length == 0:\n                return center\n\n            unit_vec = tuple(x / length for x in dx)\n\n            if not is_3d:\n                # 2D\n                def ortho_basis_2d(vec):\n                    return (-vec[1], vec[0])\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y <= 1:\n                        break\n                sample_local = (x * a1, y * a2)\n                orth = ortho_basis_2d(unit_vec)\n                mapped = (\n                    center[0] + unit_vec[0] * sample_local[0] + orth[0] * sample_local[1],\n                    center[1] + unit_vec[1] * sample_local[0] + orth[1] * sample_local[1]\n                )\n                return tuple(max(0, min(mapped[d], bounds[d])) for d in range(dim))\n\n            else:\n                # 3D\n                import numpy as np\n                def ortho_basis_3d(vec):\n                    v = np.array(vec)\n                    if abs(v[0]) < 1e-6 and abs(v[1]) < 1e-6:\n                        ortho1 = np.array([0, 1, 0])\n                    else:\n                        ortho1 = np.array([-v[1], v[0], 0])\n                    ortho1 /= np.linalg.norm(ortho1)\n                    ortho2 = np.cross(v, ortho1)\n                    ortho2 /= np.linalg.norm(ortho2)\n                    return ortho1, ortho2\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2\n                a3 = a2\n                while True:\n                    sample = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(sample) <= 1:\n                        break\n                sample[0] *= a1\n                sample[1] *= a2\n                sample[2] *= a3\n                ex = np.array(unit_vec)\n                ey, ez = ortho_basis_3d(unit_vec)\n                R = np.column_stack((ex, ey, ez))\n                mapped = R.dot(sample) + np.array(center)\n                clamped = tuple(max(0, min(mapped[d], bounds[d])) for d in range(dim))\n                return clamped\n\n        def steer(from_pos, to_pos, step_sz):\n            distance = dist(from_pos, to_pos)\n            if distance <= step_sz:\n                return to_pos\n            ratio = step_sz / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        # Nearest neighbor search\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        # Near nodes for rewiring in radius\n        def near(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        # Adaptive step size decreasing with iterations (optional for efficiency)\n        def adaptive_step(iteration):\n            return max(self.step_size * 0.5, self.step_size * (1 - iteration / self.max_iter))\n\n        # Shortcut smoothing on path to improve smoothness\n        def path_smoothing(path):\n            smoothed_path = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                a = smoothed_path[i]\n                b = smoothed_path[j]\n                if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        # Initialize tree with start node\n        nodes: List[Node] = [Node(start_position, parent=None, cost=0.0)]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_goal_node = None\n        c_best = float('inf')  # Best path cost found so far\n\n        for it in range(self.max_iter):\n            step_size_iter = adaptive_step(it)\n\n            # Sample random point in space with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample_pos = goal_position\n            else:\n                sample_pos = informed_sample(c_best)\n\n            if not in_bounds(sample_pos):\n                continue\n            if self._is_in_obstacle(sample_pos, obstacles, is_3d):\n                continue\n\n            # Find nearest node in tree\n            nearest_node = nearest(nodes, sample_pos)\n\n            new_pos = steer(nearest_node.position, sample_pos, step_size_iter)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n\n            # Connect new node and add edge\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes to improve costs\n            radius = min(50.0 * (math.log(len(nodes)) / len(nodes))**(1/dim), self.step_size * 10)\n            neighbor_nodes = near(nodes, new_node.position, radius)\n            for near_node in neighbor_nodes:\n                if near_node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node under new_node\n                        old_parent = near_node.parent\n                        if old_parent:\n                            try:\n                                old_parent.children.remove(near_node)\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can directly connect to goal\n            if dist(new_node.position, goal_position) <= step_size_iter:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Update best path if better\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node = goal_node\n\n        if best_goal_node is None:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Reconstruct best path from goal node\n        path = best_goal_node.path_from_root()\n\n        # Apply shortcut smoothing to improve path quality and smoothness\n        path = path_smoothing(path)\n\n        return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1686.89894,
    "time_improvement": -5659.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1513.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 2.2770472288131716,
            "num_nodes_avg": 4143.5,
            "path_length_avg": 167.614276507635,
            "smoothness_avg": 0.040135409921509844,
            "success_improvement": 0.0,
            "time_improvement": -8970.697685462195,
            "length_improvement": 8.127959027987588,
            "smoothness_improvement": 528.2063207092447,
            "objective_score": -2686.9426822295145
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.5685157775878906,
            "num_nodes_avg": 4384.1,
            "path_length_avg": 234.5250560259638,
            "smoothness_avg": 0.10410405114928145,
            "success_improvement": 0.0,
            "time_improvement": -1457.212565432312,
            "length_improvement": 21.708785869083297,
            "smoothness_improvement": 2578.672219188214,
            "objective_score": -419.9286513599359
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.3148346900939942,
            "num_nodes_avg": 5064.7,
            "path_length_avg": 120.16678901047115,
            "smoothness_avg": 0.12055646414723717,
            "success_improvement": 0.0,
            "time_improvement": -6550.103409945339,
            "length_improvement": 20.190940466833016,
            "smoothness_improvement": 1433.4693254003112,
            "objective_score": -1953.8254882632334
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT growth with informed sampling inside an adaptive ellipsoidal region, adaptive step sizing, cost-based pruning, and local rewiring to improve efficiency and path quality. The planner dynamically focuses sampling as better solutions are found, prunes nodes unlikely to produce better paths, and rewires neighbors to optimize cost. Post-processing smooths the path by shortcutting. The approach balances exploration, exploitation, and robustness to obstacles by adaptively adjusting step sizes and sampling strategy.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately sampling points informed by the current best cost and adaptively stepping towards samples with collision checking. Rewiring of neighbors improves path cost and pruning discards unpromising branches early. When trees connect within a step-size distance collision-free, the path is updated. Finally, a shortcut smoothing refines the path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float('inf')\n        best_path = []\n\n        # Distance between start and goal\n        c_min = math.dist(start, goal)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            # Sample goal with goal_sample_rate chance\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float('inf'):\n                # Uniform random sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fall back\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Check intermediate points to detect nearby obstacles\n            steps = max(5, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node under new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                # Avoid duplicate connecting point\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Swap growing direction to alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune if cannot improve best cost\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring to optimize cost locally\n            rewire(tree_a, new_node)\n\n            # Attempt connect tree_b\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success_state = True\n\n            # Early stop if good path found\n            if success_state and i % 100 == 0 and best_cost < float('inf'):\n                break\n\n        if success_state and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 20.66653,
    "time_improvement": -39.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1000.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.062411928176879884,
            "num_nodes_avg": 330.1,
            "path_length_avg": 167.17785158767057,
            "smoothness_avg": 0.018509807095481248,
            "success_improvement": -9.999999999999998,
            "time_improvement": -148.62010998091006,
            "length_improvement": 8.367170442215494,
            "smoothness_improvement": 189.71867573372768,
            "objective_score": -91.96400552716128
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06956179141998291,
            "num_nodes_avg": 503.3,
            "path_length_avg": 239.59967121352528,
            "smoothness_avg": 0.06647143366904831,
            "success_improvement": 0.0,
            "time_improvement": 57.82681320536589,
            "length_improvement": 20.01473325477588,
            "smoothness_improvement": 1610.3578657430642,
            "objective_score": 29.402779941280265
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06351680755615234,
            "num_nodes_avg": 476.6,
            "path_length_avg": 129.51948982360113,
            "smoothness_avg": 0.10209670594631756,
            "success_improvement": 0.0,
            "time_improvement": -27.425159324018466,
            "length_improvement": 13.979321914506155,
            "smoothness_improvement": 1198.6625636422293,
            "objective_score": 0.5616294039068368
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an advanced bidirectional informed RRT* planner with adaptive parameters and dynamic rewiring for improved path quality and efficiency. It incorporates ellipsoidal informed sampling, adaptive step size shrinking near obstacles, heuristic node pruning, balanced alternate tree growth, and robust path smoothing to enhance success rate, robustness, and shortened search times while ensuring collision-free paths in 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, sampling new points within an ellipsoidal informed space bounded by the current best solution cost. Each new sample is steered with adaptive step size considering obstacle proximity to ensure safe progress. Nodes that cannot improve the best current solution are pruned early. The trees attempt connection when close, creating or updating the best path. Neighborhood rewiring optimizes sub-paths continuously. Finally, the path is smoothed by shortcutting collision-free segments to produce a high-quality feasible trajectory efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        # Adaptive rewiring radius balancing exploration and rewiring cost\n        self.rewire_radius = 10.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        if c_min < 1e-12:\n            # Start and goal are effectively the same\n            return PlannerResult(success=True, path=[start], nodes=nodes, edges=edges)\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for informed sampling via SVD\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1.0] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            steps_check = max(6, int(dist_ * 2.5))\n            reduction = 1.0\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction = 0.3\n                    break\n            return max(self.base_step * reduction, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, node):\n            return [n for n in tree if n is not node and math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            neighs = neighbors(tree, new_node)\n            for near in neighs:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if near.cost - potential_cost > 1e-8:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # update edges: remove old edge and add new\n                        for i, (p, c) in enumerate(edges):\n                            if c == near:\n                                edges[i] = (new_node, near)\n                                break\n                        else:\n                            edges.append((new_node, near))\n\n        def node_heuristic(node, goal_pos):\n            return node.cost + math.dist(node.position, goal_pos)\n\n        def prune_nodes(tree, goal_pos):\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                h_cost = node_heuristic(node, goal_pos)\n                if h_cost >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n\n        def connect_trees(new_node, other_tree):\n            nonlocal c_best, best_path, success\n            near_other = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            dist_conn = math.dist(new_node.position, near_other.position)\n            if dist_conn <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, near_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + near_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = near_other.path_from_root()\n                        if path_a[-1] == path_b[-1]:\n                            combined = path_a + path_b[-2::-1]\n                        else:\n                            combined = path_a + path_b[::-1]\n                        best_path[:] = combined\n                        success = True\n\n        def smooth_path(path, max_iterations=80):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(max_iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            # Alternate tree roles for balanced expansion\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            sample = None\n            # Goal bias 10% towards opposite tree root\n            if random.random() < 0.10:\n                sample = tree_b[0].position\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal if tree_a is tree_start else start)\n            if new_cost + heuristic_remain >= c_best:\n                # Skip nodes that cannot improve best solution\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune_nodes(tree_a, goal if tree_a is tree_start else start)\n\n            # Attempt to connect trees\n            connect_trees(new_node, tree_b)\n\n            if success and itr > 150 and itr % 50 == 0:\n                # Early stopping if stable good solution found\n                break\n\n        if success and best_path:\n            best_path = smooth_path(best_path, max_iterations=100)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.53951,
    "time_improvement": -59.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1369.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07836000919342041,
            "num_nodes_avg": 327.1,
            "path_length_avg": 166.60132035833274,
            "smoothness_avg": 0.030201232220188223,
            "success_improvement": 0.0,
            "time_improvement": -212.14985136431417,
            "length_improvement": 8.683176344737511,
            "smoothness_improvement": 372.71486727140456,
            "objective_score": -60.04474580398972
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.05514779090881348,
            "num_nodes_avg": 401.2,
            "path_length_avg": 236.05978277206486,
            "smoothness_avg": 0.08622974041979233,
            "success_improvement": -9.999999999999998,
            "time_improvement": 66.56558090537187,
            "length_improvement": 21.196449906574706,
            "smoothness_improvement": 2118.7533297728255,
            "objective_score": -15.19726909820936
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06517646312713624,
            "num_nodes_avg": 375.8,
            "path_length_avg": 129.695420445783,
            "smoothness_avg": 0.13486578703122842,
            "success_improvement": 0.0,
            "time_improvement": -30.754701278227298,
            "length_improvement": 13.862477172168944,
            "smoothness_improvement": 1615.482856280332,
            "objective_score": 1.6234993323672615
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an enhanced bidirectional informed RRT* planner with adaptive ellipsoidal sampling, dynamic step sizing to maneuver near obstacles, rewiring for cost optimization, pruning of unpromising nodes, and intensive shortcut smoothing to ensure both high success rate and high-quality smooth paths efficiently. It balances exploration and exploitation inside an ellipsoidal informed sampling region defined by the current best path cost, connecting the two trees to incrementally improve path quality and computation efficiency.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal. It samples points informed by an ellipse reflecting the current best path cost to focus search. Trees are extended towards samples with dynamic step size adjusted based on obstacle proximity, ensuring collision-free nodes and edges. Nearby nodes are rewired for path cost improvement and nodes unlikely to yield better paths are pruned. The trees attempt connection when nodes are within step size proximity, updating the best path. Upon finding a path or reaching iteration limit, iterative shortcut smoothing is applied for enhanced path smoothness and quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 7.0, rewire_radius: float = 20.0, shortcut_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path = []\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-12:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n\n            # Rotation matrix via SVD to align x-axis with a1\n            unit_x = np.zeros(dim)\n            unit_x[0] = 1.0\n            M = np.outer(a1, unit_x)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            try:\n                val = math.sqrt(max(0, c_best ** 2 - c_min ** 2))\n            except:\n                val = 0.0\n            r2 = val / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-12:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if in_bounds(x_rand):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            check_pts = max(5, int(d * 1.5))\n            for i in range(1, check_pts + 1):\n                interp = tuple(from_pos[j] + (to_pos[j] - from_pos[j]) * (i / check_pts) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.2, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + dist(neighbor.position, goal_pos) >= c_best:\n                    continue\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        try:\n                            # Update edges: remove old edge to neighbor, add new edge from new_node to neighbor\n                            edges.remove((neighbor.parent, neighbor))  # neighbor.parent updated by update_parent\n                        except Exception:\n                            pass\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node in (start_root, goal_root):\n                    continue\n                heuristic = node.cost + dist(node.position, goal_pos)\n                if heuristic >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def connect_trees(node_start, tree_goal):\n            nearest_goal = nearest(tree_goal, node_start.position)\n            if dist(nearest_goal.position, node_start.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(node_start.position, nearest_goal.position, obstacles, is_3d):\n                    return nearest_goal\n            return None\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def path_shortcut(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(active_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            # Heuristic cost to goal based on tree origin\n            if active_tree is tree_start:\n                heuristic = dist(new_pos, goal_pos)\n            else:\n                heuristic = dist(new_pos, start_pos)\n\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(active_tree, new_node)\n            prune(active_tree)\n\n            conn_node = connect_trees(new_node, other_tree)\n            if conn_node:\n                total_cost = new_node.cost + dist(new_node.position, conn_node.position) + conn_node.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    if active_tree is tree_start:\n                        best_path = merge_paths(new_node, conn_node)\n                    else:\n                        best_path = merge_paths(conn_node, new_node)\n                    success = True\n\n                    # Early stopping if path found and sufficient iterations elapsed\n                    if itr > int(self.max_iter * 0.15):\n                        break\n\n        if success and best_path:\n            best_path = path_shortcut(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 119.79848,
    "time_improvement": -211.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1406.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.13527956008911132,
            "num_nodes_avg": 354.5,
            "path_length_avg": 168.39413625610433,
            "smoothness_avg": 0.04245067784690496,
            "success_improvement": -9.999999999999998,
            "time_improvement": -438.89088336135086,
            "length_improvement": 7.700505542183027,
            "smoothness_improvement": 564.4452914264492,
            "objective_score": -177.3049374428364
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.14239747524261476,
            "num_nodes_avg": 481.4,
            "path_length_avg": 237.3915212212866,
            "smoothness_avg": 0.09472180005115513,
            "success_improvement": -9.999999999999998,
            "time_improvement": 13.668765569399518,
            "length_improvement": 20.7518772802586,
            "smoothness_improvement": 2337.2601406711087,
            "objective_score": -30.062694169772875
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.15308551788330077,
            "num_nodes_avg": 476.6,
            "path_length_avg": 123.99975838886257,
            "smoothness_avg": 0.11128308188393396,
            "success_improvement": -19.999999999999996,
            "time_improvement": -207.1147190329783,
            "length_improvement": 17.645264712093567,
            "smoothness_improvement": 1315.5125875009717,
            "objective_score": -152.0277998299699
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed sampling inside an ellipsoid defined by the current best path cost, adaptive step sizing to improve obstacle navigation, and local rewiring to optimize path cost. It alternates expansions from start and goal trees, checks for collision-safe connections, prunes suboptimal nodes periodically, and performs shortcut smoothing to enhance path quality. The approach balances exploration and exploitation to efficiently find shorter, smoother, and feasible paths.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal using informed elliptical sampling once a solution is found, performing adaptive steering steps to avoid obstacles. Each new node triggers local rewiring to improve path costs. The trees attempt to connect when close and collision-free, updating the best path. Suboptimal nodes are pruned to speed convergence, and final smoothing reduces unnecessary detours.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees, nodes, edges\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float(\"inf\")\n        success = False\n        best_path = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min == 0:\n            return PlannerResult(True, [start_pos], nodes, edges)\n\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for ellipsoid sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if not success or best_cost == float(\"inf\"):\n                # Uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball *= scale\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n            # Fallback uniform\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            near = near_nodes(tree, new_node.position, self.rewire_radius)\n            for node in near:\n                if node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                if new_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            if (node.parent, node) in edges:\n                                edges.remove((node.parent, node))\n                        new_node.add_child(node)\n                        node.cost = new_cost\n                        edges.append((new_node, node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def prune_nodes(tree):\n            retained = []\n            for node in tree:\n                heuristic = math.dist(node.position, goal_pos)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        def shortcut_smoothing(path, max_trials=50):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate trees each iteration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            if not in_bounds(sample): \n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try to connect opposite tree\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, nearest_b)\n                        success = True\n\n            # Prune every 250 iterations if solution found\n            if success and iteration > 0 and iteration % 250 == 0:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early termination if path quality sufficient\n            if success and iteration % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 21.8305,
    "time_improvement": -43.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 949.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.06928391456604004,
            "num_nodes_avg": 349.4,
            "path_length_avg": 170.71329222276952,
            "smoothness_avg": 0.023730501630408452,
            "success_improvement": -9.999999999999998,
            "time_improvement": -175.99490934647784,
            "length_improvement": 6.429339407475842,
            "smoothness_improvement": 271.43388212497473,
            "objective_score": -100.1554355118233
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06339704990386963,
            "num_nodes_avg": 494.4,
            "path_length_avg": 237.1998653462102,
            "smoothness_avg": 0.06470154955002734,
            "success_improvement": 0.0,
            "time_improvement": 61.564307456052994,
            "length_improvement": 20.8158575278676,
            "smoothness_improvement": 1564.8174725646516,
            "objective_score": 30.456551105212675
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05720210075378418,
            "num_nodes_avg": 439.4,
            "path_length_avg": 123.58877931024256,
            "smoothness_avg": 0.08727695637180613,
            "success_improvement": 0.0,
            "time_improvement": -14.75681922104857,
            "length_improvement": 17.918217447392276,
            "smoothness_improvement": 1010.1564429345709,
            "objective_score": 4.207379937836739
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is a high-performance bidirectional RRT* variant integrating adaptive informed ellipsoidal sampling, KD-tree accelerated neighbor queries, dynamic neighbor radius scaling based on iteration and node count, collision caching, iterative extensive shortcut smoothing, and heuristic-driven pruning for node removal. The approach balances exploration and exploitation, aggressively improves path quality through incremental rewiring, and reduces planning time and computational overhead by pruning non-promising nodes and caching collision results. It also ensures strict collision checking and map-bound enforcement during node and edge addition for robustness and reliability.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, sampling adaptively within ellipsoidal domains informed by the current best path cost to focus search efforts. It uses KD-trees for efficient nearest neighbor and radius neighborhoods, rewires nearby nodes to optimize path cost, and attempts incremental connections between trees at each iteration. After successful connections, the best path undergoes iterative shortcut smoothing to reduce length and improve smoothness. Periodic pruning discards nodes unlikely to improve the solution, aided by collision caches to minimize redundant checks, resulting in faster convergence, better path solutions, and higher success rate.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = tuple((start[d_] + goal[d_]) / 2 for d_ in range(dim))\n            a1 = tuple((goal[d_] - start[d_]) / c_min for d_ in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d_ == 0 else 0 for d_ in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0.0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        # If path was found but smoothing not yet done\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.8915,
    "time_improvement": 63.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1569.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012656188011169434,
            "num_nodes_avg": 78.8,
            "path_length_avg": 170.4983514035294,
            "smoothness_avg": 0.0370613183431263,
            "success_improvement": 0.0,
            "time_improvement": 49.58363012983066,
            "length_improvement": 6.547151876456593,
            "smoothness_improvement": 480.0901120108348,
            "objective_score": 18.58496997429469
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02591986656188965,
            "num_nodes_avg": 226.5,
            "path_length_avg": 234.44598291853708,
            "smoothness_avg": 0.11020151456416685,
            "success_improvement": 0.0,
            "time_improvement": 84.28557758659817,
            "length_improvement": 21.73518274833554,
            "smoothness_improvement": 2735.5643446785944,
            "objective_score": 43.31053154903953
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022350120544433593,
            "num_nodes_avg": 194.5,
            "path_length_avg": 122.12280915104859,
            "smoothness_avg": 0.1250325298986739,
            "success_improvement": 0.0,
            "time_improvement": 55.161983404664824,
            "length_improvement": 18.891845025131442,
            "smoothness_improvement": 1490.40455136978,
            "objective_score": 27.778986783274632
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT*\u2019s asymptotic optimality with informed elliptical sampling, adaptive step sizing near obstacles, cost-based pruning, and rigorous rewiring for path cost improvements. It alternates tree expansions, focuses sampling within an informed ellipsoidal domain based on the best current path cost, prunes nodes unlikely to contribute to cost improvements, dynamically adjusts step sizes near obstacles to enhance navigation in cluttered environments, and employs post-planning shortcut smoothing to refine path quality and length, enhancing efficiency, robustness, and success rate.",
    "planning_mechanism": "The planner initializes two trees from start and goal, samples mostly within an ellipsoidal informed region shrinking with the best solution cost, and dynamically adjusts the extension step size near obstacles. Nodes and edges are added only after collision checks. The planner prunes branches unable to improve the best path cost and rewires neighbors for better cost paths. Trees are connected when close enough and collision-free. Finally, shortcut smoothing reduces unnecessary detours, improving smoothness and length of the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = 15.0           # Radius for rewiring neighbors\n        self.pruning_interval = 100         # Interval to prune nodes\n        self.smoothing_iters = 50           # Shortcut smoothing iterations\n        self.goal_sample_rate = 0.1         # Probability to sample goal directly\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Create rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float(\"inf\"):\n                # Uniform random sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / dist) for d in range(dim))\n\n        def adaptive_step_size(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            samples = max(5, int(dist * 2))\n            for i in range(1, samples +1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / samples) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if distance(node.position, position) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for near in neighbors:\n                if near == new_node:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic = distance(near.position, goal)\n                if new_cost + heuristic >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune(tree):\n            # Remove nodes whose cost + heuristic exceeds c_best (if path found)\n            # Only prune if path found for meaningful bound\n            if c_best == float(\"inf\"):\n                return\n            to_remove = []\n            for node in tree:\n                heuristic = distance(node.position, goal)\n                if node.cost + heuristic >= c_best and node != tree[0]:\n                    to_remove.append(node)\n            for node in to_remove:\n                # Disconnect from parent\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.parent = None\n                # Remove children links\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step_size(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n\n            # Prune nodes that cannot improve c_best\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect trees within step size distance\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Periodically prune unpromising nodes for efficiency\n            if success and i % self.pruning_interval == 0:\n                prune(tree_start)\n                prune(tree_goal)\n\n            # Early stopping heuristic: if path found with cost close to c_min\n            if success and c_best <= 1.05 * c_min:\n                break\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 816.14051,
    "time_improvement": -2749.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 788.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1368308067321777,
            "num_nodes_avg": 1670.2,
            "path_length_avg": 149.15236675824906,
            "smoothness_avg": 0.03160650379982029,
            "success_improvement": 0.0,
            "time_improvement": -4428.605483849522,
            "length_improvement": 18.247224309306983,
            "smoothness_improvement": 394.710419088724,
            "objective_score": -1322.9586481975514
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.779088282585144,
            "num_nodes_avg": 2964.2,
            "path_length_avg": 223.94558957688918,
            "smoothness_avg": 0.04914962860516327,
            "success_improvement": 0.0,
            "time_improvement": -978.6068175359608,
            "length_improvement": 25.240516282841956,
            "smoothness_improvement": 1164.6553450574143,
            "objective_score": -282.71066527893277
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.464723324775696,
            "num_nodes_avg": 2666.5,
            "path_length_avg": 114.62745080620411,
            "smoothness_avg": 0.07101527231628328,
            "success_improvement": 0.0,
            "time_improvement": -2838.4758177612566,
            "length_improvement": 23.86990514716721,
            "smoothness_improvement": 803.3090220609791,
            "objective_score": -842.7522191886386
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with informed sampling and adaptive rewiring for improved convergence speed and path quality. It grows two trees from start and goal positions simultaneously, biasing sampling within an ellipsoidal informed subset to focus on promising regions, adaptively adjusting step sizes near obstacles, continuously rewiring to optimize path costs, pruning non-promising nodes, and applying path shortcutting to smooth the final path.",
    "planning_mechanism": "The planner iteratively samples points biased by the current best path cost to limit exploration to relevant areas. It alternates tree expansions from both start and goal, steering towards samples with adaptive step sizes to navigate safely near obstacles. Rewiring optimizes local paths while pruning removes nodes unlikely to improve the solution. When the two trees connect, the planner extracts and smooths the path, minimizing length and improving smoothness before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        import numpy as np  # allowed internally\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):  # limit retries\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Fallback uniform random if fails\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.55653,
    "time_improvement": -15.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1742.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06790504455566407,
            "num_nodes_avg": 335.1,
            "path_length_avg": 175.69567130624606,
            "smoothness_avg": 0.06361610002435195,
            "success_improvement": 0.0,
            "time_improvement": -170.50213218603682,
            "length_improvement": 3.6984184809734817,
            "smoothness_improvement": 895.7301099533913,
            "objective_score": -45.93230540984939
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04278788566589355,
            "num_nodes_avg": 366.0,
            "path_length_avg": 239.82044278321973,
            "smoothness_avg": 0.10830022940011286,
            "success_improvement": 0.0,
            "time_improvement": 74.0590134627154,
            "length_improvement": 19.941033350254575,
            "smoothness_improvement": 2686.6429079671343,
            "objective_score": 39.639125248701205
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02438187599182129,
            "num_nodes_avg": 239.9,
            "path_length_avg": 132.33767217613973,
            "smoothness_avg": 0.13703623037701726,
            "success_improvement": 0.0,
            "time_improvement": 51.08594791812151,
            "length_improvement": 12.107619383372741,
            "smoothness_improvement": 1643.090735433303,
            "objective_score": 25.962761929277516
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with adaptive step sizing, radius-based rewiring, and iterative pruning of suboptimal nodes. It uses ellipsoidal informed sampling once a feasible path is found to focus sampling in promising regions between start and goal. The planner alternates expansions from start and goal trees, performs collision checks on nodes and edges, and rewires locally to improve path cost. Periodic pruning enhances convergence speed and memory usage. Finally, shortcut smoothing refines the path for better smoothness and length optimization.",
    "planning_mechanism": "The planner begins with start and goal nodes and grows two trees bidirectionally. Sampling is uniform at first, then switches to informed ellipsoidal sampling after a path is found. Each iteration adds a collision-free node with adaptive steering distance, followed by local rewiring within a radius to optimize paths. When the trees get close, they attempt to connect if collision-free, updating the best path. Suboptimal nodes are pruned regularly, and shortcut smoothing is applied at the end to produce a smooth and feasible final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=20.0,\n                 prune_interval: int=200, shortcut_trials: int=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_interval = prune_interval\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle boundaries\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees and core data structures\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min == 0:\n            return PlannerResult(True, [start_pos], nodes, edges)\n\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for ellipsoidal sampling\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U)*np.linalg.det(Vt)\n        C = U @ np.diag([1.0]*(dim-1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if (not success) or best_cost == float('inf'):\n                # Uniform sampling in entire space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball *= scale\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n            # Fallback uniform sampling in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            distance = math.dist(from_pos, to_pos)\n            if distance <= max_step:\n                return to_pos\n            ratio = max_step / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            # Check obstacle collision on path by sampling finer\n            steps = max(5, int(distance * 3))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step size if obstacle detected on direct path\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            near = near_nodes(tree, new_node.position, self.rewire_radius)\n            for node in near:\n                if node is new_node.parent or not node.valid:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                if new_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=0.5):\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            if (node.parent, node) in edges:\n                                edges.remove((node.parent, node))\n                        new_node.add_child(node)\n                        node.cost = new_cost\n                        edges.append((new_node, node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def prune_nodes(tree):\n            retained = []\n            for node in tree:\n                heuristic = math.dist(node.position, goal_pos)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate tree expansion\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is tree_start else start_pos\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample) if n.valid else float('inf'))\n            step_len = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step_len)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try connecting opposite tree\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position) if n.valid else float('inf'))\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, nearest_b)\n                        success = True\n\n            # Prune suboptimal nodes periodically\n            if success and iteration > 0 and iteration % self.prune_interval == 0:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early stop if path cost very close to minimal\n            if success and best_cost <= c_min * 1.01:\n                break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 958.11758,
    "time_improvement": -3169.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 954.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.2718511819839478,
            "num_nodes_avg": 1525.4,
            "path_length_avg": 149.800340589072,
            "smoothness_avg": 0.030656186668189478,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4966.463895299693,
            "length_improvement": 17.89205958483052,
            "smoothness_improvement": 379.8358923320207,
            "objective_score": -1534.4615772112816
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.3030889511108397,
            "num_nodes_avg": 2700.7,
            "path_length_avg": 222.7283823615081,
            "smoothness_avg": 0.06089416816841274,
            "success_improvement": 0.0,
            "time_improvement": -1296.2923978400215,
            "length_improvement": 25.64685508670327,
            "smoothness_improvement": 1466.850807269745,
            "objective_score": -376.4240942983171
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.6672740221023559,
            "num_nodes_avg": 2515.8,
            "path_length_avg": 113.64013150094385,
            "smoothness_avg": 0.08766631313491437,
            "success_improvement": 0.0,
            "time_improvement": -3244.825819770145,
            "length_improvement": 24.525635618627962,
            "smoothness_improvement": 1015.1090322219807,
            "objective_score": -963.467073646208
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner that grows two trees from start and goal positions while ensuring collision-free extension and rewiring for path cost optimization. It balances exploration by random sampling and exploitation through rewiring, with robust collision checks on both nodes and connecting edges. The planner attempts connections between trees at each iteration to find a feasible path efficiently, then returns the optimized path and explored graph.",
    "planning_mechanism": "The planner initializes two trees at start and goal, sampling points uniformly within bounds. In each iteration, it extends each tree towards the sample with collision-checked nodes and edges, rewires neighbors to improve costs, and attempts to connect the two trees. If connected, it extracts the full path by concatenating tree branches. The process repeats until success or iteration limit, returning the best found path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d])**2 for d in range(dim)) <= r2]\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                neighbors = near_nodes(tree_a, new_pos, self.radius)\n                for neighbor in neighbors:\n                    if neighbor is new_node or neighbor is nearest_node:\n                        continue\n                    potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                try:\n                                    neighbor.parent.children.remove(neighbor)\n                                    edges.remove((neighbor.parent, neighbor))\n                                except ValueError:\n                                    pass\n                            neighbor.parent = new_node\n                            neighbor.cost = potential_cost\n                            new_node.add_child(neighbor)\n                            edges.append((new_node, neighbor))\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                        # extract full path\n                        path_a = new_node.path_from_root()\n                        path_b = nearest_other.path_from_root()\n                        final_path = path_a + path_b[::-1][1:]\n                        success = True\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.10511,
    "time_improvement": 48.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 120.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011091971397399902,
            "num_nodes_avg": 150.1,
            "path_length_avg": 187.84179597993017,
            "smoothness_avg": 0.012363766462785824,
            "success_improvement": 0.0,
            "time_improvement": 55.8147420007408,
            "length_improvement": -2.9590649203348067,
            "smoothness_improvement": 93.51979349119479,
            "objective_score": 16.62020858361125
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0326352596282959,
            "num_nodes_avg": 286.5,
            "path_length_avg": 275.0283720240446,
            "smoothness_avg": 0.009391425218857656,
            "success_improvement": 0.0,
            "time_improvement": 80.21424014103054,
            "length_improvement": 8.187613165613756,
            "smoothness_improvement": 141.64813525137475,
            "objective_score": 26.410035351688787
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.04579734802246094,
            "num_nodes_avg": 280.1,
            "path_length_avg": 146.04954231216885,
            "smoothness_avg": 0.01756855771566413,
            "success_improvement": -9.999999999999998,
            "time_improvement": 8.122989915377943,
            "length_improvement": 3.000848128113153,
            "smoothness_improvement": 123.47075736720929,
            "objective_score": -46.34557961292793
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner advances bidirectional RRT* by combining adaptive ellipsoidal informed sampling with a dynamically shrinking neighbor radius optimized for fast convergence and enhanced path quality. Leveraging KD-tree accelerated nearest neighbor searches, it performs incremental rewiring, aggressive pruning of non-promising nodes, and caches collision checks for efficiency. After path discoveries, it applies an iterative shortcut smoothing strategy to refine path smoothness while maintaining robustness in complex 2D and 3D spaces. These improvements minimize planning time and path length while maximizing success rates and smoothness.",
    "planning_mechanism": "The planner grows two balanced trees rooted at start and goal positions, extending alternately towards samples biased by the current best path cost using ellipsoidal informed sampling. KD-trees accelerate nearest and radius neighbor queries for efficient rewiring and incremental connections. Collision checking is aggressively cached to reduce redundancy. It prunes nodes unlikely to improve the solution periodically, thereby controlling tree size and focusing search. Once a better connection is found, extensive shortcut smoothing refines the path. The process iterates until success or maximum iterations, yielding fast, reliable, and high-quality paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        \n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                # Uniform random samples inside bounds avoiding obstacles\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Householder transform to align sampling axis\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):  # Increased trials for better samples\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        # Cache to accelerate collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos): \n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # Prune dead ends and nodes that can't improve path\n                if not node.children or node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0  # restart smoothing after successful shortcut\n                else:\n                    iteration += 1\n            return path\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Expand smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node (incremental rewiring)\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Apply additional smoothing after initial success for improved smoothness\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning to remove obsolete nodes and clear cache\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        # Final smoothing if success and extracted_path is non-empty\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -8.92451,
    "time_improvement": 50.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1480.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02080519199371338,
            "num_nodes_avg": 79.8,
            "path_length_avg": 164.45684423843875,
            "smoothness_avg": 0.05039011432391068,
            "success_improvement": -9.999999999999998,
            "time_improvement": 17.121786287526948,
            "length_improvement": 9.858597687450098,
            "smoothness_improvement": 688.7147130538465,
            "objective_score": -39.44817101098266
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03086545467376709,
            "num_nodes_avg": 234.7,
            "path_length_avg": 239.50461596305007,
            "smoothness_avg": 0.09143793467005715,
            "success_improvement": 0.0,
            "time_improvement": 81.2872187606693,
            "length_improvement": 20.046465433398186,
            "smoothness_improvement": 2252.7639191428284,
            "objective_score": 39.65927831059457
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023805689811706544,
            "num_nodes_avg": 155.2,
            "path_length_avg": 124.96929160458971,
            "smoothness_avg": 0.1256230970077935,
            "success_improvement": 0.0,
            "time_improvement": 52.24187213135454,
            "length_improvement": 17.001346914418143,
            "smoothness_improvement": 1497.9165214066518,
            "objective_score": 26.56241362932325
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* variant with enhanced adaptive informed sampling focused on an ellipsoidal domain shaped by the current best solution cost. It uses efficient KD-tree based nearest neighbor queries with a dynamically scaling neighbor radius to balance exploration and exploitation. The planner aggressively rewires nodes to optimize path costs, caches collision results to minimize redundant checks, and prunes nodes unlikely to improve solutions to reduce computational overhead. An iterative shortcut smoothing is applied to the found path for better smoothness and shorter length. The planner strictly enforces collision-free node and edge additions and map bounds, leading to higher success rate, faster convergence, and improved path quality.",
    "planning_mechanism": "The planning mechanism grows two trees from the start and goal positions, extending the smaller tree at each iteration using informed ellipsoidal sampling guided by the current best path cost. Using KD-trees, the closest neighbors within a dynamic radius are identified for rewiring to minimize costs. Trees repeatedly try to connect multiple intermediate nodes to bridge the gap. Collision checks are cached and reused. Nodes with combined cost and heuristic exceeding the best known path cost are periodically pruned. After connection, iterative shortcut smoothing is applied to the solution path to improve smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d_] <= bounds[d_] for d_ in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            # ensure within bounds\n            return tuple(max(0., min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = tuple((start[d_] + goal[d_]) / 2 for d_ in range(dim))\n            a1 = tuple((goal[d_] - start[d_]) / c_min for d_ in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d_ == 0 else 0 for d_ in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0.0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            # pick best parent\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree toward new_node by multiple steps\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            dist_b_to_new = dist(last_node_b.position, new_node.position)\n            max_steps = max(1, int(dist_b_to_new / self.step_size))\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px, py = pos[0], pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -31.70924,
    "time_improvement": 72.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1305.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008213996887207031,
            "num_nodes_avg": 66.1,
            "path_length_avg": 155.70495043210556,
            "smoothness_avg": 0.038461222836878126,
            "success_improvement": 0.0,
            "time_improvement": 67.27925463714848,
            "length_improvement": 14.655649365333387,
            "smoothness_improvement": 502.001657279315,
            "objective_score": 25.624914550607798
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022413420677185058,
            "num_nodes_avg": 211.4,
            "path_length_avg": 236.68333777093594,
            "smoothness_avg": 0.0896268599369011,
            "success_improvement": 0.0,
            "time_improvement": 86.41142849213483,
            "length_improvement": 20.988289299916058,
            "smoothness_improvement": 2206.16366179432,
            "objective_score": 41.15190471659526
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01903834342956543,
            "num_nodes_avg": 155.0,
            "path_length_avg": 122.14525863440576,
            "smoothness_avg": 0.10273219616241272,
            "success_improvement": 0.0,
            "time_improvement": 61.805952815983865,
            "length_improvement": 18.876935147215125,
            "smoothness_improvement": 1206.7459522839513,
            "objective_score": 28.35090263565794
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an Adaptive Bidirectional RRT* with Dynamic Informed Sampling and Progressive Randomized Shortcut Smoothing. It integrates elliptical informed sampling that tightens progressively on improved solutions, adaptive step sizes based on obstacle proximity, and neighborhood rewiring for continual path quality enhancement. The planner balances exploration and exploitation by alternating tree expansions bidirectionally and pruning nodes that cannot improve current best solutions. A multi-pass randomized smoothing phase refines the final path, promoting smoothness and shorter lengths while strictly maintaining collision-free constraints, thus achieving improved efficiency, robustness, quality, and success rate.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points within an adaptively shrinking ellipsoidal informed set guided by the best path cost found so far. It uses adaptive stepping controlled by local obstacle density, adds nodes only if they are collision-free, and rewires neighborhoods for path improvement dynamically. On finding a connecting path, it prunes nodes that can't improve and performs iterative randomized shortcut smoothing in multiple passes, resulting in higher-quality smooth paths and reduced overall planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, base_step: float = 6.0, rewire_radius: float = 15.0,\n                 smoothing_passes: int = 3, smoothing_trials_per_pass: int = 50):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.rewire_radius = rewire_radius\n        self.smoothing_passes = smoothing_passes\n        self.smoothing_trials_per_pass = smoothing_trials_per_pass\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Compute minimal possible path length between start and goal\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min < 1e-14:\n            # Start == goal\n            return PlannerResult(True, [start_pos], [], [])\n\n        # Initialization\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_sign = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1.0] * (dim - 1) + [det_sign]) @ Vt\n\n        def informed_sample():\n            # If no solution found, sample uniformly in space\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = best_cost / 2.0\n            val = best_cost ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample uniformly inside unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if in_bounds(x_rand):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            steps_check = max(8, int(dist_ * 3.0))\n            reduction = 1.0\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction = 0.35\n                    break\n            return max(self.base_step * reduction, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, node):\n            return [n for n in tree if n is not node and math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            neighs = neighbors(tree, new_node)\n            for near in neighs:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, new_cost)\n                        # Update edges: Remove old edge and add new edge\n                        replaced = False\n                        for i, (p, c) in enumerate(edges):\n                            if c == near:\n                                edges[i] = (new_node, near)\n                                replaced = True\n                                break\n                        if not replaced:\n                            edges.append((new_node, near))\n\n        def prune_nodes(tree, other_goal_pos):\n            nonlocal best_cost, all_nodes, edges\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                heuristic = node.cost + math.dist(node.position, other_goal_pos)\n                if heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in all_nodes:\n                    all_nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n\n        def try_connection(new_node, other_tree):\n            nonlocal best_cost, best_path, success\n            # Check all nodes within step distance for possible connection\n            for other_node in other_tree:\n                dist_conn = math.dist(new_node.position, other_node.position)\n                if dist_conn <= self.base_step:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_conn + other_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            path_from_start = new_node.path_from_root() if new_node in tree_start else other_node.path_from_root()\n                            path_from_goal = other_node.path_from_root() if other_node in tree_goal else new_node.path_from_root()\n                            if path_from_start[-1] == path_from_goal[-1]:\n                                combined_path = path_from_start + path_from_goal[-2::-1]\n                            else:\n                                combined_path = path_from_start + path_from_goal[::-1]\n                            best_path = combined_path\n                            success = True\n\n        def multi_pass_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_passes):\n                if len(smoothed) < 3:\n                    break\n                for _ in range(self.smoothing_trials_per_pass):\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) - 1)\n                    a, b = smoothed[i], smoothed[j]\n                    if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                        smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < 0.1 and tree_b:\n                sample = tree_b[0].position  # Goal bias to opposite root\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal_pos if tree_a is tree_start else start_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                # Discard node that can\u2019t improve the best cost\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune_nodes(tree_a, goal_pos if tree_a is tree_start else start_pos)\n\n            try_connection(new_node, tree_b)\n\n            if success and itr > 200 and itr % 50 == 0:\n                # Early stopping if stable solution\n                break\n\n        if success and best_path:\n            best_path = multi_pass_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.06124,
    "time_improvement": -34.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1522.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.07142696380615235,
            "num_nodes_avg": 222.3,
            "path_length_avg": 160.100417602488,
            "smoothness_avg": 0.0443990807496148,
            "success_improvement": -9.999999999999998,
            "time_improvement": -184.5318213332574,
            "length_improvement": 12.246424158612312,
            "smoothness_improvement": 594.9420278784813,
            "objective_score": -99.93555142886234
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05235316753387451,
            "num_nodes_avg": 316.9,
            "path_length_avg": 237.2054630413984,
            "smoothness_avg": 0.104299823465584,
            "success_improvement": 0.0,
            "time_improvement": 68.25987559224068,
            "length_improvement": 20.81398885609306,
            "smoothness_improvement": 2583.7095818957787,
            "objective_score": 37.55930835836971
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04286811351776123,
            "num_nodes_avg": 264.3,
            "path_length_avg": 127.52484700111665,
            "smoothness_avg": 0.11685377250645593,
            "success_improvement": 0.0,
            "time_improvement": 13.999515953447347,
            "length_improvement": 15.304068702515913,
            "smoothness_improvement": 1386.3713610338411,
            "objective_score": 14.192525331706593
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional obstacle-aware rewiring approach of the first algorithm with the goal biasing and incremental space-filling strategy of the second. It grows two trees from start and goal, samples with a goal bias to accelerate convergence, extends towards samples with step limits, and rewires neighbors to optimize cost locally. The planner alternates tree expansions, connects trees when close, and smooths the final path for better quality and robustness.",
    "planning_mechanism": "The planner incrementally builds two trees rooted at start and goal. Each iteration samples a point biased toward the goal, extends the active tree toward it with collision checks, rewires nearby nodes to minimize cost, then attempts to connect to the other tree. When connection occurs, it extracts and smooths the path. This bidirectional, goal-biased, cost-optimizing method improves path quality, success rate, and planning efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0, smooth_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smooth_iterations = smooth_iterations\n\n    def plan(self, map: \"Map\") -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: list = []\n        nodes: list = []\n        edges: list = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def swap_trees():\n            nonlocal tree_start, tree_goal\n            tree_start, tree_goal = tree_goal, tree_start\n\n        for iter_num in range(self.max_iter):\n            # Sample point with goal bias from active tree's perspective\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            new_start_node = self._extend_and_rewire(tree_start, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_start_node is None:\n                swap_trees()\n                continue\n\n            connect_node = self._connect_and_rewire(tree_goal, new_start_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node is not None:\n                success_state = True\n                path_start = new_start_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                full_path = path_start + path_goal[::-1]\n                extracted_path = self._smooth_path(full_path, obstacles, is_3d, bounds)\n                break\n\n            swap_trees()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_and_rewire(self, tree, target_point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n        # Find nearest node in tree to target_point\n        nearest = self._nearest(tree, target_point)\n        new_pos = self._steer(nearest.position, target_point, bounds)\n        if new_pos is None:\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Choose best parent (lowest cost) from neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if cheaper\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    # Remove old edge\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        curr_pos = nearest.position\n        total_dist = math.dist(curr_pos, target_node.position)\n        if total_dist == 0:\n            return None\n\n        direction = tuple((target_node.position[d] - curr_pos[d])/total_dist for d in range(len(curr_pos)))\n\n        prev_node = nearest\n        dist_travelled = 0.0\n\n        while dist_travelled < total_dist:\n            dist_step = min(self.step_size, total_dist - dist_travelled)\n            new_pos = tuple(prev_node.position[d] + direction[d]*dist_step for d in range(len(curr_pos)))\n            # Check bounds\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(prev_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            import math\n            # Find best parent among neighbors\n            min_cost = prev_node.cost + math.dist(prev_node.position, new_pos)\n            best_parent = prev_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Check if close enough to target_node\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                return new_node\n\n            prev_node = new_node\n            dist_travelled += dist_step\n\n        return None\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        import math\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]  # make copy\n        for _ in range(self.smooth_iterations):\n            if len(path) <= 2:\n                break\n            # Randomly pick indices i,j with j > i + 1\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if self._can_connect_direct(path[i], path[j], obstacles, is_3d, bounds):\n                # Remove nodes between i and j\n                del path[i+1:j]\n        return path\n\n    def _can_connect_direct(self, p1, p2, obstacles, is_3d, bounds):\n        # Check nodes inside bounds\n        if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n            return False\n        if self._is_in_obstacle(p1, obstacles, is_3d) or self._is_in_obstacle(p2, obstacles, is_3d):\n            return False\n        # Check straight line edge collision\n        if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n            return False\n        return True\n\n    def _within_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos, bounds):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist == 0:\n            return None\n        step = min(dist, self.step_size)\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        # Ensure new_pos within bounds\n        for d in range(len(bounds)):\n            if new_pos[d] < 0:\n                new_pos = new_pos[:d] + (0.0,) + new_pos[d+1:]\n            elif new_pos[d] > bounds[d]:\n                new_pos = new_pos[:d] + (bounds[d],) + new_pos[d+1:]\n        return new_pos\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 37.84253,
    "time_improvement": 63.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1149.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014295625686645507,
            "num_nodes_avg": 79.1,
            "path_length_avg": 160.83653233363623,
            "smoothness_avg": 0.03454935574153824,
            "success_improvement": 0.0,
            "time_improvement": 43.052872515219725,
            "length_improvement": 11.842948009985605,
            "smoothness_improvement": 440.7724424818849,
            "objective_score": 17.488313568972462
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.025276875495910643,
            "num_nodes_avg": 240.7,
            "path_length_avg": 229.76260216130214,
            "smoothness_avg": 0.07934648258819792,
            "success_improvement": -19.999999999999996,
            "time_improvement": 84.67540340590597,
            "length_improvement": 23.298630048741266,
            "smoothness_improvement": 1941.6421479556814,
            "objective_score": -60.22944222870153
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.018804073333740234,
            "num_nodes_avg": 201.0,
            "path_length_avg": 111.30591765590157,
            "smoothness_avg": 0.09144038508357552,
            "success_improvement": -19.999999999999996,
            "time_improvement": 62.2759371466508,
            "length_improvement": 26.075909311186134,
            "smoothness_improvement": 1063.114948835937,
            "objective_score": -70.78646224958783
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional tree growth with dynamic informed sampling inside an ellipsoidal region, adaptive step sizing based on local obstacle proximity, cost-aware node pruning, and local rewiring to enhance convergence speed, path quality, and robustness. The planner further applies iterative shortcut smoothing on the final path to improve smoothness and path length reduction. It alternates tree growing direction each iteration to maintain balanced exploration, and prunes nodes and edges unlikely to improve the current best solution, thus reducing search time and improving efficiency.",
    "planning_mechanism": "The planning mechanism initializes two trees from start and goal, alternately samples points informed by the current best path cost, and adaptively extends towards samples using collision-free checks and adaptive step sizing. It rewires neighbors to optimize local costs, prunes branches exceeding best cost, and attempts to connect the two trees. Once a connecting path is found, iterative shortcut smoothing is applied to generate a smoother, shorter final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...] (W,H) or (W,H,D)\n        goal = map.goal                    # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1]*(dim-1) + [det_val]) @ Vt\n\n        def informed_sample():\n            # With goal_sample_rate, sample goal directly (to encourage connection)\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float('inf'):\n                # Uniform random sampling in entire bounds\n                for _ in range(100):\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                x_rand_t = tuple(x_rand)\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                    return x_rand_t\n            # fallback uniform\n            for _ in range(100):\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Use finer sampling to detect nearby obstacle on the segment\n            steps = max(5, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # If near obstacle, reduce step size conservatively\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n is not new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node under new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicate connecting node if exists\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def shortcut_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path\n            length = len(path)\n            for _ in range(max_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iter_idx in range(self.max_iter):\n            # Alternate tree selection for growth\n            tree_a, tree_b = (tree_start, tree_goal) if iter_idx % 2 == 0 else (tree_goal, tree_start)\n            root_a = tree_a[0]\n            root_b = tree_b[0]\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Enforce map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision node check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Collision edge check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Calculate cost to new node\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal if tree_a is tree_start else start)\n            if new_cost + heuristic_remain >= best_cost:\n                # Prune unpromising node\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring to reduce costs\n            rewire(tree_a, new_node)\n\n            # Try connecting trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    success_state = True\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n\n            # Early break if a good path is found and iter multiples of 100\n            if success_state and iter_idx % 100 == 0 and best_cost < float('inf'):\n                break\n\n        if success_state and best_path:\n            best_path = shortcut_smoothing(best_path, max_iters=150)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.84234,
    "time_improvement": -41.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1391.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.06633493900299073,
            "num_nodes_avg": 315.7,
            "path_length_avg": 159.59419174422138,
            "smoothness_avg": 0.03602485481774475,
            "success_improvement": -9.999999999999998,
            "time_improvement": -164.24756151997798,
            "length_improvement": 12.5238945731903,
            "smoothness_improvement": 463.8672071220442,
            "objective_score": -94.4501535057451
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06623361110687256,
            "num_nodes_avg": 479.3,
            "path_length_avg": 237.2645867834746,
            "smoothness_avg": 0.08928854718770776,
            "success_improvement": 0.0,
            "time_improvement": 59.84458714657445,
            "length_improvement": 20.79425164920546,
            "smoothness_improvement": 2197.4586310807517,
            "objective_score": 33.099519629217184
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.059464025497436526,
            "num_nodes_avg": 398.6,
            "path_length_avg": 127.5776912157896,
            "smoothness_avg": 0.12670194869028087,
            "success_improvement": 0.0,
            "time_improvement": -19.294612160091233,
            "length_improvement": 15.268972091301238,
            "smoothness_improvement": 1511.6394351753434,
            "objective_score": 4.823607946109594
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive ellipsoidal informed sampling, dynamic neighbor radius, KD-tree accelerated nearest neighbor search, incremental rewiring, aggressive pruning of non-promising nodes, collision check caching, and iterative shortcut path smoothing. Parameter tuning balances exploration-exploitation, accelerates convergence, improves success rate, path optimality, and smoothness in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates expansions of two trees rooted at the start and goal, biased by the current best path cost through ellipsoidal informed sampling; neighbor radius shrinks dynamically to balance exploration and refinement. KD-trees accelerate nearest and radius neighbor queries enabling efficient rewiring. Collision checks are cached to minimize redundancy. Periodic pruning removes futile nodes, and shortcut smoothing refines the final path for enhanced smoothness and shorter length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 120,\n                 prune_threshold: int = 200,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 0.4,\n                 goal_sample_rate: float = 0.18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -15.52638,
    "time_improvement": 17.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1368.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023497653007507325,
            "num_nodes_avg": 91.4,
            "path_length_avg": 158.55454962507443,
            "smoothness_avg": 0.0451878173496607,
            "success_improvement": 0.0,
            "time_improvement": 6.396273185742368,
            "length_improvement": 13.093738892878351,
            "smoothness_improvement": 607.2874684381404,
            "objective_score": 7.574067076489083
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03952329158782959,
            "num_nodes_avg": 267.8,
            "path_length_avg": 235.59660813744208,
            "smoothness_avg": 0.09339958230957038,
            "success_improvement": 0.0,
            "time_improvement": 76.03823701421378,
            "length_improvement": 21.351070931354453,
            "smoothness_improvement": 2303.2385258251884,
            "objective_score": 38.59787791966097
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06504204273223876,
            "num_nodes_avg": 261.4,
            "path_length_avg": 123.60544267814672,
            "smoothness_avg": 0.10175022439068415,
            "success_improvement": 0.0,
            "time_improvement": -30.48503186480369,
            "length_improvement": 17.907150431854646,
            "smoothness_improvement": 1194.2553438291804,
            "objective_score": 0.4071972460757243
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified, generalized bidirectional RRT* planner that balances exploration and exploitation by simultaneously growing trees from start and goal states, incorporating goal biasing and efficient collision checks. It adaptively steers with a fixed step size, rewires nearby nodes to reduce path cost, and performs path shortcutting for smoothness, aiming for improved planning efficiency, robustness, and path quality.",
    "planning_mechanism": "Sampling alternates between start and goal trees, nodes are extended toward random collision-free samples within map bounds, edges are only added if both node and connecting path are collision-free. The planner rewires neighbors to optimize costs, prunes inefficient nodes, and shortcuts the resulting path for smoothness, returning the best successful path found within iteration limits.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n        best_cost = float('inf')\n        best_path_nodes = (None, None)\n\n        import random\n        import math\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near(tree, node):\n            return [n for n in tree if math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def can_connect(from_pos, to_pos):\n            if not (all(0 <= to_pos[d] <= bounds[d] for d in range(dim))):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            neighbors = near(tree, new_node)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, new_cost)\n                        for i, e in enumerate(edges):\n                            if e[1] == neighbor:\n                                edges[i] = (new_node, neighbor)\n                                break\n\n        def connect_trees(node_start, tree_goal):\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            if can_connect(node_start.position, nearest_goal_node.position):\n                total_cost = node_start.cost + math.dist(node_start.position, nearest_goal_node.position) + nearest_goal_node.cost\n                return nearest_goal_node, total_cost\n            return None, float('inf')\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for i in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = sample()\n            nearest_node = nearest(active_tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not can_connect(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            if new_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(active_tree, new_node)\n\n            other_connect_node, total_cost = connect_trees(new_node, other_tree)\n            if other_connect_node and total_cost < best_cost:\n                best_cost = total_cost\n                if i % 2 == 0:\n                    path_start = new_node.path_from_root()\n                    path_goal = other_connect_node.path_from_root()\n                else:\n                    path_start = other_connect_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 809.24856,
    "time_improvement": -2734.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1285.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.154827094078064,
            "num_nodes_avg": 2722.1,
            "path_length_avg": 149.5229991748837,
            "smoothness_avg": 0.05207290330911385,
            "success_improvement": 0.0,
            "time_improvement": -4500.294327150469,
            "length_improvement": 18.044074808703066,
            "smoothness_improvement": 715.0540149070455,
            "objective_score": -1342.904213108865
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.489027976989746,
            "num_nodes_avg": 3369.6,
            "path_length_avg": 222.77332906059308,
            "smoothness_avg": 0.08128620389775457,
            "success_improvement": 0.0,
            "time_improvement": -802.7521248969027,
            "length_improvement": 25.631850584829703,
            "smoothness_improvement": 1991.5525743753608,
            "objective_score": -225.74150448022806
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.4945019721984862,
            "num_nodes_avg": 3335.7,
            "path_length_avg": 115.79626322045928,
            "smoothness_avg": 0.09821328368963246,
            "success_improvement": 0.0,
            "time_improvement": -2898.2166806651144,
            "length_improvement": 23.093635594485168,
            "smoothness_improvement": 1149.2657191816086,
            "objective_score": -859.0999484847292
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines the strengths of bidirectional RRT* and RRG strategies, incorporating adaptive informed ellipsoidal sampling, efficient KD-tree based neighbor searches, dynamic rewiring, collision caching, incremental connection attempts, and aggressive periodic pruning to minimize path length and significantly reduce planning time. The planner balances exploration and exploitation by alternating tree growth from start and goal, focusing sampling within promising ellipsoidal subsets informed by the current best path cost. It performs continuous incremental rewiring to maintain near-optimal paths and applies shortcut smoothing iteratively for enhanced smoothness and reduced path length, ensuring robustness and higher success rates in complex 2D/3D environments.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal positions alternately. It samples adaptively within an informed ellipsoidal subset to bias exploration toward shorter paths. KD-tree accelerated nearest and near neighbor searches allow efficient rewiring around newly added nodes, optimizing local paths incrementally. Collision results for nodes and edges are cached to avoid redundant checks. The trees attempt gradual incremental connections when nearby, linking together upon collision-free paths. Periodic aggressive pruning removes dead-end and suboptimal nodes, keeping the search space manageable. Discovered paths are repeatedly shortcut-smoothed to improve smoothness and length, yielding fast convergence to high-quality solutions in cluttered spaces.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent                  # Parent Node or None\n        self.cost = cost                      # Cost from root to this node\n        self.children = []                    # Child nodes\n        self.valid = True                     # Mark invalid if pruned or in collision\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update descendants' cost\n        def update_subtree_costs(n):\n            for c in n.children:\n                c.cost = n.cost + self._dist(n.position, c.position)\n                update_subtree_costs(c)\n        update_subtree_costs(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no valid path found or early iteration, sample uniformly with goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            # Fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # KDTree substitute with brute force for correctness and efficiency\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                node.valid = False\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balanced alternate tree expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring near new node in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Merge paths respecting expansion order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of dead-end and non-promising nodes\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.42259,
    "time_improvement": 62.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1491.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010709810256958007,
            "num_nodes_avg": 63.0,
            "path_length_avg": 156.75710618693898,
            "smoothness_avg": 0.05200015569333173,
            "success_improvement": 0.0,
            "time_improvement": 57.33709433854746,
            "length_improvement": 14.078946123634333,
            "smoothness_improvement": 713.9153567460792,
            "objective_score": 23.5864943100215
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02057681083679199,
            "num_nodes_avg": 203.0,
            "path_length_avg": 234.22921575317713,
            "smoothness_avg": 0.096105485400136,
            "success_improvement": 0.0,
            "time_improvement": 87.52490887104165,
            "length_improvement": 21.8075458674296,
            "smoothness_improvement": 2372.8633613286593,
            "objective_score": 42.48329864144171
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029833245277404784,
            "num_nodes_avg": 194.8,
            "path_length_avg": 126.35183607140945,
            "smoothness_avg": 0.11692653906150388,
            "success_improvement": 0.0,
            "time_improvement": 40.149604822863836,
            "length_improvement": 16.083126709249374,
            "smoothness_improvement": 1387.2969462429828,
            "objective_score": 22.19799151992394
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional search, adaptive ellipsoidal informed sampling, dynamic neighbor radius, and KD-tree accelerated nearest neighbor search from the first algorithm, with adaptive step sizing, cost-aware pruning, and selective rewiring from the second. It integrates collision check caching and aggressive pruning of non-promising nodes, and applies iterative shortcut smoothing for optimized path smoothness and length. Balancing exploration and exploitation, it alternates tree growth directions and rewiring procedures to enhance convergence speed, path quality, robustness, and overall planning efficiency in both 2D and 3D environments.",
    "planning_mechanism": "The planner maintains two trees from start and goal, alternately sampling nodes informed by the current best path cost within an adaptive ellipsoidal region. It uses dynamic neighbor radius and KD-tree for efficient nearest neighbor and radius searches. Adaptive step sizing adjusts expansion steps based on obstacle proximity. Nodes are rewired locally to improve costs, and nodes/edges unlikely to lead to better paths are pruned aggressively. The trees attempt to connect whenever nodes are close, and shortcut smoothing refines the final path for better smoothness and length reduction, ensuring bounded, collision-free growth throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_check_resolution: float = 0.4,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 150,\n                 smoothing_iterations: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_check_resolution = collision_check_resolution\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def euclidean_dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = euclidean_dist(from_pos, to_pos)\n            if d <= step:\n                new_p = to_pos\n            else:\n                ratio = step / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        # Dynamic neighbor radius function combining iteration decay and log scaling\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Cached collision checks for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        # Adaptive step size lowers when close/near obstacle\n        def adaptive_step(from_pos, to_pos):\n            dist = euclidean_dist(from_pos, to_pos)\n            steps = max(5, int(dist * 3))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * (i / steps) for d_ in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        # Ellipsoidal informed sampling combining approach from both algorithms\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        # KD-Tree simplified but efficient with memoization of nodes and points for nearest/radius searches\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = euclidean_dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        # Prune nodes that can't improve best cost or without children (except roots)\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            removed = 0\n            heuristic = lambda pos: euclidean_dist(pos, goal)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    rm_node.parent.remove_child(rm_node)\n                if rm_node in nodes_list:\n                    nodes_list.remove(rm_node)\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Shortcut smoothing with collision check to improve smoothness and shorten path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        # Local rewiring to improve cost of near nodes\n        def rewire(tree, new_node, edges, best_cost):\n            r = neighbor_radius(iteration, len(nodes))\n            kdtree = KDTree([(node.position, node) for node in tree])\n            near_nodes = kdtree.radius_search(new_node.position, r)\n            for near in near_nodes:\n                if near is new_node:\n                    continue\n                new_cost = new_node.cost + euclidean_dist(new_node.position, near.position)\n                heuristic_remain = euclidean_dist(near.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost + 1e-12 < near.cost and can_connect(new_node.position, near.position):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        # Initialize roots and trees\n        root_start = Node(start, parent=None, cost=0.0)\n        root_goal = Node(goal, parent=None, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = euclidean_dist(start, goal)\n        best_path = []\n\n        success_state = False\n\n        alternate_flag = True  # Start expanding tree_start\n\n        for iteration in range(self.max_iter):\n            # Alternate tree direction for balanced growth\n            if alternate_flag:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                goal_b_pos = goal\n                start_a_pos = start\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                goal_b_pos = start\n                start_a_pos = goal\n            alternate_flag = not alternate_flag\n\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n\n            step = adaptive_step(nearest_a.position, q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            new_cost = nearest_a.cost + euclidean_dist(nearest_a.position, new_pos)\n            heuristic_remain = euclidean_dist(new_pos, goal if tree_a is tree_start else start)\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_a, cost=new_cost)\n            nearest_a.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_a, new_node))\n\n            # Local rewiring to reduce costs and improve tree structure\n            rewire(tree_a, new_node, edges, c_best)\n\n            # Attempt connection to other tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_connect = euclidean_dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size and can_connect(new_node.position, nearest_b.position):\n                total_cost = new_node.cost + dist_connect + nearest_b.cost\n                if total_cost + 1e-12 < c_best:\n                    c_best = total_cost\n                    success_state = True\n                    # Build merged path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    merged_path = path_a + path_b[::-1][1:]\n                    best_path = shortcut_path(merged_path)\n\n            # Aggressive pruning every prune_interval iterations once enough nodes and solution found\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n            if success_state and iteration % 100 == 0:\n                # Optionally break early if good path found and some iterations passed\n                break\n\n        if success_state and best_path:\n            best_path = shortcut_path(best_path)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 63.44808,
    "time_improvement": -193.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1638.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.12022578716278076,
            "num_nodes_avg": 213.0,
            "path_length_avg": 164.5115586108254,
            "smoothness_avg": 0.05095322252579626,
            "success_improvement": -9.999999999999998,
            "time_improvement": -378.92364969465575,
            "length_improvement": 9.828607872940259,
            "smoothness_improvement": 697.5285792223879,
            "objective_score": -158.22373043769673
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09553639888763428,
            "num_nodes_avg": 277.9,
            "path_length_avg": 237.53455848579375,
            "smoothness_avg": 0.11089549082803829,
            "success_improvement": 0.0,
            "time_improvement": 42.079203054890726,
            "length_improvement": 20.70412732426674,
            "smoothness_improvement": 2753.4208537989052,
            "objective_score": 30.53169065031509
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.17069511413574218,
            "num_nodes_avg": 300.2,
            "path_length_avg": 129.7391407291614,
            "smoothness_avg": 0.1228601876349936,
            "success_improvement": 0.0,
            "time_improvement": -242.4424644665826,
            "length_improvement": 13.83344024168518,
            "smoothness_improvement": 1462.772518121393,
            "objective_score": -62.65218870103079
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This planner synthesizes the adaptive rewiring and dual-tree bidirectional growth of the first algorithm with the informed sampling, adaptive step sizing, and cost-aware pruning of the second algorithm. It dynamically adjusts rewiring radius, uses ellipsoidal informed sampling to focus exploration within promising regions, and applies adaptive step sizing based on local obstacle proximity for safer expansions. The planner prunes unpromising nodes to boost efficiency, rewires locally for cost improvements, and performs shortcut smoothing on the final path to enhance smoothness and reduce length. This unified approach aims to maximize success rate, path quality, and planning speed.",
    "planning_mechanism": "The planner grows two bidirectional trees from start and goal, alternately expanding each using adaptive step sizes determined by obstacle proximity. Sampling is informed by the current best path cost, focusing on an ellipsoidal region that shrinks as better paths are found. After each extension, local rewiring optimizes paths, while cost-aware pruning removes nodes unlikely to contribute to better solutions. The two trees are connected incrementally when close and collision-free nodes exist, with path extraction followed by iterative shortcut smoothing to improve final path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_factor: float=40.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # Factor for adaptive rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float('inf')\n\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n        a1 = np.array(goal_position) - np.array(start_position)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1]*(dim-1) + [det_val]) @ Vt\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_rewire_radius(tree_size):\n            gamma = self.rewire_factor\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1.0 / dim)\n            return max(r, self.base_step * 1.5)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps_check = max(5, int(dist * 2))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, current_best_cost):\n            radius = adaptive_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                if neighbor is new_node:\n                    continue\n                potential_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                heuristic_remain = distance(neighbor.position, goal_position if tree is start_tree else start_position)\n                if potential_cost + heuristic_remain >= current_best_cost:\n                    continue\n                if potential_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Disconnect old parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            if best_cost == float('inf'):\n                # Uniform random sampling in full bounds avoiding obstacles\n                for _ in range(100):\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball = x_ball / norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + np.array(x_center)\n                x_rand_t = tuple(x_rand)\n                if in_bounds(x_rand_t) and not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                    return x_rand_t\n            # fallback uniform\n            for _ in range(100):\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def shortcut_smoothing(path, max_iters=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iter_idx in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if iter_idx % 2 == 0 else (goal_tree, start_tree)\n            root_a = tree_a[0]\n            root_b = tree_b[0]\n\n            sample = informed_sample()\n\n            # Select nearest node to sample in tree_a\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Cost pruning: heuristic from new_pos to opposite tree root\n            heuristic_remain = distance(new_pos, goal_position if tree_a is start_tree else start_position)\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                continue  # Prune unpromising node\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring for cost improvement\n            rewire(tree_a, new_node, best_cost)\n\n            # Attempt connection to tree_b within adaptive radius\n            radius_conn = adaptive_rewire_radius(len(tree_b))\n            neighbors_b = near_nodes(tree_b, new_node.position, radius_conn)\n\n            best_connect_node = None\n            min_total_cost = float('inf')\n            for nb in neighbors_b:\n                dist_connect = distance(nb.position, new_node.position)\n                if dist_connect <= self.base_step and not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nb.cost\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        best_connect_node = nb\n\n            if best_connect_node is not None and min_total_cost < best_cost:\n                # Connect trees by linking best_connect_node as child of new_node\n                conn_pos = best_connect_node.position\n                conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + distance(new_node.position, conn_pos))\n                new_node.add_child(conn_node)\n                tree_a.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((new_node, conn_node))\n\n                # Rewire around connecting node for further refinement\n                rewire(tree_a, conn_node, min_total_cost)\n\n                # Extract combined path\n                extracted_path = extract_path(conn_node, best_connect_node)\n                best_cost = min_total_cost\n                success_state = True\n\n                # Early stopping if a good path has been found\n                if best_cost < float('inf') and iter_idx % 100 == 0:\n                    break\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_smoothing(extracted_path, max_iters=150)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 682.33524,
    "time_improvement": -2308.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1179.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.106761646270752,
            "num_nodes_avg": 1845.1,
            "path_length_avg": 149.30679133318304,
            "smoothness_avg": 0.03673994756380158,
            "success_improvement": 0.0,
            "time_improvement": -4308.823926071554,
            "length_improvement": 18.162581752771686,
            "smoothness_improvement": 475.0599614465858,
            "objective_score": -1286.6393616636788
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.372148299217224,
            "num_nodes_avg": 2735.1,
            "path_length_avg": 224.34246383426563,
            "smoothness_avg": 0.07139481210628704,
            "success_improvement": 0.0,
            "time_improvement": -731.891550685451,
            "length_improvement": 25.10802823233759,
            "smoothness_improvement": 1737.039939099368,
            "objective_score": -205.86065986367092
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9890510320663453,
            "num_nodes_avg": 2200.9,
            "path_length_avg": 119.46629940291402,
            "smoothness_avg": 0.11199383220668539,
            "success_improvement": 0.0,
            "time_improvement": -1884.1989890505993,
            "length_improvement": 20.65617231044182,
            "smoothness_improvement": 1324.5532791442379,
            "objective_score": -554.5056958573701
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned and optimized bidirectional RRT* variant integrating adaptive rewiring radius, goal biasing, dynamic step sizing, and refined collision checks to improve planning efficiency, path quality, success rate, and robustness. It alternates growth of two trees from start and goal while adaptively rewiring locally for path shortening and attempts incremental connections within adaptive radii for faster convergence and smoother paths.",
    "planning_mechanism": "The planner samples points with a goal bias, grows two trees simultaneously by incrementally extending towards samples, dynamically adjusts the rewiring radius based on tree size, performs rewiring around new nodes to locally optimize the tree, and tries to connect the two trees through collision-checked edges within adaptive neighborhoods. The final path is extracted from merged trees upon successful connection.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, base_rewire_factor: float=30.0, min_step_size: float=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_rewire_factor = base_rewire_factor\n        self.min_step_size = min_step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_adaptive_rewire_radius(tree_size):\n            # Shrinks with tree growth but stays above step_size * 1.2 for localized rewiring\n            if tree_size <= 1:\n                return self.step_size * 2.0\n            gamma = self.base_rewire_factor\n            r = gamma * (math.log(tree_size) / tree_size) ** (1 / dim)\n            return max(r, self.step_size * 1.2)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            # Node inside obstacle or out-of-bounds disallowed\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect_edge(from_pos, to_pos):\n            if not can_add_node(to_pos):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_adaptive_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved_any = False\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if can_connect_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved_any = True\n            return improved_any\n\n        def extend(tree, target_pos, step_sz):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos, step_sz)\n            if not can_connect_edge(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate growing trees and attempt incremental connection with adaptive step sizing\n        for itr in range(self.max_iter):\n            # Dynamically reduce step size linearly to favor finer refinement in later iterations\n            step_sz = max(self.min_step_size, self.step_size * (1 - itr / self.max_iter))\n\n            for tree_a, tree_b, bias_target in [\n                (start_tree, goal_tree, goal_position),\n                (goal_tree, start_tree, start_position)\n            ]:\n                # Goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_bounds(sample):\n                        continue\n                    if self._is_in_obstacle(sample, obstacles, is_3d):\n                        continue\n\n                new_node = extend(tree_a, sample, step_sz)\n                if new_node is None:\n                    continue\n\n                # Attempt connection within adaptive radius from opposite tree\n                radius = get_adaptive_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= step_sz and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node:\n                    # Connect trees by attaching node from opposite tree as child of new_node\n                    conn_pos = best_connect_node.position\n                    conn_cost = new_node.cost + math.dist(new_node.position, conn_pos)\n                    conn_node = Node(conn_pos, parent=new_node, cost=conn_cost)\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire around connecting node\n                    rewire(tree_a, conn_node)\n\n                    # Extract path from start_tree root to conn_node\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    # Extract path from goal_tree root to best_connect_node\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    # Merge paths avoiding duplicated connecting node\n                    extracted_path = path_start + path_goal[1:]\n                    success_state = True\n                    break\n\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.31911,
    "time_improvement": 51.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 64.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.00920400619506836,
            "num_nodes_avg": 108.9,
            "path_length_avg": 182.8479047462968,
            "smoothness_avg": 0.011049775353405792,
            "success_improvement": -9.999999999999998,
            "time_improvement": 63.33551775555366,
            "length_improvement": -0.2218340019097853,
            "smoothness_improvement": 72.95297925203339,
            "objective_score": -30.678946577455687
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020600104331970216,
            "num_nodes_avg": 274.8,
            "path_length_avg": 296.1986414576328,
            "smoothness_avg": 0.00643369854301599,
            "success_improvement": 0.0,
            "time_improvement": 87.5107867372783,
            "length_improvement": 1.1203678762628302,
            "smoothness_improvement": 65.54369751755404,
            "objective_score": 26.80502808402382
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04904608726501465,
            "num_nodes_avg": 475.9,
            "path_length_avg": 156.81206160608994,
            "smoothness_avg": 0.012018474565363134,
            "success_improvement": 0.0,
            "time_improvement": 1.6054848405420448,
            "length_improvement": -4.147104730813277,
            "smoothness_improvement": 52.874109359905006,
            "objective_score": -0.08340494720051705
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an efficient bidirectional RRT* inspired planner with adaptive informed sampling, collision-aware extensions, rewiring to optimize paths, and path shortcutting for smoothness. It balances exploration and exploitation by sampling within an ellipsoidal informed subset, alternately growing two trees from start and goal, and refines the path for quality and robustness.",
    "planning_mechanism": "The planner initializes two trees from start and goal nodes, iteratively samples informed points biased around the current best solution, and grows each tree towards these samples using adaptive steps respecting obstacles and bounds. It rewires local nodes for cost improvements and tries to connect the trees when close. Once connected, it shortcuts the path to improve smoothness and returns the optimized route along with explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, shortcut_trials: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(s + g) / 2.0 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = 0.0 if c_best**2 - c_min**2 < 0 else math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_collision_free_point(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        success = False\n        best_path = []\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n            if not is_collision_free_point(sample):\n                continue\n\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_collision_free_point(new_pos):\n                continue\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_pos if active_tree is tree_start else start_pos)\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            neighbors = near_nodes(active_tree, new_pos, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if is_collision_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Prune nodes too costly\n            to_remove = [node for node in active_tree if node not in [start_root, goal_root, new_node]\n                         and node.cost + dist(node.position, goal_pos if active_tree is tree_start else start_pos) >= c_best]\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Attempt to connect to other tree\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if dist(other_nearest.position, new_node.position) <= self.step_size and is_collision_free_edge(new_node.position, other_nearest.position):\n                total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = other_nearest.path_from_root()\n                    best_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n        def shortcut_path(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.26269,
    "time_improvement": 33.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1377.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01788928508758545,
            "num_nodes_avg": 127.7,
            "path_length_avg": 163.2739687727461,
            "smoothness_avg": 0.04330001360213202,
            "success_improvement": -9.999999999999998,
            "time_improvement": 28.737403956653463,
            "length_improvement": 10.506950474057474,
            "smoothness_improvement": 577.7392403578652,
            "objective_score": -36.38869251640314
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.03112919330596924,
            "num_nodes_avg": 257.9,
            "path_length_avg": 238.65238592336794,
            "smoothness_avg": 0.09382923559181991,
            "success_improvement": -9.999999999999998,
            "time_improvement": 81.1273220936374,
            "length_improvement": 20.330964350725665,
            "smoothness_improvement": 2314.293814244219,
            "objective_score": -10.024141430542542
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.055481338500976564,
            "num_nodes_avg": 307.8,
            "path_length_avg": 121.74325281921783,
            "smoothness_avg": 0.1051479472012086,
            "success_improvement": 0.0,
            "time_improvement": -11.304687216005306,
            "length_improvement": 19.14392826820313,
            "smoothness_improvement": 1237.4741271852415,
            "objective_score": 6.624750124765242
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines the strengths of bidirectional anytime informed RRT* and adaptive lazy collision checking with accelerated neighbor search via KD-trees. It uses ellipsoidal informed sampling biased adaptively near the current best path, dynamically shrinks neighbor radius for rewiring, caches collision checks aggressively, and asynchronously grows smaller trees with incremental multi-step connections. Periodic aggressive pruning removes nodes unlikely to improve the solution to keep the search space manageable. After each successful connection, the path is shortcut-smoothed adaptively to enhance smoothness and length optimality. These strategies collectively reduce planning time, improve success rate, and yield shorter, smoother, and more reliable paths in 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, extending the smaller tree first each iteration. Sampling is adaptively biased near the best solution using ellipsoidal informed distribution and Gaussian perturbations along the path. New nodes connect using collision-checked incremental steering steps. KD-tree acceleration is used for nearest and radius neighbor searches for rewiring and connection attempts. Lazy collision checks with caching improve efficiency. Nodes estimated unlikely to improve the path cost are periodically pruned to control complexity. Upon finding better paths, shortcut smoothing improves path quality. The process iterates up to a max iteration limit to quickly find optimized, smooth, and feasible paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # Children nodes for rewiring/pruning\n        self.valid = True               # Validity flag for node removal/pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=120, collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio*(to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for di in range(self.dim):\n                        delta = p[di] - pt[di]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        # Edge collision cache key canonicalizer (order-independent)\n        def edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Informed ellipsoidal sampling biased inside ellipsoid defined by start, goal and c_best\n        def informed_sample(c_best, c_min, start, goal):\n            # Occasionally bias to goal sampling for faster convergence\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sample around best path with Gaussian noise, fallback to informed sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_pt = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_pt) and not is_in_obstacle(sample_pt):\n                        return sample_pt\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing tries to directly replace subpaths with shorter collision-free edges\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            iteration = 0\n            trials = self.smoothing_trials\n            while iteration < trials and len(smooth) >= 3:\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n                    iteration = 0  # reset after shortcut\n                else:\n                    iteration += 1\n            return smooth\n\n        # Remove nodes whose estimated total cost cannot beat best_cost to prune search space\n        def prune_nodes(node_list, best_cost, root_s, root_g):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in node_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                node.valid = False\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incrementally connect tree_b towards new_node \n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position)/self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nb in near_nodes_b:\n                    if nb is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nb.position)\n                    if new_cost_b + 1e-12 < nb.cost and can_connect(new_node_b.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nb))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connect_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connect_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if connect_cost + 1e-12 < c_best:\n                        c_best = connect_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path[:]\n                break\n\n            # Periodic pruning\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path[:]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -33.39447,
    "time_improvement": 74.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1641.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009571051597595215,
            "num_nodes_avg": 64.9,
            "path_length_avg": 159.74769245933928,
            "smoothness_avg": 0.045202918679287496,
            "success_improvement": 0.0,
            "time_improvement": 61.873379491124595,
            "length_improvement": 12.439758398859693,
            "smoothness_improvement": 607.5238370398619,
            "objective_score": 24.087584712308626
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031320714950561525,
            "num_nodes_avg": 249.0,
            "path_length_avg": 239.24149085001199,
            "smoothness_avg": 0.11227237052560837,
            "success_improvement": 0.0,
            "time_improvement": 81.0112083776487,
            "length_improvement": 20.134304169766747,
            "smoothness_improvement": 2788.8489601437436,
            "objective_score": 42.27446814796668
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011041569709777831,
            "num_nodes_avg": 120.6,
            "path_length_avg": 129.27773604973066,
            "smoothness_avg": 0.12796842619623125,
            "success_improvement": 0.0,
            "time_improvement": 77.84879571896218,
            "length_improvement": 14.139883260033287,
            "smoothness_improvement": 1527.7489355693867,
            "objective_score": 33.82136004554225
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with goal biasing and incremental rewiring for path cost optimization. It grows two trees from start and goal, alternates their expansions with goal-biased sampling to accelerate convergence, performs extensive collision checks for nodes and edges, and rewires locally to improve path quality and smoothness. The planner attempts frequent connections between the two trees, and when a connection is found, it extracts and returns the optimized path, maximizing planning efficiency, robustness, and success rate.",
    "planning_mechanism": "The planner initializes two trees from start and goal positions. Each iteration alternates between expanding the start and goal trees by sampling points with a bias toward the opposite root. It extends trees toward sampled points using collision-free steering, rewires neighbors within a specified radius to reduce costs, and attempts to connect the two trees. When connected, it reconstructs the path by merging branches, producing a smooth and optimized route. The process continues until a feasible path is found or the iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Accumulated cost from root\n        self.children = []\n        self.valid = True                  # Collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        current = self\n        while current:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        \n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d])**2 for d in range(dim)) <= r2]\n\n        def sample_free(tree):\n            # Goal biasing: biased sampling towards the opposite root of the tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree is start_tree else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n        \n        for iter_i in range(self.max_iter):\n            # Alternate expansions: expand start_tree first then goal_tree in each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                rand_point = sample_free(tree_a)\n\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewiring neighbors within radius\n                neighbors = near_nodes(tree_a, new_pos, self.rewire_radius)\n                for neighbor in neighbors:\n                    if neighbor is new_node or neighbor is nearest_node:\n                        continue\n                    potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            # Rewire\n                            if neighbor.parent:\n                                try:\n                                    neighbor.parent.children.remove(neighbor)\n                                    edges.remove((neighbor.parent, neighbor))\n                                except ValueError:\n                                    pass\n                            neighbor.parent = new_node\n                            neighbor.cost = potential_cost\n                            new_node.add_child(neighbor)\n                            edges.append((new_node, neighbor))\n\n                # Attempt connection to the other tree\n                nearest_other = nearest(tree_b, new_node.position)\n                connect_dist = dist(new_node.position, nearest_other.position)\n                if connect_dist <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                        # Connect nodes, choose parent from tree_a's new_node\n                        conn_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + connect_dist)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n\n                        # Extract paths from connected nodes\n                        path_from_start = conn_node.path_from_root()\n                        path_from_goal = nearest_other.path_from_root()\n\n                        # Ensure no duplicate nodes on connection\n                        final_path = path_from_start + path_from_goal[::-1][1:]\n                        success = True\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -17.36533,
    "time_improvement": 56.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 108.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015301656723022462,
            "num_nodes_avg": 141.1,
            "path_length_avg": 182.59532743368382,
            "smoothness_avg": 0.01241845552963865,
            "success_improvement": 0.0,
            "time_improvement": 39.04531251483982,
            "length_improvement": -0.08339237452297603,
            "smoothness_improvement": 94.37579614665101,
            "objective_score": 12.168794260280606
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03011958599090576,
            "num_nodes_avg": 277.1,
            "path_length_avg": 284.1700448208208,
            "smoothness_avg": 0.008985734378671919,
            "success_improvement": 0.0,
            "time_improvement": 81.73941613288278,
            "length_improvement": 5.135859657587952,
            "smoothness_improvement": 131.20941772609464,
            "objective_score": 26.205043860012896
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02689793109893799,
            "num_nodes_avg": 242.7,
            "path_length_avg": 154.91624743260792,
            "smoothness_avg": 0.015538644556578742,
            "success_improvement": 0.0,
            "time_improvement": 46.03832768612355,
            "length_improvement": -2.8879952257564,
            "smoothness_improvement": 97.6504118162468,
            "objective_score": 13.722151319767018
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a hybrid bidirectional RRT* algorithm combining adaptive elliptical informed sampling, dynamic adaptive step sizing based on obstacle proximity, efficient neighborhood rewiring for path optimization, pruning of suboptimal nodes, and multi-pass randomized shortcut smoothing for final path refinement. It aims to improve planning efficiency, path quality, robustness, and smoothness while reducing search time and path lengths.",
    "planning_mechanism": "The planner grows two trees alternatingly from start and goal positions, samples new nodes within a progressively shrinking informed ellipsoidal subset guided by the current best path cost, employs adaptive step sizing to safely extend trees near obstacles, performs rewiring of neighbors to improve path costs, prunes nodes unlikely to improve the current best solution, attempts to connect the two trees to update the best path, and applies multi-pass randomized shortcut smoothing on the extracted path before returning it.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, rewire_radius: float = 18.0,\n                 smoothing_passes: int = 3, smoothing_trials_per_pass: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.smoothing_passes = smoothing_passes\n        self.smoothing_trials_per_pass = smoothing_trials_per_pass\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Minimal possible cost estimate\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min < 1e-14:\n            # Start == goal\n            return PlannerResult(True, [start_pos], [], [])\n\n        # Initialization of trees and supporting data structures\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        # Precompute for elliptical informed sampling rotation matrix\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 < 1e-14:\n            C = np.eye(dim)\n        else:\n            a1_unit = a1 / norm_a1\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1_unit, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det_sign = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1.0] * (dim - 1) + [det_sign]) @ Vt\n\n        def informed_sample():\n            if best_cost == float('inf'):\n                # No solution yet, sample uniformly\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            val = best_cost ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if in_bounds(x_rand):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            samples = max(6, int(dist * 3))\n            reduction = 1.0\n            for i in range(1, samples + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / samples for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction = 0.35\n                    break\n            return max(self.step_size * reduction, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, node):\n            return [n for n in tree if n is not node and math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            neighs = neighbors(tree, new_node)\n            for near in neighs:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost:  # small epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, new_cost)\n                        # Update edges: replace old edge if exists\n                        replaced = False\n                        for i, (p, c) in enumerate(edges):\n                            if c == near:\n                                edges[i] = (new_node, near)\n                                replaced = True\n                                break\n                        if not replaced:\n                            edges.append((new_node, near))\n\n        def prune_nodes(tree, other_goal_pos):\n            nonlocal best_cost, all_nodes, edges\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                heuristic = node.cost + math.dist(node.position, other_goal_pos)\n                if heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in all_nodes:\n                    all_nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n\n        def try_connection(new_node, other_tree):\n            nonlocal best_cost, best_path, success\n            # Search for nodes in other_tree within step_size distance for potential connection\n            threshold = self.step_size * 1.1\n            for other_node in other_tree:\n                dist_conn = math.dist(new_node.position, other_node.position)\n                if dist_conn <= threshold:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_conn + other_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            # Build paths from roots\n                            if new_node in tree_start:\n                                path_from_start = new_node.path_from_root()\n                                path_from_goal = other_node.path_from_root()\n                            else:\n                                path_from_start = other_node.path_from_root()\n                                path_from_goal = new_node.path_from_root()\n                            # Avoid duplicate middle node if overlap\n                            if path_from_start[-1] == path_from_goal[-1]:\n                                combined_path = path_from_start + path_from_goal[-2::-1]\n                            else:\n                                combined_path = path_from_start + path_from_goal[::-1]\n                            best_path = combined_path\n                            success = True\n\n        def multi_pass_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_passes):\n                if len(smoothed) < 3:\n                    break\n                for _ in range(self.smoothing_trials_per_pass):\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) - 1)\n                    a, b = smoothed[i], smoothed[j]\n                    if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                        smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            # Occasionally apply goal bias on the alternate tree's root to improve chances of connection\n            if random.random() < 0.12 and tree_b:\n                sample = tree_b[0].position\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            rem_goal = math.dist(new_pos, goal_pos if tree_a is tree_start else start_pos)\n            if new_cost + rem_goal >= best_cost:\n                # Prune nodes that cannot improve current best\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune_nodes(tree_a, goal_pos if tree_a is tree_start else start_pos)\n\n            try_connection(new_node, tree_b)\n\n            # Early stop if found a stable solution after some iterations\n            if success and itr > 250 and itr % 40 == 0:\n                break\n\n        if success and best_path:\n            best_path = multi_pass_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 35.10755,
    "time_improvement": -96.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1406.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08166389465332032,
            "num_nodes_avg": 254.8,
            "path_length_avg": 161.72082807147913,
            "smoothness_avg": 0.038675306814774504,
            "success_improvement": 0.0,
            "time_improvement": -225.31099524175855,
            "length_improvement": 11.358251503511237,
            "smoothness_improvement": 505.3525364241922,
            "objective_score": -62.79488558970435
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06612634658813477,
            "num_nodes_avg": 405.4,
            "path_length_avg": 235.32303009898996,
            "smoothness_avg": 0.09310808159954675,
            "success_improvement": -9.999999999999998,
            "time_improvement": 59.90961834391457,
            "length_improvement": 21.442399155096993,
            "smoothness_improvement": 2295.7380025968055,
            "objective_score": -16.259944652822192
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1112788200378418,
            "num_nodes_avg": 405.5,
            "path_length_avg": 123.2688489268493,
            "smoothness_avg": 0.11916916805806417,
            "success_improvement": 0.0,
            "time_improvement": -123.24360934190717,
            "length_improvement": 18.130699974594332,
            "smoothness_improvement": 1415.823021545576,
            "objective_score": -26.267827699925405
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner incorporating adaptive informed sampling within an elliptical region refining as better paths are found, dynamic step sizing near obstacles, and cost-based pruning to focus the tree growth in promising regions. It balances exploration and exploitation through rewiring and prunes suboptimal nodes periodically. The planner attempts tree connections each iteration, performs collision checks for nodes and edges, and applies shortcut smoothing on the final path to improve smoothness and shorten path length.",
    "planning_mechanism": "The planner starts two trees from start and goal samples and iteratively grows them towards adaptive informed samples. Step sizes adapt near obstacles to improve safety and efficiency. Rewiring optimizes costs locally. Nodes unlikely to improve the best path are pruned to reduce computation. When trees connect within step size without collision, the path is extracted and shortcut smoothed. The process halts upon success or at max iterations, yielding an efficient, smooth, and valid path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(False, [], nodes, edges)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(tuple(x_rand), obstacles, is_3d):\n                        return tuple(x_rand)\n            # fallback uniform sampling\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance = dist(from_pos, to_pos)\n            if distance <= max_step:\n                return to_pos\n            ratio = max_step / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(5, int(distance * 2.5))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d])**2 for d in range(dim)) <= r2]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                heuristic_to_goal = dist(neighbor.position, goal)\n                if potential_cost + heuristic_to_goal >= best_cost:\n                    continue\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        new_node.add_child(neighbor)\n                        neighbor.cost = potential_cost\n                        edges.append((new_node, neighbor))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(tree):\n            retained = []\n            for node in tree:\n                heuristic = dist(node.position, goal)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        for it in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n            sample = informed_sample()\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic_remain = dist(new_pos, goal)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n\n            nearest_opposite = nearest(tree_b, new_node.position)\n            conn_dist = dist(new_node.position, nearest_opposite.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, nearest_opposite.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + nearest_opposite.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, nearest_opposite)\n                    success = True\n\n            if success and it > 0 and it % 200 == 0:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            if success and it % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 45.86743,
    "time_improvement": -65.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 881.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07372689247131348,
            "num_nodes_avg": 328.6,
            "path_length_avg": 175.77114261636177,
            "smoothness_avg": 0.014290070028637086,
            "success_improvement": 0.0,
            "time_improvement": -193.69366802480744,
            "length_improvement": 3.6570514599796184,
            "smoothness_improvement": 123.67062733191207,
            "objective_score": -56.75833697878675
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.09041371345520019,
            "num_nodes_avg": 468.7,
            "path_length_avg": 242.36863834321812,
            "smoothness_avg": 0.05669232206616034,
            "success_improvement": -9.999999999999998,
            "time_improvement": 45.184930570271135,
            "length_improvement": 19.090372326584685,
            "smoothness_improvement": 1358.734280591374,
            "objective_score": -25.832774960644844
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.07307331562042237,
            "num_nodes_avg": 405.7,
            "path_length_avg": 126.68523396753372,
            "smoothness_avg": 0.09898797479653224,
            "success_improvement": -9.999999999999998,
            "time_improvement": -46.597085771901206,
            "length_improvement": 15.861699701345419,
            "smoothness_improvement": 1159.1197328796245,
            "objective_score": -55.01118712690315
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified yet efficient bidirectional RRT* inspired planner with informed sampling and incremental rewiring for path cost optimization. It grows two trees from start and goal nodes, samples points within bounds, steers towards samples with step control, and ensures collision-free expansions and connections. The planner rewires nearby nodes to improve path quality and applies path shortcutting to smooth the result, balancing exploration and exploitation while maintaining robust collision checks.",
    "planning_mechanism": "The planner alternately expands the start and goal trees by sampling points biased to improve the current best path cost when found, steering towards samples stepwise, and rewiring near nodes for cost reduction. Upon successful tree connection, it extracts and shortcuts the path, returning an optimized collision-free route along with explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, shortcut_trials: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) / 2.0 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(center)\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n            r1 = c_best / 2.0\n            r2 = 0.0 if c_best**2 - c_min**2 < 0 else math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def is_collision_free_point(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        success = False\n        best_path = []\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n            sample = informed_sample()\n            if not is_collision_free_point(sample):\n                continue\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_collision_free_point(new_pos):\n                continue\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                continue\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_pos if active_tree is tree_start else start_pos)\n            if new_cost + heuristic >= c_best:\n                continue\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            neighbors = near_nodes(active_tree, new_pos, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor in {new_node, nearest_node}:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes in active tree too costly to improve\n            to_remove = [node for node in active_tree if node not in (start_root, goal_root, new_node) and \n                         node.cost + dist(node.position, goal_pos if active_tree is tree_start else start_pos) >= c_best]\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Try connecting trees\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if dist(other_nearest.position, new_node.position) <= self.step_size:\n                if is_collision_free_edge(new_node.position, other_nearest.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_start = new_node.path_from_root()\n                        path_goal = other_nearest.path_from_root()\n                        best_path = path_start + path_goal[::-1][1:]\n                        success = True\n                        break\n\n        def shortcut_path(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.65468,
    "time_improvement": 49.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1418.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.014847874641418457,
            "num_nodes_avg": 110.2,
            "path_length_avg": 168.02560638626102,
            "smoothness_avg": 0.039703341805664275,
            "success_improvement": -9.999999999999998,
            "time_improvement": 40.85296938959645,
            "length_improvement": 7.902502603573637,
            "smoothness_improvement": 521.4435164453308,
            "objective_score": -33.55639108017967
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.03644814491271973,
            "num_nodes_avg": 285.1,
            "path_length_avg": 235.505961827745,
            "smoothness_avg": 0.09173332784738633,
            "success_improvement": -9.999999999999998,
            "time_improvement": 77.90260439899409,
            "length_improvement": 21.38133127864069,
            "smoothness_improvement": 2260.364598358614,
            "objective_score": -11.05112943278056
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.035779595375061035,
            "num_nodes_avg": 250.2,
            "path_length_avg": 129.38135915086121,
            "smoothness_avg": 0.12363579153569766,
            "success_improvement": 0.0,
            "time_improvement": 28.220248834366153,
            "length_improvement": 14.071061730264201,
            "smoothness_improvement": 1472.6381424892238,
            "objective_score": 18.643477708808806
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates a bidirectional informed RRT* framework leveraging ellipsoidal informed sampling to focus on promising regions, KD-tree based nearest neighbor and radius searches for efficient rewiring, collision caching to reduce redundant checks, dynamic neighbor radius adjusting with iteration and node count, and incremental rewiring to minimize path cost. It applies aggressive shortcut smoothing on the best path found and periodically prunes non-promising nodes to maintain responsiveness. The design addresses both 2D and 3D maps and balances exploration versus exploitation to optimize success rate, path quality, smoothness, and computation time.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal toward samples drawn from an informed ellipsoid defined by the current best path cost. KD-trees speed up nearest and near neighbor searches for rewiring and cost improvement. Each extension checks bounds, node and edge collisions with caching for efficiency. Incremental connections attempt to connect opposite trees to form complete paths. Pruning removes nodes unlikely to improve current solutions. After a successful connection, aggressive shortcut smoothing refines the path for length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Uniform or ellipsoidal informed sampling\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Try uniform samples inside map bounds\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Init start & goal roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Grow smaller tree first (to balance growth)\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to improve best solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.30842,
    "time_improvement": 62.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1476.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01131894588470459,
            "num_nodes_avg": 74.0,
            "path_length_avg": 159.7818972852484,
            "smoothness_avg": 0.04058633842817909,
            "success_improvement": 0.0,
            "time_improvement": 54.910581151285484,
            "length_improvement": 12.421010191768755,
            "smoothness_improvement": 535.2643310455434,
            "objective_score": 21.63369803896711
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022147941589355468,
            "num_nodes_avg": 201.3,
            "path_length_avg": 234.46853282417,
            "smoothness_avg": 0.09926323515898369,
            "success_improvement": 0.0,
            "time_improvement": 86.57238034418691,
            "length_improvement": 21.72765494077222,
            "smoothness_improvement": 2454.1145370590284,
            "objective_score": 42.58781777670566
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027123904228210448,
            "num_nodes_avg": 179.5,
            "path_length_avg": 129.2320184826669,
            "smoothness_avg": 0.12097875442834927,
            "success_improvement": 0.0,
            "time_improvement": 45.58498843453988,
            "length_improvement": 14.170246691240443,
            "smoothness_improvement": 1438.840826605831,
            "objective_score": 23.703750001639207
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid Anytime RRT* planner with incremental informed resampling and progressive path refinement. It combines bidirectional tree growth, adaptive sampling biased by a dynamically shrinking ellipsoidal informed set derived from the best-found solution, and hierarchical shortcut smoothing interleaved during planning. The step size adapts according to proximity to obstacles, promoting safe and efficient exploration. Collision checks ensure validity of nodes and edges, while periodic pruning removes non-promising branches. This approach aims for rapid convergence to high-quality, smooth paths with improved success and reduced search time.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending them towards samples drawn mostly from the informed ellipsoidal region that shrinks as better solutions appear, enhancing focus on promising areas. Step size adapts dynamically near obstacles to avoid collisions. When trees connect, the path is extracted and progressively improved through hierarchical shortcut smoothing during the search, balancing exploration, exploitation, and refinement to achieve fast, robust path planning with smooth, cost-efficient paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def total_cost(self):\n        return self.cost\nclass Planner:\n    def __init__(self, max_iter: int = 6000, base_step: float = 5.0, goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = 250\n        self.smooth_interval = 500\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        nodes_start = [Node(start)]\n        nodes_goal = [Node(goal)]\n        nodes_all = [nodes_start[0], nodes_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes_all, edges)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for informed sampling (Householder transform)\n        e1 = np.zeros(dim)\n        e1[0] = 1.0\n        v = a1_unit + e1\n        if np.linalg.norm(v) == 0:\n            C = np.eye(dim)\n        else:\n            v /= np.linalg.norm(v)\n            C = np.eye(dim) - 2 * np.outer(v, v)\n\n        def in_bounds(point):\n            return all(0 <= point[d] <= bounds[d] for d in range(dim))\n\n        def adapt_step_size(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            step = self.base_step\n            # Check for obstacles along path; reduce step if near obstacle\n            check_n = max(5, int(dist*2))\n            for i in range(1, check_n + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / check_n) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.3, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, max_step) -> tuple:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest_node(tree_nodes, sample_pos):\n            return min(tree_nodes, key=lambda n: math.dist(n.position, sample_pos))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:  # same connecting node\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_trials = 80\n            trial = 0\n            while trial < max_trials and len(path) >= 3:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n                trial += 1\n            return path\n\n        def informed_sample():\n            # With probability goal_sample_rate sample goal position\n            if random.random() < self.goal_sample_rate:\n                return goal\n\n            if best_cost == float('inf'):\n                # Uniform sample inside bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample inside informed ellipsoid\n            for _ in range(100):\n                # radii of prolate hyperspheroid\n                r1 = best_cost / 2.0\n                r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n\n                L = np.diag([r1] + [r2] * (dim - 1))\n                # Sample unit ball uniformly\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand_c = C @ (L @ x_ball) + x_center\n                if in_bounds(x_rand_c):\n                    return tuple(x_rand_c)\n\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.8):\n                return False\n            return True\n\n        def rewire(tree_nodes, new_node, edges):\n            radius = max(self.base_step * 2.0, (math.log(len(tree_nodes)+1) / (len(tree_nodes)+1)) ** (1 / dim))\n            neighbors = [n for n in tree_nodes if n != new_node and math.dist(n.position, new_node.position) <= radius]\n            for n in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost + 1e-7 < n.cost and can_connect_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    new_node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((new_node, n))\n\n        def prune_tree(tree_nodes, edges, cost_limit):\n            retained = []\n            for node in tree_nodes:\n                h = math.dist(node.position, goal)\n                if node.cost + h < cost_limit:\n                    retained.append(node)\n                else:\n                    # Remove from parent's children if valid\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        def progressive_shortcut(path):\n            # Progressive smoothing during search: one pass limited shortcutting\n            max_attempts = 10\n            count = 0\n            while count < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n                count += 1\n            return path\n\n        for iteration in range(self.max_iter):\n            # Alternate tree expansion\n            if iteration % 2 == 0:\n                tree_from, tree_to = nodes_start, nodes_goal\n            else:\n                tree_from, tree_to = nodes_goal, nodes_start\n\n            sample = informed_sample()\n            nearest = nearest_node(tree_from, sample)\n            step = adapt_step_size(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect_edge(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Heuristic pruning to avoid exploring costly nodes\n            heuristic_remain = math.dist(new_pos, goal)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_from, new_node, edges)\n\n            # Attempt to connect to nearest node in opposite tree\n            nearest_to = nearest_node(tree_to, new_pos)\n            dist_connect = math.dist(new_pos, nearest_to.position)\n            if dist_connect <= self.base_step and can_connect_edge(new_pos, nearest_to.position):\n                total_cost = new_node.cost + dist_connect + nearest_to.cost\n                if total_cost + 1e-7 < best_cost:\n                    best_cost = total_cost\n                    path_candidate = extract_path(new_node, nearest_to)\n                    best_path = progressive_shortcut(path_candidate)\n                    success = True\n\n            # Periodic pruning for efficiency\n            if success and iteration > 0 and iteration % self.prune_interval == 0:\n                nodes_start = prune_tree(nodes_start, edges, best_cost)\n                nodes_goal = prune_tree(nodes_goal, edges, best_cost)\n            \n            # Periodic progressive smoothing of best path during planning\n            if success and iteration > 0 and iteration % self.smooth_interval == 0 and best_path:\n                best_path = progressive_shortcut(best_path)\n\n            # Early stop heuristic: if solution found and stable quality\n            if success and iteration > self.max_iter // 3:\n                if best_cost < float('inf'):\n                    break\n\n        final_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 98.81025,
    "time_improvement": -284.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 166.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.17673847675323487,
            "num_nodes_avg": 702.2,
            "path_length_avg": 169.36362265083898,
            "smoothness_avg": 0.00801215128655973,
            "success_improvement": 0.0,
            "time_improvement": -604.0439353790923,
            "length_improvement": 7.169114686733952,
            "smoothness_improvement": 25.407566299653816,
            "objective_score": -179.65231984488264
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1836545705795288,
            "num_nodes_avg": 931.1,
            "path_length_avg": 261.6998162843071,
            "smoothness_avg": 0.012578761627119826,
            "success_improvement": 0.0,
            "time_improvement": -11.344149606155794,
            "length_improvement": 12.63706871274354,
            "smoothness_improvement": 223.66059678158052,
            "objective_score": 0.24247184460987237
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.1683452844619751,
            "num_nodes_avg": 946.0,
            "path_length_avg": 127.5506512449306,
            "smoothness_avg": 0.027361996865118227,
            "success_improvement": -9.999999999999998,
            "time_improvement": -237.72831978449412,
            "length_improvement": 15.286930752440735,
            "smoothness_improvement": 248.0425804717818,
            "objective_score": -117.02089688250119
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm integrates goal biasing, bidirectional growth, incremental connection attempts, and a rewiring step inspired by RRT* concepts to enhance planning efficiency, path quality, and robustness. It samples with goal bias, grows two trees alternately from start and goal, and attempts incremental connections. After connecting, a local path smoothing is applied to the final path to improve smoothness and shorten length. The rewiring step reduces unnecessary detours, increasing success rate and path optimality.",
    "planning_mechanism": "The planner alternates between extending start and goal trees toward biased/random samples, verifies collision-free extensions, incrementally tries to connect trees, and upon successful connection, rewires neighboring nodes to improve path quality. Finally, it extracts and smooths the path, providing a feasible, efficient, and smooth route while avoiding obstacles and respecting bounds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, rewire_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if math.dist(n.position, position) <= radius]\n\n        def rewire(tree, new_node, obstacles, is_3d):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                # Attempt rewire: check if new_node->neighbor path is better and collision free\n                dist_new_to_neighbor = math.dist(new_node.position, neighbor.position)\n                proposed_cost = new_node.cost + dist_new_to_neighbor\n                if proposed_cost < neighbor.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)):\n                        # Rewire neighbor\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = proposed_cost\n                        new_node.add_child(neighbor)\n                        # Update costs recursively downstream\n                        self._update_costs(neighbor)\n\n        start_grows = True # flag to alternate expansion\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, tree_a_start_flag in [(start_tree, goal_tree, start_grows), (goal_tree, start_tree, not start_grows)]:\n                # Sample with goal biasing: towards goal if extending start_tree, else towards start\n                if (random.random() < self.goal_sample_rate):\n                    sample = goal_pos if tree_a_start_flag else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire nearby nodes to improve path costs in this tree\n                rewire(tree_a, new_node, obstacles, is_3d)\n\n                # Incremental attempts to connect tree_b toward new_node\n                # Grow tree_b step-wise from its nearest node toward new_node\n                connect_node_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                current_b_node = connect_node_b\n                reached_connection = False\n\n                while True:\n                    next_pos = steer(current_b_node.position, new_pos, self.step_size)\n                    if not in_bounds(next_pos):\n                        break\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                        break\n                    if self._is_edge_in_obstacle(current_b_node.position, next_pos, obstacles, is_3d):\n                        break\n\n                    temp_node = Node(next_pos, parent=current_b_node, cost=current_b_node.cost + math.dist(current_b_node.position, next_pos))\n                    current_b_node.add_child(temp_node)\n                    tree_b.append(temp_node)\n                    nodes.append(temp_node)\n                    edges.append((current_b_node, temp_node))\n                    current_b_node = temp_node\n\n                    # Rewire nearby nodes in tree_b\n                    rewire(tree_b, current_b_node, obstacles, is_3d)\n\n                    dist_to_new_node = math.dist(current_b_node.position, new_pos)\n                    if dist_to_new_node <= self.step_size:\n                        # Final connection step - connect current_b_node to new_node\n                        if not self._is_edge_in_obstacle(current_b_node.position, new_pos, obstacles, is_3d):\n                            final_node = Node(new_pos, parent=current_b_node, cost=current_b_node.cost + dist_to_new_node)\n                            current_b_node.add_child(final_node)\n                            tree_b.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current_b_node, final_node))\n                            # Merge trees at new_node and final_node\n                            # Extract path: from start root (depending on which tree new_node is) and from goal root\n                            if tree_a is start_tree:\n                                path = self._extract_path(new_node, final_node)\n                            else:\n                                path = self._extract_path(final_node, new_node)\n\n                            # Smooth path\n                            path = self._smooth_path(path, obstacles, is_3d)\n\n                            return PlannerResult(True, path, nodes, edges)\n                        break  # cannot connect edge\n\n            start_grows = not start_grows\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _update_costs(self, node):\n        # Recursively update cost of children based on parent's cost\n        for child in node.children:\n            dist = math.dist(node.position, child.position)\n            new_cost = node.cost + dist\n            if new_cost < child.cost:\n                child.cost = new_cost\n                self._update_costs(child)\n\n    def _extract_path(self, node_a: Node, node_b: Node):\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        return path_a + path_b[1:]  # avoid duplication\n\n    def _smooth_path(self, path: \"List[Tuple[float, ...]]\", obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path) - 1\n            while j > i +1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -34.50561,
    "time_improvement": 76.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1611.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008003616333007812,
            "num_nodes_avg": 72.4,
            "path_length_avg": 159.13025723919287,
            "smoothness_avg": 0.04501115055604358,
            "success_improvement": 0.0,
            "time_improvement": 68.11731297071924,
            "length_improvement": 12.7781844269091,
            "smoothness_improvement": 604.5222494799498,
            "objective_score": 26.01344202399734
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02314436435699463,
            "num_nodes_avg": 293.9,
            "path_length_avg": 233.30529175846755,
            "smoothness_avg": 0.10243108935674967,
            "success_improvement": 0.0,
            "time_improvement": 85.96827969283419,
            "length_improvement": 22.115978290541317,
            "smoothness_improvement": 2535.6257072806984,
            "objective_score": 42.891808102362006
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01260359287261963,
            "num_nodes_avg": 231.8,
            "path_length_avg": 122.50696116041638,
            "smoothness_avg": 0.14103405451702689,
            "success_improvement": 0.0,
            "time_improvement": 74.71512042810379,
            "length_improvement": 18.636709551862292,
            "smoothness_improvement": 1693.942763405543,
            "objective_score": 34.61159185583131
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a sampling-based anytime planner combining informed sampling, batch node addition, lazy collision checking, and dynamic path refinement. It grows a single tree from the start using informed sampling biased toward the goal, batches multiple node expansions for efficiency, postpones expensive edge collision checks until connecting promising nodes, and continuously improves the solution by rewiring and smoothing. This approach balances exploration and exploitation for fast convergence to high-quality, smooth paths in complex environments.",
    "planning_mechanism": "The planner uses an informed ellipse-based sampling to guide exploration. Each iteration generates multiple candidate nodes toward the goal region, adding collision-free nodes in batches after lazy validation. It then attempts rewiring within a dynamic neighborhood radius to reduce path costs. When a path to the goal is found, a smoothing procedure is triggered iteratively to shortcut the path. The process repeats to improve path quality within the iteration budget, terminating with an optimized solution or failure.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        if new_cost < self.cost:\n            # Remove from old parent's children list\n            if self.parent:\n                try:\n                    self.parent.children.remove(self)\n                except ValueError:\n                    pass\n            self.parent = new_parent\n            self.cost = new_cost\n            new_parent.children.append(self)\n            # Recursively update children's costs\n            for child in self.children:\n                child.update_cost(child.cost - self.cost + new_cost, self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, batch_size: int = 10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        root = Node(start_position)\n        nodes = [root]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        path_found = False\n        best_goal_node = None\n\n        def heuristic(p):\n            return dist(p, goal_position)\n\n        def informed_sample():\n            if not path_found:\n                # Uniform random sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed sampling within ellipsoid guiding towards goal based on c_best\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(diff)\n            if length < 1e-10:\n                return tuple(center)\n            a1 = diff / length\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball = x_ball / norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball = x_ball * radius\n                sample = C @ L @ x_ball + center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def find_nearest(tree_nodes, point):\n            return min(tree_nodes, key=lambda n: dist(n.position, point))\n\n        def neighbors_within_radius(point, radius):\n            return [node for node in nodes if dist(node.position, point) <= radius]\n\n        def path_from_node_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def is_collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n        \n        def is_collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i +1:\n                    if is_collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n        \n        # Dynamic neighborhood radius based on number of nodes and tree dimension\n        def dynamic_radius():\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( ( (math.factorial(dim)/ (math.pi ** (dim/2))) )**(1/dim) )\n            r = min(self.step_size * 5.0, gamma_rrt_star * (math.log(len(nodes)+1)/ (len(nodes)+1))**(1/dim))\n            return max(r, self.step_size)\n\n        iter_counter = 0\n\n        while iter_counter < self.max_iter:\n            batch_samples = [informed_sample() for _ in range(self.batch_size)]\n            candidate_nodes = []\n\n            # Batch extend\n            for sample in batch_samples:\n                nearest_node = find_nearest(nodes, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                # Bounds check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                # Node collision check - lazy check; skip those in obstacles\n                if not is_collision_free_node(new_pos):\n                    continue\n                \n                # Estimate new cost to node\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                # Prune using heuristic estimate if path is not promising\n                if new_cost + heuristic(new_pos) >= c_best:\n                    continue\n\n                candidate_nodes.append( (new_pos, nearest_node, new_cost) )\n\n            # Lazy edge collision check and addition\n            for pos, parent_node, cost_val in candidate_nodes:\n                if not is_collision_free_edge(parent_node.position, pos):\n                    continue\n                new_node = Node(pos, parent_node, cost_val)\n                parent_node.add_child(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                \n                # Rewiring phase within radius\n                r = dynamic_radius()\n                neighbor_nodes = neighbors_within_radius(new_node.position, r)\n                for neighbor in neighbor_nodes:\n                    if neighbor == new_node or neighbor == parent_node:\n                        continue\n                    potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost:\n                        if is_collision_free_edge(new_node.position, neighbor.position):\n                            neighbor.update_cost(potential_cost, new_node)\n\n                # Check if new node can connect directly to goal\n                if dist(new_node.position, goal_position) <= self.step_size and is_collision_free_edge(new_node.position, goal_position):\n                    goal_node = Node(goal_position, new_node, new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    total_cost = goal_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        best_goal_node = goal_node\n                        path_found = True\n\n            iter_counter += self.batch_size\n\n            # If path found -> try to improve and smooth\n            if path_found:\n                current_path = path_from_node_to_root(best_goal_node)\n                smoothed_path = smooth_path(current_path)\n                # Replace best path if improved\n                if len(smoothed_path) < len(current_path) or sum(dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1)) + 1e-6 < c_best:\n                    c_best = sum(dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1))\n                    # Rebuild tree path costs along smoothed path:\n                    # (Note: For efficiency and since smoothed path is a shortcut, update cost and parent for nodes on path)\n                    prev_node = None\n                    total_c = 0.0\n                    # Mark previous best_goal_node invalid to avoid conflict\n                    best_goal_node.valid = False\n                    new_nodes_to_add = []\n                    for pos_i in smoothed_path:\n                        node_i = Node(pos_i)\n                        if prev_node:\n                            cost_seg = dist(prev_node.position, node_i.position)\n                            node_i.parent = prev_node\n                            node_i.cost = prev_node.cost + cost_seg\n                            prev_node.children = [node_i]  # overwrite children to single child on smoothed path\n                        else:\n                            node_i.cost = 0.0\n                        new_nodes_to_add.append(node_i)\n                        prev_node = node_i\n                    # Replace best_goal_node\n                    best_goal_node = new_nodes_to_add[-1]\n                    nodes.extend(new_nodes_to_add)\n                    edges = []\n                    for idx in range(len(new_nodes_to_add)-1):\n                        edges.append((new_nodes_to_add[idx], new_nodes_to_add[idx+1]))\n                    extracted_path = [node.position for node in new_nodes_to_add]\n                else:\n                    extracted_path = current_path\n                # Continue looping to try further improvements until max_iter exhausted\n\n        success_state = path_found\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1283.64315,
    "time_improvement": -4263.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1690.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.8758091926574707,
            "num_nodes_avg": 1581.7,
            "path_length_avg": 160.25347015608887,
            "smoothness_avg": 0.058936405283119955,
            "success_improvement": -9.999999999999998,
            "time_improvement": -7372.351862932254,
            "length_improvement": 12.162533628710763,
            "smoothness_improvement": 822.4827251333297,
            "objective_score": -2255.160638528267
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.3241263389587403,
            "num_nodes_avg": 3297.4,
            "path_length_avg": 234.9674026767681,
            "smoothness_avg": 0.10177022776948333,
            "success_improvement": 0.0,
            "time_improvement": -1309.0467227254185,
            "length_improvement": 21.561117824802437,
            "smoothness_improvement": 2518.621262640974,
            "objective_score": -375.80868693946013
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.0976606130599977,
            "num_nodes_avg": 3112.5,
            "path_length_avg": 121.46330201069334,
            "smoothness_avg": 0.14386124556112403,
            "success_improvement": 0.0,
            "time_improvement": -4108.252084939648,
            "length_improvement": 19.32985826540013,
            "smoothness_improvement": 1729.904424804923,
            "objective_score": -1219.9601317047895
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes bidirectional RRT* with informed sampling, goal bias, adaptive step sizing, incremental rewiring, pruning, and path shortcutting to enhance efficiency, robustness, path quality, and smoothness. It grows two trees simultaneously from start and goal, focusing exploration within an informed ellipsoidal region constrained by the current best path. Alternating expansions employ adaptive steering near obstacles and continuous rewiring optimizes local costs. Pruning removes non-promising nodes, and path shortcutting smooths the final route, collectively improving convergence speed, success rate, and path optimality.",
    "planning_mechanism": "The planner initializes two trees from start and goal points and iteratively samples points biased to the informed ellipsoidal subset defined by the current best solution cost. It alternates expansions between the trees, steering adaptively toward samples with collision checks. It rewires neighbors within a radius to optimize the path cost and prunes nodes that cannot contribute to better solutions. When the trees connect with a lower-cost path, it extracts and shortcut-smooths the final path. The process halts on finding a valid, optimized path or exhausting iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start, tree_goal = [start_root], [goal_root]\n\n        nodes.extend([start_root, goal_root])\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) **2 for d in range(dim)) <= r2]\n\n        def informed_sample():\n            nonlocal c_best\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            x_center = np.array([(s + g) / 2 for s,g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # fallback to uniform sampling\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def rewire(new_node, tree):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # update edges\n                        for idx, e in enumerate(edges):\n                            if e[1] == neighbor:\n                                edges[idx] = (new_node, neighbor)\n                                break\n\n        def prune(tree):\n            nonlocal c_best\n            to_remove = []\n            for node in tree:\n                if node.cost + dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing integrated into sampling occasionally\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if active_tree is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            nearest = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            # Prune paths that are already longer than best solution\n            if new_cost + dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors to optimize\n            rewire(new_node, active_tree)\n\n            # Prune unlikely nodes to speed convergence\n            prune(active_tree)\n\n            # Try connecting the two trees\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -9.67169,
    "time_improvement": -6.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1727.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04750416278839111,
            "num_nodes_avg": 202.9,
            "path_length_avg": 169.91407991269716,
            "smoothness_avg": 0.057176499522051706,
            "success_improvement": 0.0,
            "time_improvement": -89.2345024740956,
            "length_improvement": 6.867400338955985,
            "smoothness_improvement": 794.936378276083,
            "objective_score": -21.422188783057074
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06947968006134034,
            "num_nodes_avg": 373.5,
            "path_length_avg": 239.63816252776397,
            "smoothness_avg": 0.10620479028780665,
            "success_improvement": 0.0,
            "time_improvement": 57.87659481097589,
            "length_improvement": 20.001883746171956,
            "smoothness_improvement": 2632.725750323709,
            "objective_score": 34.5269839441457
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04269857406616211,
            "num_nodes_avg": 274.0,
            "path_length_avg": 129.13921068209606,
            "smoothness_avg": 0.14562963379795335,
            "success_improvement": 0.0,
            "time_improvement": 14.339639968852659,
            "length_improvement": 14.231885213347029,
            "smoothness_improvement": 1752.39819264855,
            "objective_score": 15.910259996567955
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid enhanced bidirectional RRT* planner incorporating adaptive informed sampling, dynamic rewiring radius, incremental step sizing, and advanced collision-aware rewiring. It combines rapid exploration with focused exploitation by sampling within an ellipsoidal informed subset biased by the current best solution, grows two trees from start and goal simultaneously, and maintains path quality through continual rewiring and shortcutting for smoother, shorter paths. The planner gracefully balances efficient search, robustness against obstacles, and improved convergence speed.",
    "planning_mechanism": "The planner alternates expansion of two trees while drawing samples adaptively from an informed subset shaped by the current best path cost. It uses dynamic adaptive rewiring radii dependent on tree size and geometry to locally optimize connections, steering increments that shrink progressively for finer resolution, and performs collision checks both for nodes and edges rigorously. Upon successful connection of the two trees, the merged path is shortcut multiple times to refine smoothness and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_rewire_factor: float=30.0, min_step_size: float=1.5, shortcut_trials: int=150, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_factor = base_rewire_factor\n        self.min_step_size = min_step_size\n        self.shortcut_trials = shortcut_trials\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import math\n        import random\n        import numpy as np\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def get_adaptive_rewire_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.5\n            gamma = self.base_rewire_factor\n            r = gamma * (math.log(tree_size) / tree_size) ** (1 / dim)\n            return max(r, self.step_size * 1.5)\n\n        def is_collision_free_point(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_collision_free_edge(p1, p2):\n            if not is_collision_free_point(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.4)\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def informed_sample(c_best):\n            # Ellipsoidal informed sampler as per sampling within an ellipsoid around start-goal if path exists\n            if c_best == float('inf'):\n                # Uniform sampling if no solution yet\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_collision_free_point(sample):\n                        return sample\n\n            c_min = dist(start_position, goal_position)\n            center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            radicand = c_best**2 - c_min**2\n            r2 = math.sqrt(radicand) / 2.0 if radicand > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            max_tries = 100\n            for _ in range(max_tries):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_sample = random.random() ** (1/dim)\n                sample_point = C @ (L @ (x_ball * radius_sample)) + center\n                sample = tuple(sample_point)\n                if is_collision_free_point(sample):\n                    return sample\n            # Fallback if informed sampling fails repeatedly\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_collision_free_point(sample):\n                    return sample\n\n        # Initialize trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_best = float('inf')\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            step_sz = max(self.min_step_size, self.step_size * (1 - itr / self.max_iter))  # dynamic decreasing step size\n\n            # Alternate tree growth\n            if itr % 2 == 0:\n                active_tree, other_tree = tree_start, tree_goal\n                goal_node = goal_position\n            else:\n                active_tree, other_tree = tree_goal, tree_start\n                goal_node = start_position\n\n            sample = None\n            # Goal bias to improve success rate\n            if random.random() < self.goal_sample_rate:\n                sample = goal_node\n                if not is_collision_free_point(sample):\n                    sample = None\n\n            if sample is None:\n                sample = informed_sample(c_best)\n\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, step_sz)\n\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_position if active_tree is tree_start else start_position)\n\n            # Prune paths which cannot improve the best solution\n            if new_cost + heuristic >= c_best:\n                continue\n\n            # Create new node and add it to active tree\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius depending on tree size\n            radius = get_adaptive_rewire_radius(len(active_tree))\n            neighbors = near_nodes(active_tree, new_pos, radius)\n\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if is_collision_free_edge(new_node.position, neighbor.position):\n                        # Rewire neighbor to new_node if beneficial\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect trees via nearest nodes from opposite tree within step size\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            connection_dist = dist(new_node.position, other_nearest.position)\n\n            if connection_dist <= step_sz and is_collision_free_edge(new_node.position, other_nearest.position):\n                total_cost = new_node.cost + connection_dist + other_nearest.cost\n                if total_cost + 1e-9 < c_best:\n                    # Update best solution cost and build merged path\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = other_nearest.path_from_root()\n                    path_goal.reverse()\n                    extracted_path = path_start + path_goal[1:]\n                    success_state = True\n\n            if success_state:\n                break\n\n        # Path shortcutting for smoothness and path length reduction\n        def shortcut_path(path):\n            path = list(path)\n            length = len(path)\n            for _ in range(self.shortcut_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if is_collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n                    length = len(path)\n            return path\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.96396,
    "time_improvement": -35.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1415.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03548355102539062,
            "num_nodes_avg": 156.5,
            "path_length_avg": 167.96711863917352,
            "smoothness_avg": 0.03947379983897356,
            "success_improvement": 0.0,
            "time_improvement": -41.34997293215943,
            "length_improvement": 7.934560664549956,
            "smoothness_improvement": 517.8506862082623,
            "objective_score": -8.228826315696525
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04521968364715576,
            "num_nodes_avg": 295.5,
            "path_length_avg": 231.71110267255168,
            "smoothness_avg": 0.09621255433622898,
            "success_improvement": 0.0,
            "time_improvement": 72.58468871608267,
            "length_improvement": 22.648164493608647,
            "smoothness_improvement": 2375.6183221729693,
            "objective_score": 38.183131124411375
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.11795227527618408,
            "num_nodes_avg": 529.0,
            "path_length_avg": 125.04131646757932,
            "smoothness_avg": 0.11403564183868442,
            "success_improvement": -9.999999999999998,
            "time_improvement": -136.63165779247987,
            "length_improvement": 16.95351142987586,
            "smoothness_improvement": 1350.5249469525559,
            "objective_score": -80.84617031700601
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned hybrid bidirectional RRT* algorithm with adaptive rewiring radius, goal biasing and incremental tree connection attempts. It dynamically adjusts the rewiring radius to balance exploration and exploitation while ensuring collision-free nodes and edges. The planner alternately expands the start and goal trees toward random samples with a goal bias to accelerate convergence. On successful connection, it extracts an optimized and smoothed path to achieve improved path quality, smoothness, robustness, success rate, and reduced planning time.",
    "planning_mechanism": "The planner grows two trees rooted at the start and goal. Each iteration alternates between expanding one tree by steering towards a random sample (biased occasionally toward the opposite root). Upon adding a new node, an adaptive rewiring step improves local path costs. The planner attempts an incremental connection from the new node to nearby nodes in the opposite tree within an adaptive radius, performing rigorous collision checks. If connected, the two trees are merged, and the path is extracted. The adaptive rewiring radius decreases with tree size to refine paths as search proceeds.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_factor: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # base factor for adaptive rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                    # Tuple[int, ...]\n        start_position = map.start           # Tuple[float, ...]\n        goal_position = map.goal             # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_rewire_radius(tree_size):\n            import math\n            gamma = self.rewire_factor\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)\n\n        def near_nodes(tree, pos, radius):\n            import math\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                import math\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.5):\n                        # Remove old edge if exists\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def extend(tree, target_pos):\n            import math\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n\n            if not can_connect(nearest.position, new_pos):\n                return None\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree, new_node)\n            return new_node\n\n        # Initialize trees and data\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        import random\n\n        # Main planning loop with alternating tree expansion and goal biasing\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                # Sample point with goal biasing\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = extend(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Attempt incremental connection from opposite tree\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                import math\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d, resolution=0.5):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node is not None:\n                    # Connect trees by attaching best_connect_node as child of new_node\n                    conn_pos = best_connect_node.position\n                    conn_cost = new_node.cost + math.dist(new_node.position, conn_pos)\n                    conn_node = Node(conn_pos, parent=new_node, cost=conn_cost)\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire near new connecting node for improved local paths\n                    rewire(tree_a, conn_node)\n\n                    # Extract path from start root to connection\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    # Extract path from goal root to best_connect_node\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    # Merge paths without duplicate connecting node\n                    extracted_path = path_start + path_goal[1:]\n                    success_state = True\n                    break\n            if success_state:\n                break\n\n        # Optional: path shortcutting for smoothness\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.68891,
    "time_improvement": 47.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1657.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02569713592529297,
            "num_nodes_avg": 121.8,
            "path_length_avg": 166.67849111084993,
            "smoothness_avg": 0.0572067390255143,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2.365444339972083,
            "length_improvement": 8.64087783243401,
            "smoothness_improvement": 795.4096921714054,
            "objective_score": -45.004409274647784
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.02362954616546631,
            "num_nodes_avg": 255.5,
            "path_length_avg": 233.76020943921534,
            "smoothness_avg": 0.10587894463342187,
            "success_improvement": -19.999999999999996,
            "time_improvement": 85.67412880021993,
            "length_improvement": 21.964113674628283,
            "smoothness_improvement": 2624.3415069392504,
            "objective_score": -56.7832310903121
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02142367362976074,
            "num_nodes_avg": 301.1,
            "path_length_avg": 128.9972697607164,
            "smoothness_avg": 0.1297101299916341,
            "success_improvement": 0.0,
            "time_improvement": 57.020588240921256,
            "length_improvement": 14.326155614827055,
            "smoothness_improvement": 1549.9032792877094,
            "objective_score": 27.720923991680337
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines bidirectional RRT* with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated queries, and collision caching for efficiency. It grows two trees rooted at start and goal, extending the smaller tree towards informed samples within an ellipsoidal domain bounded by the current best path cost. Incremental rewiring and periodic pruning of non-promising nodes reduce computational overhead. After successfully connecting the trees, an aggressive shortcut smoothing optimizes path quality. These techniques increase success rate, reduce planning time, and minimize final path length and complexity.",
    "planning_mechanism": "The planner alternates expanding between start and goal trees toward samples biased within an ellipsoidal informed set shaped by the current best solution. Efficient nearest and radius neighbors queries using KD-tree accelerate exploration and rewiring. Collision checks are cached to avoid redundant work. Periodic pruning removes nodes unlikely to improve the path. Paths are shortcut-smoothed repeatedly after successful connections, yielding smoother, shorter routes and faster convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-Tree implementation optimized for nearest and radius queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Samples inside ellipsoidal informed set or uniform if no solution found\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node in tree_a\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect the other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.79361,
    "time_improvement": 63.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1538.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010819768905639649,
            "num_nodes_avg": 65.5,
            "path_length_avg": 160.2206442336522,
            "smoothness_avg": 0.0442859819651789,
            "success_improvement": 0.0,
            "time_improvement": 56.89907019593318,
            "length_improvement": 12.18052603695833,
            "smoothness_improvement": 593.1717863041181,
            "objective_score": 22.471685197692207
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024241113662719728,
            "num_nodes_avg": 213.5,
            "path_length_avg": 240.01987026134765,
            "smoothness_avg": 0.09902904244407314,
            "success_improvement": 0.0,
            "time_improvement": 85.30335412963281,
            "length_improvement": 19.874458717853795,
            "smoothness_improvement": 2448.0885898221854,
            "objective_score": 41.806340931571526
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026984333992004395,
            "num_nodes_avg": 180.7,
            "path_length_avg": 124.40656447040799,
            "smoothness_avg": 0.13157767388698716,
            "success_improvement": 0.0,
            "time_improvement": 45.86498927635997,
            "length_improvement": 17.375083482755045,
            "smoothness_improvement": 1573.6582997888493,
            "objective_score": 25.102804978403245
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a hybrid bidirectional RRT* with dynamic informed sampling radius adaptation and multi-resolution collision checking to enhance planning efficiency and path quality. It incorporates adaptive step size control near obstacles, priority rewiring based on estimated cost-to-go heuristics, and intermittent lazy collision checks for efficient exploration. Post-processing applies iterative shortcut smoothing with curvature constraints to ensure smooth, feasible paths suitable for both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternately sampling within dynamically adjusted informed ellipses derived from the best known path cost to balance exploration and focused improvement. Nodes are extended with collision-aware adaptive stepping, and neighbors are rewired selectively to optimize path cost using heuristics to reduce unnecessary computations. Tree connections are verified lazily to reduce overhead, and final smoothing enforces path feasibility and smoothness. The process balances robust exploration, quick convergence, and high-quality path generation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def reset_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.base_step = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_cost = float(\"inf\")\n        best_path = []\n        c_min = dist(start, goal)\n        x_center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        vec_start_to_goal = np.array(goal) - np.array(start)\n        norm_vec = np.linalg.norm(vec_start_to_goal)\n        if norm_vec == 0:\n            return PlannerResult(success=True, path=[start], nodes=nodes, edges=edges)\n        unit_vec = vec_start_to_goal / norm_vec\n\n        # Rotation matrix for informed sampling basis\n        M = np.outer(unit_vec, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            except ValueError:\n                r2 = 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                sample = C @ L @ x_ball + np.array(x_center)\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(float(val) for val in sample)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            # Fallback uniform\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step_size(from_p, to_p):\n            dist_full = dist(from_p, to_p)\n            max_steps = max(3, int(dist_full * 1.6))\n            for i in range(1, max_steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / max_steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_p, to_p, step):\n            dist_full = dist(from_p, to_p)\n            if dist_full <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist_full for d in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda node: dist(node.position, p))\n\n        def near_nodes(tree, p, rad):\n            rad2 = rad * rad\n            return [node for node in tree if sum((node.position[d] - p[d])**2 for d in range(dim)) <= rad2]\n\n        # Heuristic function: cost + Euclidean distance to goal\n        def heuristic_cost(node, goal_p):\n            return node.cost + dist(node.position, goal_p)\n\n        # Dynamic radius for rewiring: r = gamma * (log(n)/n)^{1/d}\n        def rewiring_radius(num_nodes):\n            gamma = 30.0  # Tuned constant\n            if num_nodes <= 1:\n                return self.base_step * 2.0\n            return min(self.base_step * 4.0, gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n\n        for i in range(self.max_iter):\n            # Alternate sampling towards start or goal tree\n            tree_from, tree_to = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Informed sample\n            sample = informed_sample(best_cost)\n\n            near_rewire_radius = rewiring_radius(len(tree_from))\n\n            nearest_node = nearest(tree_from, sample)\n            step = adaptive_step_size(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            # Prune nodes if cost + heuristic worse than current best\n            if new_cost + dist(new_pos, goal if tree_from is tree_start else start) >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring with cost+heuristic priority\n            neighbors = near_nodes(tree_from, new_pos, near_rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + dist(neighbor.position, goal if tree_from is tree_start else start) >= best_cost:\n                    continue\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.4):\n                        neighbor.reset_parent(new_node, potential_cost)\n\n            # Attempt lazy connection to other tree, try nearest neighbors within step * 1.5\n            max_conn_dist = self.base_step * 1.5\n            other_nearest = min(tree_to, key=lambda node: dist(node.position, new_node.position))\n            connect_dist = dist(new_node.position, other_nearest.position)\n            if connect_dist <= max_conn_dist:\n                # Lazy edge collision check only when close enough\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d, resolution=0.3):\n                    total_path_cost = new_node.cost + connect_dist + other_nearest.cost\n                    if total_path_cost < best_cost:\n                        best_cost = total_path_cost\n                        path_from = new_node.path_from_root()\n                        path_to = other_nearest.path_from_root()\n                        # Merge paths without duplication of connecting node\n                        if path_from[-1] == path_to[-1]:\n                            merged = path_from + path_to[-2::-1]\n                        else:\n                            merged = path_from + path_to[::-1]\n                        best_path = merged\n                        success = True\n\n            # Early stopping if path found and improved enough\n            if success and i > self.max_iter / 10 and i % 100 == 0:\n                break\n\n        # Post-process: iterative shortcut smoothing with curvature constraints\n        def iterative_smoothing(path, max_trials=75):\n            if len(path) < 3:\n                return path\n            def is_smooth(a, b, c, max_angle=150.0):\n                import math\n                vec1 = np.array(b) - np.array(a)\n                vec2 = np.array(c) - np.array(b)\n                norm1 = np.linalg.norm(vec1)\n                norm2 = np.linalg.norm(vec2)\n                if norm1 == 0 or norm2 == 0:\n                    return True\n                cos_angle = np.dot(vec1, vec2) / (norm1 * norm2)\n                cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                angle = math.degrees(math.acos(cos_angle))\n                return angle >= (180 - max_angle)  # allow only gentle turns\n\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.3):\n                    # Check angle smoothness at neighbors if possible\n                    if i > 0 and not is_smooth(path[i-1], path[i], path[j]):\n                        continue\n                    if j < len(path)-1 and not is_smooth(path[i], path[j], path[j+1]):\n                        continue\n                    # Shortcut possible\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = iterative_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 60.28015,
    "time_improvement": -158.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 385.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.11205792427062988,
            "num_nodes_avg": 450.5,
            "path_length_avg": 180.51679091423733,
            "smoothness_avg": 0.005836342746057295,
            "success_improvement": -9.999999999999998,
            "time_improvement": -346.38668072294877,
            "length_improvement": 1.0558864283044989,
            "smoothness_improvement": -8.648562203078725,
            "objective_score": -153.74806974223912
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09644217491149902,
            "num_nodes_avg": 527.1,
            "path_length_avg": 258.21622159415966,
            "smoothness_avg": 0.022592465335592678,
            "success_improvement": 0.0,
            "time_improvement": 41.53005875212374,
            "length_improvement": 13.799992890028298,
            "smoothness_improvement": 481.32040577983355,
            "objective_score": 17.62561823254195
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13422565460205077,
            "num_nodes_avg": 556.7,
            "path_length_avg": 130.54683179201191,
            "smoothness_avg": 0.06141899918516115,
            "success_improvement": 0.0,
            "time_improvement": -169.2787323720003,
            "length_improvement": 13.297010295855245,
            "smoothness_improvement": 681.2451361563077,
            "objective_score": -44.7179919716475
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional RRT*-style tree growth with informed elliptical sampling, adaptive dynamic step sizing near obstacles, adaptive rewiring radius, goal biasing, and iterative pruning of suboptimal nodes. It balances exploration and exploitation by alternating tree expansions, focusing sampling within an ellipsoidal informed set when a solution is found, reducing step sizes near obstacles to safely navigate narrow passages, and locally rewiring the trees to optimize path cost and smoothness while pruning inefficient branches. This synergy aims to enhance efficiency, robustness, quality, and smoothness of the generated path.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points biased toward the goal or within an informed subset. It steers towards samples with dynamic step sizes that shrink near obstacles, validates nodes and edges against obstacles, rewires neighbors within adaptive radii for cost improvement, prunes nodes costing more than current best path, and tries to connect the two trees dynamically updating the best path. The final solution is smoothed by shortcutting collision-free segments to yield a shorter, safer path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # From root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 base_rewire_factor: float=25.0, min_step_size: float=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_rewire_factor = base_rewire_factor\n        self.min_step_size = min_step_size\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_adaptive_rewire_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.2\n            gamma = self.base_rewire_factor\n            radius = gamma * (math.log(tree_size) / tree_size) ** (1 / dim)\n            return max(radius, self.step_size * 1.3)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def is_collision_node(pos):\n            if not in_bounds(pos):\n                return True\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return True\n            return False\n\n        def is_collision_edge(from_pos, to_pos):\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return True\n            return False\n\n        def adaptive_step_size(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(int(distance * 2), 3)\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, self.min_step_size)\n            # Gradually reduce step size in later iterations (fine refinement)\n            progress_factor = 1 - (iteration / self.max_iter)\n            return max(self.min_step_size, self.step_size * progress_factor)\n\n        def rewire(tree, new_node):\n            radius = get_adaptive_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not is_collision_edge(new_node.position, neighbor.position):\n                        # Remove old edge\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def informed_sample(c_best, c_min, x_center, C, L):\n            while True:\n                # Sample uniformly in unit n-ball\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball = x_ball * radius\n                # Transform to ellipsoid\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def compute_rotation_matrix(start, goal):\n            diff = np.array(goal) - np.array(start)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return np.eye(dim)\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim -1) + [det]) @ Vt\n            return C\n\n        def shorten_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_collision_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n        C = compute_rotation_matrix(start_position, goal_position)\n        r1 = c_best / 2.0\n        r2 = 0.0 if c_best == float(\"inf\") else math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        for iteration in range(self.max_iter):\n\n            # Alternate trees per iteration\n            if iteration % 2 == 0:\n                active_tree, other_tree = start_tree, goal_tree\n                active_root, other_root = start_tree[0], goal_tree[0]\n                bias_target = goal_position\n            else:\n                active_tree, other_tree = goal_tree, start_tree\n                active_root, other_root = goal_tree[0], start_tree[0]\n                bias_target = start_position\n\n            # Sampling: goal bias + informed sample if path found\n            use_goal_bias = random.random() < self.goal_sample_rate\n            if success_state and not use_goal_bias:\n                # Update ellipsoid params\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                sample = informed_sample(c_best, c_min, x_center, C, L)\n            else:\n                if use_goal_bias:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_bounds(sample):\n                        continue\n                    if self._is_in_obstacle(sample, obstacles, is_3d):\n                        continue\n\n            # Find nearest node in active_tree\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size near obstacles\n            step_sz = adaptive_step_size(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_sz)\n\n            if is_collision_node(new_pos):\n                continue\n            if is_collision_edge(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            # Prune if cost + heuristic worse than best known path\n            if new_cost + math.dist(new_pos, bias_target) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors\n            rewire(active_tree, new_node)\n\n            # Prune nodes from active_tree whose cost+heuristic exceed c_best\n            prune_list = []\n            for node in active_tree:\n                if node == active_root:\n                    continue\n                if node.cost + math.dist(node.position, bias_target) >= c_best:\n                    prune_list.append(node)\n            for prune_node in prune_list:\n                if prune_node.parent and prune_node in prune_node.parent.children:\n                    prune_node.parent.children.remove(prune_node)\n                    try:\n                        edges.remove((prune_node.parent, prune_node))\n                    except ValueError:\n                        pass\n                prune_node.children.clear()\n                if prune_node in active_tree:\n                    active_tree.remove(prune_node)\n                if prune_node in nodes:\n                    nodes.remove(prune_node)\n\n            # Attempt connection to other_tree within adaptive radius\n            radius = get_adaptive_rewire_radius(len(other_tree))\n            neighbors_other = near_nodes(other_tree, new_node.position, radius)\n\n            best_connect = None\n            best_connect_cost = float(\"inf\")\n\n            for node_other in neighbors_other:\n                dist_connect = math.dist(new_node.position, node_other.position)\n                if dist_connect <= step_sz and not is_collision_edge(new_node.position, node_other.position):\n                    total_cost = new_node.cost + dist_connect + node_other.cost\n                    if total_cost < best_connect_cost:\n                        best_connect_cost = total_cost\n                        best_connect = node_other\n\n            if best_connect is not None:\n                # Connect trees: attach node_other as child of new_node\n                conn_pos = best_connect.position\n                conn_cost = new_node.cost + math.dist(new_node.position, conn_pos)\n                conn_node = Node(conn_pos, parent=new_node, cost=conn_cost)\n                new_node.children.append(conn_node)\n                active_tree.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((new_node, conn_node))\n\n                # Rewire after connecting node\n                rewire(active_tree, conn_node)\n\n                # Extract full path\n                path_start = []\n                node_ptr = conn_node\n                while node_ptr:\n                    path_start.append(node_ptr.position)\n                    node_ptr = node_ptr.parent\n                path_start.reverse()\n\n                path_goal = []\n                node_ptr = best_connect\n                while node_ptr:\n                    path_goal.append(node_ptr.position)\n                    node_ptr = node_ptr.parent\n\n                extracted_path = path_start + path_goal[1:]\n                success_state = True\n                c_best = best_connect_cost\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                # Update rotation matrix in case path found\n                C = compute_rotation_matrix(start_position, goal_position)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                L = np.diag([r1] + [r2]*(dim - 1))\n\n                # Continue for further refinement or break immediately (here break)\n                break\n\n        # Path smoothing by shortcutting collision-free segments\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shorten_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 42.38042,
    "time_improvement": -72.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1820.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.06413683891296387,
            "num_nodes_avg": 267.1,
            "path_length_avg": 163.03516443487274,
            "smoothness_avg": 0.053091043213726555,
            "success_improvement": -9.999999999999998,
            "time_improvement": -155.49135253725393,
            "length_improvement": 10.637842915742745,
            "smoothness_improvement": 730.9901153404243,
            "objective_score": -90.86488660132551
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06015217304229736,
            "num_nodes_avg": 483.9,
            "path_length_avg": 236.27631886343207,
            "smoothness_avg": 0.12199481281201752,
            "success_improvement": -9.999999999999998,
            "time_improvement": 63.531577062185676,
            "length_improvement": 21.124163926630523,
            "smoothness_improvement": 3039.0144029651747,
            "objective_score": -11.520622081192313
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11117246150970458,
            "num_nodes_avg": 569.0,
            "path_length_avg": 122.69501523196065,
            "smoothness_avg": 0.14073922428149716,
            "success_improvement": 0.0,
            "time_improvement": -123.0302366471071,
            "length_improvement": 18.511812991715185,
            "smoothness_improvement": 1690.192544571709,
            "objective_score": -24.755745672930548
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines bidirectional RRT* with informed sampling and adaptive step size steering along with goal biasing and incremental rewiring to efficiently explore the space. It adaptively focuses sampling within the informed ellipsoidal subset to accelerate convergence, alternates expansions of start and goal trees using goal biasing to improve success rates, rewires neighbors for optimal path quality, prunes non-promising branches to improve robustness and speed, and applies path shortcutting to smooth the result.",
    "planning_mechanism": "The planner iteratively samples points either informed by current best cost or biased towards the opposite tree\u2019s root. It grows two trees from start and goal, steering adaptively considering obstacles, rewires local nodes to minimize costs, and prunes nodes unlikely to yield better paths. On connecting the two trees through collision-free edges, it extracts, shortcuts, and returns a smooth, optimized path while limiting the search space and ensuring efficient exploration.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            import numpy as np\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # fallback uniform sample\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def sample_free(tree):\n            # Combine goal biasing with informed sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree is tree_a else start_position\n            else:\n                return informed_sample()\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = sample_free(active_tree)\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            if new_cost + dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            nearest_other = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            connect_dist = dist(new_node.position, nearest_other.position)\n            if connect_dist <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + connect_dist + nearest_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        # Connect the trees\n                        conn_node = Node(nearest_other.position, new_node, new_node.cost + connect_dist)\n                        new_node.add_child(conn_node)\n                        active_tree.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n\n                        path_a = conn_node.path_from_root()\n                        path_b = nearest_other.path_from_root()\n                        extracted_path = path_a + path_b[::-1][1:]\n                        success_state = True\n                        break\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.23688,
    "time_improvement": -25.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1706.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.057176852226257326,
            "num_nodes_avg": 302.5,
            "path_length_avg": 156.08230323307876,
            "smoothness_avg": 0.05507640912982022,
            "success_improvement": 0.0,
            "time_improvement": -127.76600089276387,
            "length_improvement": 14.448816315582198,
            "smoothness_improvement": 762.0654032183814,
            "objective_score": -31.629709988620807
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05155367851257324,
            "num_nodes_avg": 413.8,
            "path_length_avg": 240.13179558797748,
            "smoothness_avg": 0.107640393849365,
            "success_improvement": 0.0,
            "time_improvement": 68.74458133582955,
            "length_improvement": 19.837094822232856,
            "smoothness_improvement": 2669.664863986055,
            "objective_score": 37.939117685125716
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05838408470153809,
            "num_nodes_avg": 404.4,
            "path_length_avg": 127.17947813913125,
            "smoothness_avg": 0.14045600666658145,
            "success_improvement": 0.0,
            "time_improvement": -17.128073360794534,
            "length_improvement": 15.533446255948697,
            "smoothness_improvement": 1686.5900374149312,
            "objective_score": 6.401217430026035
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* algorithm with adaptive ellipsoidal informed sampling, dynamic neighbor radius adjustment, efficient nearest neighbor search via a basic KD-tree, collision check caching, incremental rewiring, and iterative shortcut smoothing. It emphasizes balanced exploration and exploitation, pruning of infeasible nodes, and smooth path refinement to enhance planning efficiency, robustness, success rate, and path quality in 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, iteratively sampling points biased within an informed ellipsoidal region defined by the current best path cost. Each iteration chooses the tree with fewer nodes for expansion. New nodes are added via adaptive steering and validated via collision checks on nodes and edges, leveraging cached results. Neighbor radius shrinks dynamically to focus rewiring for path cost improvement. Trees attempt connection each iteration to form candidate paths, which undergo iterative shortcut smoothing. Periodic pruning removes non-promising nodes to improve convergence speed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 120,\n                 prune_threshold: int = 200,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 0.4,\n                 goal_sample_rate: float = 0.18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # Prune nodes without children or whose cost + heuristic is worse than best_cost\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Select tree with fewer nodes to expand\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better path cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7.45151,
    "time_improvement": 49.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1579.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.020490527153015137,
            "num_nodes_avg": 74.1,
            "path_length_avg": 160.20391077229107,
            "smoothness_avg": 0.04047555184823013,
            "success_improvement": -9.999999999999998,
            "time_improvement": 18.375264742475615,
            "length_improvement": 12.189697912289027,
            "smoothness_improvement": 533.5302804924332,
            "objective_score": -39.38182959233734
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.037952113151550296,
            "num_nodes_avg": 267.9,
            "path_length_avg": 235.93544176450615,
            "smoothness_avg": 0.103055573102564,
            "success_improvement": -9.999999999999998,
            "time_improvement": 76.99079445024717,
            "length_improvement": 21.23795851385527,
            "smoothness_improvement": 2551.694123857962,
            "objective_score": -9.89669934286498
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024168014526367188,
            "num_nodes_avg": 171.8,
            "path_length_avg": 126.37966550901531,
            "smoothness_avg": 0.13768272111173824,
            "success_improvement": 0.0,
            "time_improvement": 51.51498918069859,
            "length_improvement": 16.064643721886974,
            "smoothness_improvement": 1651.3140498599719,
            "objective_score": 26.92399574788683
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified bidirectional RRT* inspired planner that balances exploration and exploitation through goal biasing and adaptive neighbor radius techniques. It expands two trees from start and goal, connecting them incrementally with collision-checked nodes and edges. The planner incorporates rewiring to optimize path costs locally, uses bounding checks to stay within the map dimensions, and applies shortcut smoothing on the final path to improve smoothness and reduce length, enhancing efficiency, robustness, and solution quality.",
    "planning_mechanism": "The planner alternates expansions from the start and goal trees, samples points with goal biasing, steers towards these samples to generate new nodes, and ensures nodes and connections are collision free. It rewires nearby nodes to optimize costs and attempts incremental connections between trees. Upon connection, the combined path is extracted and smoothed through shortcutting to yield a feasible, high-quality path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=20.0,\n                 smoothing_iterations: int=100, collision_check_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def extract_path(node_start: Node, node_goal: Node) -> list:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path_len = len(path)\n            iters = 0\n            while iters < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n                    iters = 0\n                else:\n                    iters += 1\n            return path\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success_state = False\n        final_path = []\n\n        for it in range(self.max_iter):\n            # Alternate tree selection, goal biasing sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Alternate expansions between start and goal trees\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Find nearest node in tree_a\n            nearest_a = min(tree_a, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest_a.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = [n for n in tree_a if dist(n.position, new_pos) <= r]\n\n            # Choose best parent for new node from near neighbors\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for n in near_nodes:\n                c_candidate = n.cost + dist(n.position, new_pos)\n                if c_candidate + 1e-12 < min_cost and can_connect(n.position, new_pos):\n                    min_cost = c_candidate\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to this new node if cheaper\n            for n in near_nodes:\n                if n is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, n.position)\n                if c_via_new + 1e-12 < n.cost and can_connect(new_node.position, n.position):\n                    try:\n                        edges.remove((n.parent, n))\n                    except ValueError:\n                        pass\n                    n.update_parent(new_node, c_via_new)\n                    edges.append((new_node, n))\n\n            # Attempt to connect tree_b towards new_node incrementally\n            nearest_b = min(tree_b, key=lambda node: dist(node.position, new_node.position))\n            curr_b = nearest_b\n            connected = False\n            max_steps = int(dist(curr_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos = steer(curr_b.position, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_b.position, next_pos):\n                    break\n\n                cost_next = curr_b.cost + dist(curr_b.position, next_pos)\n                next_node = Node(next_pos, parent=curr_b, cost=cost_next)\n                curr_b.children.append(next_node)\n                tree_b.append(next_node)\n                nodes.append(next_node)\n                edges.append((curr_b, next_node))\n\n                # Rewire around next_node\n                near_b_nodes = [n for n in tree_b if dist(n.position, next_pos) <= r]\n                for nb_node in near_b_nodes:\n                    if nb_node is curr_b:\n                        continue\n                    c_via_next = next_node.cost + dist(next_node.position, nb_node.position)\n                    if c_via_next + 1e-12 < nb_node.cost and can_connect(next_node.position, nb_node.position):\n                        try:\n                            edges.remove((nb_node.parent, nb_node))\n                        except ValueError:\n                            pass\n                        nb_node.update_parent(next_node, c_via_next)\n                        edges.append((next_node, nb_node))\n\n                if dist(next_node.position, new_node.position) <= self.step_size and can_connect(next_node.position, new_node.position):\n                    connect_cost = next_node.cost + dist(next_node.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=next_node, cost=connect_cost)\n                    next_node.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((next_node, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    final_path = shortcut_path(combined_path)\n                    connected = True\n                    break\n\n                curr_b = next_node\n\n            if connected:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.15684,
    "time_improvement": 36.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1478.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02960829734802246,
            "num_nodes_avg": 100.0,
            "path_length_avg": 165.23124110567187,
            "smoothness_avg": 0.04162530407510468,
            "success_improvement": -9.999999999999998,
            "time_improvement": -17.945693364105193,
            "length_improvement": 9.434138493415997,
            "smoothness_improvement": 551.5263995699422,
            "objective_score": -50.739248312698635
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04431650638580322,
            "num_nodes_avg": 350.7,
            "path_length_avg": 242.73184423916845,
            "smoothness_avg": 0.10434197052990202,
            "success_improvement": 0.0,
            "time_improvement": 73.13225746861403,
            "length_improvement": 18.969123744214404,
            "smoothness_improvement": 2584.7940562179842,
            "objective_score": 38.657472270517005
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.0239013671875,
            "num_nodes_avg": 194.2,
            "path_length_avg": 131.7246320218027,
            "smoothness_avg": 0.10995867156292874,
            "success_improvement": -19.999999999999996,
            "time_improvement": 52.04992758433985,
            "length_improvement": 12.51477146404823,
            "smoothness_improvement": 1298.6661859755861,
            "objective_score": -75.38873650201046
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of bidirectional anytime informed RRT* with adaptive lazy collision checking and efficient KD-tree neighbor searches, enhanced by aggressive pruning and shortcut smoothing. It dynamically samples informed ellipsoids around the best path to concentrate search, incrementally grows two trees from start and goal alternately targeting the smaller tree, while caching collision checks for speed. Periodic node pruning removes non-promising nodes to reduce computation, and path smoothing via shortcutting further improves path quality and smoothness. This approach balances exploration and exploitation to yield shorter, smoother paths faster, with improved robustness and success rates in both 2D and 3D environments.",
    "planning_mechanism": "The planning mechanism initiates two trees growing from start and goal, extending the smaller tree each iteration using adaptive and informed sampling biased towards the best path found so far. KD-tree structures facilitate fast neighbor queries for rewiring and cost improvements, while lazy collision checking reduces redundant computations. Incremental connection attempts link the two trees efficiently, and pruning removes nodes unlikely to lead to better paths, keeping the search space manageable. Upon connection, the best path is extracted and iteratively smoothed by shortcutting, producing a high-quality feasible path quickly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 250,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate  # added low probability goal bias in sampling\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        # KDTree Helper (brute force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Adaptive informed ellipsoidal sampling around best path and goal bias\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit n-ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not self._is_in_obstacle(p_tuple, obstacles, is_3d):\n                    # 5% goal bias inside ellipsoid to enhance direct paths\n                    if random.random() < self.goal_sample_rate:\n                        return goal_position\n                    return p_tuple\n\n            # Fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        # Sample near best known path with Gaussian noise fallback to informed_sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                        return sample_point\n            # Small goal sample bias outside best_path sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return informed_sample(c_best, c_min, start_position, goal_position)\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            const_factor = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.85)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(const_factor+1)/const_factor)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Shortcut smoothing on final path by attempting to replace path segments with direct edges\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(tree_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_position)\n            for node in tree_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_position, goal_position)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-14 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost found\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-14 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incrementally connect tree_b toward new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 2\n            last_node_b = nearest_b\n            connected = False\n\n            for _step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-14 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connection possible within step size\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-14 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.704,
    "time_improvement": 60.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1319.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0074797868728637695,
            "num_nodes_avg": 66.3,
            "path_length_avg": 162.87053071056394,
            "smoothness_avg": 0.040174281871941456,
            "success_improvement": 0.0,
            "time_improvement": 70.2040060404023,
            "length_improvement": 10.728081268824702,
            "smoothness_improvement": 528.8147511452909,
            "objective_score": 25.850891821612088
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025371432304382324,
            "num_nodes_avg": 230.7,
            "path_length_avg": 232.7446912862997,
            "smoothness_avg": 0.08245711639573813,
            "success_improvement": 0.0,
            "time_improvement": 84.61807650467216,
            "length_improvement": 22.30312286414085,
            "smoothness_improvement": 2021.680996322661,
            "objective_score": 39.95445250584312
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.037958836555480956,
            "num_nodes_avg": 245.9,
            "path_length_avg": 127.10947086609492,
            "smoothness_avg": 0.11849381435928316,
            "success_improvement": 0.0,
            "time_improvement": 23.848332717911823,
            "length_improvement": 15.579941753311315,
            "smoothness_improvement": 1407.2325723465062,
            "objective_score": 17.306651027768343
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces an advanced bidirectional Anytime RRT* planner with adaptive informed sampling and dynamic rewiring radius. It balances rapid initial solution discovery and continuous path optimization through iterative rewiring and path smoothing. The planner incrementally refines the path by focusing sampling within informed ellipsoidal regions oriented toward the current best solution, adaptively adjusting expansion step size based on obstacle proximity, and pruning nodes that do not contribute to improvements. Collision checks are rigorously applied to nodes and edges, ensuring robust navigation in cluttered 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, employing informed elliptical sampling biased by the latest best path cost to confine exploration and improve convergence speed. It adaptively adjusts step sizes to safely navigate near obstacles and employs dynamic rewiring with radius scaled by the iteration count to enhance path optimality over time. Upon connecting the trees, the current best path is updated and subjected to iterative shortcut path smoothing. The procedure iterates until the maximum iterations are reached or no further improvements are found, ensuring efficient exploration, high-quality, smooth, and short paths with strong success rates.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # For future use (e.g., collision invalidation)\n    \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, min_step_size: float=1.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Distance between start and goal (euclidean)\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min == 0:\n            return PlannerResult(True, [start_pos], nodes, edges)\n\n        # Center and rotation matrix for informed sampling\n        x_center = tuple((s + g) / 2.0 for s, g in zip(start_pos, goal_pos))\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1 if norm_a1 > 0 else np.array([1] + [0] * (dim - 1))\n        # Create orthonormal basis via SVD\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            except ValueError:\n                r2 = 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(50):  # Limit retries to avoid infinite loops\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if informed sampling failed\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            # Check waypoints between to detect nearby obstacles, shrink step if near\n            steps = max(3, int(dist * 1.5))\n            for i in range(1, steps + 1):\n                pos = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(pos, obstacles, is_3d):\n                    return max(self.min_step_size, self.step_size * 0.3)\n            return self.step_size\n\n        def find_nearest(tree, sample):\n            return min(tree, key=lambda n: math.dist(n.position, sample))\n\n        def neighbors(tree, node, radius):\n            return [n for n in tree if math.dist(n.position, node.position) <= radius and n != node]\n\n        def rewire(tree, new_node, radius):\n            nonlocal best_cost, best_path, success\n            near_nodes = neighbors(tree, new_node, radius)\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire parent-child relations\n                        if near.parent:\n                            try:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                            except (ValueError, IndexError):\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def connect_trees(node_new, other_tree):\n            nonlocal best_cost, best_path, success\n            nearest_other = find_nearest(other_tree, node_new.position)\n            dist_to_other = math.dist(node_new.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(node_new.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = node_new.cost + dist_to_other + nearest_other.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        path_from_new = node_new.path_from_root()\n                        path_from_other = nearest_other.path_from_root()\n                        # Avoid duplicate connection node\n                        if path_from_new[-1] == path_from_other[-1]:\n                            best_path.clear()\n                            best_path.extend(path_from_new + path_from_other[-2::-1])\n                        else:\n                            best_path.clear()\n                            best_path.extend(path_from_new + path_from_other[::-1])\n                        success = True\n\n        def shortcut_path(path):\n            # Iterative path smoothing via random shortcuts\n            if len(path) < 3:\n                return path\n            trials = 100\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Dynamic rewiring radius shrinking over iterations (RRT* style)\n        def dynamic_radius(iteration):\n            gamma = 30.0 * (math.log(iteration + 1) / (iteration + 1)) ** (1 / dim)\n            return max(gamma, self.step_size)\n\n        # Main loop\n        for i in range(self.max_iter):\n            # Alternate trees: start_tree expands at even iterations\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample with goal biasing combined with informed sampling around best cost\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = find_nearest(tree_a, sample)\n            step_size_adapted = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_size_adapted)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if no improvement possible\n            if new_cost + math.dist(new_pos, goal_pos) >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbours around new_node with dynamic radius\n            radius = dynamic_radius(i+1)\n            rewire(tree_a, new_node, radius)\n\n            # Attempt connecting to opposite tree\n            connect_trees(new_node, tree_b)\n\n            # Early stopping condition if improved path found reasonably early\n            if success and i > self.max_iter * 0.3 and i % 100 == 0:\n                break\n\n        # If success, smooth final path\n        if success:\n            extracted_path = shortcut_path(best_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 55.77265,
    "time_improvement": -223.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1653.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1436011552810669,
            "num_nodes_avg": 528.8,
            "path_length_avg": 164.35263457826704,
            "smoothness_avg": 0.03845293085375735,
            "success_improvement": 0.0,
            "time_improvement": -472.0402503537814,
            "length_improvement": 9.915716653497947,
            "smoothness_improvement": 501.8718697371453,
            "objective_score": -137.1195724267491
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14400603771209716,
            "num_nodes_avg": 803.2,
            "path_length_avg": 239.50013586980398,
            "smoothness_avg": 0.12623896760697959,
            "success_improvement": 0.0,
            "time_improvement": 12.693543337316063,
            "length_improvement": 20.047961017476066,
            "smoothness_improvement": 3148.2195627806855,
            "objective_score": 23.55875301859346
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1549920082092285,
            "num_nodes_avg": 872.5,
            "path_length_avg": 128.14436635248907,
            "smoothness_avg": 0.11078954583488373,
            "success_improvement": 0.0,
            "time_improvement": -210.93945208991403,
            "length_improvement": 14.892613447675727,
            "smoothness_improvement": 1309.2348453860945,
            "objective_score": -53.757138710508585
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes bidirectional RRT* with adaptive informed sampling using ellipsoidal heuristics, dynamic neighbor radii, KD-tree accelerated nearest neighbor and radius queries for efficient rewiring, adaptive step sizing to navigate near obstacles safely, collision check caching for speedup, aggressive pruning of non-promising nodes, and iterative shortcut path smoothing. It balances exploration and exploitation to improve planning efficiency, path optimality, robustness, and success rate in 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal alternately, samples within an informed ellipsoidal subset biased by the current best path cost, uses KD-trees for fast neighbor searches to rewire and optimize paths dynamically, adjusts step sizes adaptively near obstacles to avoid collisions, caches collision checks for performance, prunes nodes unlikely to improve the solution, and refines the final path through shortcut smoothing before outputting optimized smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0,\n                 min_neighbor_radius: float=6.0, max_neighbor_radius: float=25.0,\n                 prune_interval: int=100, prune_threshold: int=150,\n                 smoothing_iterations: int=150, collision_check_resolution: float=0.4,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Check if point is in bounds\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Euclidean distance\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Adaptive neighbor radius\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Adaptive step size near obstacles\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.step_size\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.step_size * 0.25, 1.0)\n                    break\n            return step\n\n        # Steer function with step size limit and bound clamp\n        def steer(from_pos, to_pos, step_size=None):\n            d = dist(from_pos, to_pos)\n            step = step_size if step_size is not None else self.step_size\n            if d <= step:\n                new_p = to_pos\n            else:\n                ratio = step / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        # Informed sampling based on current best path cost c_best\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        # KD-tree implementation for fast nearest and radius search\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        # Collision check cache to avoid redundant checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # Prune nodes unlikely to improve best path\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        # Iterative shortcut smoothing of path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        # Initialize roots for both trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            step_sz = adaptive_step(nearest_a.position, q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step_sz)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                step_b = adaptive_step(last_node_b.position, new_node.position)\n                next_pos_b = steer(last_node_b.position, new_node.position, step_b)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Prune infrequent and costly nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.53194,
    "time_improvement": -24.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1575.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04345345497131348,
            "num_nodes_avg": 193.6,
            "path_length_avg": 153.59437955077442,
            "smoothness_avg": 0.04484230163914103,
            "success_improvement": -9.999999999999998,
            "time_improvement": -73.09836548232992,
            "length_improvement": 15.812486709526791,
            "smoothness_improvement": 601.8793972691333,
            "objective_score": -65.75761531644794
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0683561086654663,
            "num_nodes_avg": 444.6,
            "path_length_avg": 241.34946787133148,
            "smoothness_avg": 0.10047288625938156,
            "success_improvement": 0.0,
            "time_improvement": 58.55778178715965,
            "length_improvement": 19.430600765295942,
            "smoothness_improvement": 2485.2397311487357,
            "objective_score": 33.87965334495076
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07810230255126953,
            "num_nodes_avg": 389.5,
            "path_length_avg": 127.18736267286477,
            "smoothness_avg": 0.13651537816252096,
            "success_improvement": 0.0,
            "time_improvement": -56.68606041589739,
            "length_improvement": 15.528209724064046,
            "smoothness_improvement": 1636.4655337102217,
            "objective_score": -5.717848511405299
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates features from both presented algorithms to enhance bidirectional RRT* planning by combining adaptive ellipsoidal informed sampling, dynamic neighbor radius shrinking, collision check caching, balanced tree expansion based on tree sizes, incremental rewiring, periodic pruning, and iterative path shortcutting. The approach emphasizes robust and efficient exploration that improves path quality, success rate, and smoothness while reducing redundant computations and search time.",
    "planning_mechanism": "The planner grows two trees from start and goal, expanding alternately the smaller tree to maintain balanced growth. Sampling is biased within an informed ellipsoidal domain constrained by the current best solution cost to focus search. Adaptive steering and collision-checked connections are employed before adding nodes and edges. Neighbor radius for rewiring shrinks dynamically with iterations and nodes count. Collision checks on edges use caching to avoid repeated costly calculations. After connection of the two trees, iterative shortcut smoothing refines the final path. Periodic pruning removes nodes unlikely to yield better paths, speeding convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 150,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # Remove nodes that have no children or have cost + heuristic worse than best\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Expand the smaller tree to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning for efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.99262,
    "time_improvement": 44.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1593.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017129731178283692,
            "num_nodes_avg": 74.4,
            "path_length_avg": 154.55357292016964,
            "smoothness_avg": 0.046418527841171536,
            "success_improvement": 0.0,
            "time_improvement": 31.76311365643787,
            "length_improvement": 15.286737624369676,
            "smoothness_improvement": 626.5507601608927,
            "objective_score": 15.719035422609759
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03994307518005371,
            "num_nodes_avg": 272.2,
            "path_length_avg": 233.82510706545835,
            "smoothness_avg": 0.1025731516301579,
            "success_improvement": 0.0,
            "time_improvement": 75.78373506009784,
            "length_improvement": 21.94244897901377,
            "smoothness_improvement": 2539.2810718988117,
            "objective_score": 39.82001567332617
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03698146343231201,
            "num_nodes_avg": 231.3,
            "path_length_avg": 123.23144329695529,
            "smoothness_avg": 0.13466992297981464,
            "success_improvement": 0.0,
            "time_improvement": 25.809103901644797,
            "length_improvement": 18.155543012905248,
            "smoothness_improvement": 1612.9914800035294,
            "objective_score": 19.438797173092134
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an optimized bidirectional RRT with adaptive goal biasing, informed sampling near tree nodes, and dynamic step sizing to improve planning efficiency, path quality, and success rate. It grows two trees from start and goal simultaneously, steering towards goal-biased or node-informed samples, and incrementally attempts to connect the trees with rigorous collision checks ensuring valid nodes and edges only. Path smoothing post extraction enhances path smoothness and reduces lengths.",
    "planning_mechanism": "The planner alternates expansions from start and goal trees by sampling goal-biased points or points biased near existing nodes to focus search in promising regions. Adaptive step sizing accelerates convergence in free space while cautious near obstacles. The trees are connected incrementally once close, validated by collision checks. Finally, the path is extracted and smoothed for high quality and feasibility.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Accumulated path cost from root\n        self.children = []\n        self.valid = True                 # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        \n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return list(reversed(path))\nclass Planner:\n    def __init__(self, max_iter: int = 3500, step_size: float = 7.0, goal_sample_rate: float = 0.15,\n                 node_sample_rate: float = 0.2, smoothing_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate      # Probability to sample goal directly\n        self.node_sample_rate = node_sample_rate      # Probability to sample near existing nodes\n        self.smoothing_iters = smoothing_iters        # Number of smoothing iterations post path extraction\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_point():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Goal biasing on start tree expansions\n                return goal_pos\n            elif r < self.goal_sample_rate + self.node_sample_rate:\n                # Sample nearby existing nodes to guide sampling into promising regions\n                combined = start_tree + goal_tree\n                near_node = random.choice(combined)\n                dim = len(bounds)\n                def sample_around_node(n):\n                    return tuple(\n                        max(0.0, min(bounds[d], random.gauss(n.position[d], self.step_size * 2)))\n                        for d in range(dim)\n                    )\n                return sample_around_node(near_node)\n            else:\n                # Uniform random sampling within bounds\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, sample):\n            return min(tree, key=lambda n: math.dist(n.position, sample))\n\n        def collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def connect_trees(new_node, tree_other):\n            nearest_node = nearest(tree_other, new_node.position)\n            dist = math.dist(new_node.position, nearest_node.position)\n            if dist <= self.step_size * 1.5:\n                if edge_collision_free(new_node.position, nearest_node.position):\n                    # Connect by adding nearest_node as child of new_node\n                    conn_node = Node(nearest_node.position, parent=new_node,\n                                     cost=new_node.cost + dist)\n                    new_node.add_child(conn_node)\n                    tree_other.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n                    return conn_node, nearest_node\n            return None, None\n\n        def extract_path(node_a, node_b):\n            path_start = node_a.path_from_root()\n            path_goal = node_b.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if edge_collision_free(path[i], path[j]):\n                    path[i+1:j] = []\n            return path\n\n        # Alternate expansions\n        for itr in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                sample = sample_point()\n                if not collision_free(sample):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                # Adaptive step size: reduce near obstacles to avoid collision; increase on free space\n                # Simple heuristic: if path from nearest_node to sample crosses obstacle edge, reduce step size\n                proposed_step = self.step_size\n                new_pos = steer(nearest_node.position, sample, proposed_step)\n                if not collision_free(new_pos):\n                    continue\n                if not edge_collision_free(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                conn_node_a, conn_node_b = connect_trees(new_node, tree_b)\n                if conn_node_a and conn_node_b:\n                    raw_path = extract_path(conn_node_a, conn_node_b)\n                    smoothed_path = smooth_path(raw_path)\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # No success found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.20302,
    "time_improvement": 73.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 779.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012627959251403809,
            "num_nodes_avg": 165.7,
            "path_length_avg": 183.5408985028027,
            "smoothness_avg": 0.026771640307624234,
            "success_improvement": 0.0,
            "time_improvement": 49.696080386737705,
            "length_improvement": -0.601674861039459,
            "smoothness_improvement": 319.03430636173897,
            "objective_score": 16.383660675622114
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01845707893371582,
            "num_nodes_avg": 301.2,
            "path_length_avg": 261.5017196726376,
            "smoothness_avg": 0.048893393753069045,
            "success_improvement": 0.0,
            "time_improvement": 88.81003749809561,
            "length_improvement": 12.703199063613631,
            "smoothness_improvement": 1158.0622377545258,
            "objective_score": 34.97396225092404
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009975814819335937,
            "num_nodes_avg": 207.2,
            "path_length_avg": 135.81575222594273,
            "smoothness_avg": 0.07540672737726299,
            "success_improvement": 0.0,
            "time_improvement": 79.98687525948147,
            "length_improvement": 9.7976442226679,
            "smoothness_improvement": 859.1680062931462,
            "objective_score": 30.251431453843747
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner with informed sampling, adaptive rewiring, and goal biasing. It grows two trees from start and goal points alternatingly, focusing exploration inside an ellipsoidal informed region around the current best path (when found), and rewires nearby nodes to optimize connections. Collision and boundary checks ensure node validity and free edges. The algorithm finishes when a path is found or the iteration limit is reached and returns a smoothed, optimized path.",
    "planning_mechanism": "The planner initializes two trees from start and goal, then iteratively samples points either uniformly or within an informed ellipsoid based on the best path cost. It expands the active tree toward samples, steering with fixed step size and checking collisions. After adding new nodes, it rewires neighbors if cheaper connections exist while pruning non-promising nodes. The two trees attempt to connect whenever possible, updating the best path. Final path shortcutting enhances smoothness and reduces path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes.extend(start_tree + goal_tree)\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start_pos, goal_pos)\n        success = False\n        extracted_path = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def informed_sample():\n            nonlocal best_cost\n            if best_cost == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = best_cost / 2.0\n            val = best_cost**2 - c_min**2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Fallback\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def near_nodes(tree, pos, radius=20.0):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        for i, (p, c) in enumerate(edges):\n                            if c is neighbor:\n                                edges[i] = (new_node, neighbor)\n                                break\n\n        def try_connect_trees(tree_a, tree_b, new_node):\n            nonlocal best_cost, success, extracted_path\n            connection_candidates = near_nodes(tree_b, new_node.position, radius=self.step_size*1.5)\n            for node_b in connection_candidates:\n                dist_ab = dist(new_node.position, node_b.position)\n                if dist_ab <= self.step_size and not self._is_edge_in_obstacle(new_node.position, node_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_ab + node_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = node_b.path_from_root()\n                        extracted_path = path_a + path_b[::-1]\n                        success = True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Main loop\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n            goal_sample = goal_pos if active_tree is start_tree else start_pos\n\n            if random.random() < 0.1:\n                sample = goal_sample\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(active_tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            if new_cost + dist(new_pos, goal_pos) >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(active_tree, new_node)\n            try_connect_trees(active_tree, other_tree, new_node)\n\n            if success:\n                break\n\n        if success and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -16.03436,
    "time_improvement": 19.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1515.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02261345386505127,
            "num_nodes_avg": 127.9,
            "path_length_avg": 170.63354588034477,
            "smoothness_avg": 0.051991652617775275,
            "success_improvement": 0.0,
            "time_improvement": 9.918511553694051,
            "length_improvement": 6.473049641420511,
            "smoothness_improvement": 713.7822651488966,
            "objective_score": 7.839074720136802
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05692472457885742,
            "num_nodes_avg": 319.4,
            "path_length_avg": 241.42635440527783,
            "smoothness_avg": 0.09515852903822501,
            "success_improvement": 0.0,
            "time_improvement": 65.48828036352714,
            "length_improvement": 19.404933827208477,
            "smoothness_improvement": 2348.4974920715913,
            "objective_score": 35.26995833485779
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.059438776969909665,
            "num_nodes_avg": 306.4,
            "path_length_avg": 125.34634322187426,
            "smoothness_avg": 0.12448244956667284,
            "success_improvement": 0.0,
            "time_improvement": -19.243959462536136,
            "length_improvement": 16.75092718348635,
            "smoothness_improvement": 1483.4075701494332,
            "objective_score": 4.994035448683596
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm is an enhanced bidirectional informed RRT* planner integrating adaptive ellipsoidal informed sampling, efficient nearest-neighbor search using a lightweight KD-tree, collision caching to avoid redundant checks, dynamic neighbor radius for rewiring, and iterative path shortcutting for smoothness. It balances exploration and exploitation, leverages pruning of nodes unlikely to improve the best solution, and alternates tree growth to efficiently minimize path length and planning time in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately sampling within a dynamically defined ellipsoid based on the current best path cost. It steers nodes towards samples, performs collision checks, and uses cached edge checks. Rewiring is done within a radius adapting through iterations to improve path quality. KD-tree accelerates nearest and radius searches. The planner prunes nodes that cannot offer better paths periodically, and performs shortcut smoothing on the best path. The planning terminates early upon finding an optimized connection between the two trees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 100\n        self.collision_check_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        import numpy as np\n        import random\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best_sample, c_min_sample, start, goal):\n            if c_best_sample == float('inf') or c_best_sample < c_min_sample * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min_sample for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            v = a1_np - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best_sample / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min_sample / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        for it in range(self.max_iter):\n\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree with fewer nodes expands\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -32.06206,
    "time_improvement": 72.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1471.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009120488166809082,
            "num_nodes_avg": 79.4,
            "path_length_avg": 161.5552488611424,
            "smoothness_avg": 0.0364388210118174,
            "success_improvement": 0.0,
            "time_improvement": 63.668214757196715,
            "length_improvement": 11.449008092467299,
            "smoothness_improvement": 470.34667700125965,
            "objective_score": 23.741999430658772
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02316892147064209,
            "num_nodes_avg": 210.3,
            "path_length_avg": 240.30368523846565,
            "smoothness_avg": 0.09745118191340611,
            "success_improvement": 0.0,
            "time_improvement": 85.95339146583702,
            "length_improvement": 19.77971310933064,
            "smoothness_improvement": 2407.4891018811195,
            "objective_score": 41.77940557102283
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017485976219177246,
            "num_nodes_avg": 156.3,
            "path_length_avg": 124.10213891329643,
            "smoothness_avg": 0.128510851183319,
            "success_improvement": 0.0,
            "time_improvement": 64.92025667859883,
            "length_improvement": 17.577268442601284,
            "smoothness_improvement": 1534.6485413674952,
            "objective_score": 30.664773398937385
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges the strengths of bidirectional tree growth, ellipsoidal informed sampling, adaptive step sizing near obstacles, aggressive rewiring with pruning, and dynamic goal biasing for efficient, robust pathfinding. It grows two trees simultaneously from start and goal, alternates expansions, uses informed sampling after initial success to focus search, adapts steps near obstacles for safe exploration, rewires neighbors to optimize paths continuously, and prunes nodes unlikely to improve solutions. Final paths are smoothed by shortcutting, yielding faster convergence, shorter and smoother paths with high success rates.",
    "planning_mechanism": "The planner alternates expansion between two trees grown from start and goal. Initially, uniform and goal-biased random sampling is used; once a feasible solution is found, sampling is restricted to an ellipsoidal informed subset around the best solution to focus the search. An adaptive step size prevents collisions near obstacles. Each expansion rewires neighbors to improve path costs and prunes inefficient nodes that cannot improve current solutions. The two trees attempt to connect during expansions to update best paths. Finally, a shortcut-based smoothing refines the returned path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start_pos, goal_pos)\n        solution_node_start = None\n        solution_node_goal = None\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _euclidean(p1, p2):\n            return math.dist(p1, p2)\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = _euclidean(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = _euclidean(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _informed_sample(c_best, c_min, start, goal):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) * 0.5 for s, g in zip(start, goal)])\n            diff = np.array(goal) - np.array(start)\n            length = np.linalg.norm(diff)\n            if length < 1e-10:\n                return tuple(center)\n            a1 = diff / length\n\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball = x_ball / norm * (random.random() ** (1.0 / dim))\n                x_rand = C @ (L @ x_ball) + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: _euclidean(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(dim))) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for node in neighbors:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + _euclidean(new_node.position, node.position)\n                if potential_cost + 1e-9 < node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, node.position):\n                        # Remove old parent-child relation\n                        if node.parent and node in node.parent.children:\n                            try:\n                                node.parent.children.remove(node)\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                        # Update parent and cost\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = _euclidean(from_pos, to_pos)\n            steps_check = max(3, int(distance))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return max(self.step_size * 0.25, 1.0)\n            return self.step_size\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        # Main loop: alternate expansions between start and goal trees\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, expand_from_start in [(start_tree, goal_tree, True), (goal_tree, start_tree, False)]:\n                # Sampling strategy with dynamic goal biasing and informed sampling after solution found\n                if best_cost < float(\"inf\"):\n                    sample = _informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if expand_from_start else start_pos\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample) or _is_in_obstacle(sample):\n                    continue\n\n                nearest = nearest_node(tree_a, sample)\n                step = adaptive_step(nearest.position, sample)\n                new_pos = _steer(nearest.position, sample, step)\n\n                if not in_bounds(new_pos) or _is_in_obstacle(new_pos):\n                    continue\n                if _is_edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + _euclidean(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                neighbors = near_nodes(tree_a, new_pos, radius=20.0)\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect to the other tree within step_size*1.5 radius\n                near_in_b = near_nodes(tree_b, new_pos, radius=self.step_size * 1.5)\n                connect_node = None\n                min_connect_cost = float(\"inf\")\n                for nbr in near_in_b:\n                    dist = _euclidean(new_pos, nbr.position)\n                    if dist <= self.step_size and not _is_edge_in_obstacle(new_pos, nbr.position):\n                        total_cost = new_node.cost + dist + nbr.cost\n                        if total_cost < min_connect_cost:\n                            min_connect_cost = total_cost\n                            connect_node = nbr\n\n                if connect_node is not None:\n                    # Connect via new connecting node in tree_a\n                    conn_node = Node(connect_node.position, parent=new_node,\n                                     cost=new_node.cost + _euclidean(new_node.position, connect_node.position))\n                    new_node.add_child(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire neighbors around connection node\n                    near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                    rewire(tree_a, conn_node, near_conn)\n\n                    # Update solution if better\n                    if min_connect_cost < best_cost:\n                        best_cost = min_connect_cost\n                        success_state = True\n                        if expand_from_start:\n                            solution_node_start = conn_node\n                            solution_node_goal = connect_node\n                        else:\n                            solution_node_start = connect_node\n                            solution_node_goal = conn_node\n\n                # Prune nodes in expanded tree whose cost + heuristic exceed best_cost to keep tree lean\n                heuristic = lambda node: node.cost + _euclidean(node.position, goal_pos)\n                to_prune = []\n                for node in tree_a:\n                    if heuristic(node) >= best_cost:\n                        if node != new_node and node != tree_a[0] and node != tree_b[0]:\n                            to_prune.append(node)\n                for node in to_prune:\n                    if node.parent and node in node.parent.children:\n                        try:\n                            node.parent.children.remove(node)\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    node.children = []\n                    if node in tree_a:\n                        tree_a.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n\n            if success_state and solution_node_start and solution_node_goal:\n                extracted_path = extract_path(solution_node_start, solution_node_goal)\n                break\n\n        # Shortcut smoothing of path (attempt shortcutting intermediate points)\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 40.68757,
    "time_improvement": -172.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1568.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0905123233795166,
            "num_nodes_avg": 317.5,
            "path_length_avg": 164.23925333904523,
            "smoothness_avg": 0.05111066621462969,
            "success_improvement": 0.0,
            "time_improvement": -260.5590221386443,
            "length_improvement": 9.977862707356127,
            "smoothness_improvement": 699.9929148470736,
            "objective_score": -72.6721695258867
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0861548662185669,
            "num_nodes_avg": 404.7,
            "path_length_avg": 235.16064101197676,
            "smoothness_avg": 0.10111951142499584,
            "success_improvement": 0.0,
            "time_improvement": 47.766939405494306,
            "length_improvement": 21.496609306452704,
            "smoothness_improvement": 2501.8778624052725,
            "objective_score": 31.138792994965193
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.20172576904296874,
            "num_nodes_avg": 440.0,
            "path_length_avg": 125.16534381525102,
            "smoothness_avg": 0.12586495743069498,
            "success_improvement": 0.0,
            "time_improvement": -304.6950602379672,
            "length_improvement": 16.871138371099956,
            "smoothness_improvement": 1500.9929681336791,
            "objective_score": -80.52932555650177
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm featuring adaptive ellipsoidal informed sampling to focus exploration within promising regions, dynamic neighbor radius adjustment for efficient rewiring, collision check caching to minimize redundant expensive computations, balanced tree expansions by growing the smaller tree alternatively, incremental rewiring to continuously improve path quality, periodic pruning to discard non-promising nodes and accelerate convergence, and iterative shortcutting for smooth, shorter final paths. It aims to maximize success rate, path optimality, and computational efficiency in both 2D and 3D spaces.",
    "planning_mechanism": "The planning mechanism grows two RRT* trees rooted at start and goal, expanding alternately the smaller tree to maintain balance. Sampling leverages ellipsoidal informed sets shaped by current best path cost to bias samples. The planner uses adaptive neighbor radii for rewiring, cached collision checks for speed, and only adds nodes and edges after strict collision validations. Upon connection of the trees, the resulting path is shortcut iteratively for smoothness. Periodic pruning removes nodes unlikely to improve the solution, enhancing search efficiency and convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For obstacle validity\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 150,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Ensure no coordinate exceeds map bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet, or very close to c_min, sample uniformly or with goal bias\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform sampling if ellipsoidal sampling fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # Prune nodes with no children or cost+heuristic no better than current best\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Expand smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning to speed convergence\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.91158,
    "time_improvement": 37.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1470.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.021331429481506348,
            "num_nodes_avg": 96.2,
            "path_length_avg": 167.83553664880722,
            "smoothness_avg": 0.04694168452840133,
            "success_improvement": -9.999999999999998,
            "time_improvement": 15.025500755050288,
            "length_improvement": 8.00668283851979,
            "smoothness_improvement": 634.7392983689683,
            "objective_score": -40.7173167139361
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03392972946166992,
            "num_nodes_avg": 261.3,
            "path_length_avg": 231.03875110943778,
            "smoothness_avg": 0.0925792744633723,
            "success_improvement": 0.0,
            "time_improvement": 79.42944266861784,
            "length_improvement": 22.872614797942774,
            "smoothness_improvement": 2282.1314140986524,
            "objective_score": 39.81401283066717
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.042313003540039064,
            "num_nodes_avg": 232.8,
            "path_length_avg": 123.21561777449415,
            "smoothness_avg": 0.12532913061336257,
            "success_improvement": 0.0,
            "time_improvement": 15.113157839353933,
            "length_improvement": 18.16605357139354,
            "smoothness_improvement": 1494.1772905678324,
            "objective_score": 15.63804451892405
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a carefully tuned bidirectional RRT* variant with adaptive rewiring radius, dynamic step size scheduling, and goal biasing. It grows two trees from start and goal positions alternately, rewires locally to optimize cost, and attempts incremental tree connections within adaptive neighborhoods. The approach balances exploration and exploitation with refined collision checks, leading to efficient convergence, improved path smoothness, and reliable success even in cluttered environments.",
    "planning_mechanism": "The planner samples points with a controlled goal bias, dynamically decreases step size for finer refinement over time, and adjusts rewiring radius based on tree size and dimensionality. Each extension grows the respective tree towards the sample with collision checks, then rewires nearby nodes to reduce path cost. After each extension, it tries connecting to the other tree within the adaptive radius, ensuring collision-free linking. On success, the merged path is extracted from corresponding tree roots, delivering a high-quality smooth path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=6.0, goal_sample_rate: float=0.25, base_rewire_factor: float=25.0, min_step_size: float=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_rewire_factor = base_rewire_factor\n        self.min_step_size = min_step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_adaptive_rewire_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.5\n            gamma = self.base_rewire_factor\n            r = gamma * (math.log(tree_size) / tree_size) ** (1 / dim)\n            return max(r, self.step_size * 1.2)\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect_edge(from_pos, to_pos):\n            if not can_add_node(to_pos):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_adaptive_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if can_connect_edge(new_node.position, neighbor.position):\n                        # Detach from previous parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        if neighbor not in new_node.children:\n                            new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def extend(tree, target_pos, step_sz):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos, step_sz)\n            if not can_connect_edge(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            step_sz = max(self.min_step_size, self.step_size * (1 - itr / self.max_iter))\n\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_bounds(sample):\n                        continue\n                    if self._is_in_obstacle(sample, obstacles, is_3d):\n                        continue\n\n                new_node = extend(tree_a, sample, step_sz)\n                if new_node is None:\n                    continue\n\n                radius = get_adaptive_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= step_sz and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node:\n                    conn_pos = best_connect_node.position\n                    conn_cost = new_node.cost + math.dist(new_node.position, conn_pos)\n                    conn_node = Node(conn_pos, parent=new_node, cost=conn_cost)\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n                    rewire(tree_a, conn_node)\n\n                    # Extract full path\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    extracted_path = path_start + path_goal[1:]\n                    success_state = True\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.85332,
    "time_improvement": 36.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 88.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015274119377136231,
            "num_nodes_avg": 112.5,
            "path_length_avg": 190.33744130224105,
            "smoothness_avg": 0.012623121416361589,
            "success_improvement": -9.999999999999998,
            "time_improvement": 39.15500850025168,
            "length_improvement": -4.326967667524198,
            "smoothness_improvement": 97.5792617129515,
            "objective_score": -38.630994674864574
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030224013328552245,
            "num_nodes_avg": 246.2,
            "path_length_avg": 308.4313649855806,
            "smoothness_avg": 0.007438065010176367,
            "success_improvement": 0.0,
            "time_improvement": 81.67610503167145,
            "length_improvement": -2.9632673367902234,
            "smoothness_improvement": 91.38677013351617,
            "objective_score": 24.367111892810975
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.05556855201721191,
            "num_nodes_avg": 309.9,
            "path_length_avg": 159.80983214584052,
            "smoothness_avg": 0.013764551977750153,
            "success_improvement": -9.999999999999998,
            "time_improvement": -11.479651869127592,
            "length_improvement": -6.138081184822379,
            "smoothness_improvement": 75.08408516343977,
            "objective_score": -54.29609137188555
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* with informed sampling and adaptive rewiring. It grows two trees from start and goal, focusing the search within an ellipsoidal informed region around the current best path cost. Nodes are added only if valid and collision-free edges connect them. Rewiring optimizes local connectivity and pruning removes unpromising nodes. A final path shortcutting step enhances path smoothness and quality while maintaining computational efficiency.",
    "planning_mechanism": "The planner alternates expansions between two trees, samples within or outside an informed set depending on current best cost, steers toward samples with fixed step size, validates nodes and edges against obstacles and map bounds, rewires neighbors to reduce costs, prunes nodes that cannot improve solutions, attempts connecting the two trees to update the best path, and applies path shortcutting to smooth the resulting route.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        best_cost = float(\"inf\")\n        c_min = 0.0 if start_pos == goal_pos else math.dist(start_pos, goal_pos)\n\n        nodes = []\n        edges = []\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes.extend(start_tree + goal_tree)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if best_cost == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            import numpy as np\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            r2 = math.sqrt(val)/2 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            # fallback\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if tentative_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, tentative_cost)\n                        for idx, (p, c) in enumerate(edges):\n                            if c is neighbor:\n                                edges[idx] = (new_node, neighbor)\n                                break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + dist(node.position, goal_pos) >= best_cost:\n                    if node not in (start_tree[0], goal_tree[0]):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def try_connect_trees(tree_a, tree_b, new_node):\n            nonlocal best_cost, success\n            candidates = near_nodes(tree_b, new_node.position, self.step_size * 1.5)\n            for node_b in candidates:\n                d_ab = dist(new_node.position, node_b.position)\n                if d_ab <= self.step_size and not self._is_edge_in_obstacle(new_node.position, node_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_ab + node_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = node_b.path_from_root()\n                        nonlocal extracted_path\n                        extracted_path = path_a + path_b[::-1]\n                        success = True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (start_tree, goal_tree) if iter_num % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(active_tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_cost = new_cost + dist(new_pos, goal_pos)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(active_tree, new_node)\n            prune(active_tree)\n\n            try_connect_trees(active_tree, other_tree, new_node)\n\n            if success:\n                break\n\n        if success and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -21.76095,
    "time_improvement": 35.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1618.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021036052703857423,
            "num_nodes_avg": 122.6,
            "path_length_avg": 164.34665238535374,
            "smoothness_avg": 0.04726759721577694,
            "success_improvement": 0.0,
            "time_improvement": 16.202144532771076,
            "length_improvement": 9.918995588227643,
            "smoothness_improvement": 639.840539657125,
            "objective_score": 10.043645175762476
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.046055936813354494,
            "num_nodes_avg": 292.3,
            "path_length_avg": 236.20054964953934,
            "smoothness_avg": 0.10009415170700017,
            "success_improvement": 0.0,
            "time_improvement": 72.07769399576597,
            "length_improvement": 21.149457871123815,
            "smoothness_improvement": 2475.494618324491,
            "objective_score": 38.23067286457701
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04133353233337402,
            "num_nodes_avg": 243.7,
            "path_length_avg": 126.58416413864329,
            "smoothness_avg": 0.14464412450030917,
            "success_improvement": 0.0,
            "time_improvement": 17.07813812354475,
            "length_improvement": 15.928825469266375,
            "smoothness_improvement": 1739.8625871252457,
            "objective_score": 17.00851946654293
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner advances bidirectional informed RRT* by integrating adaptive ellipsoidal sampling, bidirectional tree growth prioritizing the smaller tree, KD-tree accelerated nearest neighbor and radius queries with adaptive radius diminishing over iterations, collision caching to prevent redundant checks, and aggressive shortcut smoothing for path refinement. It enhances pruning frequency and employs early path extraction upon first successful connection, balancing exploration and exploitation for faster convergence, shorter and smoother paths, and reduced computational time in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling within an informed ellipsoid focused on the current best path cost to confine search space and improve convergence. Tree expansions extend via steering within step size bounds. Nearest neighbors and radius-based rewiring leverage KD-trees, with adaptive radius shrinking with iterations to fine-tune connectivity. Collision checks for nodes and edges employ a cache for efficiency. Periodic pruning removes nodes unlikely to improve the solution. Upon connecting the two trees, a shortcut smoothing process aggressively refines the path. The smaller tree is always extended first to balance growth and maintain search efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=100, prune_threshold: int=200,\n                 smoothing_iterations: int=200, collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds strictly\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.92)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for dd in range(self.dim):\n                        delta = p[dd] - pt[dd]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            v = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x_ball / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            # Sample point with adaptive informed sampling\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent for new node minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning (more frequent for efficiency)\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -30.26437,
    "time_improvement": 64.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1502.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01036214828491211,
            "num_nodes_avg": 72.8,
            "path_length_avg": 161.86544122578286,
            "smoothness_avg": 0.0452046323516444,
            "success_improvement": 0.0,
            "time_improvement": 58.72201802623206,
            "length_improvement": 11.278986742095293,
            "smoothness_improvement": 607.5506597335466,
            "objective_score": 22.91015605495641
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02655627727508545,
            "num_nodes_avg": 232.1,
            "path_length_avg": 235.99224541938037,
            "smoothness_avg": 0.10235549529282002,
            "success_improvement": 0.0,
            "time_improvement": 83.89974123394204,
            "length_improvement": 21.218995818855703,
            "smoothness_improvement": 2533.680617567585,
            "objective_score": 42.08212462179168
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024642467498779297,
            "num_nodes_avg": 179.7,
            "path_length_avg": 121.88970405439372,
            "smoothness_avg": 0.11513496062715078,
            "success_improvement": 0.0,
            "time_improvement": 50.563158508983555,
            "length_improvement": 19.04666233105772,
            "smoothness_improvement": 1364.5082007985757,
            "objective_score": 25.800821022899488
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* combined with adaptive heuristic-guided sampling and dynamic tree balancing. It integrates an incremental replanning step with local informed exploration and real-time path smoothing. The planner employs a priority queue-based node expansion to focus computational efforts on promising areas, a KD-tree for fast nearest neighbor queries, and lazy collision checking with caching to reduce expensive computations. Adaptive neighbor radius and pruning maintain exploration-exploitation balance, ensuring rapid convergence towards high-quality, smooth, and feasible paths with improved success rate and robustness.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, dynamically choosing which tree to expand based on their sizes and current costs. Sampling blends uniform random points, heuristic biased points along the current best path, and goal biasing to focus search in promising areas. Extension attempts are done incrementally with collision checks deferred until necessary. Upon connection between trees, iterative local shortcut smoothing refines the path. Adaptive pruning removes nodes unlikely to contribute to better paths, optimizing memory and search efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For obstacle validity and search pruning\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_cache = {}   # Cache collisions for edges\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in self.collision_cache:\n                return not self.collision_cache[key]\n            if rev_key in self.collision_cache:\n                return not self.collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                self.collision_cache[key] = True\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                self.collision_cache[key] = True\n                return False\n            self.collision_cache[key] = False\n            return True\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # KDTree implementation for fast NN and radius queries:\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = math.dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius*radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sq_dist = 0.0\n                    for i in range(self.dim):\n                        diff = p[i] - pt[i]\n                        sq_dist += diff * diff\n                        if sq_dist > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        # Adaptive neighbor radius (shrinks with more nodes)\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            max_r = max(bounds) * 0.3\n            min_r = self.step_size * 1.2\n            r1 = max_r * (1.0 - (iteration/self.max_iter)**0.9)\n            r2 = min_r + (max_r - min_r) * math.sqrt(math.log(c+1)/c)\n            return max(min_r, min(r1, r2))\n\n        # Heuristic estimate for pruning\n        def heuristic(pos):\n            return math.dist(pos, goal_pos)\n\n        # Informed sample towards current best cost path or random sample\n        def informed_sample(c_best):\n            if c_best == float('inf') or random.random() < 0.2:\n                for _ in range(30):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback if none found\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                a1 = tuple((goal_pos[d] - start_pos[d]) / c_best for d in range(dim))\n                import numpy as np\n                id_mat = np.eye(dim)\n                a1_vec = np.array(a1)\n                u = a1_vec - id_mat[:,0]\n                norm_u = np.linalg.norm(u)\n                if norm_u > 1e-12:\n                    u /= norm_u\n                    rot = id_mat - 2 * np.outer(u, u)\n                else:\n                    rot = id_mat\n                r1 = c_best / 2.0\n                r_others = math.sqrt(max(r1**2 - (c_best/2)**2, 0))\n                radii = np.array([r1] + [r_others]*(dim-1))\n                for _ in range(100):\n                    x = np.random.uniform(-1,1,dim)\n                    norm_x = np.linalg.norm(x)\n                    if 1e-15 < norm_x <= 1:\n                        radius_factor = np.random.uniform(0,1)**(1/dim)\n                        x_scaled = (x/norm_x) * radius_factor * radii\n                        sample_np = rot @ x_scaled + np.array(center)\n                        sample = tuple(float(coord) for coord in sample_np)\n                        if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Shortcut smoothing of path\n        def shortcut_path(path, iterations=150):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve solution\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if not node.children:\n                    # Cost + heuristic >= best cost \u2192 prune\n                    if node.cost + heuristic(node.position) >= best_cost - 1e-10:\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        root_s = Node(start_pos, cost=0.0)\n        root_g = Node(goal_pos, cost=0.0)\n        tree_s = [root_s]\n        tree_g = [root_g]\n        nodes = [root_s, root_g]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n\n        import heapq\n\n        # Priority queue for expansion favoring nodes with low cost+heuristic\n        def prioritized_nodes(tree):\n            return [(node.cost + heuristic(node.position), node) for node in tree]\n\n        for it in range(self.max_iter):\n            # Alternate expansion and pick smaller tree to grow (balanced growth)\n            if len(tree_s) <= len(tree_g):\n                tree_a, tree_b = tree_s, tree_g\n                root_a, root_b = root_s, root_g\n                reverse = False\n            else:\n                tree_a, tree_b = tree_g, tree_s\n                root_a, root_b = root_g, root_s\n                reverse = True\n\n            # Sampling - mix random, goal bias and heuristically informed\n            if random.random() < 0.12:\n                sample_pos = goal_pos if not reverse else start_pos\n            else:\n                sample_pos = informed_sample(best_cost)\n\n            # Build KDTree to accelerate nearest and radius search\n            if len(tree_a) > 1:\n                kdt_a = KDTree([(node.position, node) for node in tree_a])\n                nearest_node = kdt_a.nearest(sample_pos)\n            else:\n                nearest_node = tree_a[0]\n\n            new_pos = steer(nearest_node.position, sample_pos)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n\n            near_nodes = []\n            if len(tree_a) > 1:\n                near_nodes = kdt_a.radius_search(new_pos, r)\n            else:\n                near_nodes = [nearest_node]\n\n            # Choose best parent from near_nodes\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                candi_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if candi_cost + 1e-12 < min_cost and can_connect(nnode.position, new_pos):\n                    min_cost = candi_cost\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection to tree_b\n            if len(tree_b) > 0:\n                kdt_b = KDTree([(node.position, node) for node in tree_b])\n                nearest_b = kdt_b.nearest(new_node.position)\n                dist_nb = math.dist(nearest_b.position, new_node.position)\n\n                path_connected = False\n\n                if dist_nb <= self.step_size and can_connect(nearest_b.position, new_node.position):\n                    # Shortcut edge connecting two trees\n                    conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_nb)\n                    nearest_b.children.append(conn_node)\n                    tree_b.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((nearest_b, conn_node))\n\n                    # Extract merged path start->goal\n                    if not reverse:\n                        path_from_start = conn_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                        path_from_goal.reverse()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = conn_node.path_from_root()\n                        path_from_goal.reverse()\n\n                    merged_path = path_from_start + path_from_goal[1:]\n\n                    # Update best cost & path if improved\n                    total_cost = conn_node.cost + new_node.cost - dist_nb  # approximate total cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_path = merged_path\n                        best_path = shortcut_path(best_path, iterations=200)\n\n                    success_state = True\n                    path_connected = True\n\n                # If not directly connected, attempt local incremental extensions from nearest_b toward new_node.position\n                if not path_connected:\n                    last_node = nearest_b\n                    max_ext = int(math.ceil(dist_nb / self.step_size)) + 5\n                    for _ in range(max_ext):\n                        next_pos = steer(last_node.position, new_node.position)\n                        if not can_add_node(next_pos) or not can_connect(last_node.position, next_pos):\n                            break\n                        cost_next = last_node.cost + math.dist(last_node.position, next_pos)\n                        next_node = Node(next_pos, parent=last_node, cost=cost_next)\n                        last_node.children.append(next_node)\n                        tree_b.append(next_node)\n                        nodes.append(next_node)\n                        edges.append((last_node, next_node))\n\n                        # Rewire neighbors around next_node\n                        near_b = kdt_b.radius_search(next_pos, r)\n                        for nb_n in near_b:\n                            if nb_n is last_node:\n                                continue\n                            cost_via_new_b = next_node.cost + math.dist(next_node.position, nb_n.position)\n                            if cost_via_new_b + 1e-12 < nb_n.cost and can_connect(next_node.position, nb_n.position):\n                                try:\n                                    edges.remove((nb_n.parent, nb_n))\n                                except ValueError:\n                                    pass\n                                nb_n.update_parent(next_node, cost_via_new_b)\n                                edges.append((next_node, nb_n))\n\n                        dist_to_new = math.dist(next_node.position, new_node.position)\n                        if dist_to_new <= self.step_size and can_connect(next_node.position, new_node.position):\n                            connect_node = Node(new_node.position, parent=next_node, cost=next_node.cost + dist_to_new)\n                            next_node.children.append(connect_node)\n                            tree_b.append(connect_node)\n                            nodes.append(connect_node)\n                            edges.append((next_node, connect_node))\n\n                            # Path extraction again\n                            if not reverse:\n                                path_from_start = connect_node.path_from_root()\n                                path_from_goal = new_node.path_from_root()\n                                path_from_goal.reverse()\n                            else:\n                                path_from_start = new_node.path_from_root()\n                                path_from_goal = connect_node.path_from_root()\n                                path_from_goal.reverse()\n                            merged_path = path_from_start + path_from_goal[1:]\n\n                            total_cost = connect_node.cost + new_node.cost - dist_to_new\n                            if total_cost + 1e-12 < best_cost:\n                                best_cost = total_cost\n                                best_path = merged_path\n                                best_path = shortcut_path(best_path, iterations=200)\n                            success_state = True\n                            break\n\n                        last_node = next_node\n\n            # Periodic pruning to keep efficient search\n            if it > 0 and it % 200 == 0 and len(nodes) > 500 and best_cost < float('inf'):\n                removed_s = prune_nodes(nodes, tree_s, tree_g, best_cost)\n                removed_g = prune_nodes(nodes, tree_g, tree_s, best_cost)\n                # Clear collision cache to re-validate connections\n                self.collision_cache.clear()\n\n            if success_state and best_path:\n                extracted_path = shortcut_path(best_path, iterations=250)\n                # Early stop if good enough\n                if best_cost < math.dist(start_pos, goal_pos)*1.1:\n                    break\n\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1939.47056,
    "time_improvement": -6500.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1281.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.9569186687469482,
            "num_nodes_avg": 1839.9,
            "path_length_avg": 153.10668711811613,
            "smoothness_avg": 0.0439909060703762,
            "success_improvement": 0.0,
            "time_improvement": -7695.4543123343865,
            "length_improvement": 16.07979865984793,
            "smoothness_improvement": 588.5532077828944,
            "objective_score": -2302.4775679294316
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 6.303923511505127,
            "num_nodes_avg": 6092.0,
            "path_length_avg": 224.60721237103138,
            "smoothness_avg": 0.07866042684547524,
            "success_improvement": 0.0,
            "time_improvement": -3721.8760380201948,
            "length_improvement": 25.019647550401075,
            "smoothness_improvement": 1923.989439549449,
            "objective_score": -1101.938934698231
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.079040670394898,
            "num_nodes_avg": 4345.5,
            "path_length_avg": 118.07507310889143,
            "smoothness_avg": 0.1125268570818599,
            "success_improvement": 0.0,
            "time_improvement": -8083.226256368657,
            "length_improvement": 21.58015857185454,
            "smoothness_improvement": 1331.333316212654,
            "objective_score": -2413.995178615163
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional RRT* style incremental tree growth with goal biasing, adaptive rewiring radius, and enhanced connection attempts for faster convergence and improved path quality. It alternates tree expansions from start and goal, adaptively rewires around new nodes to optimize cost, and strategically attempts tree bridging within adaptive radius, ensuring node and edge collision-freeness. The planner uses refined collision checking granularity, dynamic rewiring radius shrinking as the tree grows, and path smoothing by shortcutting extracted paths for reduced length and higher smoothness. Overall, it aims for higher success rates, shorter and smoother paths, and lower computation time by combining exploration and exploitation effectively.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately sampling with goal biasing towards the opposite root. Each expansion steers from nearest existing node towards the sample under step size limits, rejecting invalid or colliding nodes. After node insertion, an adaptive rewiring procedure optimizes nearby nodes' parentage to minimize cost. The planner attempts to connect the two trees within an adaptively computed radius, considering collision-free edges. Upon successful connection, it extracts and shortcuts the path from start to goal to improve smoothness and reduce length. The process continues until success or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def reparent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, rewire_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        # Utils\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_rewire_radius(tree_size):\n            if tree_size == 0:\n                return self.step_size * 2.0\n            gamma = self.rewire_factor\n            r = gamma * ((math.log(tree_size + 1) / (tree_size + 1)) ** (1 / dim))\n            return max(r, self.step_size * 1.5)\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def is_valid_point(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not is_valid_point(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor.parent is None:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.3):\n                        neighbor.reparent(new_node, potential_cost)\n\n        def extend(tree, target_pos):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            new_pos = steer(nearest_node.position, target_pos)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing unnecessary intermediate nodes\n            if len(path) <= 2:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.3):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        # Initialize\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        extracted_path = []\n\n        # Alternate growth\n        for _ in range(self.max_iter):\n            for tree_a, tree_b, opposite_root in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                samp = opposite_root if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_valid_point(samp):\n                    continue\n\n                new_node = extend(tree_a, samp)\n                if new_node is None:\n                    continue\n\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_cost = float('inf')\n                for nb in neighbors_b:\n                    d = dist(nb.position, new_node.position)\n                    if d <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d, resolution=0.3):\n                        total_cost = new_node.cost + d + nb.cost\n                        if total_cost < min_cost:\n                            best_connect_node = nb\n                            min_cost = total_cost\n\n                if best_connect_node is not None:\n                    # Connect trees by attaching best_connect_node to new_node\n                    connect_pos = best_connect_node.position\n                    connect_cost = new_node.cost + dist(new_node.position, connect_pos)\n                    connect_node = Node(connect_pos, parent=new_node, cost=connect_cost)\n                    new_node.children.append(connect_node)\n                    tree_a.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    rewire(tree_a, connect_node)\n\n                    # Build path: start_tree root -> connect_node, goal_tree root -> best_connect_node\n                    path_start = []\n                    cur = connect_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    full_path = path_start + path_goal[1:]\n                    extracted_path = shortcut_path(full_path)\n                    success = True\n                    break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.78714,
    "time_improvement": 11.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1730.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04920442104339599,
            "num_nodes_avg": 152.9,
            "path_length_avg": 172.5881128385138,
            "smoothness_avg": 0.046899447573852705,
            "success_improvement": 0.0,
            "time_improvement": -96.00754100540406,
            "length_improvement": 5.401720519552614,
            "smoothness_improvement": 634.0781983112677,
            "objective_score": -24.551527206154358
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.047154474258422854,
            "num_nodes_avg": 268.7,
            "path_length_avg": 236.1447124385955,
            "smoothness_avg": 0.11578865631105095,
            "success_improvement": 0.0,
            "time_improvement": 71.41168433836575,
            "length_improvement": 21.168097939321875,
            "smoothness_improvement": 2879.325526081461,
            "objective_score": 40.053752519781405
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.020639967918395997,
            "num_nodes_avg": 181.2,
            "path_length_avg": 126.67048905614561,
            "smoothness_avg": 0.13968973069573454,
            "success_improvement": -9.999999999999998,
            "time_improvement": 58.59283075398382,
            "length_improvement": 15.87149256941217,
            "smoothness_improvement": 1676.843063626367,
            "objective_score": -20.863636941790574
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid enhanced bidirectional RRT which integrates adaptive goal-biased and informed sampling with dynamic step sizing and robust collision checking. It improves planning efficiency, success rate, and path quality by steering expansions strategically, connecting trees incrementally, and performing post-processing path smoothing. The planner ensures all nodes and edges are collision-free, respects map boundaries, and refines the path for smoothness and optimality.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with adaptive biases toward the goal and near existing nodes to efficiently explore free space. Each extension uses dynamic step sizes adjusted for obstacle proximity. Trees are connected incrementally when close and collision-free. Upon success, the path is extracted from connected nodes and subsequently smoothed to reduce length and improve feasibility. The process iterates within maximum iterations, providing a practical balance of speed and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return list(reversed(path))\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float=6.0,\n                 goal_sample_rate: float = 0.2, node_sample_rate: float = 0.25,\n                 smoothing_iters: int = 40, obstacle_influence_radius: float = 8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate      # Probability to sample goal directly\n        self.node_sample_rate = node_sample_rate      # Probability to sample near existing nodes\n        self.smoothing_iters = smoothing_iters        # Number of smoothing iterations post path extraction\n        self.obstacle_influence_radius = obstacle_influence_radius  # Radius to reduce step size near obstacles\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def sample_point():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < self.goal_sample_rate + self.node_sample_rate:\n                combined = start_tree + goal_tree\n                near_node = random.choice(combined)\n                dim = len(bounds)\n                return tuple(\n                    max(0.0, min(bounds[d], random.gauss(near_node.position[d], self.step_size * 1.5)))\n                    for d in range(dim)\n                )\n            else:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, sample):\n            return min(tree, key=lambda n: math.dist(n.position, sample))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(p1, p2, resolution=0.4):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def reduce_step_if_near_obstacle(from_pos, to_pos):\n            # Reduce step size if near obstacles for safer expansion\n            dist = distance(from_pos, to_pos)\n            if dist < 1e-6:\n                return self.step_size\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            closest_dist = float('inf')\n            # Check sampled points along the line for proximity to obstacles\n            check_steps = max(1, int(dist / 1.0))\n            for i in range(check_steps + 1):\n                sample_pt = tuple(from_pos[d] + direction[d] * (dist * i / check_steps) for d in range(len(from_pos)))\n                # Distance to closest obstacle surfaces (approximate by checking obstacle AABB distances)\n                for obs in obstacles:\n                    if is_3d:\n                        x, y, z, w, h, d_ = obs\n                        px, py, pz = sample_pt\n                        dx = 0 if x <= px <= x + w else min(abs(px - x), abs(px - (x + w)))\n                        dy = 0 if y <= py <= y + h else min(abs(py - y), abs(py - (y + h)))\n                        dz = 0 if z <= pz <= z + d_ else min(abs(pz - z), abs(pz - (z + d_)))\n                        dist_obs = math.sqrt(dx*dx + dy*dy + dz*dz)\n                    else:\n                        x, y, w, h = obs\n                        px, py = sample_pt\n                        dx = 0 if x <= px <= x + w else min(abs(px - x), abs(px - (x + w)))\n                        dy = 0 if y <= py <= y + h else min(abs(py - y), abs(py - (y + h)))\n                        dist_obs = math.sqrt(dx*dx + dy*dy)\n                    if dist_obs < closest_dist:\n                        closest_dist = dist_obs\n            if closest_dist < self.obstacle_influence_radius:\n                factor = max(0.2, closest_dist / self.obstacle_influence_radius)\n                return self.step_size * factor\n            return self.step_size\n\n        def connect_trees(new_node, tree_other):\n            nearest_node = nearest(tree_other, new_node.position)\n            dist = distance(new_node.position, nearest_node.position)\n            max_connect_dist = self.step_size * 1.8\n            if dist <= max_connect_dist:\n                if edge_collision_free(new_node.position, nearest_node.position):\n                    conn_node = Node(nearest_node.position, parent=new_node, cost=new_node.cost + dist)\n                    if collision_free(conn_node.position):\n                        new_node.add_child(conn_node)\n                        tree_other.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        return conn_node, nearest_node\n            return None, None\n\n        def extract_path(node_a, node_b):\n            path_start = node_a.path_from_root()\n            path_goal = node_b.path_from_root()\n            path_goal.reverse()\n            # skip duplicate node at connection\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if edge_collision_free(path[i], path[j]):\n                    del path[i + 1:j]\n            return path\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                sample = sample_point()\n                if not collision_free(sample):\n                    continue\n                nearest_node = nearest(tree_a, sample)\n\n                adapt_step = reduce_step_if_near_obstacle(nearest_node.position, sample)\n                new_pos = steer(nearest_node.position, sample, adapt_step)\n\n                if not collision_free(new_pos):\n                    continue\n                if not edge_collision_free(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                if not collision_free(new_node.position):\n                    continue\n\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                conn_node_a, conn_node_b = connect_trees(new_node, tree_b)\n                if conn_node_a and conn_node_b:\n                    raw_path = extract_path(conn_node_a, conn_node_b)\n                    smoothed_path = smooth_path(raw_path)\n                    success_state = True\n                    extracted_path = smoothed_path\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 231.57753,
    "time_improvement": -790.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 647.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5700606822967529,
            "num_nodes_avg": 418.2,
            "path_length_avg": 163.57313794705698,
            "smoothness_avg": 0.006993644937940147,
            "success_improvement": 0.0,
            "time_improvement": -2170.856768384762,
            "length_improvement": 10.34297110897874,
            "smoothness_improvement": 9.465730221821483,
            "objective_score": -649.1411076425237
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.23153469562530518,
            "num_nodes_avg": 995.8,
            "path_length_avg": 257.4543677471367,
            "smoothness_avg": 0.04135332548715951,
            "success_improvement": 0.0,
            "time_improvement": -40.37240514826216,
            "length_improvement": 14.054321632911677,
            "smoothness_improvement": 964.0508503810198,
            "objective_score": -4.480602965991214
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12834565639495848,
            "num_nodes_avg": 727.9,
            "path_length_avg": 140.7952728447601,
            "smoothness_avg": 0.08389646216857978,
            "success_improvement": 0.0,
            "time_improvement": -157.48248918548165,
            "length_improvement": 6.490483726940603,
            "smoothness_improvement": 967.1568061916579,
            "objective_score": -41.11086597929808
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner employs a tuned hybrid bidirectional RRT* approach incorporating adaptive step sizing, informed sampling with enhanced goal biasing, incremental rewiring with a dynamic radius, pruning non-promising nodes, and path shortcutting to improve planning efficiency, robustness, and path quality. It balances exploration and exploitation by alternating expansions between start and goal trees, focusing search within an informed ellipsoidal subset of the space constrained by the current best path cost, and adapts local growth near obstacles for smoother paths and faster convergence.",
    "planning_mechanism": "The planner initializes two trees from start and goal positions, sampling points biased within an informed ellipsoid defined by the current best path cost and the minimal possible path. It expands trees alternately using adaptive step sizes that decrease near obstacles to refine local exploration. Rewiring optimizes path costs inside a dynamically computed neighborhood radius, and pruning discards nodes unlikely to improve the solution. Upon connection of trees through collision-free edges, the final path is shortcut-smoothed to reduce unnecessary detours, terminating early when an optimized path is found or maximum iterations are exhausted.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, base_rewire_factor: float = 1.5, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.base_rewire_factor = base_rewire_factor\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start, tree_goal = [start_root], [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(4, int(distance))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.3, 1.0)\n                    break\n            return step\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def informed_sample():\n            nonlocal c_best\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.01\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # fallback uniform sampling\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Dynamic rewire radius based on number of nodes and search dimension\n        def compute_rewire_radius(num_nodes):\n            gamma_rrt_star = self.base_rewire_factor * (math.log(num_nodes + 1) / (num_nodes + 1)) ** (1 / dim)\n            radius = min(gamma_rrt_star * (bounds[0] if dim == 1 else max(bounds)), self.base_step * 8)\n            return max(radius, self.base_step * 1.5)\n\n        def rewire(new_node, tree):\n            radius = compute_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # update edges\n                        for idx, e in enumerate(edges):\n                            if e[1] == neighbor:\n                                edges[idx] = (new_node, neighbor)\n                                break\n\n        def prune(tree):\n            nonlocal c_best\n            to_remove = []\n            for node in tree:\n                if node.cost + dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if active_tree is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            nearest = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            if new_cost + dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state and iter_num > self.max_iter * 0.3:\n                # Attempt more shortcut path smoothing\n                for _ in range(3):\n                    extracted_path = shortcut_path(extracted_path)\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 286.98713,
    "time_improvement": -883.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1422.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.5115656614303589,
            "num_nodes_avg": 628.4,
            "path_length_avg": 152.38901531938265,
            "smoothness_avg": 0.04946411433630614,
            "success_improvement": -19.999999999999996,
            "time_improvement": -1937.839796373859,
            "length_improvement": 16.473165944971143,
            "smoothness_improvement": 674.2208024066776,
            "objective_score": -674.68620171113
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.33187601566314695,
            "num_nodes_avg": 768.1,
            "path_length_avg": 229.04954303700455,
            "smoothness_avg": 0.08595725542662694,
            "success_improvement": 0.0,
            "time_improvement": -101.20627884232614,
            "length_improvement": 23.536669708700696,
            "smoothness_improvement": 2111.7420946356724,
            "objective_score": -15.095839237779341
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.35356869697570803,
            "num_nodes_avg": 764.5,
            "path_length_avg": 118.84553183027147,
            "smoothness_avg": 0.12424669135812298,
            "success_improvement": 0.0,
            "time_improvement": -609.3169395247926,
            "length_improvement": 21.06845657441572,
            "smoothness_improvement": 1480.4087431385396,
            "objective_score": -171.17934682686194
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with informed sampling and adaptive neighbor radius for rewiring. It balances exploration and exploitation by expanding the smaller tree at each iteration, uses collision check caching to avoid redundant computations, and applies iterative shortcutting for path smoothing, resulting in high-quality, smooth paths with improved planning efficiency and robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding the smaller one. Sampling is biased within an ellipsoidal informed set based on the current best cost to focus search efforts. Adaptive neighbor radius shrinks over iterations to optimize rewiring. Each new node is connected considering the lowest-cost parent from nearby nodes with collision checks. Trees are incrementally connected, and paths are shortcut iteratively for smoothness. Node pruning removes lesser promising nodes periodically to accelerate convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = 20.0 * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = 5.0 + (20.0 - 5.0) * math.sqrt(math.log(c + 1) / c)\n            return max(5.0, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < 0.15:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            heuristic = lambda pos: dist(pos, goal_position)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            iteration = 0\n            max_iter = 100\n            while iteration < max_iter:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        prune_interval = 100\n        prune_threshold = 150\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Expand the smaller tree to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b , cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning for efficiency\n            if it > 0 and it % prune_interval == 0 and len(nodes) > prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -30.21987,
    "time_improvement": 65.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1522.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014252924919128418,
            "num_nodes_avg": 82.4,
            "path_length_avg": 164.1325608223221,
            "smoothness_avg": 0.045959125307800226,
            "success_improvement": 0.0,
            "time_improvement": 43.22297252376747,
            "length_improvement": 10.0363425664232,
            "smoothness_improvement": 619.3601129050631,
            "objective_score": 18.070960834940195
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023722171783447266,
            "num_nodes_avg": 221.8,
            "path_length_avg": 238.32159558083922,
            "smoothness_avg": 0.09632176901970001,
            "success_improvement": 0.0,
            "time_improvement": 85.61797272072086,
            "length_improvement": 20.441391688333844,
            "smoothness_improvement": 2378.4284946428356,
            "objective_score": 41.6658126270972
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01717720031738281,
            "num_nodes_avg": 171.7,
            "path_length_avg": 124.77901840118238,
            "smoothness_avg": 0.13106039981308298,
            "success_improvement": 0.0,
            "time_improvement": 65.53971190620594,
            "length_improvement": 17.12771731628499,
            "smoothness_improvement": 1567.0786117499888,
            "objective_score": 30.922850093868725
        }
    ],
    "success_rate": 1.0
}
