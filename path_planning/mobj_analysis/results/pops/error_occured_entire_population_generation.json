{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            return to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            return (new_x, new_y)\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            new_node = to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            new_node = (new_x, new_y)\n        return new_node\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            new_node = to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            new_node = (new_x, new_y)\n        return new_node\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner that maintains balanced growth of two trees from start and goal, uses informed sampling within an ellipsoidal subset to focus exploration, applies adaptive neighbor radius shrinking for rewiring, caches collision results for efficiency, prunes non-promising nodes periodically, and performs path shortcutting to generate shorter, smoother paths.",
    "planning_mechanism": "The planner iteratively samples points biased in an ellipsoid defined by the current best path cost, grows the smaller tree towards samples, rewires neighbors within a shrinking radius to improve path cost, attempts to connect the two trees with rewiring, prunes nodes unlikely to improve solutions, caches collision checks for faster feasibility testing, and shortcuts the path after a successful connection.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position          # 2D or 3D coordinate\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from start\n        self.children: List[Node] = []   # Child nodes\n        self.valid = True                 # Validity for collision/pruning\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_cache = {}   # Cache for edge collision results\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_start_node = None\n        best_goal_node = None\n\n        def ellipsoidal_sample():\n            # If no path found yet, sample uniformly\n            if best_cost == math.inf:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Informed sampling inside ellipsoid\n            c_min = math.dist(start_pos, goal_pos)\n            c_best = best_cost\n\n            # Center, rotation and axes lengths of ellipsoid\n            mid = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(len(bounds)))\n            a1 = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(bounds)))\n            # Build rotation matrix aligning x-axis with start-goal vector\n            # For simplicity, sample in unit ball and scale/rotate to ellipsoid\n            import numpy as np\n            L = np.diag([c_best * 0.5] + [math.sqrt(c_best**2 - c_min**2)/2] * (len(bounds)-1))\n            while True:\n                # Sample point in unit n-ball\n                x = np.random.normal(0,1,len(bounds))\n                norm_x = np.linalg.norm(x)\n                if norm_x > 1e-8:\n                    x_ball = x / norm_x * (np.random.uniform()**(1/len(bounds)))\n                else:\n                    x_ball = np.zeros_like(x)\n                sample_in_ellipsoid = np.array(mid) + L.dot(x_ball)\n                sample_t = tuple(sample_in_ellipsoid.tolist())\n                if self._inside_bounds(sample_t, bounds) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        import random\n        import numpy as np\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def radius(iter_num: int, dim: int, gamma_rrt_star=30.0) -> float:\n            return min(self.step_size * 20.0, (gamma_rrt_star * (math.log(iter_num + 1) / (iter_num + 1))) ** (1/dim))\n\n        def rewire(tree: List[Node], new_node: Node, radius_val: float):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= radius_val and node != new_node]\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-6 < neighbor.cost:\n                    if not self._edge_collision_cached(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Detach old parent edge\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def connect_trees(tree_a: List[Node], tree_b: List[Node], new_node: Node, radius_val: float):\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_nearest = math.dist(new_node.position, nearest_in_b.position)\n            if dist_to_nearest <= radius_val and not self._edge_collision_cached(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                # Connect the two trees\n                conn_cost = new_node.cost + dist_to_nearest\n                if conn_cost < best_cost:\n                    nonlocal best_cost, best_start_node, best_goal_node\n                    # Re-wire goal tree node if better\n                    if nearest_in_b.parent:\n                        try:\n                            edges.remove((nearest_in_b.parent, nearest_in_b))\n                            nearest_in_b.parent.children.remove(nearest_in_b)\n                        except ValueError:\n                            pass\n                    nearest_in_b.parent = new_node\n                    nearest_in_b.cost = conn_cost\n                    new_node.children.append(nearest_in_b)\n                    edges.append((new_node, nearest_in_b))\n                    best_cost = conn_cost\n                    best_start_node, best_goal_node = (new_node, nearest_in_b)\n                    return True\n            return False\n\n        def prune_nodes(tree: List[Node], cost_upper_bound: float):\n            # Remove nodes whose cost + heuristic to goal exceed current best cost + margin\n            pruned = []\n            for node in tree[:]:\n                if node.cost + math.dist(node.position, goal_pos) > cost_upper_bound * 1.05:\n                    # Remove node and its descendants from tree and edges\n                    def remove_subtree(nd: Node):\n                        for c in nd.children[:]:\n                            remove_subtree(c)\n                        if nd.parent:\n                            if (nd.parent, nd) in edges:\n                                edges.remove((nd.parent, nd))\n                            if nd in nd.parent.children:\n                                nd.parent.children.remove(nd)\n                        if nd in tree:\n                            tree.remove(nd)\n                            if nd in nodes:\n                                nodes.remove(nd)\n                    remove_subtree(node)\n                    pruned.append(node)\n            return pruned\n\n        def shortcut_path(path_in: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_in) < 3:\n                return path_in\n            shortened = [path_in[0]]\n            i = 0\n            while i < len(path_in) -1:\n                j = len(path_in) -1\n                while j > i +1:\n                    if not self._edge_collision_cached(path_in[i], path_in[j], obstacles, is_3d):\n                        shortened.append(path_in[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path_in[i+1])\n                    i += 1\n            return shortened\n\n        dim = len(bounds)\n        treeA, treeB = start_tree, goal_tree\n        for iter_num in range(1, self.max_iter+1):\n            sample = ellipsoidal_sample()\n\n            # Grow smaller tree first for balanced expansion\n            if len(treeA) > len(treeB):\n                treeA, treeB = treeB, treeA\n\n            nearest_node = nearest(treeA, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not self._inside_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_collision_cached(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = cost_to_new\n            nearest_node.children.append(new_node)\n\n            treeA.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            curr_radius = radius(iter_num, dim)\n            rewire(treeA, new_node, curr_radius)\n\n            connected = connect_trees(treeA, treeB, new_node, curr_radius)\n            if connected:\n                success = True\n                # Compose full path from start to goal across trees\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                path_goal = path_goal[::-1][1:]  # Avoid duplicate connecting node\n                raw_path = path_start + path_goal\n                path = shortcut_path(raw_path)\n\n                prune_nodes(treeA, best_cost)\n                prune_nodes(treeB, best_cost)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _inside_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_collision_cached(self, from_pos, to_pos, obstacles, is_3d):\n        key = (from_pos, to_pos)\n        rev_key = (to_pos, from_pos)\n        if key in self.collision_cache:\n            return self.collision_cache[key]\n        if rev_key in self.collision_cache:\n            return self.collision_cache[rev_key]\n\n        collision = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n        self.collision_cache[key] = collision\n        return collision",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 130\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
