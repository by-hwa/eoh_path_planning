{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            return to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            return (new_x, new_y)\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            new_node = to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            new_node = (new_x, new_y)\n        return new_node\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, start: Tuple[float, float], goal: Tuple[float, float], map_: 'Map', max_iter=5000, step_size=1.0):\n        self.start = start\n        self.goal = goal\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.nodes = [start]\n        self.parents = {start: None}\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rnd = self.sample_free()\n            nearest = self.get_nearest_node(rnd)\n            new_node = self.steer(nearest, rnd)\n\n            if self.is_in_obstacle(new_node):\n                continue\n\n            if self.edge_collides(nearest, new_node):\n                continue\n\n            self.nodes.append(new_node)\n            self.parents[new_node] = nearest\n\n            if self.reached_goal(new_node):\n                path = self.generate_path(new_node)\n                cost = self.compute_cost(path)\n                return PlannerResult(path, cost)\n\n        # If goal not reached, find closest node to goal and path to it\n        closest = min(self.nodes, key=lambda n: self.distance(n, self.goal))\n        path = self.generate_path(closest)\n        cost = self.compute_cost(path)\n        return PlannerResult(path, cost)\n\n    def sample_free(self) -> Tuple[float, float]:\n        x_min, x_max = 0, self.map.width\n        y_min, y_max = 0, self.map.height\n\n        while True:\n            x = np.random.uniform(x_min, x_max)\n            y = np.random.uniform(y_min, y_max)\n            if not self.is_in_obstacle((x, y)):\n                return (x, y)\n\n    def get_nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        nearest = min(self.nodes, key=lambda n: self.distance(n, point))\n        return nearest\n\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\n        dist = self.distance(from_node, to_node)\n        if dist < self.step_size:\n            new_node = to_node\n        else:\n            theta = math.atan2(to_node[1] - from_node[1], to_node[0] - from_node[0])\n            new_x = from_node[0] + self.step_size * math.cos(theta)\n            new_y = from_node[1] + self.step_size * math.sin(theta)\n\n            # Clamp to map bounds\n            new_x = max(0, min(new_x, self.map.width))\n            new_y = max(0, min(new_y, self.map.height))\n            new_node = (new_x, new_y)\n        return new_node\n\n    def is_in_obstacle(self, point: Tuple[float, float]) -> bool:\n        return self.map.point_in_obstacle(point)\n\n    def edge_collides(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Check if line segment between p1 and p2 crosses any obstacle\n        return self.map.edge_intersects_obstacle(p1, p2)\n\n    def reached_goal(self, node: Tuple[float, float]) -> bool:\n        dist = self.distance(node, self.goal)\n        threshold = self.step_size  # Close enough\n        if dist <= threshold:\n            # Check edge from node to goal for collision\n            if not self.edge_collides(node, self.goal) and not self.is_in_obstacle(self.goal):\n                self.nodes.append(self.goal)\n                self.parents[self.goal] = node\n                return True\n        return False\n\n    def generate_path(self, end_node: Tuple[float, float]) -> List[Tuple[float, float]]:\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = self.parents[node]\n        path.reverse()\n        return path\n\n    def compute_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self.distance(path[i], path[i + 1])\n        return cost\n\n    @staticmethod\n    def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 3 required positional arguments: 'start', 'goal', and 'map_'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner that maintains balanced growth of two trees from start and goal, uses informed sampling within an ellipsoidal subset to focus exploration, applies adaptive neighbor radius shrinking for rewiring, caches collision results for efficiency, prunes non-promising nodes periodically, and performs path shortcutting to generate shorter, smoother paths.",
    "planning_mechanism": "The planner iteratively samples points biased in an ellipsoid defined by the current best path cost, grows the smaller tree towards samples, rewires neighbors within a shrinking radius to improve path cost, attempts to connect the two trees with rewiring, prunes nodes unlikely to improve solutions, caches collision checks for faster feasibility testing, and shortcuts the path after a successful connection.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position          # 2D or 3D coordinate\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from start\n        self.children: List[Node] = []   # Child nodes\n        self.valid = True                 # Validity for collision/pruning\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_cache = {}   # Cache for edge collision results\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_start_node = None\n        best_goal_node = None\n\n        def ellipsoidal_sample():\n            # If no path found yet, sample uniformly\n            if best_cost == math.inf:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Informed sampling inside ellipsoid\n            c_min = math.dist(start_pos, goal_pos)\n            c_best = best_cost\n\n            # Center, rotation and axes lengths of ellipsoid\n            mid = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(len(bounds)))\n            a1 = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(bounds)))\n            # Build rotation matrix aligning x-axis with start-goal vector\n            # For simplicity, sample in unit ball and scale/rotate to ellipsoid\n            import numpy as np\n            L = np.diag([c_best * 0.5] + [math.sqrt(c_best**2 - c_min**2)/2] * (len(bounds)-1))\n            while True:\n                # Sample point in unit n-ball\n                x = np.random.normal(0,1,len(bounds))\n                norm_x = np.linalg.norm(x)\n                if norm_x > 1e-8:\n                    x_ball = x / norm_x * (np.random.uniform()**(1/len(bounds)))\n                else:\n                    x_ball = np.zeros_like(x)\n                sample_in_ellipsoid = np.array(mid) + L.dot(x_ball)\n                sample_t = tuple(sample_in_ellipsoid.tolist())\n                if self._inside_bounds(sample_t, bounds) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        import random\n        import numpy as np\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def radius(iter_num: int, dim: int, gamma_rrt_star=30.0) -> float:\n            return min(self.step_size * 20.0, (gamma_rrt_star * (math.log(iter_num + 1) / (iter_num + 1))) ** (1/dim))\n\n        def rewire(tree: List[Node], new_node: Node, radius_val: float):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= radius_val and node != new_node]\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-6 < neighbor.cost:\n                    if not self._edge_collision_cached(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Detach old parent edge\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def connect_trees(tree_a: List[Node], tree_b: List[Node], new_node: Node, radius_val: float):\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_nearest = math.dist(new_node.position, nearest_in_b.position)\n            if dist_to_nearest <= radius_val and not self._edge_collision_cached(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                # Connect the two trees\n                conn_cost = new_node.cost + dist_to_nearest\n                if conn_cost < best_cost:\n                    nonlocal best_cost, best_start_node, best_goal_node\n                    # Re-wire goal tree node if better\n                    if nearest_in_b.parent:\n                        try:\n                            edges.remove((nearest_in_b.parent, nearest_in_b))\n                            nearest_in_b.parent.children.remove(nearest_in_b)\n                        except ValueError:\n                            pass\n                    nearest_in_b.parent = new_node\n                    nearest_in_b.cost = conn_cost\n                    new_node.children.append(nearest_in_b)\n                    edges.append((new_node, nearest_in_b))\n                    best_cost = conn_cost\n                    best_start_node, best_goal_node = (new_node, nearest_in_b)\n                    return True\n            return False\n\n        def prune_nodes(tree: List[Node], cost_upper_bound: float):\n            # Remove nodes whose cost + heuristic to goal exceed current best cost + margin\n            pruned = []\n            for node in tree[:]:\n                if node.cost + math.dist(node.position, goal_pos) > cost_upper_bound * 1.05:\n                    # Remove node and its descendants from tree and edges\n                    def remove_subtree(nd: Node):\n                        for c in nd.children[:]:\n                            remove_subtree(c)\n                        if nd.parent:\n                            if (nd.parent, nd) in edges:\n                                edges.remove((nd.parent, nd))\n                            if nd in nd.parent.children:\n                                nd.parent.children.remove(nd)\n                        if nd in tree:\n                            tree.remove(nd)\n                            if nd in nodes:\n                                nodes.remove(nd)\n                    remove_subtree(node)\n                    pruned.append(node)\n            return pruned\n\n        def shortcut_path(path_in: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_in) < 3:\n                return path_in\n            shortened = [path_in[0]]\n            i = 0\n            while i < len(path_in) -1:\n                j = len(path_in) -1\n                while j > i +1:\n                    if not self._edge_collision_cached(path_in[i], path_in[j], obstacles, is_3d):\n                        shortened.append(path_in[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path_in[i+1])\n                    i += 1\n            return shortened\n\n        dim = len(bounds)\n        treeA, treeB = start_tree, goal_tree\n        for iter_num in range(1, self.max_iter+1):\n            sample = ellipsoidal_sample()\n\n            # Grow smaller tree first for balanced expansion\n            if len(treeA) > len(treeB):\n                treeA, treeB = treeB, treeA\n\n            nearest_node = nearest(treeA, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not self._inside_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_collision_cached(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = cost_to_new\n            nearest_node.children.append(new_node)\n\n            treeA.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            curr_radius = radius(iter_num, dim)\n            rewire(treeA, new_node, curr_radius)\n\n            connected = connect_trees(treeA, treeB, new_node, curr_radius)\n            if connected:\n                success = True\n                # Compose full path from start to goal across trees\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                path_goal = path_goal[::-1][1:]  # Avoid duplicate connecting node\n                raw_path = path_start + path_goal\n                path = shortcut_path(raw_path)\n\n                prune_nodes(treeA, best_cost)\n                prune_nodes(treeB, best_cost)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _inside_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_collision_cached(self, from_pos, to_pos, obstacles, is_3d):\n        key = (from_pos, to_pos)\n        rev_key = (to_pos, from_pos)\n        if key in self.collision_cache:\n            return self.collision_cache[key]\n        if rev_key in self.collision_cache:\n            return self.collision_cache[rev_key]\n\n        collision = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n        self.collision_cache[key] = collision\n        return collision",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 130\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, map: Map, max_iter: int = 1000):\n        self.map = map\n        self.max_iter = max_iter\n        self.nodes: List[Tuple[float, float]] = []\n        self.edges: Dict[int, List[int]] = {}\n\n    def is_in_collision(self, point: Tuple[float, float]) -> bool:\n        for (ox, oy, r) in self.map.obstacles:\n            if (point[0] - ox) ** 2 + (point[1] - oy) ** 2 <= r ** 2:\n                return True\n        return False\n\n    def edge_collision_free(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Bresenham-like line check or incremental sampling along the edge\n        steps = int(math.dist(p1, p2) * 10)\n        if steps == 0:\n            return True\n        for i in range(steps + 1):\n            t = i / steps\n            x = p1[0] + t * (p2[0] - p1[0])\n            y = p1[1] + t * (p2[1] - p1[1])\n            if self.is_in_collision((x, y)):\n                return False\n        return True\n\n    def get_nearest_node_index(self, point: Tuple[float, float]) -> Optional[int]:\n        min_dist = float('inf')\n        min_idx = None\n        for i, node in enumerate(self.nodes):\n            dist = (node[0] - point[0]) ** 2 + (node[1] - point[1]) ** 2\n            if dist < min_dist:\n                min_dist = dist\n                min_idx = i\n        return min_idx\n\n    def sample_free(self) -> Tuple[float, float]:\n        while True:\n            x = random.uniform(0, self.map.width)\n            y = random.uniform(0, self.map.height)\n            if not self.is_in_collision((x, y)):\n                return (x, y)\n\n    def plan(self, start: Tuple[float, float], goal: Tuple[float, float]) -> PlannerResult:\n        if self.is_in_collision(start) or self.is_in_collision(goal):\n            return PlannerResult(False, [], 0, float('inf'))\n\n        self.nodes = [start]\n        self.edges = {0: []}\n        for i in range(self.max_iter):\n            random_point = self.sample_free()\n            nearest_index = self.get_nearest_node_index(random_point)\n            nearest_node = self.nodes[nearest_index]\n\n            # Check edge collision before adding\n            if self.edge_collision_free(nearest_node, random_point):\n                # Add new node\n                self.nodes.append(random_point)\n                new_index = len(self.nodes) - 1\n                self.edges[new_index] = []\n                # Connect edges both ways\n                self.edges[nearest_index].append(new_index)\n                self.edges[new_index].append(nearest_index)\n\n                # Check if goal can be connected directly\n                if math.dist(random_point, goal) <= max(self.map.width, self.map.height):\n                    if not self.is_in_collision(goal) and self.edge_collision_free(random_point, goal):\n                        self.nodes.append(goal)\n                        goal_index = len(self.nodes) - 1\n                        self.edges[goal_index] = []\n                        self.edges[new_index].append(goal_index)\n                        self.edges[goal_index].append(new_index)\n\n                        # Reconstruct path\n                        path = self._reconstruct_path(0, goal_index)\n                        cost = self._path_cost(path)\n                        return PlannerResult(True, path, i + 1, cost)\n        # Failed to find path\n        return PlannerResult(False, [], self.max_iter, float('inf'))\n\n    def _reconstruct_path(self, start_idx: int, goal_idx: int) -> List[Tuple[float, float]]:\n        from collections import deque\n\n        queue = deque([start_idx])\n        visited = {start_idx: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == goal_idx:\n                break\n            for neighbor in self.edges.get(current, []):\n                if neighbor not in visited:\n                    visited[neighbor] = current\n                    queue.append(neighbor)\n\n        path_indices = []\n        cur = goal_idx\n        while cur is not None:\n            path_indices.append(cur)\n            cur = visited[cur]\n        path_indices.reverse()\n        return [self.nodes[i] for i in path_indices]\n\n    def _path_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += math.dist(path[i], path[i + 1])\n        return cost",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 1 required positional argument: 'map'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, map: Map, max_iter: int = 1000):\n        self.map = map\n        self.max_iter = max_iter\n        self.nodes: List[Tuple[float, float]] = []\n        self.edges: Dict[int, List[int]] = {}\n\n    def is_in_collision(self, point: Tuple[float, float]) -> bool:\n        # Check if point is outside map bounds\n        if not (0 <= point[0] <= self.map.width and 0 <= point[1] <= self.map.height):\n            return True\n        for (ox, oy, r) in self.map.obstacles:\n            if (point[0] - ox) ** 2 + (point[1] - oy) ** 2 <= r ** 2:\n                return True\n        return False\n\n    def edge_collision_free(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Incremental sampling along the edge\n        steps = int(math.dist(p1, p2) * 10)\n        if steps == 0:\n            return True\n        for i in range(steps + 1):\n            t = i / steps\n            x = p1[0] + t * (p2[0] - p1[0])\n            y = p1[1] + t * (p2[1] - p1[1])\n            if self.is_in_collision((x, y)):\n                return False\n        return True\n\n    def get_nearest_node_index(self, point: Tuple[float, float]) -> Optional[int]:\n        min_dist = float('inf')\n        min_idx = None\n        for i, node in enumerate(self.nodes):\n            dist = (node[0] - point[0]) ** 2 + (node[1] - point[1]) ** 2\n            if dist < min_dist:\n                min_dist = dist\n                min_idx = i\n        return min_idx\n\n    def sample_free(self) -> Tuple[float, float]:\n        while True:\n            x = random.uniform(0, self.map.width)\n            y = random.uniform(0, self.map.height)\n            if not self.is_in_collision((x, y)):\n                return (x, y)\n\n    def plan(self, start: Tuple[float, float], goal: Tuple[float, float]) -> PlannerResult:\n        if self.is_in_collision(start) or self.is_in_collision(goal):\n            return PlannerResult(False, [], 0, float('inf'))\n\n        self.nodes = [start]\n        self.edges = {0: []}\n        for i in range(self.max_iter):\n            random_point = self.sample_free()\n            # Ensure new sampled node is free and edge is collision free\n            if self.is_in_collision(random_point):\n                continue\n            nearest_index = self.get_nearest_node_index(random_point)\n            nearest_node = self.nodes[nearest_index]\n            if self.edge_collision_free(nearest_node, random_point):\n                # Add new node only if collision free\n                if self.is_in_collision(random_point):\n                    continue\n                self.nodes.append(random_point)\n                new_index = len(self.nodes) - 1\n                self.edges[new_index] = []\n                # Connect edges both ways with collision check\n                if self.edge_collision_free(nearest_node, random_point):\n                    self.edges[nearest_index].append(new_index)\n                    self.edges[new_index].append(nearest_index)\n\n                # Check if goal can be connected directly\n                if (math.dist(random_point, goal) <= max(self.map.width, self.map.height) and\n                    not self.is_in_collision(goal) and\n                    self.edge_collision_free(random_point, goal)):\n                    self.nodes.append(goal)\n                    goal_index = len(self.nodes) - 1\n                    self.edges[goal_index] = []\n                    self.edges[new_index].append(goal_index)\n                    self.edges[goal_index].append(new_index)\n\n                    # Reconstruct path\n                    path = self._reconstruct_path(0, goal_index)\n                    cost = self._path_cost(path)\n                    return PlannerResult(True, path, i + 1, cost)\n        # Failed to find path\n        return PlannerResult(False, [], self.max_iter, float('inf'))\n\n    def _reconstruct_path(self, start_idx: int, goal_idx: int) -> List[Tuple[float, float]]:\n        from collections import deque\n\n        queue = deque([start_idx])\n        visited = {start_idx: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == goal_idx:\n                break\n            for neighbor in self.edges.get(current, []):\n                if neighbor not in visited:\n                    visited[neighbor] = current\n                    queue.append(neighbor)\n\n        path_indices = []\n        cur = goal_idx\n        while cur is not None:\n            path_indices.append(cur)\n            cur = visited[cur]\n        path_indices.reverse()\n        return [self.nodes[i] for i in path_indices]\n\n    def _path_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += math.dist(path[i], path[i + 1])\n        return cost",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 1 required positional argument: 'map'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, map: Map, max_iter: int = 1000):\n        self.map = map\n        self.max_iter = max_iter\n        self.nodes: List[Tuple[float, float]] = []\n        self.edges: Dict[int, List[int]] = {}\n\n    def is_in_collision(self, point: Tuple[float, float]) -> bool:\n        # Check if point is outside map bounds\n        if not (0 <= point[0] <= self.map.width and 0 <= point[1] <= self.map.height):\n            return True\n        for (ox, oy, r) in self.map.obstacles:\n            if (point[0] - ox) ** 2 + (point[1] - oy) ** 2 <= r ** 2:\n                return True\n        return False\n\n    def edge_collision_free(self, p1: Tuple[float, float], p2: Tuple[float, float]) -> bool:\n        # Incremental sampling along the edge\n        steps = int(math.dist(p1, p2) * 10)\n        if steps == 0:\n            return True\n        for i in range(steps + 1):\n            t = i / steps\n            x = p1[0] + t * (p2[0] - p1[0])\n            y = p1[1] + t * (p2[1] - p1[1])\n            if self.is_in_collision((x, y)):\n                return False\n        return True\n\n    def get_nearest_node_index(self, point: Tuple[float, float]) -> Optional[int]:\n        min_dist = float('inf')\n        min_idx = None\n        for i, node in enumerate(self.nodes):\n            dist = (node[0] - point[0]) ** 2 + (node[1] - point[1]) ** 2\n            if dist < min_dist:\n                min_dist = dist\n                min_idx = i\n        return min_idx\n\n    def sample_free(self) -> Tuple[float, float]:\n        while True:\n            x = random.uniform(0, self.map.width)\n            y = random.uniform(0, self.map.height)\n            if not self.is_in_collision((x, y)):\n                return (x, y)\n\n    def plan(self, start: Tuple[float, float], goal: Tuple[float, float]) -> PlannerResult:\n        if self.is_in_collision(start) or self.is_in_collision(goal):\n            return PlannerResult(False, [], 0, float('inf'))\n\n        self.nodes = [start]\n        self.edges = {0: []}\n        for i in range(self.max_iter):\n            random_point = self.sample_free()\n            # Ensure new sampled node is free and edge is collision free\n            if self.is_in_collision(random_point):\n                continue\n            nearest_index = self.get_nearest_node_index(random_point)\n            nearest_node = self.nodes[nearest_index]\n            if self.edge_collision_free(nearest_node, random_point):\n                # Add new node only if collision free\n                if self.is_in_collision(random_point):\n                    continue\n                self.nodes.append(random_point)\n                new_index = len(self.nodes) - 1\n                self.edges[new_index] = []\n                # Connect edges both ways with collision check\n                if self.edge_collision_free(nearest_node, random_point):\n                    self.edges[nearest_index].append(new_index)\n                    self.edges[new_index].append(nearest_index)\n\n                # Check if goal can be connected directly\n                if (math.dist(random_point, goal) <= max(self.map.width, self.map.height) and\n                    not self.is_in_collision(goal) and\n                    self.edge_collision_free(random_point, goal)):\n                    self.nodes.append(goal)\n                    goal_index = len(self.nodes) - 1\n                    self.edges[goal_index] = []\n                    self.edges[new_index].append(goal_index)\n                    self.edges[goal_index].append(new_index)\n\n                    # Reconstruct path\n                    path = self._reconstruct_path(0, goal_index)\n                    cost = self._path_cost(path)\n                    return PlannerResult(True, path, i + 1, cost)\n        # Failed to find path\n        return PlannerResult(False, [], self.max_iter, float('inf'))\n\n    def _reconstruct_path(self, start_idx: int, goal_idx: int) -> List[Tuple[float, float]]:\n        from collections import deque\n\n        queue = deque([start_idx])\n        visited = {start_idx: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == goal_idx:\n                break\n            for neighbor in self.edges.get(current, []):\n                if neighbor not in visited:\n                    visited[neighbor] = current\n                    queue.append(neighbor)\n\n        path_indices = []\n        cur = goal_idx\n        while cur is not None:\n            path_indices.append(cur)\n            cur = visited[cur]\n        path_indices.reverse()\n        return [self.nodes[i] for i in path_indices]\n\n    def _path_cost(self, path: List[Tuple[float, float]]) -> float:\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += math.dist(path[i], path[i + 1])\n        return cost",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 1 required positional argument: 'map'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "class Node:\n    def __init__(self, point: Tuple[float, float], parent: 'Node' = None):\n        self.point = point\n        self.parent = parent\n",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, map_: Map, max_iter: int = 5000, step_size: float = 1.0, neighbor_radius: float = 5.0):\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        \n        # Nodes will be stored as list of (x, y) tuples\n        self.nodes: List[Tuple[float, float]] = [self.map.start]\n        # Edges stored as adjacency list: node index -> list of connected node indices\n        self.edges: List[List[int]] = [[]]\n    \n    def is_in_collision(self, point: Tuple[float, float]) -> bool:\n        x, y = point\n        # Check boundaries\n        if x < 0 or x > self.map.width or y < 0 or y > self.map.height:\n            return True\n        for (ox, oy, r) in self.map.obstacles:\n            if (x - ox)**2 + (y - oy)**2 <= r**2:\n                return True\n        return False\n\n    def edge_in_collision(self, p1: Tuple[float, float], p2: Tuple[float, float], step_size: float = 0.5) -> bool:\n        # Sample points along edge and check collision\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / step_size), 1)\n        for i in range(steps + 1):\n            t = i / steps\n            x = p1[0] + t * (p2[0] - p1[0])\n            y = p1[1] + t * (p2[1] - p1[1])\n            if self.is_in_collision((x, y)):\n                return True\n        return False\n\n    def nearest_node_index(self, point: Tuple[float, float]) -> int:\n        distances = [math.dist(point, node) for node in self.nodes]\n        return int(np.argmin(distances))\n\n    def get_neighbors(self, point: Tuple[float, float]) -> List[int]:\n        neighbors = []\n        for idx, node in enumerate(self.nodes):\n            if math.dist(point, node) <= self.neighbor_radius:\n                neighbors.append(idx)\n        return neighbors\n\n    def steer(self, from_node: Tuple[float, float], to_point: Tuple[float, float]) -> Tuple[float, float]:\n        direction = (to_point[0] - from_node[0], to_point[1] - from_node[1])\n        length = math.sqrt(direction[0]**2 + direction[1]**2)\n        if length <= self.step_size:\n            new_point = to_point\n        else:\n            scale = self.step_size / length\n            new_point = (from_node[0] + direction[0]*scale, from_node[1] + direction[1]*scale)\n        # Clip to map bounds\n        x = min(max(new_point[0], 0), self.map.width)\n        y = min(max(new_point[1], 0), self.map.height)\n        return (x, y)\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            # Sample random point in map\n            rand_point = (random.uniform(0, self.map.width), random.uniform(0, self.map.height))\n\n            if self.is_in_collision(rand_point):\n                continue\n\n            nearest_idx = self.nearest_node_index(rand_point)\n            nearest_node = self.nodes[nearest_idx]\n\n            new_node = self.steer(nearest_node, rand_point)\n\n            if self.is_in_collision(new_node):\n                continue\n            if self.edge_in_collision(nearest_node, new_node):\n                continue\n\n            # Add new node and edge\n            self.nodes.append(new_node)\n            self.edges.append([])\n            new_idx = len(self.nodes) - 1\n            self.edges[nearest_idx].append(new_idx)\n            self.edges[new_idx].append(nearest_idx)\n\n            # Also connect to neighbors if collision free\n            neighbors = self.get_neighbors(new_node)\n            for n_idx in neighbors:\n                if n_idx == new_idx or n_idx == nearest_idx:\n                    continue\n                if not self.edge_in_collision(self.nodes[n_idx], new_node):\n                    self.edges[new_idx].append(n_idx)\n                    self.edges[n_idx].append(new_idx)\n\n            # Check if goal is reached\n            if math.dist(new_node, self.map.goal) <= self.step_size:\n                # Add goal node\n                if not self.is_in_collision(self.map.goal) and not self.edge_in_collision(new_node, self.map.goal):\n                    self.nodes.append(self.map.goal)\n                    self.edges.append([])\n                    goal_idx = len(self.nodes) - 1\n                    self.edges[new_idx].append(goal_idx)\n                    self.edges[goal_idx].append(new_idx)\n                    path = self._search_path(0, goal_idx)\n                    if path is not None:\n                        return PlannerResult(path=path, success=True)\n                # Otherwise continue searching\n\n        # Fail to find path\n        return PlannerResult(path=[], success=False)\n\n    def _search_path(self, start_idx: int, goal_idx: int) -> List[Tuple[float, float]]:\n        # BFS to find shortest path\n        from collections import deque\n        queue = deque([start_idx])\n        came_from = {start_idx: None}\n        while queue:\n            current = queue.popleft()\n            if current == goal_idx:\n                break\n            for neighbor in self.edges[current]:\n                if neighbor not in came_from:\n                    came_from[neighbor] = current\n                    queue.append(neighbor)\n        else:\n            return None  # no path found\n\n        # Reconstruct path\n        path = []\n        cur = goal_idx\n        while cur is not None:\n            path.append(self.nodes[cur])\n            cur = came_from[cur]\n        path.reverse()\n        return path",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 1 required positional argument: 'map_'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\nclass Planner:\n    def __init__(self, map_: Map, max_iter: int = 5000, step_size: float = 1.0, neighbor_radius: float = 5.0):\n        self.map = map_\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        \n        # Nodes will be stored as list of (x, y) tuples\n        self.nodes: List[Tuple[float, float]] = [self.map.start]\n        # Edges stored as adjacency list: node index -> list of connected node indices\n        self.edges: List[List[int]] = [[]]\n    \n    def is_in_collision(self, point: Tuple[float, float]) -> bool:\n        x, y = point\n        # Check boundaries\n        if x < 0 or x > self.map.width or y < 0 or y > self.map.height:\n            return True\n        for (ox, oy, r) in self.map.obstacles:\n            if (x - ox)**2 + (y - oy)**2 <= r**2:\n                return True\n        return False\n\n    def edge_in_collision(self, p1: Tuple[float, float], p2: Tuple[float, float], step_size: float = 0.5) -> bool:\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / step_size), 1)\n        for i in range(steps + 1):\n            t = i / steps\n            x = p1[0] + t * (p2[0] - p1[0])\n            y = p1[1] + t * (p2[1] - p1[1])\n            if self.is_in_collision((x, y)):\n                return True\n        return False\n\n    def nearest_node_index(self, point: Tuple[float, float]) -> int:\n        distances = [math.dist(point, node) for node in self.nodes]\n        return int(np.argmin(distances))\n\n    def get_neighbors(self, point: Tuple[float, float]) -> List[int]:\n        neighbors = []\n        for idx, node in enumerate(self.nodes):\n            if math.dist(point, node) <= self.neighbor_radius:\n                neighbors.append(idx)\n        return neighbors\n\n    def steer(self, from_node: Tuple[float, float], to_point: Tuple[float, float]) -> Tuple[float, float]:\n        direction = (to_point[0] - from_node[0], to_point[1] - from_node[1])\n        length = math.sqrt(direction[0]**2 + direction[1]**2)\n        if length <= self.step_size:\n            new_point = to_point\n        else:\n            scale = self.step_size / length\n            new_point = (from_node[0] + direction[0]*scale, from_node[1] + direction[1]*scale)\n        # Clip to map bounds\n        x = min(max(new_point[0], 0), self.map.width)\n        y = min(max(new_point[1], 0), self.map.height)\n        return (x, y)\n\n    def plan(self) -> PlannerResult:\n        for _ in range(self.max_iter):\n            rand_point = (random.uniform(0, self.map.width), random.uniform(0, self.map.height))\n            if self.is_in_collision(rand_point):\n                continue\n\n            nearest_idx = self.nearest_node_index(rand_point)\n            nearest_node = self.nodes[nearest_idx]\n\n            new_node = self.steer(nearest_node, rand_point)\n\n            if self.is_in_collision(new_node):\n                continue\n            if self.edge_in_collision(nearest_node, new_node):\n                continue\n\n            # Add new node and initialize edges list\n            self.nodes.append(new_node)\n            self.edges.append([])\n            new_idx = len(self.nodes) - 1\n\n            # Add edge between nearest node and new node if collision free\n            if not self.edge_in_collision(nearest_node, new_node):\n                self.edges[nearest_idx].append(new_idx)\n                self.edges[new_idx].append(nearest_idx)\n\n            # Connect to neighbors if collision-free\n            neighbors = self.get_neighbors(new_node)\n            for n_idx in neighbors:\n                if n_idx == new_idx or n_idx == nearest_idx:\n                    continue\n                if not self.is_in_collision(self.nodes[n_idx]) and not self.edge_in_collision(self.nodes[n_idx], new_node):\n                    # Avoid duplicate edges\n                    if n_idx not in self.edges[new_idx]:\n                        self.edges[new_idx].append(n_idx)\n                    if new_idx not in self.edges[n_idx]:\n                        self.edges[n_idx].append(new_idx)\n\n            # Check if goal is reached\n            if math.dist(new_node, self.map.goal) <= self.step_size:\n                if not self.is_in_collision(self.map.goal) and not self.edge_in_collision(new_node, self.map.goal):\n                    self.nodes.append(self.map.goal)\n                    self.edges.append([])\n                    goal_idx = len(self.nodes) - 1\n\n                    self.edges[new_idx].append(goal_idx)\n                    self.edges[goal_idx].append(new_idx)\n\n                    path = self._search_path(0, goal_idx)\n                    if path is not None:\n                        return PlannerResult(path=path, success=True)\n                # Continue searching if goal is not connectable\n\n        return PlannerResult(path=[], success=False)\n\n    def _search_path(self, start_idx: int, goal_idx: int) -> Optional[List[Tuple[float, float]]]:\n        from collections import deque\n        queue = deque([start_idx])\n        came_from = {start_idx: None}\n        while queue:\n            current = queue.popleft()\n            if current == goal_idx:\n                break\n            for neighbor in self.edges[current]:\n                if neighbor not in came_from:\n                    came_from[neighbor] = current\n                    queue.append(neighbor)\n        else:\n            return None\n\n        path = []\n        cur = goal_idx\n        while cur is not None:\n            path.append(self.nodes[cur])\n            cur = came_from[cur]\n        path.reverse()\n        return path",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() missing 1 required positional argument: 'map_'\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": "\n",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that improves upon classical RRT* approaches by integrating informed sampling for focused exploration, adaptive step sizing near obstacles for safer expansion, node pruning based on cost heuristics to maintain computational efficiency, and incremental rewiring to continuously improve path optimality. It uses efficient data structures to accelerate nearest neighbor queries, caching collision results to reduce overhead, and applies shortcut smoothing post-planning to refine the final trajectory.",
    "planning_mechanism": "The planner grows two balanced trees simultaneously from start and goal, sampling new points within an informed ellipsoidal region centered between them. New samples are steered toward with adaptive step sizes to avoid collisions and improve precision near obstacles. Upon adding a new node, neighbors within a radius are rewired if a lower cost path is found, and branches exceeding current best path cost are pruned. The two trees are incrementally connected to detect solutions early. Finally, the solution path is smoothed via shortcut techniques to enhance quality and execution efficiency.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position: Tuple[float, ...] = position\n        self.parent = parent                 # type: Node or None\n        self.cost: float = cost\n        self.children: List[Node] = []\n        self.valid: bool = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost: float) -> None:\n        self.cost = new_cost\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        base_step: float = 5.0,\n        rewire_radius: float = 20.0,\n        prune_interval: int = 100,\n        collision_cache_enabled: bool = True,\n        smoothing_iterations: int = 50,\n        goal_sample_rate: float = 0.1,\n    ):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.rewire_radius = rewire_radius\n        self.prune_interval = prune_interval\n        self.collision_cache_enabled = collision_cache_enabled\n        self.smoothing_iterations = smoothing_iterations\n        self.goal_sample_rate = goal_sample_rate\n\n        # Cache for collision checks {(pos): bool}\n        self._collision_cache = dict()\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        # Cached KDTrees for neighbor searches; updated periodically\n        kdtree_a = KDTree([start])\n        kdtree_b = KDTree([goal])\n\n        for iteration in range(1, self.max_iter + 1):\n            # Alternate expanding tree_a and tree_b\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_b, tree_a\n                kdtree_a, kdtree_b = kdtree_b, kdtree_a\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n\n            # With small probability, sample the goal directly to bias toward it\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n\n            nearest_idx = kdtree_a.query(sample)[1]\n            nearest = tree_a[nearest_idx]\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not self._valid_position(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_cost = new_cost + math.dist(new_pos, goal)\n            if heuristic_cost >= c_best:\n                # Prune paths that can't improve best known cost\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Update KDTree\n            kdtree_a = self._build_kdtree(tree_a)\n\n            # Rewiring neighbors to improve cost\n            neighbors_idx = kdtree_a.query_ball_point(new_pos, self.rewire_radius)\n            for idx in neighbors_idx:\n                neighbor = tree_a[idx]\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + math.dist(neighbor.position, goal) >= c_best:\n                    continue  # Prune costlier paths\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect trees\n            nearest_other_idx = kdtree_b.query(new_node.position)[1]\n            nearest_other = tree_b[nearest_other_idx]\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_from_start = new_node.path_from_root()\n                path_from_goal = nearest_other.path_from_root()\n                best_path = path_from_start + path_from_goal[::-1]\n                success = True\n\n            # Prune nodes periodically to maintain efficiency\n            if iteration % self.prune_interval == 0 and success:\n                tree_a, nodes, edges = self._prune(tree_a, nodes, edges, c_best)\n                kdtree_a = self._build_kdtree(tree_a)\n\n        if success and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smoothing_iterations)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _valid_position(self, pos, obstacles, is_3d):\n        if self.collision_cache_enabled:\n            if pos in self._collision_cache:\n                return not self._collision_cache[pos]\n            collision = self._is_in_obstacle(pos, obstacles, is_3d)\n            self._collision_cache[pos] = collision\n            return not collision\n        else:\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n    def _valid_edge(self, from_pos, to_pos, obstacles, is_3d):\n        key = (from_pos, to_pos)\n        if self.collision_cache_enabled and key in self._edge_collision_cache:\n            return not self._edge_collision_cache[key]\n        collision = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n        if self.collision_cache_enabled:\n            self._edge_collision_cache[key] = collision\n        return not collision\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        if c_best == float(\"inf\"):\n            # No solution found yet, uniform sampling\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling between start and goal\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                # Start and goal coincident\n                return start\n            a1_unit = a1 / a1_norm\n\n            # Generate rotation matrix C that aligns ellipse with coordinate axis\n            id_mat = np.eye(dim)\n            M = np.outer(a1_unit, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            detU = np.linalg.det(U)\n            detV = np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [detU * detV]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample uniformly from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(3, int(dist))  # Increase minimum steps for finer checks\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Near obstacle => reduce step size to 30% of base but not less than 1\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Precise collision at a point\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _build_kdtree(self, nodes: List[Node]) -> KDTree:\n        pts = [node.position for node in nodes]\n        return KDTree(pts) if pts else None\n\n    def _prune(self, tree: List[Node], nodes: List[Node], edges: List[Tuple[Node, Node]], c_bound: float):\n        # Remove nodes and edges with cost exceeding c_bound\n        pruned_nodes = []\n        valid_nodes = set()\n        pruned_edges = []\n\n        # Mark valid nodes: those that can still contribute to better solutions\n        for node in tree:\n            if node.cost + self._heuristic(node.position, tree[0].position) <= c_bound:\n                valid_nodes.add(node)\n            else:\n                node.valid = False\n\n        # Filter nodes and edges accordingly\n        for node in nodes:\n            if node in valid_nodes and node.valid:\n                pruned_nodes.append(node)\n\n        for parent, child in edges:\n            if parent in valid_nodes and child in valid_nodes and parent.valid and child.valid:\n                pruned_edges.append((parent, child))\n\n        # Return pruned tree (subset of nodes)\n        pruned_tree = [node for node in tree if node in valid_nodes and node.valid]\n\n        return pruned_tree, pruned_nodes, pruned_edges\n\n    def _heuristic(self, pos1: Tuple[float, ...], pos2: Tuple[float, ...]) -> float:\n        return math.dist(pos1, pos2)\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        path = list(path)\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut is valid: remove intermediate points\n                del path[i + 1 : j]\n        return path",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 269, in Planner\nNameError: name 'KDTree' is not defined\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that improves upon classical RRT* approaches by integrating informed sampling for focused exploration, adaptive step sizing near obstacles for safer expansion, node pruning based on cost heuristics to maintain computational efficiency, and incremental rewiring to continuously improve path optimality. It uses efficient data structures to accelerate nearest neighbor queries, caching collision results to reduce overhead, and applies shortcut smoothing post-planning to refine the final trajectory.",
    "planning_mechanism": "The planner grows two balanced trees simultaneously from start and goal, sampling new points within an informed ellipsoidal region centered between them. New samples are steered toward with adaptive step sizes to avoid collisions and improve precision near obstacles. Upon adding a new node, neighbors within a radius are rewired if a lower cost path is found, and branches exceeding current best path cost are pruned. The two trees are incrementally connected to detect solutions early. Finally, the solution path is smoothed via shortcut techniques to enhance quality and execution efficiency.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position: Tuple[float, ...] = position\n        self.parent = parent                 # type: Node or None\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid: bool = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost: float) -> None:\n        self.cost = new_cost\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        base_step: float = 5.0,\n        rewire_radius: float = 20.0,\n        prune_interval: int = 100,\n        collision_cache_enabled: bool = True,\n        smoothing_iterations: int = 50,\n        goal_sample_rate: float = 0.1,\n    ):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.rewire_radius = rewire_radius\n        self.prune_interval = prune_interval\n        self.collision_cache_enabled = collision_cache_enabled\n        self.smoothing_iterations = smoothing_iterations\n        self.goal_sample_rate = goal_sample_rate\n\n        # Cache for collision checks {(pos): bool}\n        self._collision_cache = dict()\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        # Cached KDTrees for neighbor searches; updated periodically\n        kdtree_a = KDTree([start])\n        kdtree_b = KDTree([goal])\n\n        for iteration in range(1, self.max_iter + 1):\n            # Alternate expanding tree_a and tree_b\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_b, tree_a\n                kdtree_a, kdtree_b = kdtree_b, kdtree_a\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n\n            # With small probability, sample the goal directly to bias toward it\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n\n            nearest_idx = kdtree_a.query(sample)[1]\n            nearest = tree_a[nearest_idx]\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Ensure new position is within map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if not self._valid_position(new_pos, obstacles, is_3d):\n                continue\n            if not self._valid_edge(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_cost = new_cost + math.dist(new_pos, goal)\n            if heuristic_cost >= c_best:\n                # Prune paths that can't improve best known cost\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Update KDTree\n            kdtree_a = self._build_kdtree(tree_a)\n\n            # Rewiring neighbors to improve cost\n            neighbors_idx = kdtree_a.query_ball_point(new_pos, self.rewire_radius)\n            for idx in neighbors_idx:\n                neighbor = tree_a[idx]\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + math.dist(neighbor.position, goal) >= c_best:\n                    continue  # Prune costlier paths\n                if potential_cost < neighbor.cost and self._valid_edge(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect trees\n            nearest_other_idx = kdtree_b.query(new_node.position)[1]\n            nearest_other = tree_b[nearest_other_idx]\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost < c_best and self._valid_edge(new_node.position, nearest_other.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_from_start = new_node.path_from_root()\n                path_from_goal = nearest_other.path_from_root()\n                best_path = path_from_start + path_from_goal[::-1]\n                success = True\n\n            # Prune nodes periodically to maintain efficiency\n            if iteration % self.prune_interval == 0 and success:\n                tree_a, nodes, edges = self._prune(tree_a, nodes, edges, c_best)\n                kdtree_a = self._build_kdtree(tree_a)\n\n        if success and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smoothing_iterations)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _valid_position(self, pos, obstacles, is_3d):\n        if self.collision_cache_enabled:\n            if pos in self._collision_cache:\n                return not self._collision_cache[pos]\n            collision = self._is_in_obstacle(pos, obstacles, is_3d)\n            self._collision_cache[pos] = collision\n            return not collision\n        else:\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n    def _valid_edge(self, from_pos, to_pos, obstacles, is_3d):\n        key = (from_pos, to_pos)\n        if self.collision_cache_enabled and key in self._edge_collision_cache:\n            return not self._edge_collision_cache[key]\n        collision = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n        if self.collision_cache_enabled:\n            self._edge_collision_cache[key] = collision\n        return not collision\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        if c_best == float(\"inf\"):\n            # No solution found yet, uniform sampling\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling between start and goal\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                # Start and goal coincident\n                return start\n            a1_unit = a1 / a1_norm\n\n            # Generate rotation matrix C that aligns ellipse with coordinate axis\n            id_mat = np.eye(dim)\n            M = np.outer(a1_unit, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            detU = np.linalg.det(U)\n            detV = np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [detU * detV]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample uniformly from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(3, int(dist))  # Increase minimum steps for finer checks\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Near obstacle => reduce step size to 30% of base but not less than 1\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Precise collision at a point\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _build_kdtree(self, nodes: List[Node]) -> KDTree:\n        pts = [node.position for node in nodes]\n        return KDTree(pts) if pts else None\n\n    def _prune(self, tree: List[Node], nodes: List[Node], edges: List[Tuple[Node, Node]], c_bound: float):\n        # Remove nodes and edges with cost exceeding c_bound\n        pruned_nodes = []\n        valid_nodes = set()\n        pruned_edges = []\n\n        # Mark valid nodes: those that can still contribute to better solutions\n        for node in tree:\n            if node.cost + self._heuristic(node.position, tree[0].position) <= c_bound:\n                valid_nodes.add(node)\n            else:\n                node.valid = False\n\n        # Filter nodes and edges accordingly\n        for node in nodes:\n            if node in valid_nodes and node.valid:\n                pruned_nodes.append(node)\n\n        for parent, child in edges:\n            if parent in valid_nodes and child in valid_nodes and parent.valid and child.valid:\n                pruned_edges.append((parent, child))\n\n        # Return pruned tree (subset of nodes)\n        pruned_tree = [node for node in tree if node in valid_nodes and node.valid]\n\n        return pruned_tree, pruned_nodes, pruned_edges\n\n    def _heuristic(self, pos1: Tuple[float, ...], pos2: Tuple[float, ...]) -> float:\n        return math.dist(pos1, pos2)\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        path = list(path)\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut is valid: remove intermediate points\n                del path[i + 1 : j]\n        return path",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 273, in Planner\nNameError: name 'KDTree' is not defined\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a hybrid bidirectional informed RRT* planner that combines goal-biased and ellipsoidal informed sampling to accelerate convergence. It dynamically adjusts the neighbor radius for rewiring based on iterations count and tree density, leveraging incremental rewiring on both trees to locally optimize path costs. To enhance path smoothness and reduce length, the planner applies iterative shortcut smoothing on the final path. It enforces strict collision and boundary checking, maintains best found path with early termination on time or connection, and ensures robustness in 2D/3D environments with a hard 30-second execution time limit.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately extending them toward sampled points generated by combined goal biasing and informed sampling focused around the best path estimate so far. After each node insertion, neighbors are rewired to reduce cost locally using a dynamically shrinking radius. When connection between trees is found, the path is extracted and iteratively smoothed using shortcutting. The exploration prioritizes promising regions via ellipsoidal sampling, while the bidirectional approach halves the search space for efficient convergence. The process stops when either a collision-free connection is achieved or the 30-second time limit expires, returning the best feasible path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node') -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node') -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, \n                 goal_sample_rate: float = 0.2, smoothing_iters: int = 150, \n                 max_time_sec: float = 30.0, neighbor_factor: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n        self.max_time_sec = max_time_sec\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]\n        start_pos = map.start                 # Tuple[float, ...]\n        goal_pos = map.goal                   # Tuple[float, ...]\n        obstacles = map.obstacles             # Rectangular blocks\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            p = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(p[i], bounds[i])) for i in range(dim))\n            return clamped\n\n        def is_free_point(p: Tuple[float, ...]) -> bool:\n            return (within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not (within_bounds(p2) and within_bounds(p1)):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def dynamic_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 5\n            return min(self.step_size * 7, self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n\n        # Bidirectional sampling helpers & ellipsoidal informed sampler\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path_nodes = (None, None)\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            if c_min < 1e-9:\n                return None\n            a1 = np.array([(g - s)/c_min for s,g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c_, -s_],\n                                 [s_,  c_]])\n            elif dim == 3:\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1,0,0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c_) / (s_ * s_))\n                return R\n            else:\n                return None\n\n        rotation = rotation_matrix()\n\n        def informed_sample(np_module):\n            if best_cost == float('inf') or np_module is None or rotation is None:\n                return uniform_sample()\n            r1 = best_cost * 0.5\n            r_rest = math.sqrt(max(best_cost**2 - c_min**2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_sample = np_module.array([radius*math.cos(theta), radius*math.sin(theta)])\n                    sample_ellipsoid = np_module.array([r1, r_rest]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np_module.array(center)\n                else:  # dim==3\n                    while True:\n                        unit_sample = np_module.random.uniform(-1,1,3)\n                        norm = np.linalg.norm(unit_sample)\n                        if 1e-9 < norm <=1:\n                            unit_sample /= norm\n                            break\n                    r2 = r3 = r_rest\n                    sample_ellipsoid = np_module.array([r1, r2, r3]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np_module.array(center)\n                p = tuple(np_module.clip(sample_world, np_module.zeros(dim), np_module.array(bounds)))\n                if is_free_point(p):\n                    return p\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n\n        # Initialize trees\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        connected = False\n        best_nodes_pair = (None, None)\n\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        start_time = time.perf_counter()\n\n        def extend_and_rewire(tree_from: List[Node], tree_to: List[Node]) -> Tuple[Node, bool]:\n            # 1. Sample with goal bias (towards goal of opposite tree) or informed sampling\n            sample_goal = tree_to[0].position\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                if best_cost < float('inf') and np is not None:\n                    sample = informed_sample(np)\n                else:\n                    sample = uniform_sample()\n            nearest_node = nearest(tree_from, sample)\n            new_position = steer(nearest_node.position, sample)\n            if not is_free_point(new_position):\n                return None, False\n            if not is_free_edge(nearest_node.position, new_position):\n                return None, False\n\n            # Find neighbors for rewiring with dynamic radius\n            rad = dynamic_neighbor_radius(len(tree_from))\n            neighbors = near_nodes(tree_from, new_position, rad)\n\n            # Choose best parent considering cost and collision\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_position)\n                if tentative_cost < min_cost and is_free_edge(nbr.position, new_position):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improvement possible\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and is_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n            # Attempt to connect to opposite tree\n            nearest_to = nearest(tree_to, new_node.position)\n            if dist(nearest_to.position, new_node.position) <= self.step_size and is_free_edge(new_node.position, nearest_to.position):\n                # Connect nodes\n                connect_cost = new_node.cost + dist(new_node.position, nearest_to.position) + nearest_to.cost\n                nonlocal best_cost, best_nodes_pair\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_nodes_pair = (new_node, nearest_to)\n                return new_node, True\n            return new_node, False\n\n        # Main loop: alternate tree expansion\n        expand_start = True\n        for i in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if expand_start:\n                new_node, connected_flag = extend_and_rewire(tree_start, tree_goal)\n            else:\n                new_node, connected_flag = extend_and_rewire(tree_goal, tree_start)\n\n            if connected_flag:\n                connected = True\n                break\n\n            expand_start = not expand_start\n\n        def extract_path(n1: Node, n2: Node) -> List[Tuple[float, ...]]:\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            full_path = path1 + path2[::-1][1:]\n            return full_path\n\n        def path_shortcut(path: List[Tuple[float, ...]], iterations: int=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            path_smooth = path[:]\n            for _ in range(iterations):\n                if len(path_smooth) < 3:\n                    break\n                i = random.randint(0, len(path_smooth) - 3)\n                j = random.randint(i + 2, len(path_smooth) -1)\n                p1 = path_smooth[i]\n                p2 = path_smooth[j]\n                if is_free_edge(p1, p2):\n                    path_smooth = path_smooth[:i+1] + path_smooth[j:]\n            return path_smooth\n\n        # Extract best path if connected\n        if connected and best_nodes_pair[0] and best_nodes_pair[1]:\n            raw_path = extract_path(best_nodes_pair[0], best_nodes_pair[1])\n            # Smooth path via shortcutting\n            smoothed_path = path_shortcut(raw_path, self.smoothing_iters)\n            extracted_path = smoothed_path\n            success_state = True\n        else:\n            success_state = False\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 96, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 236\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 102, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 68, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
