[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.232877539025313,
          "time_improvement": 73.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011802577972412109,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 52.468071909137095,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 17.335726835993384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019640421867370604,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 87.88473705620726,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 30.003711846582945
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010181522369384766,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 78.79433117160421,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.35919393449961
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional search with adaptive rewiring and goal biasing to improve path planning efficiency and path quality. It incrementally grows two trees from start and goal, extends toward random samples with a bias toward the goal, and rewires locally to minimize path costs while ensuring collision-free nodes and edges. Upon connection of the two trees, it extracts a smooth and optimized path.",
          "planning_mechanism": "The planner samples points within bounds (with goal bias), extends each tree toward samples within a step size, performs local rewiring to reduce costs, and attempts to connect the two trees on each iteration. It strictly checks for collisions for both nodes and edges, ensuring valid paths. The bidirectional approach accelerates convergence, and rewiring optimizes path costs and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -20.70232,
          "time_improvement": 53.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 310.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016640830039978027,
                    "num_nodes_avg": 160.6,
                    "path_length_avg": 167.68313601037386,
                    "smoothness_avg": 0.023542751007624492,
                    "success_improvement": 0.0,
                    "time_improvement": 32.983222929654985,
                    "length_improvement": 8.090216043387771,
                    "smoothness_improvement": 268.49517717140276,
                    "objective_score": 12.855485973431062
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03169040679931641,
                    "num_nodes_avg": 374.2,
                    "path_length_avg": 235.3172522277793,
                    "smoothness_avg": 0.017255337523919966,
                    "success_improvement": 0.0,
                    "time_improvement": 80.45166169229154,
                    "length_improvement": 21.44432797481391,
                    "smoothness_improvement": 343.99226300771477,
                    "objective_score": 30.14432541768882
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025929951667785646,
                    "num_nodes_avg": 309.0,
                    "path_length_avg": 122.50151738270351,
                    "smoothness_avg": 0.032717793611091894,
                    "success_improvement": 0.0,
                    "time_improvement": 45.99413055784529,
                    "length_improvement": 18.640325049814344,
                    "smoothness_improvement": 316.1679197567731,
                    "objective_score": 19.10714377610032
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.346034584031703,
          "time_improvement": 65.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00933377742767334,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 62.410548056085524,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 18.46480044190237
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017646241188049316,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.11485438518106,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.115524236223337
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02707960605621338,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 43.59967623720094,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 12.457779073969402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the goal-biased, single-tree asymptotically optimal RRT* approach with adaptive step sizing and local rewiring, further enhanced by selective bidirectional expansions to speed convergence and improve path quality. It dynamically toggles growth direction between start and goal trees, incorporates rigorous node and edge collision checks, maintains a fixed neighbor radius for rewiring, and employs clean parent updates for cost optimization and path smoothing. The planner balances exploration and exploitation to achieve fast, robust, and smooth path solutions with reduced search time.",
          "planning_mechanism": "The planner grows two trees (from start and goal) alternately with goal bias sampling and adaptive step size. Each extension performs local rewiring within a fixed neighbor radius to optimize path cost. Upon feasible connection of the two trees, it reconstructs and returns an optimized and smooth path from start to goal. Collision checking prevents invalid nodes or edges, and the controlled expansion strategy improves efficiency and success rates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two trees: start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if math.dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges accordingly\n                    # Remove old edges pointing to neighbor\n                    for idx, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(idx)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent among neighbors to minimize cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby neighbors if better path found\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tgt_tree, from_node):\n            nearest_node = nearest(tgt_tree, from_node.position)\n            dist = math.dist(nearest_node.position, from_node.position)\n\n            if dist <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Alternate tree growth\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    # Connect goal tree with new_node\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    # Rewire around connecting_node in goal tree\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    # Extract path from start root to new_node\n                    path_start = new_node.path_from_root()\n                    # Extract path from goal root to connecting_node\n                    path_goal = connecting_node.path_from_root()\n\n                    # Merge paths (avoid duplicate)\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.68431,
          "time_improvement": 36.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 228.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03119027614593506,
                    "num_nodes_avg": 196.0,
                    "path_length_avg": 161.90028223162875,
                    "smoothness_avg": 0.01925246145745203,
                    "success_improvement": 0.0,
                    "time_improvement": -25.61102890979288,
                    "length_improvement": 11.259889834700093,
                    "smoothness_improvement": 201.3428291983296,
                    "objective_score": -4.424616560006196
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04433765411376953,
                    "num_nodes_avg": 424.7,
                    "path_length_avg": 246.60618516277526,
                    "smoothness_avg": 0.013537531152909957,
                    "success_improvement": 0.0,
                    "time_improvement": 72.65016293811588,
                    "length_improvement": 17.67575722719418,
                    "smoothness_improvement": 248.33042725393685,
                    "objective_score": 26.571852463143284
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01830921173095703,
                    "num_nodes_avg": 250.5,
                    "path_length_avg": 134.23458879587966,
                    "smoothness_avg": 0.026356378182142565,
                    "success_improvement": 0.0,
                    "time_improvement": 61.86630384046241,
                    "length_improvement": 10.847777686004214,
                    "smoothness_improvement": 235.25118505138138,
                    "objective_score": 21.90570261459647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized and hybrid variant of the RRT* and bidirectional RRT that combines rewiring optimization with a bidirectional growth strategy to improve convergence speed, path quality, and robustness. It adaptively tunes parameters such as step size and neighbor radius to balance exploration and exploitation, leading to smoother, shorter paths and faster planning times.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions. It samples free points with goal biasing, extends trees towards these samples with collision checks, applies rewiring internally to optimize path costs locally in both trees, and attempts to connect the trees repeatedly. Once connected, it reconstructs the path by backtracking parents in both trees and applies post-processing smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius_factor: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier for neighbor radius based on dimension and iteration count\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def sample():\n            # Goal biasing with higher rate for faster convergence\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: n.dist(point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_neighbor_radius(node_count):\n            # RRT* recommended radius ~ gamma*(log(n)/n)^(1/d)\n            gamma = self.neighbor_radius_factor\n            return min(gamma * ((math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)), self.step_size * 20)\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if n.dist(pos) <= radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def collision_free_node(pos):\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def rewire(new_node, tree):\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_node.position, radius)\n            for near_node in near:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + new_node.dist(near_node.position)\n                if new_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    near_node.update_parent(new_node, new_cost)\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            # Choose best parent in neighbors (RRT* style)\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and collision_free_edge(near_node.position, new_pos):\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, tree)\n            return new_node\n\n        def connect(tree, target_node):\n            # Try to connect tree towards target_node by incremental stepping (like bidirectional RRT-Connect)\n            current_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = Node(new_pos)\n                cost_to_new = current_node.cost + math.dist(current_node.position, new_pos)\n                new_node.update_parent(current_node, cost_to_new)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                rewire(new_node, tree)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        for it in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate trees as in bidirectional RRT\n            new_start = extend(tree_start, rnd_point)\n            if new_start is not None:\n                new_goal = connect(tree_goal, new_start)\n                if new_goal is not None:\n                    # Reconstruct full path from start_root to goal_root\n                    path_start = new_start.path_from_root()\n                    path_goal = new_goal.path_from_root()\n                    # Remove duplicate connection node from one side\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n                    # Optional: path smoothing after connection\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n                    break\n\n            # Swap trees for next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        # Smooth by shortcutting random pairs of points if collision-free edge exists,\n        # performed a number of times proportional to path length, aiming to reduce unnecessary waypoints.\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        attempts = max(100, len(smoothed)*5)\n        for _ in range(attempts):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed[i+1:j] = []\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.97464,
          "time_improvement": 4.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1655.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0196943998336792,
                    "num_nodes_avg": 98.3,
                    "path_length_avg": 160.73417210344533,
                    "smoothness_avg": 0.0452188588571313,
                    "success_improvement": 0.0,
                    "time_improvement": 20.68573502541093,
                    "length_improvement": 11.89905327415488,
                    "smoothness_improvement": 607.7733354377676,
                    "objective_score": 11.624397839643095
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08129169940948486,
                    "num_nodes_avg": 401.8,
                    "path_length_avg": 248.31139541126964,
                    "smoothness_avg": 0.10883507921321127,
                    "success_improvement": 0.0,
                    "time_improvement": 49.85493080829013,
                    "length_improvement": 17.10650896449116,
                    "smoothness_improvement": 2700.4049788949055,
                    "objective_score": 31.8798059298598
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0761023759841919,
                    "num_nodes_avg": 360.4,
                    "path_length_avg": 121.69348054843393,
                    "smoothness_avg": 0.13816706245341076,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -58.502994309322574,
                    "length_improvement": 19.176984640556956,
                    "smoothness_improvement": 1657.474835975687,
                    "objective_score": -55.42812718480693
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner incorporating goal biasing, rewiring, and dynamic neighbor radius. It grows two trees simultaneously\u2014one from start and one from goal\u2014sampling points with goal biasing to improve convergence speed. It rewires locally based on a radius proportional to node density to optimize path cost and improve path smoothness and length. Collision checks ensure safe node and edge placements. Upon connecting both trees, it extracts the optimal path by tracing parents from the connecting nodes.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending each toward random samples with goal biasing. At each extension, it selects the lowest cost parent among nearby nodes and rewiries neighbors to reduce path costs. The two trees attempt to connect within a specified radius while ensuring collision-free edges. This approach combines bidirectional search, incremental path quality improvement, efficient sampling, and strict collision checking for robust, efficient, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Node coordinates (2D or 3D)\n        self.parent = parent                  # Parent Node or None\n        self.cost = cost                      # Path cost from root\n        self.children: List[Node] = []       # Children nodes\n        self.valid = True                    # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self) -> List[Tuple[float, ...]]:\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_factor: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Multiplier to compute radius for neighbor search\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start: List[Node] = [Node(start_position)]\n        nodes_goal: List[Node] = [Node(goal_position)]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def get_nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(len(bounds))\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            # Based on RRT* theoretical radius: gamma * (log(n)/n)^(1/d)\n            dim = len(bounds)\n            if num_nodes <= 1:\n                return self.step_size * 2.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        # Alternate which tree to extend: True => start_tree, False => goal_tree\n        extend_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            # Sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if extend_start_tree else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Select tree to extend\n            if extend_start_tree:\n                tree_nodes = nodes_start\n                other_tree_nodes = nodes_goal\n            else:\n                tree_nodes = nodes_goal\n                other_tree_nodes = nodes_start\n\n            # Nearest node in current tree\n            nearest = get_nearest(tree_nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not new_pos:\n                extend_start_tree = not extend_start_tree\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                extend_start_tree = not extend_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                extend_start_tree = not extend_start_tree\n                continue\n\n            # Create new node without parent yet to pick best parent\n            temp_new_node = Node(new_pos)\n\n            # Find neighbors in current tree\n            radius = neighbor_radius(len(tree_nodes) + 1)\n            near_nodes = nearby(tree_nodes, new_pos, radius)\n\n            # Choose best parent among neighbors + nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = near_node\n\n            # Assign parent, cost, add node and edge\n            temp_new_node.update_parent(best_parent, min_cost)\n            tree_nodes.append(temp_new_node)\n            edges.append((best_parent, temp_new_node))\n\n            # Rewire neighbors if better path found through new node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = temp_new_node.cost + dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                        # Update edges\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(temp_new_node, cost_through_new)\n                        edges.append((temp_new_node, near_node))\n\n            # Attempt to connect trees:\n            # Find nearest node in other tree within step_size*2 radius\n            radius_connect = self.step_size * 2.0\n            near_other_nodes = nearby(other_tree_nodes, new_pos, radius_connect)\n\n            connected = False\n            best_total_cost = float('inf')\n            connect_node_other = None\n\n            for other_node in near_other_nodes:\n                # Check edge collision and node collision between temp_new_node and other_node\n                if self._is_in_obstacle(other_node.position, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(temp_new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = temp_new_node.cost + dist(temp_new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_total_cost:\n                    best_total_cost = total_cost\n                    connect_node_other = other_node\n                    connected = True\n\n            if connected:\n                # Connect trees: create a connection edge\n                edges.append((temp_new_node, connect_node_other) if extend_start_tree else (connect_node_other, temp_new_node))\n                connection_node_start = temp_new_node if extend_start_tree else connect_node_other\n                connection_node_goal = connect_node_other if extend_start_tree else temp_new_node\n                success_state = True\n                break\n\n            # Switch tree to extend\n            extend_start_tree = not extend_start_tree\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            # Extract path by connecting path from start tree root to connection_node_start \n            path_start = connection_node_start.path()\n            # Extract path from goal tree root to connection_node_goal and reverse it (excluding the connection node duplicate)\n            path_goal = connection_node_goal.path()\n            path_goal.reverse()\n            # Combine paths (removing duplicate connection node in one side)\n            if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            extracted_path = path_start + path_goal\n\n        # Combine nodes for return\n        all_nodes = nodes_start + [n for n in nodes_goal if n not in nodes_start]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 5.75664,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 227.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02871973514556885,
                    "num_nodes_avg": 158.2,
                    "path_length_avg": 161.3830685924987,
                    "smoothness_avg": 0.024604793406330365,
                    "success_improvement": 0.0,
                    "time_improvement": -15.661543513515847,
                    "length_improvement": 11.543382826081865,
                    "smoothness_improvement": 285.1184469731315,
                    "objective_score": -0.9641942539727235
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.05399606227874756,
                    "num_nodes_avg": 443.6,
                    "path_length_avg": 250.88777565076117,
                    "smoothness_avg": 0.011357259449957097,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 66.69234007018737,
                    "length_improvement": 16.24643908355544,
                    "smoothness_improvement": 192.2304659507276,
                    "objective_score": -25.781857832479055
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03892641067504883,
                    "num_nodes_avg": 366.2,
                    "path_length_avg": 129.6329212302199,
                    "smoothness_avg": 0.02386257154293267,
                    "success_improvement": 0.0,
                    "time_improvement": 18.925623938584376,
                    "length_improvement": 13.903986175253118,
                    "smoothness_improvement": 203.5301486742901,
                    "objective_score": 9.476135159997387
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 14.726307021992147,
          "time_improvement": -49.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030466032028198243,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -22.694317035068327,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -6.849891589122189
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2299717426300049,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -41.85887403129106,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -12.915927160794057
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08723273277282714,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -81.68485763375077,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -24.41310231606019
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive parameter tuning, goal biasing, and rewiring for efficient and high-quality path planning. It grows two trees from start and goal simultaneously, rewires locally to optimize path costs, and attempts frequent connections to quickly find smooth, short, and feasible paths while avoiding obstacles and map boundaries.",
          "planning_mechanism": "The planner alternates growing two trees via randomized sampling biased toward the goal. Each extension selects best parents and rewires locally to improve paths. Trees connect incrementally using steering and collision checks. Upon connection, the path is reconstructed and smoothed by shortcutting collision-free segments to enhance path quality and reduce redundant nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_factor: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier for neighbor radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: n.dist(point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_neighbor_radius(node_count):\n            if node_count == 0:\n                return self.step_size * 10\n            gamma = self.neighbor_radius_factor\n            return min(gamma * ((math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)), self.step_size * 20)\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if n.dist(pos) <= radius]\n\n        def collision_free_node(pos):\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def rewire(new_node, tree):\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_node.position, radius)\n            for near_node in near:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + new_node.dist(near_node.position)\n                if new_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    near_node.update_parent(new_node, new_cost)\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and collision_free_edge(near_node.position, new_pos):\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, tree)\n            return new_node\n\n        def connect(tree, target_node):\n            current_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = Node(new_pos)\n                cost_to_new = current_node.cost + math.dist(current_node.position, new_pos)\n                new_node.update_parent(current_node, cost_to_new)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                rewire(new_node, tree)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            # Shortcut smoothing with adaptive attempts (proportional to path length)\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            attempts = max(150, len(smoothed)*10)\n            for _ in range(attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed[i+1:j] = []\n            return smoothed\n\n        for it in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate tree extension like bidirectional RRT*\n            new_start = extend(tree_start, rnd_point)\n            if new_start is not None:\n                new_goal = connect(tree_goal, new_start)\n                if new_goal is not None:\n                    # Build final path: start_root \u2192 new_start \u2192 new_goal \u2192 goal_root\n                    path_start = new_start.path_from_root()\n                    path_goal = new_goal.path_from_root()\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap the trees to balance growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.31606,
          "time_improvement": -45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1630.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043984508514404295,
                    "num_nodes_avg": 101.1,
                    "path_length_avg": 161.42531293906998,
                    "smoothness_avg": 0.044935219137958386,
                    "success_improvement": 0.0,
                    "time_improvement": -77.13659682701844,
                    "length_improvement": 11.52022803032163,
                    "smoothness_improvement": 603.3337578992031,
                    "objective_score": -17.82026465254519
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.09677293300628662,
                    "num_nodes_avg": 346.5,
                    "path_length_avg": 228.7684483165439,
                    "smoothness_avg": 0.10896417709261567,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 40.30527770072979,
                    "length_improvement": 23.63050721725338,
                    "smoothness_improvement": 2703.726760317425,
                    "objective_score": -69.66368144474325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09473226070404053,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 129.4187057666335,
                    "smoothness_avg": 0.13235765141381864,
                    "success_improvement": 0.0,
                    "time_improvement": -97.3045753840959,
                    "length_improvement": 14.04625788632298,
                    "smoothness_improvement": 1583.5795563581935,
                    "objective_score": -18.464223256173206
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.8963390906976,
          "time_improvement": 77.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009341573715209961,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 62.379150459777954,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 23.02899267630984
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02025575637817383,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 87.50516581037996,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.9928610146115
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008779239654541016,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 81.71494969758966,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.72514893379113
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.485207755128116,
          "time_improvement": 94.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0015536069869995118,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 93.74323679452625,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 29.75091122546928
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007682299613952637,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.26114660547798,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.41313556311789
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004066658020019531,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 91.5301268236486,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -22.79339892773574
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 42.22944021394406,
          "time_improvement": -157.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049358153343200685,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -98.77760612051492,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -26.320939595668875
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4221031904220581,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -160.3758298019535,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -42.18884991852324
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14922070503234863,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -210.79093464162634,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -58.17853112764008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an optimized unidirectional RRT* planner with goal biasing, rewiring for path optimality, and fixed neighbor radius for local tree improvements. It incrementally grows a single tree by sampling the space, extending nodes toward samples, and rewiring near neighbors to improve path cost and smoothness. The planner ensures collision-free nodes and edges, balancing exploration and exploitation to reduce search time while enhancing path quality and robustness.",
          "planning_mechanism": "The planner grows a single tree from the start node by randomly sampling points (with goal biasing), extending the nearest node towards the sample within a fixed step size, and rewiring nearby nodes if the new node offers lower cost connections. It terminates upon reaching the goal within a threshold. The tree structure and edge connections maintain obstacle avoidance throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 8.0, goal_threshold: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.goal_threshold = goal_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer from nearest_node towards sample\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            dist = min(self.step_size, length)\n            new_position = tuple(nearest_node.position[d] + unit[d] * dist for d in range(len(bounds)))\n\n            # Avoid going out of bounds\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for the new node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Collision check for the edge from nearest_node to new_position\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Create new node and add to tree\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes for optimal path\n            neighbors = self._nearby_nodes(nodes, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_cost\n\n                # Check if rewiring improves cost and is collision free\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly (remove old, add new)\n                        # Remove old edge\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, neighbor))\n\n            # Check if goal reached within threshold, and final connection is collision free\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.goal_threshold:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path from goal to root\n                    path = []\n                    current = goal_node\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearby_nodes(self, nodes, node, radius):\n        import math\n        res = []\n        for other in nodes:\n            if other == node:\n                continue\n            if math.dist(node.position, other.position) <= radius:\n                res.append(other)\n        return res\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.84878,
          "time_improvement": -148.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 33.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033041524887084964,
                    "num_nodes_avg": 337.5,
                    "path_length_avg": 177.72237705166276,
                    "smoothness_avg": 0.007172456235907458,
                    "success_improvement": 0.0,
                    "time_improvement": -33.06646976757138,
                    "length_improvement": 2.5875489467029023,
                    "smoothness_improvement": 12.26451532995832,
                    "objective_score": -9.34110856428104
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4186041593551636,
                    "num_nodes_avg": 1566.5,
                    "path_length_avg": 266.0595621636338,
                    "smoothness_avg": 0.00607225829807926,
                    "success_improvement": 0.0,
                    "time_improvement": -158.2174402464647,
                    "length_improvement": 11.181660049897028,
                    "smoothness_improvement": 56.24357968044635,
                    "objective_score": -44.947682165557765
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1694263696670532,
                    "num_nodes_avg": 828.7,
                    "path_length_avg": 139.59415597637658,
                    "smoothness_avg": 0.010175509506343454,
                    "success_improvement": 0.0,
                    "time_improvement": -252.8744872928067,
                    "length_improvement": 7.288208359881884,
                    "smoothness_improvement": 29.431729842704968,
                    "objective_score": -74.25754586665211
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an efficient and robust unidirectional RRT* planner incorporating goal biasing and local rewiring. It incrementally grows a single tree from start to goal, optimizing path quality through rewiring nearby nodes while ensuring collision-free node extensions and edges.",
          "planning_mechanism": "The planner samples points within map bounds with a defined probability to directly sample the goal, steering from the nearest tree node toward the sample by a fixed step size, and connects valid new nodes to the best parent among nearby nodes. It rewires neighbors if shorter paths are found and terminates successfully upon a collision-free connection to the goal, extracting the final optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rectangles or cuboids\n\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start_position)]\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step = min(self.step_size, dist)\n            unit_vector = tuple(direction[d] / dist for d in range(len(bounds)))\n\n            new_pos = tuple(nearest_node.position[d] + unit_vector[d] * step for d in range(len(bounds)))\n\n            # Check boundaries\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node\n            new_node = Node(new_pos)\n\n            # Find nearby nodes within neighbor_radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent based on minimal cost path\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_try = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_try < min_cost:\n                    # Check edge collision to near_node\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        best_parent = near_node\n                        min_cost = cost_try\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if possible\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_via_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent and edges accordingly\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 50.07314,
          "time_improvement": -186.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 278.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08358452320098878,
                    "num_nodes_avg": 420.1,
                    "path_length_avg": 154.9412718472041,
                    "smoothness_avg": 0.02062795933159791,
                    "success_improvement": 0.0,
                    "time_improvement": -236.6157423899236,
                    "length_improvement": 15.074233698979455,
                    "smoothness_improvement": 222.872357870154,
                    "objective_score": -66.85551418783042
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5137278318405152,
                    "num_nodes_avg": 1643.7,
                    "path_length_avg": 221.01420280116628,
                    "smoothness_avg": 0.01623238282201555,
                    "success_improvement": 0.0,
                    "time_improvement": -216.89481042321557,
                    "length_improvement": 26.21909756386829,
                    "smoothness_improvement": 317.67090172322423,
                    "objective_score": -58.23626910557489
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09864957332611084,
                    "num_nodes_avg": 630.5,
                    "path_length_avg": 112.63006772970371,
                    "smoothness_avg": 0.03100782754526841,
                    "success_improvement": 0.0,
                    "time_improvement": -105.46339792037023,
                    "length_improvement": 25.19647188141747,
                    "smoothness_improvement": 294.41727761606415,
                    "objective_score": -25.12763861174725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a unidirectional RRT* planner with goal biasing, fixed neighbor radius rewiring, and path smoothing for improved planning efficiency and path quality. It grows a single tree from the start towards the goal, incrementally optimizing paths via rewiring and focusing sampling near the goal to speed convergence and enhance robustness.",
          "planning_mechanism": "The planner samples points with goal bias to guide growth towards the goal. For each sample, it finds the nearest node and attempts to steer towards it within a fixed step size, adding collision-checked nodes and edges. Nearby nodes are rewired to reduce path cost. Upon reaching the goal region, the path is extracted and smoothed by shortcutting to improve smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, neighbor_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_node = Node(start_position, cost=0.0)\n        nodes.append(start_node)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.neighbor_radius]\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            nearest_node = nearest(nodes, rand_point)\n            new_position = self._steer(nearest_node.position, rand_point, self.step_size)\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n\n            neighbors = near(nodes, new_position)\n            for near_node in neighbors:\n                if near_node == nearest_node:\n                    continue\n                potential_cost = near_node.cost + dist(near_node.position, new_position)\n                if potential_cost < new_node.cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    # Rewire new_node parent\n                    new_node.update_parent(near_node, potential_cost)\n\n            # Rewire neighbors if going through new_node is cheaper\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    near_node.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Check if goal can be reached directly from new_node\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = goal_node.path_from_root()\n                    success_state = True\n                    break\n\n        # Path smoothing by shortcutting\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_trials=100):\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy to avoid side-effects\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # remove nodes between i+1 and j-1\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 74.34264,
          "time_improvement": -282.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1160.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.059880423545837405,
                    "num_nodes_avg": 313.9,
                    "path_length_avg": 155.9517991151351,
                    "smoothness_avg": 0.040852809102449254,
                    "success_improvement": 0.0,
                    "time_improvement": -141.15341518472252,
                    "length_improvement": 14.520347690597207,
                    "smoothness_improvement": 539.4351757482023,
                    "objective_score": -36.7447791385563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5118288040161133,
                    "num_nodes_avg": 1528.0,
                    "path_length_avg": 218.72516868069314,
                    "smoothness_avg": 0.07365573914609802,
                    "success_improvement": 0.0,
                    "time_improvement": -215.72338846570509,
                    "length_improvement": 26.983243039476218,
                    "smoothness_improvement": 1795.2152203136275,
                    "objective_score": -50.34429183024814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2823688745498657,
                    "num_nodes_avg": 883.5,
                    "path_length_avg": 114.64070421990502,
                    "smoothness_avg": 0.09781379626488622,
                    "success_improvement": 0.0,
                    "time_improvement": -488.10663316483095,
                    "length_improvement": 23.86110286084681,
                    "smoothness_improvement": 1144.1842686259308,
                    "objective_score": -135.93884803415025
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A goal-biased unidirectional RRT* path planner with dynamic rewiring for path optimality and collision-aware incremental growth within map boundaries. The planner incrementally samples points, extends the tree toward samples while maintaining collision-free nodes and edges, and rewires neighbors based on cost optimization for improved path quality and smoothness.",
          "planning_mechanism": "The planner grows a single tree rooted at start, sampling points biased toward the goal. Each iteration finds the nearest node, extends toward the sample within step size and map bounds, checks collisions, and adds new nodes and edges if valid. Nearby nodes are rewired to reduce path cost. Upon reaching the goal within a threshold, the path is extracted by backtracking from goal to start.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children = []\n        self.valid = True             # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Multiplier for neighbor radius computation\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            step = min(self.step_size, length)\n            unit = tuple(d / length for d in direction)\n            new_pos = tuple(from_pos[d] + unit[d]*step for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        nodes: list[Node] = [Node(start_position)]\n        edges: list[tuple[Node, Node]] = []\n\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not new_pos:\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            temp_node = Node(new_pos)\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby(nodes, new_pos, radius)\n\n            # Choose best parent with minimal cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = near_node\n\n            temp_node.update_parent(best_parent, min_cost)\n            nodes.append(temp_node)\n            edges.append((best_parent, temp_node))\n\n            # Rewire neighbors to possibly improve cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = temp_node.cost + dist(temp_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(temp_node.position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(temp_node, cost_through_new)\n                    edges.append((temp_node, near_node))\n\n            # Check goal proximity and connectivity\n            if dist(temp_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(temp_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=temp_node, cost=temp_node.cost + dist(temp_node.position, goal_position))\n                    temp_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((temp_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = goal_node.path() if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 82.84535,
          "time_improvement": -228.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.061753582954406736,
                    "num_nodes_avg": 420.6,
                    "path_length_avg": 169.20056187137845,
                    "smoothness_avg": 0.009821549286866758,
                    "success_improvement": 0.0,
                    "time_improvement": -148.69709577035007,
                    "length_improvement": 7.258490883819664,
                    "smoothness_improvement": 53.72857417510504,
                    "objective_score": -42.888787683465566
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.4377663850784302,
                    "num_nodes_avg": 1521.7,
                    "path_length_avg": 262.16725350778154,
                    "smoothness_avg": 0.004783214453124576,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -170.03772622572728,
                    "length_improvement": 12.481024713113289,
                    "smoothness_improvement": 23.075553089009492,
                    "objective_score": -98.39973515965048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2237252712249756,
                    "num_nodes_avg": 905.2,
                    "path_length_avg": 133.49716828412363,
                    "smoothness_avg": 0.012182274526916389,
                    "success_improvement": 0.0,
                    "time_improvement": -365.9660744257183,
                    "length_improvement": 11.337537277721248,
                    "smoothness_improvement": 54.957632780406904,
                    "objective_score": -107.24752670826922
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm combines a bidirectional approach with an adaptive dynamic step size and velocity heuristic to accelerate path convergence and improve path quality while maintaining robustness. It adaptively adjusts the step size based on obstacle proximity and node density, uses informed sampling biased towards the direction of the goal, and incorporates a lazy collision checking strategy to reduce unnecessary computation. The path smoothing is done after path extraction using shortcutting to enhance path smoothness and reduce length.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, but unlike basic bidirectional RRT, it adapts step size dynamically to safely push further in open spaces and slow down near obstacles. Sampling is biased toward the line connecting start and goal to improve success rate and reduce exploration in irrelevant areas. Lazy collision checks delay edge checking to critical phases to reduce overhead. Once the trees connect, the final path is shortcut-smoothed by attempting direct connections between non-adjacent nodes for efficiency and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # Collision valid flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step_size: float = 5.0, min_step_size: float = 1.0, max_step_size: float = 10.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def adaptive_step_size(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            test_pos = self._steer(from_pos, to_pos, self.base_step_size)\n            dist_to_obs = self._distance_to_nearest_obstacle(test_pos, obstacles, is_3d)\n            if dist_to_obs is None:\n                # No obstacles nearby, increase step to max\n                step = min(self.max_step_size, dist)\n            else:\n                # Decrease step size near obstacles\n                step = max(self.min_step_size, min(dist_to_obs * 0.5, dist, self.max_step_size))\n            return step\n\n        def sample_biased():\n            # 80% samples biased towards line start-goal, 20% uniform random\n            alpha = 0.8\n            dim = len(bounds)\n            if random.random() < alpha:\n                # Sample near the line with added noise orthogonal to line direction\n                dir_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n                norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n                if norm_dir < 1e-6:\n                    # Start==Goal rare case, sample uniform\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                unit_dir = tuple(x / norm_dir for x in dir_vec)\n                t = random.uniform(0, 1)\n                base_point = tuple(start_position[d] + t * dir_vec[d] for d in range(dim))\n                # noise perpendicular to direction vector\n                noise_mag = self.base_step_size * 1.5\n                # Create a random vector perpendicular to unit_dir\n                perp_noise = []\n                for d in range(dim):\n                    aligned = sum(unit_dir[i] * (random.random()*2-1) for i in range(dim))\n                    val = (random.random()*2 - 1) - aligned*unit_dir[d]\n                    perp_noise.append(val)\n                norm_noise = math.sqrt(sum(x*x for x in perp_noise))\n                if norm_noise > 1e-9:\n                    perp_noise = tuple(noise_mag * x / norm_noise for x in perp_noise)\n                else:\n                    perp_noise = tuple(0.0 for _ in range(dim))\n                sample = tuple(base_point[d] + perp_noise[d] for d in range(dim))\n                # Clamp sample inside bounds\n                sample = tuple(max(0, min(bounds[d], sample[d])) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                else:\n                    # fallback uniform sample if inside obstacle\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for iteration in range(self.max_iter):\n            # Alternate growing trees, but start tree always samples biased\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            rand_point = sample_biased()\n\n            nearest_node_a = min(tree_a, key=lambda n: distance(n.position, rand_point))\n\n            # Compute adaptive step size\n            step = adaptive_step_size(nearest_node_a.position, rand_point)\n\n            new_pos = self._steer(nearest_node_a.position, rand_point, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy edge check with direct edge validation before addition (edge check deferred till tight)\n            if self._is_edge_in_obstacle(nearest_node_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_a = Node(new_pos, parent=nearest_node_a)\n            nearest_node_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_node_a, new_node_a))\n\n            # Try connecting the other tree to new_node_a directly with incremental steps\n            connect_node_b = min(tree_b, key=lambda n: distance(n.position, new_node_a.position))\n            connect_dist = distance(connect_node_b.position, new_node_a.position)\n\n            step_b = adaptive_step_size(connect_node_b.position, new_node_a.position)\n            last_pos = connect_node_b.position\n            connected = False\n            while True:\n                if connect_dist <= step_b:\n                    candidate_pos = new_node_a.position\n                else:\n                    candidate_pos = self._steer(last_pos, new_node_a.position, step_b)\n\n                if self._is_in_obstacle(candidate_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(last_pos, candidate_pos, obstacles, is_3d):\n                    break\n\n                new_node_b = Node(candidate_pos, parent=None)\n                # Link properly with tree_b structure\n                if last_pos == connect_node_b.position:\n                    connect_node_b.add_child(new_node_b)\n                else:\n                    parent_node = tree_b[-1]  # last inserted node in tree_b (safe as we append each step)\n                    parent_node.add_child(new_node_b)\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((new_node_b.parent, new_node_b))\n\n                last_pos = candidate_pos\n                connect_dist = distance(last_pos, new_node_a.position)\n                if connect_dist <= self.min_step_size:\n                    # Trees connected\n                    connected = True\n                    break\n                # adapt step size for next segment\n                step_b = adaptive_step_size(last_pos, new_node_a.position)\n\n            if connected:\n                # Reconstruct path from start_root to new_node_a then new_node_b to goal\n                # Tree A: new_node_a -> root\n                path_a = []\n                node = new_node_a\n                while node is not None:\n                    path_a.append(node.position)\n                    node = node.parent\n                path_a = path_a[::-1]\n\n                # Tree B: new_node_b -> root (goal)\n                path_b = []\n                node = new_node_b\n                while node is not None:\n                    path_b.append(node.position)\n                    node = node.parent\n\n                combined_path = path_a + path_b\n\n                # Shortcut smoothing on combined path\n                smoothed_path = self._shortcut_smooth(combined_path, obstacles, is_3d)\n\n                extracted_path = smoothed_path\n                success_state = True\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance_to_nearest_obstacle(self, pos, obstacles, is_3d, search_radius=10.0, resolution=0.5):\n        # Approximate distance to nearest obstacle using sampled points in neighborhood\n        # Return None if no obstacle in radius\n        min_dist = None\n        dim = len(pos)\n        steps = max(1, int(search_radius / resolution))\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                # Closest point in box to pos\n                cx = max(ox, min(pos[0], ox + w))\n                cy = max(oy, min(pos[1], oy + h))\n                cz = max(oz, min(pos[2], oz + d))\n                dist = math.dist(pos, (cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                cx = max(ox, min(pos[0], ox + w))\n                cy = max(oy, min(pos[1], oy + h))\n                dist = math.dist(pos, (cx, cy))\n            if dist <= search_radius:\n                if (min_dist is None) or (dist < min_dist):\n                    min_dist = dist\n        return min_dist\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_trials=100):\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # remove nodes between i+1 and j-1\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 87.9137,
          "time_improvement": -180.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2714.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03528840541839599,
                    "num_nodes_avg": 265.2,
                    "path_length_avg": 150.53022446227038,
                    "smoothness_avg": 0.025798357332320054,
                    "success_improvement": 0.0,
                    "time_improvement": -42.115218616566196,
                    "length_improvement": 17.491998668180383,
                    "smoothness_improvement": 303.8003142804197,
                    "objective_score": -7.617164279931682
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09829518795013428,
                    "num_nodes_avg": 724.5,
                    "path_length_avg": 258.25522538315045,
                    "smoothness_avg": 0.11670420049265859,
                    "success_improvement": 0.0,
                    "time_improvement": 39.3662694127845,
                    "length_improvement": 13.786972302601356,
                    "smoothness_improvement": 2902.8831373140447,
                    "objective_score": 29.081690970925845
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.3059559345245361,
                    "num_nodes_avg": 1399.1,
                    "path_length_avg": 140.90972647432935,
                    "smoothness_avg": 0.3959351063662842,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -537.2328212054701,
                    "length_improvement": 6.414469075876875,
                    "smoothness_improvement": 4936.26532808959,
                    "objective_score": -285.20562590601776
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a goal-biased unidirectional RRT* planner with adaptive neighbor radius based on node count and dimension. It incrementally builds a single tree from the start to the goal, rewiring locally to optimize path cost and smoothness, while ensuring collision-free node and edge placements. The planner balances exploration and exploitation to efficiently find and refine high-quality feasible paths within map constraints.",
          "planning_mechanism": "The planner samples points biased towards the goal, extends the nearest node incrementally towards the sample within step limits and map bounds, then finds neighbors within a dynamically computed radius to select the best parent and rewire suboptimal neighbors. It continues iterations until it successfully connects to the goal or reaches the iteration limit, then extracts the optimal path by tracing from the goal node back to the start.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal to bias tree growth\n        self.neighbor_factor = neighbor_factor    # Multiplier for adaptive neighbor radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: list[Node] = [Node(start_position)]\n        edges: list[tuple[Node, Node]] = []\n        success_state = False\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(dim)\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.8)\n\n        def nearby_nodes(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if new_pos is None:\n                continue\n\n            # Collision checks - node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node without assigned parent yet\n            new_node = Node(new_pos)\n\n            # Find neighbors within adaptive radius\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent based on minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if (temp_cost < min_cost and\n                    not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if shorter path found through new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edges\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if can connect directly to goal\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state and goal_node is not None:\n            extracted_path = goal_node.path()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 91.61806,
          "time_improvement": -269.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 532.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04587178230285645,
                    "num_nodes_avg": 277.4,
                    "path_length_avg": 164.5355491151085,
                    "smoothness_avg": 0.013942328972383417,
                    "success_improvement": 0.0,
                    "time_improvement": -84.73711954418755,
                    "length_improvement": 9.81545829738883,
                    "smoothness_improvement": 118.22772466975222,
                    "objective_score": -22.866905580429737
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2560333251953125,
                    "num_nodes_avg": 1055.8,
                    "path_length_avg": 241.25080706466778,
                    "smoothness_avg": 0.008030908674216396,
                    "success_improvement": 0.0,
                    "time_improvement": -57.93505241698157,
                    "length_improvement": 19.46353658235415,
                    "smoothness_improvement": 106.64106461729752,
                    "objective_score": -12.954603085537151
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.3673215866088867,
                    "num_nodes_avg": 969.2,
                    "path_length_avg": 123.2964615601171,
                    "smoothness_avg": 0.11568754781896344,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -665.0427545659493,
                    "length_improvement": 18.112360978350164,
                    "smoothness_improvement": 1371.5370690906886,
                    "objective_score": -239.03266882866131
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a goal-biased, single-tree RRT* algorithm with rewiring to efficiently find and optimize a feasible path. It combines informed sampling within the ellipsoidal subset defined by the current best path cost, adaptive neighbor search for rewiring, and rigorous collision checking to improve planning efficiency, path quality, and robustness. Path smoothing is applied by rewiring nearby nodes during expansion, leading to shorter and smoother paths with faster convergence and higher success rates.",
          "planning_mechanism": "The planner grows a single tree from the start position, sampling points biased toward the goal and within an informed subset once a solution is found. For each sample, it finds the nearest node to steer towards, adds the new node if collision-free, then rewires neighbor nodes to improve path cost locally. The process iterates until the goal is reached or max iterations run out, and the best path is extracted from root to goal, producing a smooth, high-quality path while minimizing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius      # Radius to search neighbors for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        dim = len(bounds)\n        dist = lambda a,b: math.dist(a,b)\n\n        # Ellipsoidal informed sampling helper when path found\n        def informed_sample():\n            c_min = dist(start_position, goal_position)\n            c_best = best_cost\n\n            if c_best == float('inf'):\n                # No path found yet, uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute unit vector from start to goal\n            start_goal_vec = [goal_position[d] - start_position[d] for d in range(dim)]\n            norm_start_goal = math.sqrt(sum(x*x for x in start_goal_vec))\n            if norm_start_goal < 1e-8:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            unit_vec = [x / norm_start_goal for x in start_goal_vec]\n\n            # Compute rotation matrix from unit vector to first axis (only works for 2D/3D)\n            # We will generate sample in canonical unit ball and transform:\n            # Scale ellipsoid axes lengths\n            a1 = c_best / 2.0\n            a2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[unit_vec[0], -unit_vec[1]],\n                     [unit_vec[1],  unit_vec[0]]]  # rotation matrix to align x-axis with unit_vec\n            elif dim == 3:\n                # 3d rotation matrix using unit_vec as z axis\n                ux, uy, uz = unit_vec\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    # unit_vec aligned with z-axis\n                    L = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [-uy, ux, 0]\n                    norm_vx = math.sqrt(vx[0]**2 + vx[1]**2 + vx[2]**2)\n                    vx = [x / norm_vx for x in vx]\n                    vy = [unit_vec[1]*vx[2] - unit_vec[2]*vx[1],\n                          unit_vec[2]*vx[0] - unit_vec[0]*vx[2],\n                          unit_vec[0]*vx[1] - unit_vec[1]*vx[0]]\n                    L = [vx, vy, unit_vec]\n            else:\n                # Fallback: uniform random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample a random point in unit ball\n            while True:\n                rnd = [random.uniform(-1,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd <= 1:\n                    break\n            # Scale along ellipsoid axes\n            if dim == 2:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1]]\n                # Rotate back and translate to center\n                sample = [start_position[d] + 0.5*(start_position[d]+goal_position[d]) - start_position[d] for d in range(dim)]  # midpoint\n                # Rotate canonical sample:\n                x = L[0][0]*sample_canonical[0] + L[0][1]*sample_canonical[1]\n                y = L[1][0]*sample_canonical[0] + L[1][1]*sample_canonical[1]\n                sample = (0.5*(start_position[0] + goal_position[0]) + x,\n                          0.5*(start_position[1] + goal_position[1]) + y)\n                # Clamp inside bounds\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            elif dim == 3:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1], a2 * rnd[2]]\n                # Rotate back\n                x = sum(L[0][i] * sample_canonical[i] for i in range(3))\n                y = sum(L[1][i] * sample_canonical[i] for i in range(3))\n                z = sum(L[2][i] * sample_canonical[i] for i in range(3))\n                sample = (0.5*(start_position[0] + goal_position[0]) + x,\n                          0.5*(start_position[1] + goal_position[1]) + y,\n                          0.5*(start_position[2] + goal_position[2]) + z)\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(3))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n            # Fallback uniform sample if informed sample in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample() -> Tuple[float, ...]:\n            # Goal biasing sampling: with probability goal_sample_rate sample goal, else informed or uniform\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if best_goal_node is None:\n                # No path found, uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # informed sample\n            return informed_sample()\n\n        def nearest_node(point: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def nearby_nodes(new_node: Node) -> List[Node]:\n            r = self.neighbor_radius\n            return [n for n in nodes if dist(n.position, new_node.position) <= r]\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        for iteration in range(self.max_iter):\n            rnd_point = sample()\n            nearest = nearest_node(rnd_point)\n            new_pos = steer(nearest.position, rnd_point, self.step_size)\n\n            # Boundary clamp\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Determine cost to new node via nearest\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            # Rewire nearby nodes to new_node if it improves cost and edge is obstacle free\n            neighbors = nearby_nodes(new_node)\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n\n            # Check if new node can update best goal connection\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    cost_through_new = new_node.cost + dist_to_goal\n                    if cost_through_new < best_cost:\n                        best_cost = cost_through_new\n                        goal_node = Node(goal_position, parent=new_node, cost=cost_through_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        best_goal_node = goal_node\n                        success_state = True\n\n            if success_state:\n                # Early stop option enabled - break if goal found and no bettering in 500 iterations\n                # For simplicity, just break here after first found path.\n                break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            extracted_path = []\n\n        # Return all nodes and edges (parent-child)\n        edges = []\n        for node in nodes:\n            if node.parent is not None:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 127.67695,
          "time_improvement": -383.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 475.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06704170703887939,
                    "num_nodes_avg": 415.4,
                    "path_length_avg": 184.35859921574527,
                    "smoothness_avg": 0.008057359207520117,
                    "success_improvement": 0.0,
                    "time_improvement": -169.99369167560423,
                    "length_improvement": -1.0498695791002604,
                    "smoothness_improvement": 26.115168433255526,
                    "objective_score": -51.077505576335035
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5553471088409424,
                    "num_nodes_avg": 1681.1,
                    "path_length_avg": 254.67720012963406,
                    "smoothness_avg": 0.007639532331288179,
                    "success_improvement": 0.0,
                    "time_improvement": -242.5678070520923,
                    "length_improvement": 14.98142011997174,
                    "smoothness_improvement": 96.57066941676904,
                    "objective_score": -69.29120474454949
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.40188016891479494,
                    "num_nodes_avg": 1040.0,
                    "path_length_avg": 136.05661202392085,
                    "smoothness_avg": 0.11032008387859223,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -737.0199918562732,
                    "length_improvement": 9.637676613361911,
                    "smoothness_improvement": 1303.2633239541433,
                    "objective_score": -262.6621456144389
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a unidirectional, asymptotically optimal RRT*-style planner that improves planning efficiency and path quality by employing goal-biased sampling, rewiring to optimize local path costs, adaptive step sizing, and rigorous collision checking for both nodes and connecting edges. It builds and continually improves a single tree towards the goal within bounded free space.",
          "planning_mechanism": "The planner iteratively samples points biased towards the goal, extends the tree toward these samples with adaptive step sizes, rejects samples inside obstacles, and only adds edges that do not intersect obstacles. It rewires nearby nodes to reduce path cost, updating parent-child relationships accordingly, thus continuously refining the path towards an optimal solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_pos)]\n        edges = []\n        success = False\n        best_goal_node = None\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        for _ in range(self.max_iter):\n            rnd = sample()\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, rnd))\n            new_pos = steer(nearest.position, rnd)\n\n            # Bound check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes for cost improvement\n            neighbor_nodes = [n for n in nodes \n                              if n != new_node and math.dist(n.position, new_node.position) <= self.neighbor_radius]\n\n            for near in neighbor_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly\n                        # Remove old edge(s)\n                        edges = [(p, c) for (p, c) in edges if c != near]\n                        edges.append((new_node, near))\n\n            # Check if goal reached\n            if math.dist(new_node.position, goal_pos) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, new_node, new_node.cost + math.dist(new_node.position, goal_pos))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    best_goal_node = goal_node\n                    break\n\n        path = []\n        if success and best_goal_node is not None:\n            path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 164.71387,
          "time_improvement": -447.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04162766933441162,
                    "num_nodes_avg": 359.5,
                    "path_length_avg": 173.36681203058686,
                    "smoothness_avg": 0.007998617059213408,
                    "success_improvement": 0.0,
                    "time_improvement": -67.6450170478386,
                    "length_improvement": 4.974903153099051,
                    "smoothness_improvement": 25.1957262516388,
                    "objective_score": -19.17254585247358
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.609927749633789,
                    "num_nodes_avg": 1622.3,
                    "path_length_avg": 256.2429826903963,
                    "smoothness_avg": 0.007767840664918752,
                    "success_improvement": 0.0,
                    "time_improvement": -276.23606628356083,
                    "length_improvement": 14.458716832637192,
                    "smoothness_improvement": 99.87213525784088,
                    "objective_score": -79.47971584225161
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.5261727094650268,
                    "num_nodes_avg": 1260.1,
                    "path_length_avg": 128.32960562860777,
                    "smoothness_avg": 0.012959332698074973,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -995.8915394623153,
                    "length_improvement": 14.769586340624134,
                    "smoothness_improvement": 64.8417553610762,
                    "objective_score": -395.4893357937644
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a goal-biased, unidirectional RRT* planner with adaptive neighbor radius and adaptive step size based on obstacle proximity. It incrementally builds a single tree from start to goal while rewiring locally to optimize path cost, incorporates obstacle-aware step adjustments for safer expansions, and performs aggressive pruning of suboptimal nodes to improve planning efficiency and path quality. The planner includes shortcut smoothing on the extracted path to produce smoother and shorter final routes.",
          "planning_mechanism": "The planner samples points with goal bias, adapts step sizes near obstacles to enable finer expansions in cluttered areas, and grows a single tree using rewiring with an adaptive neighbor radius computed from node counts and map dimension. It prunes nodes that cannot lead to better solutions to reduce search space and applies shortcut smoothing on the final path. Collision and edge checks ensure safety before node or edge additions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\n\n    def is_descendant_of(self, ancestor):\n        node = self.parent\n        while node:\n            if node == ancestor:\n                return True\n            node = node.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_factor: float = 35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_position)]\n        edges = []\n        success_state = False\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step_clamped = min(step, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step_clamped for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(dim)\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby_nodes(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        def adaptive_step(from_pos, to_pos):\n            # Reduce step size if obstacles are near the line segment\n            resolution = 0.3\n            dist_full = dist(from_pos, to_pos)\n            steps = max(2, int(dist_full))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def prune_nodes(c_best):\n            # Remove nodes that cannot achieve better cost than current best path\n            pruned = []\n            for node in nodes[:]:\n                est_to_goal = dist(node.position, goal_position)\n                if node.cost + est_to_goal >= c_best:\n                    # Remove from parent's children list if connected\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    nodes.remove(node)\n                    pruned.append(node)\n            # Clean edges for pruned nodes\n            edges[:] = [(p, c) for (p, c) in edges if p in nodes and c in nodes]\n\n        def shortcut_smoothing(path):\n            # Attempt to shortcut between non-adjacent nodes if line is obstacle-free\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        c_best = float(\"inf\")\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n            if new_pos is None:\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node without assigned parent yet\n            new_node = Node(new_pos)\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent by minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                # Avoid cycles\n                if near_node.is_descendant_of(new_node):\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.parent.remove_child(near_node)\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    path = goal_node.path()\n                    path = shortcut_smoothing(path)\n                    c_best = goal_node.cost\n                    extracted_path = path\n                    prune_nodes(c_best)\n                    break\n\n            # Occasionally prune nodes with high costs to improve efficiency\n            if _ % 100 == 0 and success_state:\n                prune_nodes(c_best)\n\n        if success_state and goal_node and not extracted_path:\n            # If path found but no smoothing before break, perform smoothing now\n            extracted_path = shortcut_smoothing(goal_node.path())\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 266.54382,
          "time_improvement": -872.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1591.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.42328734397888185,
                    "num_nodes_avg": 333.7,
                    "path_length_avg": 164.858207961629,
                    "smoothness_avg": 0.05420862316105281,
                    "success_improvement": 0.0,
                    "time_improvement": -1604.6838108424445,
                    "length_improvement": 9.638603870754327,
                    "smoothness_improvement": 748.482668379779,
                    "objective_score": -475.7350091366835
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.6723801374435425,
                    "num_nodes_avg": 1016.5,
                    "path_length_avg": 227.74479629149204,
                    "smoothness_avg": 0.1036553096883434,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -314.76004020287337,
                    "length_improvement": 23.97223172740555,
                    "smoothness_improvement": 2567.125778182868,
                    "objective_score": -126.79793682446655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.38209807872772217,
                    "num_nodes_avg": 519.9,
                    "path_length_avg": 117.77962512350211,
                    "smoothness_avg": 0.12251345895791133,
                    "success_improvement": 0.0,
                    "time_improvement": -695.8186431756562,
                    "length_improvement": 21.776381056028892,
                    "smoothness_improvement": 1458.3621549417553,
                    "objective_score": -197.09850596678228
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 798.7637678809918,
          "time_improvement": -2679.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.090405321121216,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "smoothness_avg": 0.0150601233961907,
                    "success_improvement": 0.0,
                    "time_improvement": -4291.3344554533405,
                    "length_improvement": 15.280155580980631,
                    "smoothness_improvement": 135.72363473177828,
                    "objective_score": -1283.665687346147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.6918304920196534,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "smoothness_avg": 0.011376062771551485,
                    "success_improvement": 0.0,
                    "time_improvement": -943.6115581201832,
                    "length_improvement": 23.354217616048047,
                    "smoothness_improvement": 192.71428895883628,
                    "objective_score": -277.44905246805115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.3928252696990966,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "smoothness_avg": 0.01876598180493872,
                    "success_improvement": 0.0,
                    "time_improvement": -2800.9209363299597,
                    "length_improvement": 22.0310377661009,
                    "smoothness_improvement": 138.7019033981297,
                    "objective_score": -835.1765638287771
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed RRT* with dynamic pruning and heuristics to improve planning efficiency and path quality. It grows a single tree from start toward goal while biasing samples within an ellipsoidal informed subset that shrinks as better paths are found. The planner applies collision-aware incremental rewiring with a dynamic neighbor radius adapting to node density, enabling continuous path cost improvements and smoothness. Additionally, it performs pruning of nodes that cannot lead to an improved solution, improving robustness and reducing search time.",
          "planning_mechanism": "The planner incrementally samples the configuration space, initially uniformly but gradually focusing samples within an ellipsoid defined by current best path cost to efficiently exploit promising regions. It extends the nearest node toward each sample with collision checks, adds new nodes, and rewires nearby nodes to optimize path cost. When a better path to the goal is found, the informed sampling ellipsoid shrinks and nodes unlikely to improve the solution are pruned. The process continues until max iterations or satisfactory path quality is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_factor: float=50.0, goal_threshold: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # factor to compute neighbor radius dynamically\n        self.goal_threshold = goal_threshold\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        # Initialization for informed sampling\n        c_min = math.dist(start_position, goal_position)  # minimum possible cost (straight line)\n        c_best = float('inf')  # current best path cost\n        unit_vect = self._unit_vector(start_position, goal_position)\n        # Rotation matrix aligning x-axis with start-goal vector for ellipse sampling\n        rotation = self._rotation_to_x_axis(unit_vect, dim)\n\n        def sample_in_ellipse():\n            # If no better path found, uniform sampling\n            if c_best == float('inf'):\n                return tuple((random.uniform(0, bounds[d]) for d in range(dim)))\n            else:\n                # Informed sampling within an ellipsoid defined by c_best and c_min\n                # Sample unit ball point:\n                while True:\n                    # Sample random point in unit n-ball with rejection\n                    x = self._sample_unit_n_ball(dim)\n                    L = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim -1)\n                    # Scale by ellipse axes lengths\n                    x_scale = [L[0]*x[0]] + [L[i]*x[i] for i in range(1, dim)]\n                    # Rotate & translate to center\n                    x_rot = self._mat_vec_mult(rotation, x_scale)\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                    # Clamp to bounds\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return sample\n\n        import random\n\n        for iter in range(self.max_iter):\n            # Sampling with goal biasing + informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = sample_in_ellipse()\n\n            # Find nearest node (Euclidean distance)\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            direction = tuple((sample[d] - nearest_node.position[d]) / dist_to_sample for d in range(dim))\n            dist = min(self.step_size, dist_to_sample)\n            new_position = tuple(nearest_node.position[d] + direction[d] * dist for d in range(dim))\n\n            # Boundary check\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Dynamic neighbor radius (as in RRT* theory) for rewiring\n            gamma = self.neighbor_factor\n            n = len(nodes)\n            radius = min(self.step_size * 10, gamma * (math.log(n) / n) ** (1 / dim))\n\n            neighbors = self._nearby_nodes(nodes, new_node, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_cost\n                if potential_cost < neighbor.cost:\n                    # Check collision for edge\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, neighbor))\n\n            # Goal check\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.goal_threshold:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = best_cost\n                        # Prune nodes that cannot improve cost\n                        nodes, edges = self._prune_tree(nodes, edges, start_position, goal_position, c_best, is_3d, obstacles)\n\n            # Optional early stop: if found a path close to theoretical minimum\n            if c_best <= 1.1 * c_min:\n                break\n\n        # Extract path if found\n        extracted_path = []\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            node = best_goal_node\n            while node is not None:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearby_nodes(self, nodes, node, radius):\n        res = []\n        for other in nodes:\n            if other == node:\n                continue\n            if math.dist(node.position, other.position) <= radius:\n                res.append(other)\n        return res\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # Helper: unit vector from point a to b\n    def _unit_vector(self, a, b):\n        dist = math.dist(a, b)\n        if dist == 0:\n            return tuple(0.0 for _ in a)\n        return tuple((b[d] - a[d]) / dist for d in range(len(a)))\n\n    # Helper: create rotation matrix aligning vector with x-axis\n    def _rotation_to_x_axis(self, v, dim):\n        # For 2D: rotation matrix to align vector v with x-axis\n        if dim == 2:\n            vx, vy = v\n            theta = math.atan2(vy, vx)\n            cos_t = math.cos(-theta)\n            sin_t = math.sin(-theta)\n            return [[cos_t, -sin_t],\n                    [sin_t, cos_t]]\n        elif dim == 3:\n            # Use Gram-Schmidt or a rotation aligning v to (1,0,0)\n            # Algorithm: find rotation matrix R such that R v = (norm(v),0,0)\n            norm_v = math.sqrt(sum([x*x for x in v]))\n            if norm_v == 0:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            # Normalize v\n            vx, vy, vz = (x / norm_v for x in v)\n\n            # Axis-angle approach: rotation axis is cross product of v and x-axis\n            ax = 0\n            ay = -vz\n            az = vy\n            angle = math.acos(vx)\n            if math.isclose(angle, 0):\n                return [[1,0,0],[0,1,0],[0,0,1]]\n\n            s = math.sin(angle)\n            c = math.cos(angle)\n            t = 1 - c\n\n            # Normalize axis\n            axis_len = math.sqrt(ax*ax + ay*ay + az*az)\n            if axis_len == 0:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            ax /= axis_len\n            ay /= axis_len\n            az /= axis_len\n\n            return [\n                [t*ax*ax + c,     t*ax*ay - s*az, t*ax*az + s*ay],\n                [t*ax*ay + s*az,  t*ay*ay + c,    t*ay*az - s*ax],\n                [t*ax*az - s*ay,  t*ay*az + s*ax, t*az*az + c   ]\n            ]\n        else:\n            # Identity if other dims\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n    # Helper: matrix-vector multiplication for rotation\n    def _mat_vec_mult(self, mat, vec):\n        return tuple(sum(mat[i][j]*vec[j] for j in range(len(vec))) for i in range(len(mat)))\n\n    # Sample random point inside unit n-ball with rejection sampling\n    def _sample_unit_n_ball(self, n):\n        import random\n        while True:\n            point = [random.uniform(-1,1) for _ in range(n)]\n            if sum(x*x for x in point) <= 1:\n                return point\n\n    # Prune nodes and edges that cannot possibly improve current best cost\n    def _prune_tree(self, nodes, edges, start_position, goal_position, c_best, is_3d, obstacles):\n        pruned_nodes = []\n        pruned_edges = []\n        dim = len(start_position)\n\n        # For quick lookup: node to index mapping\n        node_set = set(nodes)\n\n        for node in nodes:\n            # Admissible heuristic: cost to come + heuristic to goal\n            h_cost = math.dist(node.position, goal_position)\n            if node.cost + h_cost <= c_best:\n                pruned_nodes.append(node)\n            else:\n                # Disconnect pruned node from parent\n                if node.parent is not None:\n                    node.parent.remove_child(node)\n                    node.parent = None\n                node.valid = False\n\n        # Rebuild edges on pruned nodes only\n        node_set_pruned = set(pruned_nodes)\n        for (p, c) in edges:\n            if p in node_set_pruned and c in node_set_pruned:\n                pruned_edges.append((p, c))\n\n        return pruned_nodes, pruned_edges",
          "objective": 1025.53043,
          "time_improvement": -3269.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.1981682538986207,
                    "num_nodes_avg": 2661.0,
                    "path_length_avg": 157.95477047547763,
                    "smoothness_avg": 0.01728095289776719,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4725.32268951618,
                    "length_improvement": 13.422487348881177,
                    "smoothness_improvement": 170.4844390399015,
                    "objective_score": -1464.059887189878
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.7487941265106202,
                    "num_nodes_avg": 3673.4,
                    "path_length_avg": 249.36026991199805,
                    "smoothness_avg": 0.028889447072236583,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -978.7497753515913,
                    "length_improvement": 16.756364465969455,
                    "smoothness_improvement": 643.3462813962985,
                    "objective_score": -337.05692830530205
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 2.017609453201294,
                    "num_nodes_avg": 4111.3,
                    "path_length_avg": 124.02512802185954,
                    "smoothness_avg": 0.03394362310736604,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4102.196522032754,
                    "length_improvement": 17.628415409829085,
                    "smoothness_improvement": 331.7603804680588,
                    "objective_score": -1275.4744716255202
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a unidirectional, goal-biased, RRT* style planner with adaptive rewiring and informed sampling after the initial solution is found. It incrementally grows a tree towards sampled points inside the map, improving path cost by rewiring nearby nodes within an adaptive radius. Post-processing shortcut smoothing enhances final path smoothness and quality while maintaining collision-free constraints.",
          "planning_mechanism": "The planner samples points with a bias toward the goal before an initial solution and restricts sampling to an ellipsoidal informed subset afterward. Each iteration extends the tree toward the sample within a fixed step size, rewires nodes in a dynamically adjusted neighborhood to lower path costs, and checks for collision-free nodes and edges. Upon success, the path is extracted and smoothed via randomized shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_radius: float=5.0, max_radius: float=30.0, shortcut_trials: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def sample_free():\n            if best_goal_node:\n                c_best = best_cost\n                c_min = math.dist(start_position, goal_position)\n                if c_best <= c_min:\n                    return uniform_sample()\n                else:\n                    return informed_sample(c_best)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def informed_sample(c_max):\n            c_min = math.dist(start_position, goal_position)\n            if c_max < c_min:\n                return uniform_sample()\n\n            center = tuple( (start_position[d] + goal_position[d]) / 2.0 for d in range(dimension) )\n            def unit_vector(a, b):\n                dist = math.dist(a,b)\n                return tuple( (b[d] - a[d]) / dist for d in range(dimension) )\n            e1 = unit_vector(start_position, goal_position)\n\n            import numpy as np\n            if dimension == 2:\n                angle = math.atan2(e1[1], e1[0])\n                U = np.array([[math.cos(angle), -math.sin(angle)],\n                              [math.sin(angle),  math.cos(angle)]])\n            else:\n                e1_v = np.array(e1)\n                arbitrary = np.array([1,0,0]) if abs(e1_v[0]) < 0.9 else np.array([0,1,0])\n                e2_v = arbitrary - np.dot(arbitrary, e1_v)*e1_v\n                e2_v /= np.linalg.norm(e2_v)\n                e3_v = np.cross(e1_v, e2_v)\n                U = np.column_stack((e1_v, e2_v, e3_v))\n\n            r1 = c_max / 2.0\n            r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n            radii = [r1] + [r2]*(dimension -1)\n\n            while True:\n                if dimension == 2:\n                    sample = self._sample_unit_circle()\n                else:\n                    sample = self._sample_unit_ball(dimension)\n                sample_np = np.array(sample) * radii\n                rotated = U @ sample_np\n                point = tuple(rotated[d] + center[d] for d in range(dimension))\n                if self._within_bounds(point, bounds) and not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(p):\n            return min(nodes, key=lambda n: math.dist(n.position, p))\n\n        def near(p, radius):\n            return [n for n in nodes if math.dist(n.position, p) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(dimension))\n\n        def dynamic_radius():\n            gamma = 2 * (1 + 1/dimension)**(1/dimension)\n            volume = 1.0\n            for b in bounds:\n                volume *= b\n            radius = gamma * ( (math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1/dimension) )\n            radius = min(self.max_radius, max(self.min_radius, radius))\n            return radius\n\n        for _ in range(self.max_iter):\n            rnd = sample_free()\n            nearest_node = nearest(rnd)\n            new_pos = steer(nearest_node.position, rnd)\n            if not self._within_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = dynamic_radius()\n            near_nodes = near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                c = candidate.cost + math.dist(candidate.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(candidate.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = candidate\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    new_node.add_child(goal_node)\n                    goal_node.cost = new_node.cost + math.dist(new_node.position, goal_position)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n        if best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, self.shortcut_trials)\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_unit_circle(self):\n        while True:\n            x, y = random.uniform(-1,1), random.uniform(-1,1)\n            if x*x + y*y <= 1:\n                return (x,y)\n\n    def _sample_unit_ball(self, d):\n        import numpy as np\n        while True:\n            v = np.random.normal(0,1,d)\n            norm = np.linalg.norm(v)\n            if norm > 0:\n                unit_v = v / norm\n                r = random.uniform(0,1) ** (1/d)\n                sample = unit_v * r\n                return tuple(sample)\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, trials):\n        if len(path) < 3:\n            return path\n        for _ in range(trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1769.45179,
          "time_improvement": -5923.0,
          "length_improvement": 24.0,
          "smoothness_improvement": 539.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.9126778841018677,
                    "num_nodes_avg": 4758.6,
                    "path_length_avg": 145.54691866642756,
                    "smoothness_avg": 0.019381663322953192,
                    "success_improvement": 0.0,
                    "time_improvement": -11630.081009639158,
                    "length_improvement": 20.223427540415408,
                    "smoothness_improvement": 203.36511895976432,
                    "objective_score": -3483.962791788865
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.948158049583435,
                    "num_nodes_avg": 4138.6,
                    "path_length_avg": 221.09363402459257,
                    "smoothness_avg": 0.03586661985038685,
                    "success_improvement": 0.0,
                    "time_improvement": -1101.7281088030702,
                    "length_improvement": 26.19258113518759,
                    "smoothness_improvement": 822.8739624325266,
                    "objective_score": -321.1655466017209
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.466959500312805,
                    "num_nodes_avg": 4704.1,
                    "path_length_avg": 111.09161853170414,
                    "smoothness_avg": 0.05432062492827898,
                    "success_improvement": 0.0,
                    "time_improvement": -5038.0848834553235,
                    "length_improvement": 26.218236585650363,
                    "smoothness_improvement": 590.9543395562524,
                    "objective_score": -1503.2270460216855
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm combines the strengths of RRT* with informed sampling and path smoothing techniques to improve planning efficiency, path quality, and success rates. Initially, it explores uniformly like RRT*, and once a path is found, it focuses exploration within an informed elliptical subset defined by the current best path cost to accelerate convergence. After planning, a shortcut smoothing step refines the path by attempting to replace path segments with direct collision-free edges for improved smoothness and shorter path length. This approach enhances robustness and reduces search time while ensuring valid, high-quality paths.",
          "planning_mechanism": "The planner incrementally builds a cost-optimized tree using RRT* logic with rewiring and informed sampling within a prolate hyperspheroid after the first solution. It maintains valid nodes and edges, checks collision rigorously, and employs post-processing shortcut smoothing on the extracted path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child Nodes\n        self.valid = True               # Validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\") \n        c_min = math.dist(start, goal)\n        goal_nodes = []\n\n        def sample_informed():\n            if best_cost == float(\"inf\"):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            dim = len(start)\n            c_best = best_cost\n            L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n            L = np.diag(L_diag)\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm < 1e-10:\n                a1_norm = 1e-10\n            a1 = a1 / a1_norm\n            I = np.eye(dim)\n            M = np.outer(a1, I[:,0])\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, np.dot(np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]), Vt))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(x_ball)\n                if norm > 1e-10:\n                    x_ball = x_ball / norm * (random.random() ** (1.0/dim))\n                x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            x_rand = sample_informed()\n            # Find nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            # Collision check node\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            # Collision check edge\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            # Find near nodes for rewiring\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= self.rewire_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    min_cost = new_cost\n                    best_parent = n\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire neighbors if beneficial\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    # Rewire n to x_new\n                    old_parent = n.parent\n                    if old_parent:\n                        edges.remove((old_parent, n))\n                        old_parent.remove_child(n)\n\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            # Check goal connection\n            if math.dist(x_new.position, goal) <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=x_new, cost=x_new.cost + math.dist(x_new.position, goal))\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n                        goal_nodes.append(goal_node)\n\n        # Path smoothing by shortcutting\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) -1\n                while j > i+1:\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d)):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        if success_state and extracted_path:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2052.57994,
          "time_improvement": -6875.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 956.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.825208330154419,
                    "num_nodes_avg": 3037.7,
                    "path_length_avg": 143.90677504304108,
                    "smoothness_avg": 0.03603218743416349,
                    "success_improvement": 0.0,
                    "time_improvement": -11277.819278508201,
                    "length_improvement": 21.12241625013241,
                    "smoothness_improvement": 463.9819784920289,
                    "objective_score": -3376.8013904099735
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.117717814445496,
                    "num_nodes_avg": 4230.2,
                    "path_length_avg": 216.20452617096262,
                    "smoothness_avg": 0.06356681371439944,
                    "success_improvement": 0.0,
                    "time_improvement": -1823.1751416351226,
                    "length_improvement": 27.824706061896116,
                    "smoothness_improvement": 1535.6199021967593,
                    "objective_score": -533.7095017671737
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.6601815223693848,
                    "num_nodes_avg": 4619.7,
                    "path_length_avg": 109.76634119188836,
                    "smoothness_avg": 0.07602926280655545,
                    "success_improvement": 0.0,
                    "time_improvement": -7523.280134272179,
                    "length_improvement": 27.098422691830653,
                    "smoothness_improvement": 867.0866110029609,
                    "objective_score": -2247.2289226882726
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced unidirectional RRT* planner with informed ellipsoidal sampling after an initial feasible path is found, adaptive neighbor radius based on the current search space and iterations, rigorous collision checking, and post-processing shortcut smoothing to improve path smoothness and reduce length. The planner incrementally grows a tree, rewires local neighborhoods for path cost optimization, and efficiently guides exploration towards promising regions defined by start and goal locations, supporting both 2D and 3D planning.",
          "planning_mechanism": "The planner begins sampling uniformly in the free space with goal biasing. After finding an initial feasible path, it restricts sampling to an ellipsoidal informed subset that focuses search near the current best solution to accelerate convergence. It extends the tree toward samples with fixed step size, rejecting nodes and edges that collide with obstacles or violate bounds. Nearby nodes within an adaptively shrinking radius are rewired to optimize path cost. Upon completion, shortcut smoothing is applied to the extracted path to remove unnecessary waypoints and improve smoothness, yielding high-quality, collision-free trajectories.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1,\n                 c_best_inflation: float = 1.2, neighbor_radius_factor: float = 50.0,\n                 path_smooth_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability of sampling goal directly\n        self.c_best_inflation = c_best_inflation    # Multiplier of cost for ellipsoid inflation\n        self.neighbor_radius_factor = neighbor_radius_factor  # Factor to compute neighbor radius\n        self.path_smooth_trials = path_smooth_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        success = False\n        best_goal_node = None\n        c_best = float('inf')  # Current best path cost\n\n        def dist(p1, p2) -> float:\n            return math.dist(p1, p2)\n\n        def sample_uniform() -> Tuple[float, ...]:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Informed sampling ellipse parameters\n        def sample_informed(c_best, c_min, start, goal) -> Tuple[float, ...]:\n            if c_best == float('inf'):\n                return sample_uniform()\n            # 1. Sample from unit ball in dimension dim:\n            while True:\n                if dim == 2:\n                    # sample uniformly in unit circle\n                    a = random.uniform(0, 2 * math.pi)\n                    r = random.uniform(0, 1) ** 0.5\n                    x_ball = [r * math.cos(a), r * math.sin(a)]\n                else:\n                    # sample uniformly in unit sphere with rejection sampling\n                    while True:\n                        point = [random.uniform(-1, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in point))\n                        if 0 < norm <= 1:\n                            x_ball = [x / norm for x in point]\n                            break\n\n                # 2. Define scaling matrix L\n                a1 = (c_best / 2.0)\n                if c_best == float('inf'):\n                    L_diag = [bounds[d] for d in range(dim)]\n                else:\n                    L_diag = [a1] + [math.sqrt(c_best*c_best - c_min*c_min) / 2.0] * (dim - 1)\n\n                # 3. Rotation matrix C from start-goal\n                start_goal_vec = [goal[d] - start[d] for d in range(dim)]\n                norm_sg = math.sqrt(sum([x*x for x in start_goal_vec]))\n                if norm_sg == 0:\n                    # Start==Goal\n                    return start\n                e1 = [x / norm_sg for x in start_goal_vec]\n\n                # Construct orthonormal basis with e1\n                # Use Gram-Schmidt or Householder reflection (simple in 2D, more complex in 3D)\n                # For simplicity: only 2D and 3D support\n                if dim == 2:\n                    # rotation matrix that aligns x-axis with e1\n                    cos_theta = e1[0]\n                    sin_theta = e1[1]\n                    C = [[cos_theta, -sin_theta],\n                         [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    # Find rotation matrix aligning x-axis to e1\n                    # Using Rodrigues' rotation formula\n                    x_axis = [1,0,0]\n                    v = [x_axis[i] - e1[i] for i in range(3)]\n                    s = math.sqrt(sum([v[i]*v[i] for i in range(3)]))\n                    c = sum([x_axis[i]*e1[i] for i in range(3)])\n                    if s == 0:\n                        # vectors are aligned\n                        C = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1,0,0],[0,1,0],[0,0,1]]\n                        def mat_add(A,B):\n                            return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                        def mat_sub(A,B):\n                            return [[A[i][j]-B[i][j] for j in range(3)] for i in range(3)]\n                        def mat_mult_scalar(A,s):\n                            return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                        def mat_mult(A,B):\n                            return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        vx2 = mat_mult(vx,vx)\n                        C = mat_add(mat_add(I, mat_mult_scalar(vx, 1)), mat_mult_scalar(vx2, (1 - c)/(s*s)))\n                else:\n                    # For dim>3 default to uniform sampling (fallback)\n                    return sample_uniform()\n\n                # Scale x_ball by L\n                x_scaled = [L_diag[i]*x_ball[i] for i in range(dim)]\n\n                # Rotate by C\n                if dim == 2:\n                    x_rot = (C[0][0]*x_scaled[0] + C[0][1]*x_scaled[1],\n                             C[1][0]*x_scaled[0] + C[1][1]*x_scaled[1])\n                elif dim == 3:\n                    x_rot = tuple(sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                else:\n                    x_rot = tuple(x_scaled)\n\n                # Translate by midpoint between start and goal\n                x_final = tuple(x_rot[d] + (start[d] + goal[d])/2.0 for d in range(dim))\n\n                # Check bounds:\n                if all(0 <= x_final[d] <= bounds[d] for d in range(dim)):\n                    return x_final\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            factor = self.step_size / distance\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def get_nearby_nodes(nodes_list: List[Node], node: Node, radius: float) -> List[Node]:\n            return [n for n in nodes_list if n != node and dist(n.position, node.position) <= radius]\n\n        def calc_neighbor_radius(iteration: int) -> float:\n            # Adaptive radius shrinking with iterations; ensures asymptotic optimality\n            gamma = self.neighbor_radius_factor\n            unit_ball_volume = math.pi if dim == 2 else 4.0*math.pi/3.0\n            eta = self.step_size\n            return min(gamma * (math.log(iteration + 1) / (iteration + 1))**(1/dim), eta)\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.path_smooth_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible: remove intermediate points\n                    new_path = path[:i+1] + path[j:]\n                    path = new_path\n            return path\n\n        c_min = dist(start_position, goal_position)\n\n        for i in range(self.max_iter):\n            # Sampling\n            if success:\n                c_sample = c_best * self.c_best_inflation\n                sample = sample_informed(c_sample, c_min, start_position, goal_position)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_uniform()\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n\n            # Steer towards sample\n            new_pos = steer(nearest_node.position, sample)\n\n            # Check bounds:\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check - node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Collision check - edge\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive neighbor radius\n            radius = calc_neighbor_radius(i+1)\n            if radius < self.step_size:\n                radius = self.step_size * 1.5  # ensure minimum neighborhood\n\n            neighbors = get_nearby_nodes(nodes, new_node, radius)\n\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_len = dist(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_len\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges = [(p,c) for (p,c) in edges if c != neighbor]\n                        edges.append((new_node, neighbor))\n\n            # Check goal reached and connect directly if possible\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, new_node, new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node = goal_node\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            path = best_goal_node.path_from_root()\n            smoothed_path = shortcut_smoothing(path)\n            extracted_path = smoothed_path\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2251.53934,
          "time_improvement": -7529.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 729.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.389901638031006,
                    "num_nodes_avg": 3051.6,
                    "path_length_avg": 167.7891270248612,
                    "smoothness_avg": 0.01914402832031501,
                    "success_improvement": 0.0,
                    "time_improvement": -9524.730551973584,
                    "length_improvement": 8.032120688812162,
                    "smoothness_improvement": 199.64561513580918,
                    "objective_score": -2854.8145133786334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.2853837490081785,
                    "num_nodes_avg": 3658.6,
                    "path_length_avg": 230.1078899609824,
                    "smoothness_avg": 0.03779068322896369,
                    "success_improvement": 0.0,
                    "time_improvement": -1926.6004599740509,
                    "length_improvement": 23.183363042649745,
                    "smoothness_improvement": 872.381499010144,
                    "objective_score": -568.9815578886346
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 5.395042490959168,
                    "num_nodes_avg": 4425.2,
                    "path_length_avg": 116.12327584728857,
                    "smoothness_avg": 0.09554433738470118,
                    "success_improvement": 0.0,
                    "time_improvement": -11136.579386439702,
                    "length_improvement": 22.876449378413092,
                    "smoothness_improvement": 1115.3169191840066,
                    "objective_score": -3330.8219414603077
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the strengths of RRT*: optimal rewiring and incremental improvement with the bidirectional tree growth of BI-RRT to enhance planning efficiency, robustness, and path quality. It grows two trees simultaneously from start and goal, performs rewiring to optimize paths dynamically, employs goal biasing and informed sampling to guide exploration, and tries to connect the trees at each iteration to quickly find high-quality paths. Additional smoothing steps are applied post path extraction to improve path smoothness and reduce length.",
          "planning_mechanism": "The planner alternates extending two trees from start and goal towards randomly sampled points (with goal biasing and heuristic sampling near the current best path). Each extension rewires neighbors within a radius to minimize path cost while strictly validating node and edge collision. Whenever the two trees can be connected, the combined path is extracted and progressively smoothed using shortcutting to produce an optimal, collision-free, and smooth trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0, smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        success_state = False\n        best_connect_nodes = None  # (node_from_start, node_from_goal)\n        best_path_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def sample():\n            # Goal biasing with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def valid_node_and_edge(parent_pos, child_pos):\n            if self._is_in_obstacle(child_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(parent_pos, child_pos, obstacles, is_3d):\n                return False\n            # Check bounds:\n            for dim in range(len(bounds)):\n                if not (0 <= child_pos[dim] <= bounds[dim]):\n                    return False\n            return True\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Update edges\n                    if neighbor.parent:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_node_and_edge(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            # find best parent in neighbors\n            neighbors = near_nodes(tree, new_pos, self.neighbor_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor_node in neighbors:\n                cost_through_neighbor = neighbor_node.cost + dist(neighbor_node.position, new_pos)\n                if cost_through_neighbor < min_cost and \\\n                   not self._is_edge_in_obstacle(neighbor_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor_node\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            dist_to_nearest = dist(nearest_node.position, new_node.position)\n            # Iterate small steps to try connect quicker and collision free\n            cur_pos = nearest_node.position\n            while dist_to_nearest > self.step_size:\n                new_pos = steer(cur_pos, new_node.position)\n                if not valid_node_and_edge(cur_pos, new_pos):\n                    return None\n                connect_node = Node(new_pos)\n                neighbors = near_nodes(other_tree, new_pos, self.neighbor_radius)\n                min_cost = dist(cur_pos, nearest_node.position) + nearest_node.cost\n                best_parent = nearest_node\n                # find best parent among neighbors\n                for neighbor_node in neighbors:\n                    ccost = neighbor_node.cost + dist(neighbor_node.position, new_pos)\n                    if ccost < min_cost and not self._is_edge_in_obstacle(neighbor_node.position, new_pos, obstacles, is_3d):\n                        min_cost = ccost\n                        best_parent = neighbor_node\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n                rewire(other_tree, connect_node)\n                cur_pos = new_pos\n                nearest_node = connect_node\n                dist_to_nearest = dist(nearest_node.position, new_node.position)\n\n            # Finally try direct connection (if close enough)\n            if dist_to_nearest <= self.step_size \\\n               and valid_node_and_edge(nearest_node.position, new_node.position):\n                return nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def path_smoothing(path):\n            # Shortcut smoothing by attempting to replace sections with direct edges if collision free\n            if len(path) <= 2:\n                return path\n            import random\n            smoothed_path = path[:]\n            for _ in range(self.smoothing_iter):\n                if len(smoothed_path) <= 2:\n                    break\n                i = random.randint(0, len(smoothed_path) - 2)\n                j = random.randint(i + 1, len(smoothed_path) -1)\n                if j == i +1:\n                    continue\n                p_i = smoothed_path[i]\n                p_j = smoothed_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Remove intermediate nodes between i and j\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        # Bidirectional RRT* style with goal biasing and rewiring\n        for iter_num in range(self.max_iter):\n            sampled_point = sample()\n            new_node_start = extend(tree_start, sampled_point)\n            if not new_node_start:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(new_node_start, tree_goal)\n            if connect_node_goal:\n                current_cost = new_node_start.cost + connect_node_goal.cost + dist(new_node_start.position, connect_node_goal.position)\n                if current_cost < best_path_cost:\n                    best_path_cost = current_cost\n                    success_state = True\n                    best_connect_nodes = (new_node_start, connect_node_goal)\n\n            # Swap trees to alternate expansions\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state and best_connect_nodes:\n            path = extract_path(best_connect_nodes[0], best_connect_nodes[1])\n            smoothed = path_smoothing(path)\n            extracted_path = smoothed\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2346.20315,
          "time_improvement": -7846.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1070.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 3.892947244644165,
                    "num_nodes_avg": 3488.4,
                    "path_length_avg": 157.45522941728063,
                    "smoothness_avg": 0.028109037769574678,
                    "success_improvement": 0.0,
                    "time_improvement": -15577.87045563001,
                    "length_improvement": 13.69629371861357,
                    "smoothness_improvement": 339.96748084633543,
                    "objective_score": -4668.922040541049
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.712377643585205,
                    "num_nodes_avg": 4219.1,
                    "path_length_avg": 245.92652940096878,
                    "smoothness_avg": 0.07099732081539191,
                    "success_improvement": 0.0,
                    "time_improvement": -1573.1396390977354,
                    "length_improvement": 17.902645883291594,
                    "smoothness_improvement": 1726.8122018832319,
                    "objective_score": -459.72730154324614
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.1152947425842283,
                    "num_nodes_avg": 4555.0,
                    "path_length_avg": 144.18015647823285,
                    "smoothness_avg": 0.09771935026383205,
                    "success_improvement": 0.0,
                    "time_improvement": -6388.411675323514,
                    "length_improvement": 4.24240518842586,
                    "smoothness_improvement": 1142.9829224638006,
                    "objective_score": -1909.96010694705
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a single-tree, goal-biased, k-nearest informed RRT* planner with adaptive radius rewiring and path smoothing via shortcutting. It combines dynamic sampling within an informed ellipsoidal subset after an initial solution is found to focus exploration towards lower-cost paths, improving planning efficiency, path quality, and success rate. Local rewiring optimizes cost incrementally, while post-processing shortcuts smooth the final path.",
          "planning_mechanism": "The planner grows a tree from the start node by sampling points within the environment with bias towards the goal and, after finding a solution, restricts sampling to an ellipsoidal informed subset to accelerate convergence to an optimal path. Each iteration extends toward sampled points within step size, rewires near nodes within an adaptive radius, and considers collision constraints strictly. Upon success, the path is extracted and locally smoothed by shortcutting edges to ensure faster traversal and improved smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_radius: float=5.0, max_radius: float=30.0, shortcut_trials: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius          # Min neighborhood radius for rewiring\n        self.max_radius = max_radius          # Max neighborhood radius for rewiring\n        self.shortcut_trials = shortcut_trials # Number of shortcut smoothing trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def sample_free():\n            # If solution found, sample from informed ellipsoid around start-goal path (informed sampling)\n            if best_goal_node:\n                c_best = best_cost\n                c_min = math.dist(start_position, goal_position)\n                if c_best <= c_min:\n                    # Path is already optimal or near optimal, uniform sampling\n                    return self._uniform_sample(bounds, obstacles, is_3d) \n                else:\n                    return self._informed_sample(start_position, goal_position, c_best, bounds, obstacles, is_3d)\n            else:\n                # Before any solution: goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return self._uniform_sample(bounds, obstacles, is_3d)\n\n        def nearest(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def near(point, radius):\n            return [node for node in nodes if math.dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def dynamic_radius():\n            # Adaptive radius based on number of vertices (RRT* origin)\n            gamma_rrt_star = 2 * (1 + 1/dimension) ** (1/dimension) * ( (map.size[0]*map.size[1]) if dimension==2 else (map.size[0]*map.size[1]*map.size[2]) )**(1/dimension)\n            radius = min(self.max_radius, max(self.min_radius, gamma_rrt_star * (math.log(len(nodes) + 1)/ (len(nodes) + 1))**(1/dimension)))\n            return radius\n\n        for _ in range(self.max_iter):\n            rnd = sample_free()\n            nearest_node = nearest(rnd)\n            new_pos = steer(nearest_node.position, rnd)\n\n            if not self._within_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = dynamic_radius()\n            near_nodes = near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring nearby nodes if new node offers better cost path\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Check if new node is close enough to goal for connection\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.parent = new_node\n                    goal_node.cost = new_node.cost + math.dist(new_node.position, goal_position)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n        if best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, self.shortcut_trials)\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _uniform_sample(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _informed_sample(self, start, goal, c_max, bounds, obstacles, is_3d):\n        \"\"\"\n        Samples uniformly inside an ellipsoid defined by start, goal, and best cost c_max.\n        \"\"\"\n        c_min = math.dist(start, goal)\n        if c_max < c_min:\n            # Degenerate case fallback\n            return self._uniform_sample(bounds, obstacles, is_3d)\n\n        # Center of the ellipsoid\n        center = tuple( (start[i] + goal[i])/2 for i in range(len(start)) )\n\n        # Rotation matrix aligning x-axis with start->goal\n        def unit_vector(a, b):\n            dist = math.dist(a,b)\n            return tuple( (b[i]-a[i])/dist for i in range(len(a)) )\n        e1 = unit_vector(start, goal)\n\n        # Construct rotation matrix U for dimension d\n        d = len(start)\n        if d == 2:\n            import numpy as np\n            # Build 2x2 rotation matrix to align x-axis with e1\n            angle = math.atan2(e1[1], e1[0])\n            U = np.array([[math.cos(angle), -math.sin(angle)],\n                          [math.sin(angle),  math.cos(angle)]])\n        else:\n            # Use Gram-Schmidt for 3D\n            import numpy as np\n            e1_v = np.array(e1)\n            # Pick arbitrary vector not parallel to e1\n            arbitrary = np.array([1,0,0]) if abs(e1_v[0]) < 0.9 else np.array([0,1,0])\n            e2_v = arbitrary - np.dot(arbitrary, e1_v)*e1_v\n            e2_v /= np.linalg.norm(e2_v)\n            e3_v = np.cross(e1_v, e2_v)\n            U = np.column_stack((e1_v, e2_v, e3_v))\n\n        # Radii of the ellipsoid\n        r1 = c_max / 2.0\n        r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n        radii = [r1] + [r2]*(d-1)\n\n        # Sample in unit ball\n        while True:\n            # Sample from unit ball in d dimensions\n            if d == 2:\n                sample = self._sample_unit_circle()\n            else:\n                sample = self._sample_unit_ball(d)\n            # Scale sample by radii\n            import numpy as np\n            sample_np = np.array(sample) * radii\n            # Rotate and translate by center\n            if d == 2:\n                rotated = U @ sample_np\n            else:\n                rotated = U @ sample_np\n            point = tuple(rotated[i] + center[i] for i in range(d))\n            if self._within_bounds(point, bounds) and not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _sample_unit_circle(self):\n        # Uniform sampling inside unit circle (2D)\n        while True:\n            x,y = random.uniform(-1,1), random.uniform(-1,1)\n            if x*x + y*y <= 1:\n                return (x,y)\n\n    def _sample_unit_ball(self, d):\n        import numpy as np\n        while True:\n            v = np.random.normal(0,1,d)\n            norm = np.linalg.norm(v)\n            if norm > 0:\n                unit_v = v / norm\n                r = random.uniform(0,1) ** (1/d)\n                sample = unit_v * r\n                return tuple(sample)\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, trials: int) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        for _ in range(trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2671.97699,
          "time_improvement": -8935.0,
          "length_improvement": 26.0,
          "smoothness_improvement": 709.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.708799242973328,
                    "num_nodes_avg": 4699.9,
                    "path_length_avg": 143.16085264317343,
                    "smoothness_avg": 0.020776316862010254,
                    "success_improvement": 0.0,
                    "time_improvement": -18863.510136046647,
                    "length_improvement": 21.531268137396683,
                    "smoothness_improvement": 225.19447538464087,
                    "objective_score": -5653.620814809591
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.4690370321273805,
                    "num_nodes_avg": 4153.2,
                    "path_length_avg": 215.66583279955063,
                    "smoothness_avg": 0.048078286875905665,
                    "success_improvement": 0.0,
                    "time_improvement": -1423.0341315570495,
                    "length_improvement": 28.004537414702412,
                    "smoothness_improvement": 1137.0889507073591,
                    "objective_score": -415.62388723063754
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.1784035205841064,
                    "num_nodes_avg": 4751.1,
                    "path_length_avg": 109.58456537086072,
                    "smoothness_avg": 0.06801202916026226,
                    "success_improvement": 0.0,
                    "time_improvement": -6519.852121838099,
                    "length_improvement": 27.219149536922778,
                    "smoothness_improvement": 765.1079907927426,
                    "objective_score": -1946.6862666900815
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm integrates a unidirectional informed RRT* planner with adaptive goal-biased and ellipsoidal informed sampling to improve planning efficiency, path quality, and success rate. It features a dynamic rewiring strategy with an adaptive neighborhood radius, precise collision and edge checking, and post-processing shortcut smoothing to yield smooth, feasible, and near-optimal paths in 2D/3D environments.",
          "planning_mechanism": "The planner grows a single tree from the start towards the goal. It samples points biased towards the goal and restricts later sampling within an informed ellipsoid once a solution is found, reducing unnecessary exploration. Each extension step considers adaptive rewiring of nearby nodes to improve path cost incrementally. Collision constraints are strictly checked for nodes and edges. Upon finding a feasible path to the goal, the path is extracted and smoothed by repeated shortcutting to reduce length and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, min_radius: float = 5.0,\n                 max_radius: float = 30.0, shortcut_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def unit_vector(a, b):\n            dist = math.dist(a, b)\n            if dist < 1e-9:\n                return tuple(0.0 for _ in range(len(a)))\n            return tuple((b[i] - a[i]) / dist for i in range(len(a)))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def informed_sample(c_best):\n            c_min = math.dist(start_position, goal_position)\n            if c_best < c_min:\n                return uniform_sample()\n\n            center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dimension))\n            e1 = unit_vector(start_position, goal_position)\n\n            import numpy as np\n            if dimension == 2:\n                angle = math.atan2(e1[1], e1[0])\n                U = np.array([[math.cos(angle), -math.sin(angle)],\n                              [math.sin(angle),  math.cos(angle)]])\n            else:\n                e1_v = np.array(e1)\n                arbitrary = np.array([1,0,0]) if abs(e1_v[0]) < 0.9 else np.array([0,1,0])\n                e2_v = arbitrary - np.dot(arbitrary, e1_v)*e1_v\n                e2_v /= np.linalg.norm(e2_v)\n                e3_v = np.cross(e1_v, e2_v)\n                U = np.column_stack((e1_v, e2_v, e3_v))\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            radii = np.array([r1] + [r2]*(dimension-1))\n\n            while True:\n                if dimension == 2:\n                    sample = self._sample_unit_circle()\n                else:\n                    sample = self._sample_unit_ball(dimension)\n                sample_scaled = np.array(sample) * radii\n                rotated = U @ sample_scaled\n                point = tuple(rotated[i] + center[i] for i in range(dimension))\n                if within_bounds(point) and not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def near(point, radius):\n            return [node for node in nodes if math.dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def dynamic_radius():\n            volume = 1.0\n            for b in bounds:\n                volume *= b\n            gamma_rrt_star = 2 * (1 + 1/dimension)**(1/dimension) * (volume)**(1/dimension)\n            n = max(len(nodes), 1)\n            radius = gamma_rrt_star * (math.log(n) / n)**(1/dimension)\n            radius = max(self.min_radius, min(self.max_radius, radius))\n            return radius\n\n        for _ in range(self.max_iter):\n            if best_goal_node:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = dynamic_radius()\n            near_nodes = near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.parent = new_node\n                    goal_node.cost = new_node.cost + dist_to_goal\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n        if best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, self.shortcut_trials)\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_unit_circle(self):\n        while True:\n            x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n            if x*x + y*y <= 1:\n                return (x, y)\n\n    def _sample_unit_ball(self, d):\n        import numpy as np\n        while True:\n            v = np.random.normal(0, 1, d)\n            norm = np.linalg.norm(v)\n            if norm > 0:\n                unit_v = v / norm\n                r = random.uniform(0, 1) ** (1/d)\n                sample = unit_v * r\n                return tuple(sample)\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, trials):\n        if len(path) < 3:\n            return path\n        for _ in range(trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2685.56806,
          "time_improvement": -8980.0,
          "length_improvement": 26.0,
          "smoothness_improvement": 691.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.701184463500977,
                    "num_nodes_avg": 4664.0,
                    "path_length_avg": 143.2192897676209,
                    "smoothness_avg": 0.019251861319443758,
                    "success_improvement": 0.0,
                    "time_improvement": -18832.84351802865,
                    "length_improvement": 21.499237823491534,
                    "smoothness_improvement": 201.3334357352796,
                    "objective_score": -5644.54654066522
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.548213529586792,
                    "num_nodes_avg": 4256.0,
                    "path_length_avg": 215.7075396701071,
                    "smoothness_avg": 0.04267233179262632,
                    "success_improvement": 0.0,
                    "time_improvement": -1471.8744310255113,
                    "length_improvement": 27.990614460844952,
                    "smoothness_improvement": 997.9898326625216,
                    "objective_score": -430.9742572521718
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.234540581703186,
                    "num_nodes_avg": 4799.8,
                    "path_length_avg": 109.27439057611325,
                    "smoothness_avg": 0.07646622396919862,
                    "success_improvement": 0.0,
                    "time_improvement": -6636.772154413006,
                    "length_improvement": 27.425152866657516,
                    "smoothness_improvement": 872.644724738664,
                    "objective_score": -1981.1833921268772
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal path planning algorithm that enhances RRT* by focusing exploration within an ellipsoidal subset of the search space after finding an initial solution. This ellipsoid is defined by the start and goal states as focal points and the current best path cost as its transverse diameter, significantly improving convergence speed and path quality.",
          "planning_mechanism": "The planner starts like RRT*, building a tree through uniform sampling. After discovering a valid path, it switches to informed sampling within a prolate hyperspheroid defined by the current best cost. Samples are drawn by transforming points from the unit n-ball to the ellipsoid, ensuring all new samples can potentially improve the path. Tree rewiring is done locally to maintain asymptotic optimality.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        solution_nodes = []\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        edges.remove((n.parent, n))\n                        n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                solution_nodes.append(goal_node)\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 2877.784611149885,
          "time_improvement": -9615.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 350.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.149529600143433,
                    "num_nodes_avg": 3092.9,
                    "path_length_avg": 144.17782833834022,
                    "smoothness_avg": 0.025832904194730322,
                    "success_improvement": 0.0,
                    "time_improvement": -16611.191658801265,
                    "length_improvement": 20.97384764386463,
                    "smoothness_improvement": 304.3410476968528,
                    "objective_score": -4977.641022873122
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.9636428117752076,
                    "num_nodes_avg": 4230.3,
                    "path_length_avg": 216.04260686110948,
                    "smoothness_avg": 0.019191384723471337,
                    "success_improvement": 0.0,
                    "time_improvement": -2344.986935831002,
                    "length_improvement": 27.878759388114016,
                    "smoothness_improvement": 393.80815193060414,
                    "objective_score": -695.9512881120248
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 4.796421384811401,
                    "num_nodes_avg": 4590.3,
                    "path_length_avg": 109.81726433629747,
                    "smoothness_avg": 0.03559960377842232,
                    "success_improvement": 0.0,
                    "time_improvement": -9889.795215063907,
                    "length_improvement": 27.06460196401368,
                    "smoothness_improvement": 352.82433237211626,
                    "objective_score": -2959.7615224645087
               }
          ],
          "success_rate": 1.0
     }
]