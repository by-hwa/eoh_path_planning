[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.232877539025313,
          "time_improvement": 73.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011802577972412109,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 52.468071909137095,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 17.335726835993384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019640421867370604,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 87.88473705620726,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 30.003711846582945
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010181522369384766,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 78.79433117160421,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.35919393449961
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional search with adaptive rewiring and goal biasing to improve path planning efficiency and path quality. It incrementally grows two trees from start and goal, extends toward random samples with a bias toward the goal, and rewires locally to minimize path costs while ensuring collision-free nodes and edges. Upon connection of the two trees, it extracts a smooth and optimized path.",
          "planning_mechanism": "The planner samples points within bounds (with goal bias), extends each tree toward samples within a step size, performs local rewiring to reduce costs, and attempts to connect the two trees on each iteration. It strictly checks for collisions for both nodes and edges, ensuring valid paths. The bidirectional approach accelerates convergence, and rewiring optimizes path costs and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -20.70232,
          "time_improvement": 53.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 310.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016640830039978027,
                    "num_nodes_avg": 160.6,
                    "path_length_avg": 167.68313601037386,
                    "smoothness_avg": 0.023542751007624492,
                    "success_improvement": 0.0,
                    "time_improvement": 32.983222929654985,
                    "length_improvement": 8.090216043387771,
                    "smoothness_improvement": 268.49517717140276,
                    "objective_score": 12.855485973431062
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03169040679931641,
                    "num_nodes_avg": 374.2,
                    "path_length_avg": 235.3172522277793,
                    "smoothness_avg": 0.017255337523919966,
                    "success_improvement": 0.0,
                    "time_improvement": 80.45166169229154,
                    "length_improvement": 21.44432797481391,
                    "smoothness_improvement": 343.99226300771477,
                    "objective_score": 30.14432541768882
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025929951667785646,
                    "num_nodes_avg": 309.0,
                    "path_length_avg": 122.50151738270351,
                    "smoothness_avg": 0.032717793611091894,
                    "success_improvement": 0.0,
                    "time_improvement": 45.99413055784529,
                    "length_improvement": 18.640325049814344,
                    "smoothness_improvement": 316.1679197567731,
                    "objective_score": 19.10714377610032
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.346034584031703,
          "time_improvement": 65.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00933377742767334,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 62.410548056085524,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 18.46480044190237
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017646241188049316,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.11485438518106,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.115524236223337
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02707960605621338,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 43.59967623720094,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 12.457779073969402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the goal-biased, single-tree asymptotically optimal RRT* approach with adaptive step sizing and local rewiring, further enhanced by selective bidirectional expansions to speed convergence and improve path quality. It dynamically toggles growth direction between start and goal trees, incorporates rigorous node and edge collision checks, maintains a fixed neighbor radius for rewiring, and employs clean parent updates for cost optimization and path smoothing. The planner balances exploration and exploitation to achieve fast, robust, and smooth path solutions with reduced search time.",
          "planning_mechanism": "The planner grows two trees (from start and goal) alternately with goal bias sampling and adaptive step size. Each extension performs local rewiring within a fixed neighbor radius to optimize path cost. Upon feasible connection of the two trees, it reconstructs and returns an optimized and smooth path from start to goal. Collision checking prevents invalid nodes or edges, and the controlled expansion strategy improves efficiency and success rates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two trees: start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if math.dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges accordingly\n                    # Remove old edges pointing to neighbor\n                    for idx, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(idx)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent among neighbors to minimize cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby neighbors if better path found\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tgt_tree, from_node):\n            nearest_node = nearest(tgt_tree, from_node.position)\n            dist = math.dist(nearest_node.position, from_node.position)\n\n            if dist <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Alternate tree growth\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    # Connect goal tree with new_node\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    # Rewire around connecting_node in goal tree\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    # Extract path from start root to new_node\n                    path_start = new_node.path_from_root()\n                    # Extract path from goal root to connecting_node\n                    path_goal = connecting_node.path_from_root()\n\n                    # Merge paths (avoid duplicate)\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.68431,
          "time_improvement": 36.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 228.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03119027614593506,
                    "num_nodes_avg": 196.0,
                    "path_length_avg": 161.90028223162875,
                    "smoothness_avg": 0.01925246145745203,
                    "success_improvement": 0.0,
                    "time_improvement": -25.61102890979288,
                    "length_improvement": 11.259889834700093,
                    "smoothness_improvement": 201.3428291983296,
                    "objective_score": -4.424616560006196
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04433765411376953,
                    "num_nodes_avg": 424.7,
                    "path_length_avg": 246.60618516277526,
                    "smoothness_avg": 0.013537531152909957,
                    "success_improvement": 0.0,
                    "time_improvement": 72.65016293811588,
                    "length_improvement": 17.67575722719418,
                    "smoothness_improvement": 248.33042725393685,
                    "objective_score": 26.571852463143284
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01830921173095703,
                    "num_nodes_avg": 250.5,
                    "path_length_avg": 134.23458879587966,
                    "smoothness_avg": 0.026356378182142565,
                    "success_improvement": 0.0,
                    "time_improvement": 61.86630384046241,
                    "length_improvement": 10.847777686004214,
                    "smoothness_improvement": 235.25118505138138,
                    "objective_score": 21.90570261459647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* path planning algorithm with goal biasing, adaptive step sizing, and local rewiring to efficiently explore the space and optimize path quality. It grows two trees from start and goal positions, alternately extending them toward sampled points, ensuring collision-free expansions and performing rewiring within a fixed neighborhood radius to improve path cost. Upon successful connection of the two trees, it reconstructs a smooth and optimized path.",
          "planning_mechanism": "The planner samples points with goal bias, extends the start and goal trees alternately by steering toward sampled points within bounds and collision constraints, rewires neighboring nodes to minimize path cost, and attempts to connect the two trees when close enough, thus accelerating convergence and yielding high-quality feasible paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_radius: float=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        import math, random\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    for idx, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(idx)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest = nearest_node(tree, target_point)\n            new_pos = steer(nearest.position, target_point)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tgt_tree, from_node):\n            nearest_tgt = nearest_node(tgt_tree, from_node.position)\n            dist = math.dist(nearest_tgt.position, from_node.position)\n            if dist <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_tgt.position, from_node.position):\n                return nearest_tgt\n            return None\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_point()\n            if grow_start:\n                new_node = extend(tree_start, rand_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    success_state = True\n                    break\n            else:\n                new_node = extend(tree_goal, rand_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    success_state = True\n                    break\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.21349,
          "time_improvement": 26.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 237.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103264808654784,
                    "num_nodes_avg": 162.9,
                    "path_length_avg": 162.61579774657565,
                    "smoothness_avg": 0.019854948600954752,
                    "success_improvement": 0.0,
                    "time_improvement": 23.0663833521687,
                    "length_improvement": 10.867704442888806,
                    "smoothness_improvement": 210.77306131591973,
                    "objective_score": 10.14732120080797
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040572094917297366,
                    "num_nodes_avg": 404.4,
                    "path_length_avg": 243.17581811874166,
                    "smoothness_avg": 0.01347100730001293,
                    "success_improvement": 0.0,
                    "time_improvement": 74.97296130282253,
                    "length_improvement": 18.8209124841333,
                    "smoothness_improvement": 246.61872060370177,
                    "objective_score": 27.489164490691927
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05771968364715576,
                    "num_nodes_avg": 483.1,
                    "path_length_avg": 121.96169393042604,
                    "smoothness_avg": 0.027815836041917064,
                    "success_improvement": 0.0,
                    "time_improvement": -20.21625567329751,
                    "length_improvement": 18.99885008318657,
                    "smoothness_improvement": 253.8153813017396,
                    "objective_score": -0.9960297788432411
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized and hybrid variant of the RRT* and bidirectional RRT that combines rewiring optimization with a bidirectional growth strategy to improve convergence speed, path quality, and robustness. It adaptively tunes parameters such as step size and neighbor radius to balance exploration and exploitation, leading to smoother, shorter paths and faster planning times.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions. It samples free points with goal biasing, extends trees towards these samples with collision checks, applies rewiring internally to optimize path costs locally in both trees, and attempts to connect the trees repeatedly. Once connected, it reconstructs the path by backtracking parents in both trees and applies post-processing smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius_factor: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier for neighbor radius based on dimension and iteration count\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def sample():\n            # Goal biasing with higher rate for faster convergence\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: n.dist(point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_neighbor_radius(node_count):\n            # RRT* recommended radius ~ gamma*(log(n)/n)^(1/d)\n            gamma = self.neighbor_radius_factor\n            return min(gamma * ((math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)), self.step_size * 20)\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if n.dist(pos) <= radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def collision_free_node(pos):\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def rewire(new_node, tree):\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_node.position, radius)\n            for near_node in near:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + new_node.dist(near_node.position)\n                if new_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    near_node.update_parent(new_node, new_cost)\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            # Choose best parent in neighbors (RRT* style)\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and collision_free_edge(near_node.position, new_pos):\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, tree)\n            return new_node\n\n        def connect(tree, target_node):\n            # Try to connect tree towards target_node by incremental stepping (like bidirectional RRT-Connect)\n            current_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = Node(new_pos)\n                cost_to_new = current_node.cost + math.dist(current_node.position, new_pos)\n                new_node.update_parent(current_node, cost_to_new)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                rewire(new_node, tree)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        for it in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate trees as in bidirectional RRT\n            new_start = extend(tree_start, rnd_point)\n            if new_start is not None:\n                new_goal = connect(tree_goal, new_start)\n                if new_goal is not None:\n                    # Reconstruct full path from start_root to goal_root\n                    path_start = new_start.path_from_root()\n                    path_goal = new_goal.path_from_root()\n                    # Remove duplicate connection node from one side\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n                    # Optional: path smoothing after connection\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n                    break\n\n            # Swap trees for next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        # Smooth by shortcutting random pairs of points if collision-free edge exists,\n        # performed a number of times proportional to path length, aiming to reduce unnecessary waypoints.\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        attempts = max(100, len(smoothed)*5)\n        for _ in range(attempts):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed[i+1:j] = []\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.97464,
          "time_improvement": 4.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1655.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0196943998336792,
                    "num_nodes_avg": 98.3,
                    "path_length_avg": 160.73417210344533,
                    "smoothness_avg": 0.0452188588571313,
                    "success_improvement": 0.0,
                    "time_improvement": 20.68573502541093,
                    "length_improvement": 11.89905327415488,
                    "smoothness_improvement": 607.7733354377676,
                    "objective_score": 11.624397839643095
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08129169940948486,
                    "num_nodes_avg": 401.8,
                    "path_length_avg": 248.31139541126964,
                    "smoothness_avg": 0.10883507921321127,
                    "success_improvement": 0.0,
                    "time_improvement": 49.85493080829013,
                    "length_improvement": 17.10650896449116,
                    "smoothness_improvement": 2700.4049788949055,
                    "objective_score": 31.8798059298598
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0761023759841919,
                    "num_nodes_avg": 360.4,
                    "path_length_avg": 121.69348054843393,
                    "smoothness_avg": 0.13816706245341076,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -58.502994309322574,
                    "length_improvement": 19.176984640556956,
                    "smoothness_improvement": 1657.474835975687,
                    "objective_score": -55.42812718480693
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner incorporating goal biasing, rewiring, and dynamic neighbor radius. It grows two trees simultaneously\u2014one from start and one from goal\u2014sampling points with goal biasing to improve convergence speed. It rewires locally based on a radius proportional to node density to optimize path cost and improve path smoothness and length. Collision checks ensure safe node and edge placements. Upon connecting both trees, it extracts the optimal path by tracing parents from the connecting nodes.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending each toward random samples with goal biasing. At each extension, it selects the lowest cost parent among nearby nodes and rewiries neighbors to reduce path costs. The two trees attempt to connect within a specified radius while ensuring collision-free edges. This approach combines bidirectional search, incremental path quality improvement, efficient sampling, and strict collision checking for robust, efficient, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Node coordinates (2D or 3D)\n        self.parent = parent                  # Parent Node or None\n        self.cost = cost                      # Path cost from root\n        self.children: List[Node] = []       # Children nodes\n        self.valid = True                    # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self) -> List[Tuple[float, ...]]:\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_factor: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Multiplier to compute radius for neighbor search\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start: List[Node] = [Node(start_position)]\n        nodes_goal: List[Node] = [Node(goal_position)]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def get_nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(len(bounds))\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            # Based on RRT* theoretical radius: gamma * (log(n)/n)^(1/d)\n            dim = len(bounds)\n            if num_nodes <= 1:\n                return self.step_size * 2.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        # Alternate which tree to extend: True => start_tree, False => goal_tree\n        extend_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            # Sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if extend_start_tree else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Select tree to extend\n            if extend_start_tree:\n                tree_nodes = nodes_start\n                other_tree_nodes = nodes_goal\n            else:\n                tree_nodes = nodes_goal\n                other_tree_nodes = nodes_start\n\n            # Nearest node in current tree\n            nearest = get_nearest(tree_nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not new_pos:\n                extend_start_tree = not extend_start_tree\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                extend_start_tree = not extend_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                extend_start_tree = not extend_start_tree\n                continue\n\n            # Create new node without parent yet to pick best parent\n            temp_new_node = Node(new_pos)\n\n            # Find neighbors in current tree\n            radius = neighbor_radius(len(tree_nodes) + 1)\n            near_nodes = nearby(tree_nodes, new_pos, radius)\n\n            # Choose best parent among neighbors + nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = near_node\n\n            # Assign parent, cost, add node and edge\n            temp_new_node.update_parent(best_parent, min_cost)\n            tree_nodes.append(temp_new_node)\n            edges.append((best_parent, temp_new_node))\n\n            # Rewire neighbors if better path found through new node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = temp_new_node.cost + dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                        # Update edges\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(temp_new_node, cost_through_new)\n                        edges.append((temp_new_node, near_node))\n\n            # Attempt to connect trees:\n            # Find nearest node in other tree within step_size*2 radius\n            radius_connect = self.step_size * 2.0\n            near_other_nodes = nearby(other_tree_nodes, new_pos, radius_connect)\n\n            connected = False\n            best_total_cost = float('inf')\n            connect_node_other = None\n\n            for other_node in near_other_nodes:\n                # Check edge collision and node collision between temp_new_node and other_node\n                if self._is_in_obstacle(other_node.position, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(temp_new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = temp_new_node.cost + dist(temp_new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_total_cost:\n                    best_total_cost = total_cost\n                    connect_node_other = other_node\n                    connected = True\n\n            if connected:\n                # Connect trees: create a connection edge\n                edges.append((temp_new_node, connect_node_other) if extend_start_tree else (connect_node_other, temp_new_node))\n                connection_node_start = temp_new_node if extend_start_tree else connect_node_other\n                connection_node_goal = connect_node_other if extend_start_tree else temp_new_node\n                success_state = True\n                break\n\n            # Switch tree to extend\n            extend_start_tree = not extend_start_tree\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            # Extract path by connecting path from start tree root to connection_node_start \n            path_start = connection_node_start.path()\n            # Extract path from goal tree root to connection_node_goal and reverse it (excluding the connection node duplicate)\n            path_goal = connection_node_goal.path()\n            path_goal.reverse()\n            # Combine paths (removing duplicate connection node in one side)\n            if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            extracted_path = path_start + path_goal\n\n        # Combine nodes for return\n        all_nodes = nodes_start + [n for n in nodes_goal if n not in nodes_start]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 5.75664,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 227.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02871973514556885,
                    "num_nodes_avg": 158.2,
                    "path_length_avg": 161.3830685924987,
                    "smoothness_avg": 0.024604793406330365,
                    "success_improvement": 0.0,
                    "time_improvement": -15.661543513515847,
                    "length_improvement": 11.543382826081865,
                    "smoothness_improvement": 285.1184469731315,
                    "objective_score": -0.9641942539727235
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.05399606227874756,
                    "num_nodes_avg": 443.6,
                    "path_length_avg": 250.88777565076117,
                    "smoothness_avg": 0.011357259449957097,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 66.69234007018737,
                    "length_improvement": 16.24643908355544,
                    "smoothness_improvement": 192.2304659507276,
                    "objective_score": -25.781857832479055
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03892641067504883,
                    "num_nodes_avg": 366.2,
                    "path_length_avg": 129.6329212302199,
                    "smoothness_avg": 0.02386257154293267,
                    "success_improvement": 0.0,
                    "time_improvement": 18.925623938584376,
                    "length_improvement": 13.903986175253118,
                    "smoothness_improvement": 203.5301486742901,
                    "objective_score": 9.476135159997387
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive step sizing, goal biasing, fixed neighbor radius rewiring, and path smoothing. It grows two trees simultaneously from start and goal, alternately expanding each towards sampled points biased toward the opposite tree\u2019s root. Local rewiring optimizes path cost, and trees attempt connection each iteration to accelerate convergence. Upon successful connection, an optimized and smoothed path is returned, balancing exploration and exploitation while ensuring collision-free paths.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees, samples points biased toward the opposite root, steers with adaptive steps, performs collision checks on nodes and edges, rewires nearby nodes to improve costs, and tries to connect the two trees each iteration. It extracts and shortcut-smooths the resulting path upon success, achieving robustness, path quality, and computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.5, goal_sample_rate: float = 0.12, neighbor_radius: float = 14.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample(target_root):\n            if random.random() < self.goal_sample_rate:\n                return target_root\n            while True:\n                sample_p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample_p, obstacles, is_3d):\n                    return sample_p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            r = self.neighbor_radius\n            return [n for n in tree if dist(n.position, position) <= r]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges\n                    for i, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(i)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(from_node, target_tree):\n            nearest_node = nearest(target_tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_edge(nearest_node.position, from_node.position) and collision_free_node(from_node.position):\n                return nearest_node\n            return None\n\n        grow_start_tree = True\n        for _ in range(self.max_iter):\n            if grow_start_tree:\n                rand_point = sample(goal_pos)\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_goal)\n                if connect_node:\n                    # Connect new node to goal tree\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n            else:\n                rand_point = sample(start_pos)\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(new_node, tree_start)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        if success and len(final_path) > 2:\n            final_path = self._shortcut_smooth(final_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path: list, obstacles, is_3d, max_trials=150):\n        import random\n\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.24499,
          "time_improvement": -11.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1407.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.034097480773925784,
                    "num_nodes_avg": 103.5,
                    "path_length_avg": 157.87977746984552,
                    "smoothness_avg": 0.04273122682172244,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -37.319067750635874,
                    "length_improvement": 13.463592203608357,
                    "smoothness_improvement": 568.8364921041924,
                    "objective_score": -55.658819423948124
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04751076698303223,
                    "num_nodes_avg": 294.9,
                    "path_length_avg": 231.4061992478211,
                    "smoothness_avg": 0.08928321562863406,
                    "success_improvement": 0.0,
                    "time_improvement": 70.69281716310901,
                    "length_improvement": 22.749950032942188,
                    "smoothness_improvement": 2197.3214462256187,
                    "objective_score": 36.74444238664923
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07978732585906982,
                    "num_nodes_avg": 443.0,
                    "path_length_avg": 122.31500454981608,
                    "smoothness_avg": 0.12232666622785235,
                    "success_improvement": 0.0,
                    "time_improvement": -66.17786098062388,
                    "length_improvement": 18.764197992631477,
                    "smoothness_improvement": 1455.9861652030102,
                    "objective_score": -8.820587869645816
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 14.726307021992147,
          "time_improvement": -49.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030466032028198243,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -22.694317035068327,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -6.849891589122189
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2299717426300049,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -41.85887403129106,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -12.915927160794057
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08723273277282714,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -81.68485763375077,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -24.41310231606019
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a unidirectional RRT* planner with goal biasing, fixed neighborhood rewiring, and incremental path optimization to efficiently find collision-free, high-quality paths in 2D or 3D environments. It samples points biased toward the goal, extends the tree toward these samples within step limits, performs local rewiring to optimize path costs, and ensures all nodes and edges are collision-free and within bounds.",
          "planning_mechanism": "The planner grows a single tree from start by sampling the space with goal bias, steering nearest nodes toward samples by constrained steps, and rewiring nearby nodes for improved costs while checking collisions. It stops when the goal is reached within a threshold, then extracts the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 8.0, goal_threshold: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.goal_threshold = goal_threshold\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest_node(sample: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: math.dist(n.position, sample))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearby_nodes(new_node: Node) -> List[Node]:\n            return [node for node in nodes if node is not new_node and math.dist(node.position, new_node.position) <= self.neighbor_radius]\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            neighbors = nearby_nodes(new_node)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, neighbor))\n\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.goal_threshold:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = goal_node.path_from_root()\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.20303,
          "time_improvement": -64.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 32.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026504087448120116,
                    "num_nodes_avg": 303.6,
                    "path_length_avg": 175.65078275058184,
                    "smoothness_avg": 0.007080846998114912,
                    "success_improvement": 0.0,
                    "time_improvement": -6.73857708397944,
                    "length_improvement": 3.723022609637721,
                    "smoothness_improvement": 10.830631825861076,
                    "objective_score": -1.2228154441369823
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3649319648742676,
                    "num_nodes_avg": 1480.3,
                    "path_length_avg": 263.4236246953682,
                    "smoothness_avg": 0.006019418093263841,
                    "success_improvement": 0.0,
                    "time_improvement": -125.10955930085592,
                    "length_improvement": 12.061611848057327,
                    "smoothness_improvement": 54.88396315128449,
                    "objective_score": -34.84612560488888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07684125900268554,
                    "num_nodes_avg": 648.3,
                    "path_length_avg": 133.09884567617092,
                    "smoothness_avg": 0.010251935236448708,
                    "success_improvement": 0.0,
                    "time_improvement": -60.04191039914192,
                    "length_improvement": 11.6020841878391,
                    "smoothness_improvement": 30.4038594884832,
                    "objective_score": -15.54013698473234
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a goal-biased, single-tree RRT* style planner with rewiring and informed sampling to efficiently find and optimize a collision-free path. It adaptively samples within an ellipsoidal subset defined by the best path cost to focus search around promising regions, employs rewiring to improve path quality incrementally, and includes collision checks to ensure feasibility and robustness. Path smoothing is indirectly achieved via rewiring for better trajectories.",
          "planning_mechanism": "The planner grows a single tree from the start toward the goal by sampling points with goal biasing and informed elliptical sampling after finding a solution. It steers towards samples respecting step size, checks for collisions for both nodes and edges, adds new nodes, rewires neighbor nodes to lower path cost locally, and stops upon finding a satisfactory path or exceeding iteration limits. The best path is retrieved by backtracking from the goal node.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def informed_sample():\n            c_min = dist(start_position, goal_position)\n            c_best = best_cost\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            start_goal_vec = [goal_position[d] - start_position[d] for d in range(dim)]\n            norm_sg = math.sqrt(sum(x*x for x in start_goal_vec))\n            if norm_sg < 1e-8:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            unit_vec = [x / norm_sg for x in start_goal_vec]\n\n            a1 = c_best / 2.0\n            a2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n\n            # Rotation matrix L: align unit_vec to x-axis\n            if dim == 2:\n                L = [[unit_vec[0], -unit_vec[1]],\n                     [unit_vec[1],  unit_vec[0]]]\n            elif dim == 3:\n                ux, uy, uz = unit_vec\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    L = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [-uy, ux, 0]\n                    norm_vx = math.sqrt(vx[0]*vx[0]+vx[1]*vx[1]+vx[2]*vx[2])\n                    vx = [x / norm_vx for x in vx]\n                    vy = [unit_vec[1]*vx[2] - unit_vec[2]*vx[1],\n                          unit_vec[2]*vx[0] - unit_vec[0]*vx[2],\n                          unit_vec[0]*vx[1] - unit_vec[1]*vx[0]]\n                    L = [vx, vy, unit_vec]\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            while True:\n                rnd = [random.uniform(-1,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd <= 1:\n                    break\n\n            if dim == 2:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1]]\n                x = L[0][0]*sample_canonical[0] + L[0][1]*sample_canonical[1]\n                y = L[1][0]*sample_canonical[0] + L[1][1]*sample_canonical[1]\n                mid = tuple(0.5*(start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y)\n                sample = clamp_pos(sample)\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            elif dim == 3:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1], a2 * rnd[2]]\n                x = sum(L[0][i]*sample_canonical[i] for i in range(3))\n                y = sum(L[1][i]*sample_canonical[i] for i in range(3))\n                z = sum(L[2][i]*sample_canonical[i] for i in range(3))\n                mid = tuple(0.5*(start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y, mid[2] + z)\n                sample = clamp_pos(sample)\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            return informed_sample()\n\n        def nearest_node(point: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near_nodes(new_node: Node) -> List[Node]:\n            r = self.neighbor_radius\n            return [n for n in nodes if dist(n.position, new_node.position) <= r]\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        for _ in range(self.max_iter):\n            rnd_point = sample_point()\n            nearest = nearest_node(rnd_point)\n            new_pos = steer(nearest.position, rnd_point, self.step_size)\n            new_pos = clamp_pos(new_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            # Rewire neighbors\n            neighbors = near_nodes(new_node)\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    cost_through_new = new_node.cost + dist_to_goal\n                    if cost_through_new < best_cost:\n                        best_cost = cost_through_new\n                        goal_node = Node(goal_position, parent=new_node, cost=cost_through_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        best_goal_node = goal_node\n                        success_state = True\n                        # Optional early termination on first found path\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        # Collect edges\n        for node in nodes:\n            if node.parent is not None:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 33.03868,
          "time_improvement": -120.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 134.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02710566520690918,
                    "num_nodes_avg": 233.2,
                    "path_length_avg": 175.44536801832646,
                    "smoothness_avg": 0.01106093254127802,
                    "success_improvement": 0.0,
                    "time_improvement": -9.1612809067088,
                    "length_improvement": 3.835613679391623,
                    "smoothness_improvement": 73.127613470455,
                    "objective_score": -1.6156234687820406
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.25610063076019285,
                    "num_nodes_avg": 1084.0,
                    "path_length_avg": 248.0208030860644,
                    "smoothness_avg": 0.01134793165986191,
                    "success_improvement": 0.0,
                    "time_improvement": -57.97657009015642,
                    "length_improvement": 17.203517046880982,
                    "smoothness_improvement": 191.99045519304278,
                    "objective_score": -12.992315341705515
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1888735771179199,
                    "num_nodes_avg": 817.4,
                    "path_length_avg": 129.28420223481302,
                    "smoothness_avg": 0.018526525900182188,
                    "success_improvement": 0.0,
                    "time_improvement": -293.37835556305924,
                    "length_improvement": 14.135588727788228,
                    "smoothness_improvement": 135.6560419644229,
                    "objective_score": -84.50810871353801
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive parameter tuning, goal biasing, and rewiring for efficient and high-quality path planning. It grows two trees from start and goal simultaneously, rewires locally to optimize path costs, and attempts frequent connections to quickly find smooth, short, and feasible paths while avoiding obstacles and map boundaries.",
          "planning_mechanism": "The planner alternates growing two trees via randomized sampling biased toward the goal. Each extension selects best parents and rewires locally to improve paths. Trees connect incrementally using steering and collision checks. Upon connection, the path is reconstructed and smoothed by shortcutting collision-free segments to enhance path quality and reduce redundant nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_factor: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier for neighbor radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: n.dist(point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def get_neighbor_radius(node_count):\n            if node_count == 0:\n                return self.step_size * 10\n            gamma = self.neighbor_radius_factor\n            return min(gamma * ((math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)), self.step_size * 20)\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if n.dist(pos) <= radius]\n\n        def collision_free_node(pos):\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def rewire(new_node, tree):\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_node.position, radius)\n            for near_node in near:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + new_node.dist(near_node.position)\n                if new_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    near_node.update_parent(new_node, new_cost)\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = get_neighbor_radius(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and collision_free_edge(near_node.position, new_pos):\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, tree)\n            return new_node\n\n        def connect(tree, target_node):\n            current_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = Node(new_pos)\n                cost_to_new = current_node.cost + math.dist(current_node.position, new_pos)\n                new_node.update_parent(current_node, cost_to_new)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                rewire(new_node, tree)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            # Shortcut smoothing with adaptive attempts (proportional to path length)\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            attempts = max(150, len(smoothed)*10)\n            for _ in range(attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed[i+1:j] = []\n            return smoothed\n\n        for it in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate tree extension like bidirectional RRT*\n            new_start = extend(tree_start, rnd_point)\n            if new_start is not None:\n                new_goal = connect(tree_goal, new_start)\n                if new_goal is not None:\n                    # Build final path: start_root \u2192 new_start \u2192 new_goal \u2192 goal_root\n                    path_start = new_start.path_from_root()\n                    path_goal = new_goal.path_from_root()\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap the trees to balance growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.31606,
          "time_improvement": -45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1630.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043984508514404295,
                    "num_nodes_avg": 101.1,
                    "path_length_avg": 161.42531293906998,
                    "smoothness_avg": 0.044935219137958386,
                    "success_improvement": 0.0,
                    "time_improvement": -77.13659682701844,
                    "length_improvement": 11.52022803032163,
                    "smoothness_improvement": 603.3337578992031,
                    "objective_score": -17.82026465254519
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.09677293300628662,
                    "num_nodes_avg": 346.5,
                    "path_length_avg": 228.7684483165439,
                    "smoothness_avg": 0.10896417709261567,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 40.30527770072979,
                    "length_improvement": 23.63050721725338,
                    "smoothness_improvement": 2703.726760317425,
                    "objective_score": -69.66368144474325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09473226070404053,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 129.4187057666335,
                    "smoothness_avg": 0.13235765141381864,
                    "success_improvement": 0.0,
                    "time_improvement": -97.3045753840959,
                    "length_improvement": 14.04625788632298,
                    "smoothness_improvement": 1583.5795563581935,
                    "objective_score": -18.464223256173206
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.8963390906976,
          "time_improvement": 77.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009341573715209961,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 62.379150459777954,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 23.02899267630984
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02025575637817383,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 87.50516581037996,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.9928610146115
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008779239654541016,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 81.71494969758966,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.72514893379113
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.485207755128116,
          "time_improvement": 94.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0015536069869995118,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 93.74323679452625,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 29.75091122546928
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007682299613952637,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.26114660547798,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.41313556311789
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004066658020019531,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 91.5301268236486,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -22.79339892773574
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 42.22944021394406,
          "time_improvement": -157.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049358153343200685,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -98.77760612051492,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -26.320939595668875
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4221031904220581,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -160.3758298019535,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -42.18884991852324
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14922070503234863,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -210.79093464162634,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -58.17853112764008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a goal-biased, bidirectional RRT* planner that dynamically alternates growth between start and goal trees, using adaptive rewiring within a fixed neighbor radius for path cost optimization. It incorporates rigorous collision checks, clamps node expansions within map bounds for robustness, and applies early termination upon a successful connection, aiming to improve planning efficiency, path quality, smoothness, and success rate.",
          "planning_mechanism": "The planner samples points with goal bias, grows two trees alternately toward sampled points, rewires locally to optimize paths, and attempts to connect the trees at each iteration. It validates all nodes and edges for collisions and extracts an optimized smooth path immediately upon connection success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.2, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(pos[d], bounds[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp(to_pos)\n            factor = self.step_size / dist\n            new_pos = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return clamp(new_pos)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if math.dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges\n                    for idx, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(idx)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not collision_free_node(new_pos):\n                return None\n\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent among neighbors to minimize cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tgt_tree, from_node):\n            nearest_node = nearest(tgt_tree, from_node.position)\n            dist = math.dist(nearest_node.position, from_node.position)\n\n            if dist <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.6004,
          "time_improvement": -48.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 304.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03782908916473389,
                    "num_nodes_avg": 217.3,
                    "path_length_avg": 163.531742576427,
                    "smoothness_avg": 0.022233818578599605,
                    "success_improvement": 0.0,
                    "time_improvement": -52.347186362497254,
                    "length_improvement": 10.365660567572652,
                    "smoothness_improvement": 248.0075422648996,
                    "objective_score": -12.390986083910146
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.09020640850067138,
                    "num_nodes_avg": 625.2,
                    "path_length_avg": 233.91446079143662,
                    "smoothness_avg": 0.016811486449742015,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 44.35586131597053,
                    "length_improvement": 21.91262013337782,
                    "smoothness_improvement": 332.5716551761095,
                    "objective_score": -30.647859302652723
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.11288640499114991,
                    "num_nodes_avg": 648.3,
                    "path_length_avg": 119.56120804111438,
                    "smoothness_avg": 0.03386217887972522,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -135.11530325451133,
                    "length_improvement": 20.593138512012835,
                    "smoothness_improvement": 330.72441590405515,
                    "objective_score": -84.76234119443056
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an optimized unidirectional RRT* planner with goal biasing, rewiring for path optimality, and fixed neighbor radius for local tree improvements. It incrementally grows a single tree by sampling the space, extending nodes toward samples, and rewiring near neighbors to improve path cost and smoothness. The planner ensures collision-free nodes and edges, balancing exploration and exploitation to reduce search time while enhancing path quality and robustness.",
          "planning_mechanism": "The planner grows a single tree from the start node by randomly sampling points (with goal biasing), extending the nearest node towards the sample within a fixed step size, and rewiring nearby nodes if the new node offers lower cost connections. It terminates upon reaching the goal within a threshold. The tree structure and edge connections maintain obstacle avoidance throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 8.0, goal_threshold: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.goal_threshold = goal_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer from nearest_node towards sample\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            dist = min(self.step_size, length)\n            new_position = tuple(nearest_node.position[d] + unit[d] * dist for d in range(len(bounds)))\n\n            # Avoid going out of bounds\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for the new node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Collision check for the edge from nearest_node to new_position\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Create new node and add to tree\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes for optimal path\n            neighbors = self._nearby_nodes(nodes, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_cost\n\n                # Check if rewiring improves cost and is collision free\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly (remove old, add new)\n                        # Remove old edge\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, neighbor))\n\n            # Check if goal reached within threshold, and final connection is collision free\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.goal_threshold:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path from goal to root\n                    path = []\n                    current = goal_node\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearby_nodes(self, nodes, node, radius):\n        import math\n        res = []\n        for other in nodes:\n            if other == node:\n                continue\n            if math.dist(node.position, other.position) <= radius:\n                res.append(other)\n        return res\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.84878,
          "time_improvement": -148.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 33.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033041524887084964,
                    "num_nodes_avg": 337.5,
                    "path_length_avg": 177.72237705166276,
                    "smoothness_avg": 0.007172456235907458,
                    "success_improvement": 0.0,
                    "time_improvement": -33.06646976757138,
                    "length_improvement": 2.5875489467029023,
                    "smoothness_improvement": 12.26451532995832,
                    "objective_score": -9.34110856428104
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4186041593551636,
                    "num_nodes_avg": 1566.5,
                    "path_length_avg": 266.0595621636338,
                    "smoothness_avg": 0.00607225829807926,
                    "success_improvement": 0.0,
                    "time_improvement": -158.2174402464647,
                    "length_improvement": 11.181660049897028,
                    "smoothness_improvement": 56.24357968044635,
                    "objective_score": -44.947682165557765
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1694263696670532,
                    "num_nodes_avg": 828.7,
                    "path_length_avg": 139.59415597637658,
                    "smoothness_avg": 0.010175509506343454,
                    "success_improvement": 0.0,
                    "time_improvement": -252.8744872928067,
                    "length_improvement": 7.288208359881884,
                    "smoothness_improvement": 29.431729842704968,
                    "objective_score": -74.25754586665211
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an efficient and robust unidirectional RRT* planner incorporating goal biasing and local rewiring. It incrementally grows a single tree from start to goal, optimizing path quality through rewiring nearby nodes while ensuring collision-free node extensions and edges.",
          "planning_mechanism": "The planner samples points within map bounds with a defined probability to directly sample the goal, steering from the nearest tree node toward the sample by a fixed step size, and connects valid new nodes to the best parent among nearby nodes. It rewires neighbors if shorter paths are found and terminates successfully upon a collision-free connection to the goal, extracting the final optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rectangles or cuboids\n\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start_position)]\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step = min(self.step_size, dist)\n            unit_vector = tuple(direction[d] / dist for d in range(len(bounds)))\n\n            new_pos = tuple(nearest_node.position[d] + unit_vector[d] * step for d in range(len(bounds)))\n\n            # Check boundaries\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node\n            new_node = Node(new_pos)\n\n            # Find nearby nodes within neighbor_radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent based on minimal cost path\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_try = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_try < min_cost:\n                    # Check edge collision to near_node\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        best_parent = near_node\n                        min_cost = cost_try\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if possible\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_via_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent and edges accordingly\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 50.07314,
          "time_improvement": -186.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 278.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08358452320098878,
                    "num_nodes_avg": 420.1,
                    "path_length_avg": 154.9412718472041,
                    "smoothness_avg": 0.02062795933159791,
                    "success_improvement": 0.0,
                    "time_improvement": -236.6157423899236,
                    "length_improvement": 15.074233698979455,
                    "smoothness_improvement": 222.872357870154,
                    "objective_score": -66.85551418783042
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5137278318405152,
                    "num_nodes_avg": 1643.7,
                    "path_length_avg": 221.01420280116628,
                    "smoothness_avg": 0.01623238282201555,
                    "success_improvement": 0.0,
                    "time_improvement": -216.89481042321557,
                    "length_improvement": 26.21909756386829,
                    "smoothness_improvement": 317.67090172322423,
                    "objective_score": -58.23626910557489
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09864957332611084,
                    "num_nodes_avg": 630.5,
                    "path_length_avg": 112.63006772970371,
                    "smoothness_avg": 0.03100782754526841,
                    "success_improvement": 0.0,
                    "time_improvement": -105.46339792037023,
                    "length_improvement": 25.19647188141747,
                    "smoothness_improvement": 294.41727761606415,
                    "objective_score": -25.12763861174725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a unidirectional, goal-biased RRT* planner that incrementally grows a single tree from start towards the goal. It incorporates fixed-radius rewiring to optimize path costs while maintaining collision-free nodes and edges. It balances exploration and exploitation by probabilistically sampling the goal to guide growth and refines the tree structure to improve path quality and smoothness efficiently.",
          "planning_mechanism": "The planner samples random points within the map bounds with a fixed probability of directly sampling the goal. For each sample, it extends from the nearest existing node by a constrained step size towards the sample, adding new nodes only if collision-free. It finds nearby nodes within a fixed radius to choose the best parent minimizing cost and performs rewiring of neighbors if improved paths are detected. Once the goal is reached within a step size without collision, it extracts the optimized path by traversing parent links.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = [Node(start_position)]\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step = min(self.step_size, dist)\n            unit_vec = tuple(direction[d]/dist for d in range(len(bounds)))\n\n            new_pos = tuple(nearest_node.position[d] + unit_vec[d]*step for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Nearby nodes for potential better parent\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_try = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_try < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        best_parent = near_node\n                        min_cost = cost_try\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes through the new node if better\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_via_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, near_node))\n\n            # Check for goal connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                   not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    current = goal_node\n                    while current:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 54.23196,
          "time_improvement": -200.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 271.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08520050048828125,
                    "num_nodes_avg": 404.9,
                    "path_length_avg": 154.03631885977268,
                    "smoothness_avg": 0.019998466993402353,
                    "success_improvement": 0.0,
                    "time_improvement": -243.12368636585782,
                    "length_improvement": 15.57025277128835,
                    "smoothness_improvement": 213.0194358129021,
                    "objective_score": -68.75795817643517
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5368141412734986,
                    "num_nodes_avg": 1669.3,
                    "path_length_avg": 220.64972344560334,
                    "smoothness_avg": 0.01593650901741622,
                    "success_improvement": 0.0,
                    "time_improvement": -231.13568116780115,
                    "length_improvement": 26.34077126371176,
                    "smoothness_improvement": 310.05785562159593,
                    "objective_score": -62.522260819490015
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10871360301971436,
                    "num_nodes_avg": 721.6,
                    "path_length_avg": 112.48644017941595,
                    "smoothness_avg": 0.03071182069047233,
                    "success_improvement": 0.0,
                    "time_improvement": -126.42435768837335,
                    "length_improvement": 25.291862461509606,
                    "smoothness_improvement": 290.6520922720113,
                    "objective_score": -31.41567435285003
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This planner implements a hybrid bidirectional RRT* algorithm combining adaptive goal-biased sampling, variable step size, dynamic neighbor radius, and streamlined rewiring with early termination. It integrates efficient dual-tree growth with balanced exploration and exploitation, ensuring rapid convergence to high-quality, smooth, and collision-free paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling random points with goal biasing. Each tree is extended towards sampled points with collision checks, rewired locally to optimize costs, and frequently attempts incremental connections to the opposite tree. Once connected, the path is reconstructed and progressively smoothed using shortcutting to reduce redundant nodes, ensuring efficient and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos) -> float:\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_factor: float = 18.0,\n                 edge_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.edge_resolution = edge_resolution  # finer resolution for collision checking\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        # Initialize trees with root nodes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: node.dist(point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_pos = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp within bounds\n            clamped_pos = tuple(\n                max(0.0, min(new_pos[d], bounds[d])) for d in range(dim)\n            )\n            return clamped_pos\n\n        def get_neighbor_radius(node_count: int):\n            if node_count == 0:\n                return self.step_size * 15\n            gamma = self.neighbor_radius_factor\n            return min(gamma * ((math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)), self.step_size * 25)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if node.dist(pos) <= radius]\n\n        def collision_free_node(pos):\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.edge_resolution)\n\n        def rewire(new_node, tree):\n            radius = get_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + new_node.dist(neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, point):\n            nearest = nearest_node(tree, point)\n            new_pos = steer(nearest.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = get_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, tree)\n            return new_node\n\n        def connect(tree, target_node):\n            current = nearest_node(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                cost_to_new = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.update_parent(current, cost_to_new)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                rewire(new_node, tree)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            attempts = max(150, len(smoothed)*12)\n            for _ in range(attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=self.edge_resolution):\n                    del smoothed[i+1:j]\n            return smoothed\n\n        # Alternate growth: start from start tree to goal tree and vice versa\n        for it in range(self.max_iter):\n            rnd_point = sample_point()\n            new_node_start = extend(tree_start, rnd_point)\n            if new_node_start is not None:\n                new_node_goal = connect(tree_goal, new_node_start)\n                if new_node_goal is not None:\n                    # Concatenate path start -> connect node -> reversed path goal\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[-2::-1]\n                    extracted_path = smooth_path(extracted_path)\n                    success_state = True\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start  # Swap trees to balance growth\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 60.05227,
          "time_improvement": -181.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1528.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.06441938877105713,
                    "num_nodes_avg": 121.5,
                    "path_length_avg": 165.5166268460834,
                    "smoothness_avg": 0.04410606611504242,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -159.43296133102763,
                    "length_improvement": 9.277714046869992,
                    "smoothness_improvement": 590.3557125559604,
                    "objective_score": -93.02256702715448
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14325861930847167,
                    "num_nodes_avg": 369.7,
                    "path_length_avg": 242.1405414629049,
                    "smoothness_avg": 0.10512631693578658,
                    "success_improvement": 0.0,
                    "time_improvement": 11.630419468214944,
                    "length_improvement": 19.166517630637905,
                    "smoothness_improvement": 2604.9758541832757,
                    "objective_score": 20.347308637508444
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.23713581562042235,
                    "num_nodes_avg": 668.9,
                    "path_length_avg": 122.32634296716897,
                    "smoothness_avg": 0.11692225684738684,
                    "success_improvement": 0.0,
                    "time_improvement": -393.8970215808761,
                    "length_improvement": 18.756667555703103,
                    "smoothness_improvement": 1387.2424767954942,
                    "objective_score": -107.48156057914474
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a unidirectional RRT* planner with goal biasing, fixed neighbor radius rewiring, and path smoothing for improved planning efficiency and path quality. It grows a single tree from the start towards the goal, incrementally optimizing paths via rewiring and focusing sampling near the goal to speed convergence and enhance robustness.",
          "planning_mechanism": "The planner samples points with goal bias to guide growth towards the goal. For each sample, it finds the nearest node and attempts to steer towards it within a fixed step size, adding collision-checked nodes and edges. Nearby nodes are rewired to reduce path cost. Upon reaching the goal region, the path is extracted and smoothed by shortcutting to improve smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, neighbor_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_node = Node(start_position, cost=0.0)\n        nodes.append(start_node)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.neighbor_radius]\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            nearest_node = nearest(nodes, rand_point)\n            new_position = self._steer(nearest_node.position, rand_point, self.step_size)\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n\n            neighbors = near(nodes, new_position)\n            for near_node in neighbors:\n                if near_node == nearest_node:\n                    continue\n                potential_cost = near_node.cost + dist(near_node.position, new_position)\n                if potential_cost < new_node.cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    # Rewire new_node parent\n                    new_node.update_parent(near_node, potential_cost)\n\n            # Rewire neighbors if going through new_node is cheaper\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    near_node.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Check if goal can be reached directly from new_node\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    extracted_path = goal_node.path_from_root()\n                    success_state = True\n                    break\n\n        # Path smoothing by shortcutting\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_trials=100):\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy to avoid side-effects\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # remove nodes between i+1 and j-1\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 74.34264,
          "time_improvement": -282.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1160.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.059880423545837405,
                    "num_nodes_avg": 313.9,
                    "path_length_avg": 155.9517991151351,
                    "smoothness_avg": 0.040852809102449254,
                    "success_improvement": 0.0,
                    "time_improvement": -141.15341518472252,
                    "length_improvement": 14.520347690597207,
                    "smoothness_improvement": 539.4351757482023,
                    "objective_score": -36.7447791385563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5118288040161133,
                    "num_nodes_avg": 1528.0,
                    "path_length_avg": 218.72516868069314,
                    "smoothness_avg": 0.07365573914609802,
                    "success_improvement": 0.0,
                    "time_improvement": -215.72338846570509,
                    "length_improvement": 26.983243039476218,
                    "smoothness_improvement": 1795.2152203136275,
                    "objective_score": -50.34429183024814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2823688745498657,
                    "num_nodes_avg": 883.5,
                    "path_length_avg": 114.64070421990502,
                    "smoothness_avg": 0.09781379626488622,
                    "success_improvement": 0.0,
                    "time_improvement": -488.10663316483095,
                    "length_improvement": 23.86110286084681,
                    "smoothness_improvement": 1144.1842686259308,
                    "objective_score": -135.93884803415025
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a goal-biased, informed-sampling single-tree RRT* planner with rewiring and ellipsoidal sampling to improve planning efficiency, path quality, and success rate. It dynamically focuses the search within an ellipsoid defined by the current best path cost, rewires nearby nodes for path optimization, and performs robust collision and edge validations to ensure feasible trajectories while respecting map boundaries.",
          "planning_mechanism": "The planner grows a single tree from start towards goal by sampling either the goal position or points inside an informed ellipsoid after an initial solution is found. It extends the nearest tree node toward sampled points with a fixed step size, validates new nodes and edges for collision, rewires neighbors within a fixed radius to improve cost, and terminates early upon finding a satisfactory path. The best path is retrieved by backtracking from the goal node.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 3.5, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_goal_node = None\n        best_cost = float('inf')\n        extracted_path = []\n\n        root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(root)\n\n        def informed_sample():\n            c_min = dist(start_position, goal_position)\n            c_best = best_cost\n            if c_best == float('inf'):\n                # No solution yet, uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Unit vector from start to goal\n            start_goal_vec = [goal_position[d] - start_position[d] for d in range(dim)]\n            norm_sg = math.sqrt(sum(x * x for x in start_goal_vec))\n            if norm_sg < 1e-8:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            unit_vec = [x / norm_sg for x in start_goal_vec]\n\n            # Define ellipsoid axes lengths\n            a1 = c_best / 2.0\n            a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n\n            # Rotation matrix aligning unit_vec to x axis\n            if dim == 2:\n                L = [[unit_vec[0], -unit_vec[1]],\n                     [unit_vec[1],  unit_vec[0]]]\n            elif dim == 3:\n                ux, uy, uz = unit_vec\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    L = [[1, 0, 0],\n                         [0, 1, 0],\n                         [0, 0, 1]]\n                else:\n                    vx = [-uy, ux, 0]\n                    norm_vx = math.sqrt(vx[0] ** 2 + vx[1] ** 2 + vx[2] ** 2)\n                    vx = [x / norm_vx for x in vx]\n                    vy = [unit_vec[1] * vx[2] - unit_vec[2] * vx[1],\n                          unit_vec[2] * vx[0] - unit_vec[0] * vx[2],\n                          unit_vec[0] * vx[1] - unit_vec[1] * vx[0]]\n                    L = [vx, vy, unit_vec]\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample inside unit ball\n            while True:\n                rnd = [random.uniform(-1, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd <= 1:\n                    break\n\n            if dim == 2:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1]]\n                x = L[0][0] * sample_canonical[0] + L[0][1] * sample_canonical[1]\n                y = L[1][0] * sample_canonical[0] + L[1][1] * sample_canonical[1]\n                mid = tuple(0.5 * (start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y)\n            elif dim == 3:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1], a2 * rnd[2]]\n                x = sum(L[0][i] * sample_canonical[i] for i in range(3))\n                y = sum(L[1][i] * sample_canonical[i] for i in range(3))\n                z = sum(L[2][i] * sample_canonical[i] for i in range(3))\n                mid = tuple(0.5 * (start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y, mid[2] + z)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            sample = clamp_pos(sample)\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n            else:\n                # fallback to uniform sampling if sampled inside obstacle\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            return informed_sample()\n\n        def nearest_node(point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near_nodes(new_node):\n            return [n for n in nodes if dist(n.position, new_node.position) <= self.neighbor_radius]\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        for _ in range(self.max_iter):\n            rnd_point = sample_point()\n            nearest = nearest_node(rnd_point)\n            new_pos = steer(nearest.position, rnd_point, self.step_size)\n            new_pos = clamp_pos(new_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            neighbors = near_nodes(new_node)\n\n            # Choose best parent among neighbors\n            min_cost = new_node.cost\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + dist(neighbor.position, new_node.position)\n                if cost_through_neighbor < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d, resolution=0.5):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n            if best_parent != nearest:\n                new_node.update_parent(best_parent, min_cost)\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.5):\n                        neighbor.update_parent(new_node, cost_via_new)\n\n            nodes.append(new_node)\n\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, resolution=0.5)\n                        and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    cost_through_new = new_node.cost + dist_to_goal\n                    if cost_through_new < best_cost:\n                        best_cost = cost_through_new\n                        goal_node = Node(goal_position, parent=new_node, cost=cost_through_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        best_goal_node = goal_node\n                        success_state = True\n                        # Early stop on first found good path\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        # Collect edges\n        for node in nodes:\n            if node.parent is not None:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 74.88749,
          "time_improvement": -211.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 208.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08058707714080811,
                    "num_nodes_avg": 310.5,
                    "path_length_avg": 162.95421121592406,
                    "smoothness_avg": 0.017263179190833776,
                    "success_improvement": 0.0,
                    "time_improvement": -224.54427877224833,
                    "length_improvement": 10.68221465783436,
                    "smoothness_improvement": 170.20624193017125,
                    "objective_score": -64.37580949045676
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.4523578405380249,
                    "num_nodes_avg": 1325.9,
                    "path_length_avg": 224.36386055801177,
                    "smoothness_avg": 0.012715386665178319,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -179.03851657633177,
                    "length_improvement": 25.100885390080585,
                    "smoothness_improvement": 227.17605741786278,
                    "objective_score": -97.5554976077941
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15745844841003417,
                    "num_nodes_avg": 680.0,
                    "path_length_avg": 116.51023154003026,
                    "smoothness_avg": 0.025619720012085224,
                    "success_improvement": 0.0,
                    "time_improvement": -227.9481780894022,
                    "length_improvement": 22.61945183214406,
                    "smoothness_improvement": 225.880947502702,
                    "objective_score": -62.731158322878336
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A unidirectional RRT* path planner incorporating goal-biased sampling, adaptive neighborhood rewiring for cost-optimal path improvement, and collision-aware incremental tree growth within map boundaries. The planner incrementally samples points biased toward the goal, extends the tree toward these points with bounded steps, and rewires nearby nodes to minimize path cost while ensuring collision-free nodes and edges.",
          "planning_mechanism": "The planner initializes a tree at the start position and iteratively samples points, preferentially sampling the goal to accelerate convergence. For each sample, it determines the nearest tree node and attempts to steer toward the sample within a fixed step size and map bounds. New nodes are added only if they are collision-free, and nearby nodes are rewired if connecting through the new node reduces path cost and is collision-free. The process continues until a node near enough to the goal is found, from which the path is extracted by backtracking parent nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent node or None if root\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            step = min(self.step_size, length)\n            unit = tuple(direction[d] / length for d in range(dim))\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(dim))\n            # Clamp within map bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.step_size * 2.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        nodes = [Node(start_position)]\n        edges = []\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if new_pos is None:\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby(nodes, new_pos, radius)\n\n            # Choose best parent with minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize cost\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None and (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal reached close enough and add goal node\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = goal_node.path() if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 75.94754,
          "time_improvement": -207.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.06980903148651123,
                    "num_nodes_avg": 402.7,
                    "path_length_avg": 170.32806873225934,
                    "smoothness_avg": 0.009992645180230634,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -181.13839810807875,
                    "length_improvement": 6.640486506881311,
                    "smoothness_improvement": 56.406596446928845,
                    "objective_score": -102.73138914881271
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2966932773590088,
                    "num_nodes_avg": 1167.8,
                    "path_length_avg": 251.0008182381526,
                    "smoothness_avg": 0.006505335240494519,
                    "success_improvement": 0.0,
                    "time_improvement": -83.01628616398172,
                    "length_improvement": 16.208702214133716,
                    "smoothness_improvement": 67.38696134150419,
                    "objective_score": -21.32621059966025
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2189161777496338,
                    "num_nodes_avg": 824.1,
                    "path_length_avg": 130.16044834597136,
                    "smoothness_avg": 0.012409112986984532,
                    "success_improvement": 0.0,
                    "time_improvement": -355.9498862857654,
                    "length_improvement": 13.553627783112839,
                    "smoothness_improvement": 57.84300124900024,
                    "objective_score": -103.78502532286205
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "A unidirectional, goal-biased RRT* planner with adaptive neighbor radius for rewiring and incremental step steering that ensures collision-free nodes and edges, dynamically optimizes path cost for quality, and efficiently explores bounded 2D/3D spaces. It uses refined rewiring for better path smoothness and shorter paths with enhanced success and computational performance.",
          "planning_mechanism": "The planner samples points biased toward the goal within map bounds, extends the tree toward samples using a steer function capped by step size, performs rigorous collision checks for nodes and edges, and inserts new nodes with parent selection minimizing path cost. It then rewires neighbors within an adaptive radius to optimize costs and repairs tree structure. Upon reaching goal vicinity collision-free, it extracts the optimal path by backtracking from goal to start.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.15, neighbor_factor: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            step = min(self.step_size, length)\n            unit = tuple(direction[d] / length for d in range(dim))\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(dim))\n            # Clamp within map bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [node for node in nodes_list if dist(node.position, pos) <= radius]\n\n        nodes = [Node(start_position)]\n        edges = []\n\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not new_pos:\n                continue\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby(nodes, new_pos, radius)\n\n            # Select best parent based on minimum cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if path cost can be improved through new node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal can be connected directly from new_node\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = goal_node.path_from_root() if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 77.22782,
          "time_improvement": -210.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.08169121742248535,
                    "num_nodes_avg": 459.4,
                    "path_length_avg": 170.1850633102709,
                    "smoothness_avg": 0.009432816584080279,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -228.99092734288956,
                    "length_improvement": 6.718870044739103,
                    "smoothness_improvement": 47.6440632299215,
                    "objective_score": -117.11528387776944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5381176710128784,
                    "num_nodes_avg": 1660.2,
                    "path_length_avg": 258.6614944260325,
                    "smoothness_avg": 0.0048967365517595274,
                    "success_improvement": 0.0,
                    "time_improvement": -231.93976804812814,
                    "length_improvement": 13.651348002281308,
                    "smoothness_improvement": 25.996558453549408,
                    "objective_score": -66.72167802171442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1291637659072876,
                    "num_nodes_avg": 681.3,
                    "path_length_avg": 131.29553697831378,
                    "smoothness_avg": 0.012558237290835475,
                    "success_improvement": 0.0,
                    "time_improvement": -169.01714155187653,
                    "length_improvement": 12.799755960623324,
                    "smoothness_improvement": 59.73985138677311,
                    "objective_score": -47.84649201650443
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A goal-biased unidirectional RRT* path planner with dynamic rewiring for path optimality and collision-aware incremental growth within map boundaries. The planner incrementally samples points, extends the tree toward samples while maintaining collision-free nodes and edges, and rewires neighbors based on cost optimization for improved path quality and smoothness.",
          "planning_mechanism": "The planner grows a single tree rooted at start, sampling points biased toward the goal. Each iteration finds the nearest node, extends toward the sample within step size and map bounds, checks collisions, and adds new nodes and edges if valid. Nearby nodes are rewired to reduce path cost. Upon reaching the goal within a threshold, the path is extracted by backtracking from goal to start.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children = []\n        self.valid = True             # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Multiplier for neighbor radius computation\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            step = min(self.step_size, length)\n            unit = tuple(d / length for d in direction)\n            new_pos = tuple(from_pos[d] + unit[d]*step for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        nodes: list[Node] = [Node(start_position)]\n        edges: list[tuple[Node, Node]] = []\n\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not new_pos:\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            temp_node = Node(new_pos)\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby(nodes, new_pos, radius)\n\n            # Choose best parent with minimal cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = near_node\n\n            temp_node.update_parent(best_parent, min_cost)\n            nodes.append(temp_node)\n            edges.append((best_parent, temp_node))\n\n            # Rewire neighbors to possibly improve cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = temp_node.cost + dist(temp_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(temp_node.position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(temp_node, cost_through_new)\n                    edges.append((temp_node, near_node))\n\n            # Check goal proximity and connectivity\n            if dist(temp_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(temp_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=temp_node, cost=temp_node.cost + dist(temp_node.position, goal_position))\n                    temp_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((temp_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = goal_node.path() if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 82.84535,
          "time_improvement": -228.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.061753582954406736,
                    "num_nodes_avg": 420.6,
                    "path_length_avg": 169.20056187137845,
                    "smoothness_avg": 0.009821549286866758,
                    "success_improvement": 0.0,
                    "time_improvement": -148.69709577035007,
                    "length_improvement": 7.258490883819664,
                    "smoothness_improvement": 53.72857417510504,
                    "objective_score": -42.888787683465566
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.4377663850784302,
                    "num_nodes_avg": 1521.7,
                    "path_length_avg": 262.16725350778154,
                    "smoothness_avg": 0.004783214453124576,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -170.03772622572728,
                    "length_improvement": 12.481024713113289,
                    "smoothness_improvement": 23.075553089009492,
                    "objective_score": -98.39973515965048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2237252712249756,
                    "num_nodes_avg": 905.2,
                    "path_length_avg": 133.49716828412363,
                    "smoothness_avg": 0.012182274526916389,
                    "success_improvement": 0.0,
                    "time_improvement": -365.9660744257183,
                    "length_improvement": 11.337537277721248,
                    "smoothness_improvement": 54.957632780406904,
                    "objective_score": -107.24752670826922
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized unidirectional RRT* planner with goal biasing, dynamic neighbor radius scaling, and incremental rewiring for continuous path cost improvement. It balances exploration and exploitation by sampling the goal periodically and rewires nodes within an adaptive radius to reduce path cost, ensuring path feasibility with comprehensive collision checks. Post-path extraction reverses from goal to start to generate the final route.",
          "planning_mechanism": "The planner incrementally grows a single tree from the start position by sampling points within the map bounds with goal biasing. For each sample, it extends the nearest node toward it by a capped step size, checks for obstacle-free nodes and edges, selects the best parent from nearby nodes within an adaptively computed radius based on node count, and reconnects neighbors if the new node offers lower-cost paths. The iteration continues until reaching the goal vicinity or exhausting the iteration budget, then extracts the optimal path by following parents back from the goal node.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D coordinates)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=3.5, goal_sample_rate: float=0.1, neighbor_factor: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(val, self.step_size * 1.5)\n\n        def near_nodes(nodes_list, pos, radius):\n            return [node for node in nodes_list if dist(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node to sample\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_position = steer(nearest_node.position, sample)\n\n            if not is_in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Search neighbors within dynamic radius\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes_list = near_nodes(nodes, new_position, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            # Select best parent from neighbors with lower cost and collision-free edges\n            for near_node in near_nodes_list:\n                cost_through_near = near_node.cost + dist(near_node.position, new_position)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            # Create new node and attach to best parent\n            new_node = Node(new_position)\n            new_node.update_parent(best_parent, min_cost)\n\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for near_node in near_nodes_list:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node is close enough to goal to attempt connection\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist(new_node.position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 86.87575,
          "time_improvement": -132.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 54.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.047580623626708986,
                    "num_nodes_avg": 356.2,
                    "path_length_avg": 171.23258663531186,
                    "smoothness_avg": 0.009910461746880914,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -91.61905017950399,
                    "length_improvement": 6.14470591121484,
                    "smoothness_improvement": 55.12024725082378,
                    "objective_score": -75.9811726353541
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.3992518663406372,
                    "num_nodes_avg": 1426.5,
                    "path_length_avg": 254.6442921616143,
                    "smoothness_avg": 0.005642258213884707,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -146.27991059361005,
                    "length_improvement": 14.992405746900078,
                    "smoothness_improvement": 45.1793677975787,
                    "objective_score": -90.6595951897151
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.1234858512878418,
                    "num_nodes_avg": 703.9,
                    "path_length_avg": 128.96257314567478,
                    "smoothness_avg": 0.012595959850441435,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -157.1914073750385,
                    "length_improvement": 14.34919945446243,
                    "smoothness_improvement": 60.219679560571194,
                    "objective_score": -93.98648392381618
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm combines a bidirectional approach with an adaptive dynamic step size and velocity heuristic to accelerate path convergence and improve path quality while maintaining robustness. It adaptively adjusts the step size based on obstacle proximity and node density, uses informed sampling biased towards the direction of the goal, and incorporates a lazy collision checking strategy to reduce unnecessary computation. The path smoothing is done after path extraction using shortcutting to enhance path smoothness and reduce length.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, but unlike basic bidirectional RRT, it adapts step size dynamically to safely push further in open spaces and slow down near obstacles. Sampling is biased toward the line connecting start and goal to improve success rate and reduce exploration in irrelevant areas. Lazy collision checks delay edge checking to critical phases to reduce overhead. Once the trees connect, the final path is shortcut-smoothed by attempting direct connections between non-adjacent nodes for efficiency and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # Collision valid flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step_size: float = 5.0, min_step_size: float = 1.0, max_step_size: float = 10.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def adaptive_step_size(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            test_pos = self._steer(from_pos, to_pos, self.base_step_size)\n            dist_to_obs = self._distance_to_nearest_obstacle(test_pos, obstacles, is_3d)\n            if dist_to_obs is None:\n                # No obstacles nearby, increase step to max\n                step = min(self.max_step_size, dist)\n            else:\n                # Decrease step size near obstacles\n                step = max(self.min_step_size, min(dist_to_obs * 0.5, dist, self.max_step_size))\n            return step\n\n        def sample_biased():\n            # 80% samples biased towards line start-goal, 20% uniform random\n            alpha = 0.8\n            dim = len(bounds)\n            if random.random() < alpha:\n                # Sample near the line with added noise orthogonal to line direction\n                dir_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n                norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n                if norm_dir < 1e-6:\n                    # Start==Goal rare case, sample uniform\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                unit_dir = tuple(x / norm_dir for x in dir_vec)\n                t = random.uniform(0, 1)\n                base_point = tuple(start_position[d] + t * dir_vec[d] for d in range(dim))\n                # noise perpendicular to direction vector\n                noise_mag = self.base_step_size * 1.5\n                # Create a random vector perpendicular to unit_dir\n                perp_noise = []\n                for d in range(dim):\n                    aligned = sum(unit_dir[i] * (random.random()*2-1) for i in range(dim))\n                    val = (random.random()*2 - 1) - aligned*unit_dir[d]\n                    perp_noise.append(val)\n                norm_noise = math.sqrt(sum(x*x for x in perp_noise))\n                if norm_noise > 1e-9:\n                    perp_noise = tuple(noise_mag * x / norm_noise for x in perp_noise)\n                else:\n                    perp_noise = tuple(0.0 for _ in range(dim))\n                sample = tuple(base_point[d] + perp_noise[d] for d in range(dim))\n                # Clamp sample inside bounds\n                sample = tuple(max(0, min(bounds[d], sample[d])) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                else:\n                    # fallback uniform sample if inside obstacle\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for iteration in range(self.max_iter):\n            # Alternate growing trees, but start tree always samples biased\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            rand_point = sample_biased()\n\n            nearest_node_a = min(tree_a, key=lambda n: distance(n.position, rand_point))\n\n            # Compute adaptive step size\n            step = adaptive_step_size(nearest_node_a.position, rand_point)\n\n            new_pos = self._steer(nearest_node_a.position, rand_point, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy edge check with direct edge validation before addition (edge check deferred till tight)\n            if self._is_edge_in_obstacle(nearest_node_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_a = Node(new_pos, parent=nearest_node_a)\n            nearest_node_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_node_a, new_node_a))\n\n            # Try connecting the other tree to new_node_a directly with incremental steps\n            connect_node_b = min(tree_b, key=lambda n: distance(n.position, new_node_a.position))\n            connect_dist = distance(connect_node_b.position, new_node_a.position)\n\n            step_b = adaptive_step_size(connect_node_b.position, new_node_a.position)\n            last_pos = connect_node_b.position\n            connected = False\n            while True:\n                if connect_dist <= step_b:\n                    candidate_pos = new_node_a.position\n                else:\n                    candidate_pos = self._steer(last_pos, new_node_a.position, step_b)\n\n                if self._is_in_obstacle(candidate_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(last_pos, candidate_pos, obstacles, is_3d):\n                    break\n\n                new_node_b = Node(candidate_pos, parent=None)\n                # Link properly with tree_b structure\n                if last_pos == connect_node_b.position:\n                    connect_node_b.add_child(new_node_b)\n                else:\n                    parent_node = tree_b[-1]  # last inserted node in tree_b (safe as we append each step)\n                    parent_node.add_child(new_node_b)\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((new_node_b.parent, new_node_b))\n\n                last_pos = candidate_pos\n                connect_dist = distance(last_pos, new_node_a.position)\n                if connect_dist <= self.min_step_size:\n                    # Trees connected\n                    connected = True\n                    break\n                # adapt step size for next segment\n                step_b = adaptive_step_size(last_pos, new_node_a.position)\n\n            if connected:\n                # Reconstruct path from start_root to new_node_a then new_node_b to goal\n                # Tree A: new_node_a -> root\n                path_a = []\n                node = new_node_a\n                while node is not None:\n                    path_a.append(node.position)\n                    node = node.parent\n                path_a = path_a[::-1]\n\n                # Tree B: new_node_b -> root (goal)\n                path_b = []\n                node = new_node_b\n                while node is not None:\n                    path_b.append(node.position)\n                    node = node.parent\n\n                combined_path = path_a + path_b\n\n                # Shortcut smoothing on combined path\n                smoothed_path = self._shortcut_smooth(combined_path, obstacles, is_3d)\n\n                extracted_path = smoothed_path\n                success_state = True\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance_to_nearest_obstacle(self, pos, obstacles, is_3d, search_radius=10.0, resolution=0.5):\n        # Approximate distance to nearest obstacle using sampled points in neighborhood\n        # Return None if no obstacle in radius\n        min_dist = None\n        dim = len(pos)\n        steps = max(1, int(search_radius / resolution))\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                # Closest point in box to pos\n                cx = max(ox, min(pos[0], ox + w))\n                cy = max(oy, min(pos[1], oy + h))\n                cz = max(oz, min(pos[2], oz + d))\n                dist = math.dist(pos, (cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                cx = max(ox, min(pos[0], ox + w))\n                cy = max(oy, min(pos[1], oy + h))\n                dist = math.dist(pos, (cx, cy))\n            if dist <= search_radius:\n                if (min_dist is None) or (dist < min_dist):\n                    min_dist = dist\n        return min_dist\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_trials=100):\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # remove nodes between i+1 and j-1\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 87.9137,
          "time_improvement": -180.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2714.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03528840541839599,
                    "num_nodes_avg": 265.2,
                    "path_length_avg": 150.53022446227038,
                    "smoothness_avg": 0.025798357332320054,
                    "success_improvement": 0.0,
                    "time_improvement": -42.115218616566196,
                    "length_improvement": 17.491998668180383,
                    "smoothness_improvement": 303.8003142804197,
                    "objective_score": -7.617164279931682
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09829518795013428,
                    "num_nodes_avg": 724.5,
                    "path_length_avg": 258.25522538315045,
                    "smoothness_avg": 0.11670420049265859,
                    "success_improvement": 0.0,
                    "time_improvement": 39.3662694127845,
                    "length_improvement": 13.786972302601356,
                    "smoothness_improvement": 2902.8831373140447,
                    "objective_score": 29.081690970925845
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.3059559345245361,
                    "num_nodes_avg": 1399.1,
                    "path_length_avg": 140.90972647432935,
                    "smoothness_avg": 0.3959351063662842,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -537.2328212054701,
                    "length_improvement": 6.414469075876875,
                    "smoothness_improvement": 4936.26532808959,
                    "objective_score": -285.20562590601776
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a goal-biased unidirectional RRT* planner with adaptive neighbor radius based on node count and dimension. It incrementally builds a single tree from the start to the goal, rewiring locally to optimize path cost and smoothness, while ensuring collision-free node and edge placements. The planner balances exploration and exploitation to efficiently find and refine high-quality feasible paths within map constraints.",
          "planning_mechanism": "The planner samples points biased towards the goal, extends the nearest node incrementally towards the sample within step limits and map bounds, then finds neighbors within a dynamically computed radius to select the best parent and rewire suboptimal neighbors. It continues iterations until it successfully connects to the goal or reaches the iteration limit, then extracts the optimal path by tracing from the goal node back to the start.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal to bias tree growth\n        self.neighbor_factor = neighbor_factor    # Multiplier for adaptive neighbor radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: list[Node] = [Node(start_position)]\n        edges: list[tuple[Node, Node]] = []\n        success_state = False\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(dim)\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.8)\n\n        def nearby_nodes(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if new_pos is None:\n                continue\n\n            # Collision checks - node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node without assigned parent yet\n            new_node = Node(new_pos)\n\n            # Find neighbors within adaptive radius\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent based on minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if (temp_cost < min_cost and\n                    not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if shorter path found through new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edges\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if can connect directly to goal\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state and goal_node is not None:\n            extracted_path = goal_node.path()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 91.61806,
          "time_improvement": -269.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 532.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04587178230285645,
                    "num_nodes_avg": 277.4,
                    "path_length_avg": 164.5355491151085,
                    "smoothness_avg": 0.013942328972383417,
                    "success_improvement": 0.0,
                    "time_improvement": -84.73711954418755,
                    "length_improvement": 9.81545829738883,
                    "smoothness_improvement": 118.22772466975222,
                    "objective_score": -22.866905580429737
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2560333251953125,
                    "num_nodes_avg": 1055.8,
                    "path_length_avg": 241.25080706466778,
                    "smoothness_avg": 0.008030908674216396,
                    "success_improvement": 0.0,
                    "time_improvement": -57.93505241698157,
                    "length_improvement": 19.46353658235415,
                    "smoothness_improvement": 106.64106461729752,
                    "objective_score": -12.954603085537151
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.3673215866088867,
                    "num_nodes_avg": 969.2,
                    "path_length_avg": 123.2964615601171,
                    "smoothness_avg": 0.11568754781896344,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -665.0427545659493,
                    "length_improvement": 18.112360978350164,
                    "smoothness_improvement": 1371.5370690906886,
                    "objective_score": -239.03266882866131
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a goal-biased, single-tree RRT* algorithm with rewiring to efficiently find and optimize a feasible path. It combines informed sampling within the ellipsoidal subset defined by the current best path cost, adaptive neighbor search for rewiring, and rigorous collision checking to improve planning efficiency, path quality, and robustness. Path smoothing is applied by rewiring nearby nodes during expansion, leading to shorter and smoother paths with faster convergence and higher success rates.",
          "planning_mechanism": "The planner grows a single tree from the start position, sampling points biased toward the goal and within an informed subset once a solution is found. For each sample, it finds the nearest node to steer towards, adds the new node if collision-free, then rewires neighbor nodes to improve path cost locally. The process iterates until the goal is reached or max iterations run out, and the best path is extracted from root to goal, producing a smooth, high-quality path while minimizing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius      # Radius to search neighbors for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        dim = len(bounds)\n        dist = lambda a,b: math.dist(a,b)\n\n        # Ellipsoidal informed sampling helper when path found\n        def informed_sample():\n            c_min = dist(start_position, goal_position)\n            c_best = best_cost\n\n            if c_best == float('inf'):\n                # No path found yet, uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute unit vector from start to goal\n            start_goal_vec = [goal_position[d] - start_position[d] for d in range(dim)]\n            norm_start_goal = math.sqrt(sum(x*x for x in start_goal_vec))\n            if norm_start_goal < 1e-8:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            unit_vec = [x / norm_start_goal for x in start_goal_vec]\n\n            # Compute rotation matrix from unit vector to first axis (only works for 2D/3D)\n            # We will generate sample in canonical unit ball and transform:\n            # Scale ellipsoid axes lengths\n            a1 = c_best / 2.0\n            a2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[unit_vec[0], -unit_vec[1]],\n                     [unit_vec[1],  unit_vec[0]]]  # rotation matrix to align x-axis with unit_vec\n            elif dim == 3:\n                # 3d rotation matrix using unit_vec as z axis\n                ux, uy, uz = unit_vec\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    # unit_vec aligned with z-axis\n                    L = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [-uy, ux, 0]\n                    norm_vx = math.sqrt(vx[0]**2 + vx[1]**2 + vx[2]**2)\n                    vx = [x / norm_vx for x in vx]\n                    vy = [unit_vec[1]*vx[2] - unit_vec[2]*vx[1],\n                          unit_vec[2]*vx[0] - unit_vec[0]*vx[2],\n                          unit_vec[0]*vx[1] - unit_vec[1]*vx[0]]\n                    L = [vx, vy, unit_vec]\n            else:\n                # Fallback: uniform random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample a random point in unit ball\n            while True:\n                rnd = [random.uniform(-1,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd <= 1:\n                    break\n            # Scale along ellipsoid axes\n            if dim == 2:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1]]\n                # Rotate back and translate to center\n                sample = [start_position[d] + 0.5*(start_position[d]+goal_position[d]) - start_position[d] for d in range(dim)]  # midpoint\n                # Rotate canonical sample:\n                x = L[0][0]*sample_canonical[0] + L[0][1]*sample_canonical[1]\n                y = L[1][0]*sample_canonical[0] + L[1][1]*sample_canonical[1]\n                sample = (0.5*(start_position[0] + goal_position[0]) + x,\n                          0.5*(start_position[1] + goal_position[1]) + y)\n                # Clamp inside bounds\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            elif dim == 3:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1], a2 * rnd[2]]\n                # Rotate back\n                x = sum(L[0][i] * sample_canonical[i] for i in range(3))\n                y = sum(L[1][i] * sample_canonical[i] for i in range(3))\n                z = sum(L[2][i] * sample_canonical[i] for i in range(3))\n                sample = (0.5*(start_position[0] + goal_position[0]) + x,\n                          0.5*(start_position[1] + goal_position[1]) + y,\n                          0.5*(start_position[2] + goal_position[2]) + z)\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(3))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n            # Fallback uniform sample if informed sample in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample() -> Tuple[float, ...]:\n            # Goal biasing sampling: with probability goal_sample_rate sample goal, else informed or uniform\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if best_goal_node is None:\n                # No path found, uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # informed sample\n            return informed_sample()\n\n        def nearest_node(point: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def nearby_nodes(new_node: Node) -> List[Node]:\n            r = self.neighbor_radius\n            return [n for n in nodes if dist(n.position, new_node.position) <= r]\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        for iteration in range(self.max_iter):\n            rnd_point = sample()\n            nearest = nearest_node(rnd_point)\n            new_pos = steer(nearest.position, rnd_point, self.step_size)\n\n            # Boundary clamp\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Determine cost to new node via nearest\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            # Rewire nearby nodes to new_node if it improves cost and edge is obstacle free\n            neighbors = nearby_nodes(new_node)\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n\n            # Check if new node can update best goal connection\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    cost_through_new = new_node.cost + dist_to_goal\n                    if cost_through_new < best_cost:\n                        best_cost = cost_through_new\n                        goal_node = Node(goal_position, parent=new_node, cost=cost_through_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        best_goal_node = goal_node\n                        success_state = True\n\n            if success_state:\n                # Early stop option enabled - break if goal found and no bettering in 500 iterations\n                # For simplicity, just break here after first found path.\n                break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            extracted_path = []\n\n        # Return all nodes and edges (parent-child)\n        edges = []\n        for node in nodes:\n            if node.parent is not None:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 127.67695,
          "time_improvement": -383.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 475.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06704170703887939,
                    "num_nodes_avg": 415.4,
                    "path_length_avg": 184.35859921574527,
                    "smoothness_avg": 0.008057359207520117,
                    "success_improvement": 0.0,
                    "time_improvement": -169.99369167560423,
                    "length_improvement": -1.0498695791002604,
                    "smoothness_improvement": 26.115168433255526,
                    "objective_score": -51.077505576335035
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5553471088409424,
                    "num_nodes_avg": 1681.1,
                    "path_length_avg": 254.67720012963406,
                    "smoothness_avg": 0.007639532331288179,
                    "success_improvement": 0.0,
                    "time_improvement": -242.5678070520923,
                    "length_improvement": 14.98142011997174,
                    "smoothness_improvement": 96.57066941676904,
                    "objective_score": -69.29120474454949
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.40188016891479494,
                    "num_nodes_avg": 1040.0,
                    "path_length_avg": 136.05661202392085,
                    "smoothness_avg": 0.11032008387859223,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -737.0199918562732,
                    "length_improvement": 9.637676613361911,
                    "smoothness_improvement": 1303.2633239541433,
                    "objective_score": -262.6621456144389
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a goal-biased, unidirectional RRT* planner with optimized parameters for step size, neighbor radius, and rewiring to improve planning efficiency, path quality, and success rate. It incrementally expands a single tree from the start position toward the goal while dynamically rewiring nearby nodes to improve path cost and smoothness. The planner performs collision checks for nodes and edges to ensure feasibility and avoids sampling outside the map boundaries.",
          "planning_mechanism": "The planner samples points within map bounds with goal biasing, extends the nearest node toward the sample within a fixed step size, and checks for collisions. It finds neighbors within a defined radius to select the best parent minimizing path cost. Then, it rewires neighbors to the new node if a shorter collision-free path is found. The search stops once the tree can connect to the goal within step size, extracting an optimized path by following parent links.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Path cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if (random.random() < self.goal_sample_rate):\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            dir_vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n\n            unit_vec = tuple(d / dist_to_sample for d in dir_vec)\n            new_pos = tuple(nearest_node.position[d] + unit_vec[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Find neighbors within radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + collision free\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in neighbors:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if path via new_node is better\n            for near_node in neighbors:\n                if near_node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_via_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal is reachable\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and\n                        not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    current = goal_node\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 131.68634,
          "time_improvement": -344.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 212.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.8,
                    "time_avg": 0.10539586544036865,
                    "num_nodes_avg": 395.5,
                    "path_length_avg": 163.95521428817673,
                    "smoothness_avg": 0.017201523595419013,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -324.4554629417147,
                    "length_improvement": 10.13354901202394,
                    "smoothness_improvement": 169.2411979746618,
                    "objective_score": -194.4637230902363
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2898753881454468,
                    "num_nodes_avg": 1169.6,
                    "path_length_avg": 226.15987264719524,
                    "smoothness_avg": 0.013356658003419822,
                    "success_improvement": 0.0,
                    "time_improvement": -78.8106473492076,
                    "length_improvement": 24.50132485936948,
                    "smoothness_improvement": 243.6764308398919,
                    "objective_score": -17.524547078688922
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.35038979053497316,
                    "num_nodes_avg": 1134.3,
                    "path_length_avg": 114.79628220523088,
                    "smoothness_avg": 0.02533151601605695,
                    "success_improvement": 0.0,
                    "time_improvement": -629.777884815922,
                    "length_improvement": 23.757775370820923,
                    "smoothness_improvement": 222.21501394622854,
                    "objective_score": -183.0707353008813
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a unidirectional informed RRT* planner with goal biasing, adaptive step size, fixed neighbor radius rewiring, and path shortcut smoothing. It focuses on incremental path cost optimization using rewiring and heuristically guided sampling to improve planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner incrementally grows a single tree from the start towards the goal by sampling points biased towards the goal position. Each new node is collision-checked and added if valid. Nearby nodes within a fixed radius are rewired to reduce path costs locally. An informed sampling ellipsoid restricts sampling space after an initial solution for faster convergence. After planning, a shortcut smoothing postprocess further refines path smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n    \n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start)]\n        edges = []\n        success_state = False\n        extracted_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        # Precompute goal sampling frequency for convenience\n        for i in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            elif c_best == float(\"inf\"):\n                # Uniform random sampling (before any solution)\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Informed sampling within ellipsoid:\n                sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = self._steer(nearest.position, sample, self.step_size, bounds)\n\n            # Check if new position is outside bounds or invalid\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost > c_best:\n                # Prune, since this is already worse than best cost found\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring: find nearby nodes within neighbor_radius to attempt cost improvement\n            near_nodes = [n for n in nodes if n != new_node and math.dist(n.position, new_node.position) <= self.neighbor_radius]\n\n            for near in near_nodes:\n                # Potential cost if rewiring near node to come via new_node\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    # Check edge collisions before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly:\n                        # Remove old edge:\n                        for e in edges:\n                            if e[1] == near:\n                                edges.remove(e)\n                                break\n                        edges.append((new_node, near))\n\n            # Check if near goal within step_size and collision-free edge\n            if math.dist(new_node.position, goal) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, new_node, new_node.cost + math.dist(new_node.position, goal))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n                        # After finding initial path, break early or continue to optimize further\n                        # Here, break to prioritize fast planning\n                        break\n\n        # If found path, apply shortcut smoothing to improve path smoothness\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import random\n        # Ellipsoid centered between start and goal\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))  # fallback uniform\n\n        a1 /= norm_a1\n\n        # Create rotation matrix C via SVD\n        identity = np.eye(dim)\n        M = np.outer(a1, identity[0])\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0.0\n        else:\n            r2 = np.sqrt(c_best**2 - c_min**2) / 2.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            radius = random.random() ** (1 / dim)\n            x_rand = C @ (L @ (x_ball * radius)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos, step_size, bounds):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n        # Clamp to bounds just in case\n        clamped = tuple(min(max(new_pos[d], 0), bounds[d]) for d in range(len(from_pos)))\n        return clamped\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds, max_attempts=100):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = list(path)\n        for _ in range(max_attempts):\n            if len(smoothed) < 3:\n                break\n            # Randomly pick two indices i,j with j>i+1 to try shortcut\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # Shortcut valid: remove intermediate points between i and j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
          "objective": 133.78862,
          "time_improvement": -366.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1162.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.17765846252441406,
                    "num_nodes_avg": 520.2,
                    "path_length_avg": 168.10868557274432,
                    "smoothness_avg": 0.03834104563059086,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -615.4749822608381,
                    "length_improvement": 7.856965584988183,
                    "smoothness_improvement": 500.1206230319388,
                    "objective_score": -230.57049844609412
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6534616947174072,
                    "num_nodes_avg": 1553.4,
                    "path_length_avg": 227.00970381673514,
                    "smoothness_avg": 0.07996220199968115,
                    "success_improvement": 0.0,
                    "time_improvement": -303.0901326183018,
                    "length_improvement": 24.217626753943122,
                    "smoothness_improvement": 1957.4850518979115,
                    "objective_score": -76.29608917521237
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.13442726135253907,
                    "num_nodes_avg": 631.2,
                    "path_length_avg": 117.75349076966356,
                    "smoothness_avg": 0.08861538033418422,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -179.97973999662335,
                    "length_improvement": 21.793738249464266,
                    "smoothness_improvement": 1027.1810969438395,
                    "objective_score": -94.49926886437494
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines informed sampling focusing search within an ellipsoidal subset for faster convergence, goal-biased sampling for directed exploration, adaptive neighbor radius based on node count and dimension for scalable rewiring, and clean rewiring operations via a robust Node structure. It incrementally builds a single tree from start to goal, continuously improving path quality through local rewiring and pruning while ensuring collision-free sampling and edge connections to enhance efficiency, path smoothness, and success rate.",
          "planning_mechanism": "The planner samples either the goal or within an informed ellipsoid defined by the current best path cost and start-goal positions, steering incrementally towards samples with bounded step size. It dynamically adapts neighbor radius for rewiring nearby nodes to optimize cost and path smoothness. Collision checks for nodes and edges guard map constraints. The process iterates until a feasible path is found or iteration limit is reached; the resulting path is extracted by tracing back from the goal node.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_factor: float = 40.0, resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.resolution = resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                          # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start                 # Tuple[float, ...]\n        goal_position = map.goal                   # Tuple[float, ...]\n        obstacles = map.obstacles                  # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = [Node(start_position)]\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        goal_node = None\n\n        best_cost = float('inf')\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            direction = np.array(to_pos) - np.array(from_pos)\n            length = np.linalg.norm(direction)\n            if length == 0:\n                return None\n            step = min(self.step_size, length)\n            new_pos = np.array(from_pos) + direction / length * step\n            # Clamp within bounds\n            clamped = np.minimum(np.maximum(new_pos, np.zeros(dim)), np.array(bounds))\n            return tuple(clamped.tolist())\n\n        def neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 2.0)\n\n        def nearby_nodes(nodes_list: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        def informed_sample() -> Tuple[float, ...]:\n            # If no path found yet, sample uniformly\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipse parameters for informed sampling\n            start = np.array(start_position)\n            goal = np.array(goal_position)\n            c_best = best_cost\n            c_min = np.linalg.norm(goal - start)\n            if c_min == 0:\n                return tuple(goal)\n\n            # Unit vector from start to goal\n            e1 = (goal - start) / c_min\n\n            # Create rotation matrix C that aligns x1 to e1\n            I = np.eye(dim)\n            M = np.outer(e1, np.array([1] + [0]*(dim-1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*dim) @ Vt\n\n            # Sample uniformly in unit n-ball\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball = x_ball / norm_x * (random.random() ** (1.0/dim))\n                # Scale by ellipse axis lengths\n                L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                sample = C @ L @ x_ball + (start + goal)/2\n                # Check if inside bounds\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample.tolist())\n\n        for iter in range(self.max_iter):\n            # Sampling with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = informed_sample()\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if new_pos is None:\n                continue\n\n            # Collision checks - node inside obstacle\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision between nearest and new_pos\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            # Create new node without parent yet\n            new_node = Node(new_pos)\n\n            # Adaptive neighbor radius for rewiring\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent minimizing cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_try = near.cost + dist(near.position, new_pos)\n                if cost_try < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d, self.resolution):\n                        min_cost = cost_try\n                        best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cheaper path found through new_node\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_via_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.resolution):\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                        near.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, near))\n\n            # Check if new_node can connect to goal with collision-free edge and node\n            dist_goal = dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.resolution)):\n                    candidate_goal = Node(goal_position)\n                    candidate_goal.update_parent(new_node, new_node.cost + dist_goal)\n\n                    if candidate_goal.cost < best_cost:\n                        best_cost = candidate_goal.cost\n                        goal_node = candidate_goal\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n\n            # Optional early break for efficiency if path improved substantially\n            if success_state and iter > self.max_iter * 0.1 and iter % 100 == 0:\n                # Try pruning or early return could be implemented here\n                break\n\n        extracted_path = []\n        if success_state and goal_node is not None:\n            extracted_path = goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 151.35178,
          "time_improvement": -463.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 173.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.19072988033294677,
                    "num_nodes_avg": 576.9,
                    "path_length_avg": 169.19012036614683,
                    "smoothness_avg": 0.01617799168881279,
                    "success_improvement": 0.0,
                    "time_improvement": -668.1168451464789,
                    "length_improvement": 7.264214038293357,
                    "smoothness_improvement": 153.22070100116474,
                    "objective_score": -198.21610723127918
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.31413612365722654,
                    "num_nodes_avg": 1053.6,
                    "path_length_avg": 234.28898211237674,
                    "smoothness_avg": 0.011166425374508106,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -93.77596692940111,
                    "length_improvement": 21.7875941364495,
                    "smoothness_improvement": 187.32016773719636,
                    "objective_score": -72.83867041284445
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3489565849304199,
                    "num_nodes_avg": 945.6,
                    "path_length_avg": 119.3520899274594,
                    "smoothness_avg": 0.021869344300404676,
                    "success_improvement": 0.0,
                    "time_improvement": -626.792861328222,
                    "length_improvement": 20.732024805967978,
                    "smoothness_improvement": 178.17644527406495,
                    "objective_score": -183.00057121090268
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a unidirectional, asymptotically optimal RRT*-style planner that improves planning efficiency and path quality by employing goal-biased sampling, rewiring to optimize local path costs, adaptive step sizing, and rigorous collision checking for both nodes and connecting edges. It builds and continually improves a single tree towards the goal within bounded free space.",
          "planning_mechanism": "The planner iteratively samples points biased towards the goal, extends the tree toward these samples with adaptive step sizes, rejects samples inside obstacles, and only adds edges that do not intersect obstacles. It rewires nearby nodes to reduce path cost, updating parent-child relationships accordingly, thus continuously refining the path towards an optimal solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_pos)]\n        edges = []\n        success = False\n        best_goal_node = None\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        for _ in range(self.max_iter):\n            rnd = sample()\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, rnd))\n            new_pos = steer(nearest.position, rnd)\n\n            # Bound check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes for cost improvement\n            neighbor_nodes = [n for n in nodes \n                              if n != new_node and math.dist(n.position, new_node.position) <= self.neighbor_radius]\n\n            for near in neighbor_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # Update edges list accordingly\n                        # Remove old edge(s)\n                        edges = [(p, c) for (p, c) in edges if c != near]\n                        edges.append((new_node, near))\n\n            # Check if goal reached\n            if math.dist(new_node.position, goal_pos) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, new_node, new_node.cost + math.dist(new_node.position, goal_pos))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    best_goal_node = goal_node\n                    break\n\n        path = []\n        if success and best_goal_node is not None:\n            path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 164.71387,
          "time_improvement": -447.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04162766933441162,
                    "num_nodes_avg": 359.5,
                    "path_length_avg": 173.36681203058686,
                    "smoothness_avg": 0.007998617059213408,
                    "success_improvement": 0.0,
                    "time_improvement": -67.6450170478386,
                    "length_improvement": 4.974903153099051,
                    "smoothness_improvement": 25.1957262516388,
                    "objective_score": -19.17254585247358
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.609927749633789,
                    "num_nodes_avg": 1622.3,
                    "path_length_avg": 256.2429826903963,
                    "smoothness_avg": 0.007767840664918752,
                    "success_improvement": 0.0,
                    "time_improvement": -276.23606628356083,
                    "length_improvement": 14.458716832637192,
                    "smoothness_improvement": 99.87213525784088,
                    "objective_score": -79.47971584225161
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.5261727094650268,
                    "num_nodes_avg": 1260.1,
                    "path_length_avg": 128.32960562860777,
                    "smoothness_avg": 0.012959332698074973,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -995.8915394623153,
                    "length_improvement": 14.769586340624134,
                    "smoothness_improvement": 64.8417553610762,
                    "objective_score": -395.4893357937644
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a goal-biased, unidirectional RRT* planner with adaptive neighbor radius and adaptive step size based on obstacle proximity. It incrementally builds a single tree from start to goal while rewiring locally to optimize path cost, incorporates obstacle-aware step adjustments for safer expansions, and performs aggressive pruning of suboptimal nodes to improve planning efficiency and path quality. The planner includes shortcut smoothing on the extracted path to produce smoother and shorter final routes.",
          "planning_mechanism": "The planner samples points with goal bias, adapts step sizes near obstacles to enable finer expansions in cluttered areas, and grows a single tree using rewiring with an adaptive neighbor radius computed from node counts and map dimension. It prunes nodes that cannot lead to better solutions to reduce search space and applies shortcut smoothing on the final path. Collision and edge checks ensure safety before node or edge additions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\n\n    def is_descendant_of(self, ancestor):\n        node = self.parent\n        while node:\n            if node == ancestor:\n                return True\n            node = node.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_factor: float = 35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_position)]\n        edges = []\n        success_state = False\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step_clamped = min(step, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step_clamped for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d], new_pos[d]))\n                for d in range(dim)\n            )\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.5)\n\n        def nearby_nodes(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        def adaptive_step(from_pos, to_pos):\n            # Reduce step size if obstacles are near the line segment\n            resolution = 0.3\n            dist_full = dist(from_pos, to_pos)\n            steps = max(2, int(dist_full))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def prune_nodes(c_best):\n            # Remove nodes that cannot achieve better cost than current best path\n            pruned = []\n            for node in nodes[:]:\n                est_to_goal = dist(node.position, goal_position)\n                if node.cost + est_to_goal >= c_best:\n                    # Remove from parent's children list if connected\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    nodes.remove(node)\n                    pruned.append(node)\n            # Clean edges for pruned nodes\n            edges[:] = [(p, c) for (p, c) in edges if p in nodes and c in nodes]\n\n        def shortcut_smoothing(path):\n            # Attempt to shortcut between non-adjacent nodes if line is obstacle-free\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        c_best = float(\"inf\")\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n            if new_pos is None:\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node without assigned parent yet\n            new_node = Node(new_pos)\n\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent by minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                # Avoid cycles\n                if near_node.is_descendant_of(new_node):\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.parent.remove_child(near_node)\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    path = goal_node.path()\n                    path = shortcut_smoothing(path)\n                    c_best = goal_node.cost\n                    extracted_path = path\n                    prune_nodes(c_best)\n                    break\n\n            # Occasionally prune nodes with high costs to improve efficiency\n            if _ % 100 == 0 and success_state:\n                prune_nodes(c_best)\n\n        if success_state and goal_node and not extracted_path:\n            # If path found but no smoothing before break, perform smoothing now\n            extracted_path = shortcut_smoothing(goal_node.path())\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 266.54382,
          "time_improvement": -872.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1591.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.42328734397888185,
                    "num_nodes_avg": 333.7,
                    "path_length_avg": 164.858207961629,
                    "smoothness_avg": 0.05420862316105281,
                    "success_improvement": 0.0,
                    "time_improvement": -1604.6838108424445,
                    "length_improvement": 9.638603870754327,
                    "smoothness_improvement": 748.482668379779,
                    "objective_score": -475.7350091366835
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.6723801374435425,
                    "num_nodes_avg": 1016.5,
                    "path_length_avg": 227.74479629149204,
                    "smoothness_avg": 0.1036553096883434,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -314.76004020287337,
                    "length_improvement": 23.97223172740555,
                    "smoothness_improvement": 2567.125778182868,
                    "objective_score": -126.79793682446655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.38209807872772217,
                    "num_nodes_avg": 519.9,
                    "path_length_avg": 117.77962512350211,
                    "smoothness_avg": 0.12251345895791133,
                    "success_improvement": 0.0,
                    "time_improvement": -695.8186431756562,
                    "length_improvement": 21.776381056028892,
                    "smoothness_improvement": 1458.3621549417553,
                    "objective_score": -197.09850596678228
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 798.7637678809918,
          "time_improvement": -2679.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.090405321121216,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "smoothness_avg": 0.0150601233961907,
                    "success_improvement": 0.0,
                    "time_improvement": -4291.3344554533405,
                    "length_improvement": 15.280155580980631,
                    "smoothness_improvement": 135.72363473177828,
                    "objective_score": -1283.665687346147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.6918304920196534,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "smoothness_avg": 0.011376062771551485,
                    "success_improvement": 0.0,
                    "time_improvement": -943.6115581201832,
                    "length_improvement": 23.354217616048047,
                    "smoothness_improvement": 192.71428895883628,
                    "objective_score": -277.44905246805115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.3928252696990966,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "smoothness_avg": 0.01876598180493872,
                    "success_improvement": 0.0,
                    "time_improvement": -2800.9209363299597,
                    "length_improvement": 22.0310377661009,
                    "smoothness_improvement": 138.7019033981297,
                    "objective_score": -835.1765638287771
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines unidirectional RRT* with informed sampling and adaptive neighbor radius from the first algorithm, and introduces bidirectional tree growth with adaptive step size, pruning, and node rejection inspired by the second algorithm. It integrates goal biasing, robust rewiring with clean parent-child updates, adaptive step adjustment near obstacles, and dynamic pruning to accelerate convergence while maintaining path quality and smoothness. The planner also applies shortcut and spline smoothing on final paths for enhanced path smoothness and reduced length.",
          "planning_mechanism": "The planner grows and rewires two trees simultaneously from start and goal via adaptive informed sampling and step sizes. It adaptively adjusts neighbor radii and step size near obstacles, prunes nodes unlikely to improve current best path cost, and attempts direct connections between trees to quickly find and update improved paths. Once a solution is found, the path undergoes hybrid smoothing combining shortcut and spline techniques. The algorithm integrates bounding clamps to keep nodes inside the map and rigorously performs collision and edge checks before node and edge insertions, optimizing planning efficiency, success rate, and path smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, base_step: float=4.0,\n                 goal_sample_rate: float=0.2, min_radius: float=3.0, max_radius: float=20.0,\n                 shortcut_trials: int=75):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import numpy as np\n        bounds = map.size                   # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes_a: List[Node] = [Node(start_position)]\n        nodes_b: List[Node] = [Node(goal_position)]\n        nodes = [nodes_a[0], nodes_b[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        best_goal_node_a = None\n        best_goal_node_b = None\n        best_path = []\n        success_state = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def informed_sample(c_max):\n            if c_max == float('inf'):\n                # Uniform sample\n                while True:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dimension))\n            diff = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(diff)\n            if length < 1e-6:\n                return center\n            e1 = diff / length\n\n            # Rotation matrix that aligns first axis with e1\n            if dimension == 2:\n                angle = math.atan2(e1[1], e1[0])\n                U = np.array([[math.cos(angle), -math.sin(angle)],\n                              [math.sin(angle),  math.cos(angle)]])\n            else:\n                # 3D: create orthonormal basis\n                e1_v = e1\n                arbitrary = np.array([1, 0, 0]) if abs(e1_v[0]) < 0.9 else np.array([0, 1, 0])\n                e2_v = arbitrary - np.dot(arbitrary, e1_v) * e1_v\n                e2_v /= np.linalg.norm(e2_v)\n                e3_v = np.cross(e1_v, e2_v)\n                U = np.column_stack((e1_v, e2_v, e3_v))\n\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_min ** 2, 0)) / 2.0\n            radii = [r1] + [r2] * (dimension - 1)\n\n            while True:\n                if dimension == 2:\n                    sample = self._sample_unit_circle()\n                else:\n                    sample = self._sample_unit_ball(dimension)\n                sample_np = np.array(sample) * radii\n                rotated = U @ sample_np\n                point = tuple(rotated[d] + center[d] for d in range(dimension))\n                if within_bounds(point) and not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps_check = max(2, int(distance))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dimension))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacles\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                new_pos = to_pos\n            else:\n                ratio = step / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(dimension))\n            # Clamp inside bounds\n            clamped = tuple(\n                max(0.0, min(bounds[d_], new_pos[d_]))\n                for d_ in range(dimension)\n            )\n            return clamped\n\n        def dynamic_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt_star = 2 * (1 + 1 / dimension) ** (1 / dimension)\n            volume = 1.0\n            for b in bounds:\n                volume *= b\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dimension))\n            r_scaled = r * max(self.min_radius, min(self.max_radius, c_best / c_min))\n            return max(self.min_radius, min(r_scaled, self.max_radius))\n\n        def nearest_node(tree_nodes, pt):\n            return min(tree_nodes, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(tree_nodes, pt, radius):\n            return [n for n in tree_nodes if dist(n.position, pt) <= radius]\n\n        def shortcut_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def spline_smooth(path, num_points=100):\n            if is_3d or len(path) < 4:\n                return path\n            try:\n                from scipy.interpolate import splprep, splev\n                import numpy as np\n            except ImportError:\n                return path\n\n            coords = np.array(path).T  # (2,N)\n            tck, u = splprep(coords, s=1.0)\n            u_fine = np.linspace(0, 1, num_points)\n            smoothed_coords = splev(u_fine, tck)\n            smoothed_path = list(zip(smoothed_coords[0], smoothed_coords[1]))\n\n            safe_path = [smoothed_path[0]]\n            for idx in range(1, len(smoothed_path)):\n                if not self._is_edge_in_obstacle(safe_path[-1], smoothed_path[idx], obstacles, is_3d, resolution=0.3):\n                    safe_path.append(smoothed_path[idx])\n                else:\n                    # Fallback: keep original path segment to maintain connectivity\n                    safe_path.append(path[min(len(path)-1, idx)])\n            return safe_path if len(safe_path) > 1 else path\n\n        for iter_num in range(self.max_iter):\n            # Alternate trees A and B\n            tree_a, tree_b = (nodes_a, nodes_b) if iter_num % 2 == 0 else (nodes_b, nodes_a)\n\n            # Sample point with goal bias and informed sampling\n            if c_best < float('inf'):\n                sample_point = informed_sample(c_best)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_position if tree_a is nodes_a else start_position\n                else:\n                    # Uniform sample in bounds but not inside obstacles\n                    while True:\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                        if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                            sample_point = candidate\n                            break\n\n            nearest = nearest_node(tree_a, sample_point)\n            step = adaptive_step(nearest.position, sample_point)\n            new_pos = steer(nearest.position, sample_point, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            if new_cost + dist(new_pos, goal_position) >= c_best:\n                # Prune nodes unlikely to improve path\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors\n            radius = dynamic_neighbor_radius(len(nodes))\n            neighbors = near_nodes(tree_a, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_to_neighbor < neighbor.cost and \\\n                        not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.5):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.update_parent(new_node, new_cost_to_neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect with other tree\n            other_nearest = nearest_node(tree_b, new_node.position)\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d, resolution=0.5):\n                total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    # Build connection path\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    if tree_a is nodes_b:\n                        path_a, path_b = path_b, path_a\n                    best_path = path_a + path_b[::-1]\n                    success_state = True\n\n                    # Mark goal nodes for optional further use / smoothing\n                    if tree_a is nodes_a:\n                        best_goal_node_a = new_node\n                        best_goal_node_b = other_nearest\n                    else:\n                        best_goal_node_b = new_node\n                        best_goal_node_a = other_nearest\n\n        if success_state:\n            # Apply shortcut smoothing multiple trials\n            best_path = shortcut_smooth(best_path, self.shortcut_trials)\n            # Apply spline smoothing (2D only)\n            best_path = spline_smooth(best_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_unit_circle(self):\n        while True:\n            x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n            if x * x + y * y <= 1:\n                return (x, y)\n\n    def _sample_unit_ball(self, d):\n        import numpy as np\n        while True:\n            v = np.random.normal(0, 1, d)\n            norm = np.linalg.norm(v)\n            if norm > 0:\n                unit_v = v / norm\n                r = random.uniform(0, 1) ** (1 / d)\n                sample = unit_v * r\n                return tuple(sample)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 842.91133,
          "time_improvement": -2733.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.2318598270416259,
                    "num_nodes_avg": 2243.6,
                    "path_length_avg": 157.56462546394377,
                    "smoothness_avg": 0.019091955338500013,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4861.0070658994255,
                    "length_improvement": 13.636332011946214,
                    "smoothness_improvement": 198.83055989211456,
                    "objective_score": -1504.5807005679778
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.526750087738037,
                    "num_nodes_avg": 3136.9,
                    "path_length_avg": 233.74374399313382,
                    "smoothness_avg": 0.09869527275878408,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -841.7811331809891,
                    "length_improvement": 21.969610314461885,
                    "smoothness_improvement": 2439.5004554151105,
                    "objective_score": -285.94291561432874
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.2459121704101563,
                    "num_nodes_avg": 2702.2,
                    "path_length_avg": 124.26037979059647,
                    "smoothness_avg": 0.11440388441161195,
                    "success_improvement": 0.0,
                    "time_improvement": -2494.9361909207378,
                    "length_improvement": 17.47217238651944,
                    "smoothness_improvement": 1355.2089652993545,
                    "objective_score": -738.2103779724206
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed RRT* with dynamic pruning and heuristics to improve planning efficiency and path quality. It grows a single tree from start toward goal while biasing samples within an ellipsoidal informed subset that shrinks as better paths are found. The planner applies collision-aware incremental rewiring with a dynamic neighbor radius adapting to node density, enabling continuous path cost improvements and smoothness. Additionally, it performs pruning of nodes that cannot lead to an improved solution, improving robustness and reducing search time.",
          "planning_mechanism": "The planner incrementally samples the configuration space, initially uniformly but gradually focusing samples within an ellipsoid defined by current best path cost to efficiently exploit promising regions. It extends the nearest node toward each sample with collision checks, adds new nodes, and rewires nearby nodes to optimize path cost. When a better path to the goal is found, the informed sampling ellipsoid shrinks and nodes unlikely to improve the solution are pruned. The process continues until max iterations or satisfactory path quality is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_factor: float=50.0, goal_threshold: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # factor to compute neighbor radius dynamically\n        self.goal_threshold = goal_threshold\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        # Initialization for informed sampling\n        c_min = math.dist(start_position, goal_position)  # minimum possible cost (straight line)\n        c_best = float('inf')  # current best path cost\n        unit_vect = self._unit_vector(start_position, goal_position)\n        # Rotation matrix aligning x-axis with start-goal vector for ellipse sampling\n        rotation = self._rotation_to_x_axis(unit_vect, dim)\n\n        def sample_in_ellipse():\n            # If no better path found, uniform sampling\n            if c_best == float('inf'):\n                return tuple((random.uniform(0, bounds[d]) for d in range(dim)))\n            else:\n                # Informed sampling within an ellipsoid defined by c_best and c_min\n                # Sample unit ball point:\n                while True:\n                    # Sample random point in unit n-ball with rejection\n                    x = self._sample_unit_n_ball(dim)\n                    L = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim -1)\n                    # Scale by ellipse axes lengths\n                    x_scale = [L[0]*x[0]] + [L[i]*x[i] for i in range(1, dim)]\n                    # Rotate & translate to center\n                    x_rot = self._mat_vec_mult(rotation, x_scale)\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                    # Clamp to bounds\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return sample\n\n        import random\n\n        for iter in range(self.max_iter):\n            # Sampling with goal biasing + informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = sample_in_ellipse()\n\n            # Find nearest node (Euclidean distance)\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            direction = tuple((sample[d] - nearest_node.position[d]) / dist_to_sample for d in range(dim))\n            dist = min(self.step_size, dist_to_sample)\n            new_position = tuple(nearest_node.position[d] + direction[d] * dist for d in range(dim))\n\n            # Boundary check\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Dynamic neighbor radius (as in RRT* theory) for rewiring\n            gamma = self.neighbor_factor\n            n = len(nodes)\n            radius = min(self.step_size * 10, gamma * (math.log(n) / n) ** (1 / dim))\n\n            neighbors = self._nearby_nodes(nodes, new_node, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_cost\n                if potential_cost < neighbor.cost:\n                    # Check collision for edge\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, neighbor))\n\n            # Goal check\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.goal_threshold:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = best_cost\n                        # Prune nodes that cannot improve cost\n                        nodes, edges = self._prune_tree(nodes, edges, start_position, goal_position, c_best, is_3d, obstacles)\n\n            # Optional early stop: if found a path close to theoretical minimum\n            if c_best <= 1.1 * c_min:\n                break\n\n        # Extract path if found\n        extracted_path = []\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            node = best_goal_node\n            while node is not None:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearby_nodes(self, nodes, node, radius):\n        res = []\n        for other in nodes:\n            if other == node:\n                continue\n            if math.dist(node.position, other.position) <= radius:\n                res.append(other)\n        return res\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # Helper: unit vector from point a to b\n    def _unit_vector(self, a, b):\n        dist = math.dist(a, b)\n        if dist == 0:\n            return tuple(0.0 for _ in a)\n        return tuple((b[d] - a[d]) / dist for d in range(len(a)))\n\n    # Helper: create rotation matrix aligning vector with x-axis\n    def _rotation_to_x_axis(self, v, dim):\n        # For 2D: rotation matrix to align vector v with x-axis\n        if dim == 2:\n            vx, vy = v\n            theta = math.atan2(vy, vx)\n            cos_t = math.cos(-theta)\n            sin_t = math.sin(-theta)\n            return [[cos_t, -sin_t],\n                    [sin_t, cos_t]]\n        elif dim == 3:\n            # Use Gram-Schmidt or a rotation aligning v to (1,0,0)\n            # Algorithm: find rotation matrix R such that R v = (norm(v),0,0)\n            norm_v = math.sqrt(sum([x*x for x in v]))\n            if norm_v == 0:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            # Normalize v\n            vx, vy, vz = (x / norm_v for x in v)\n\n            # Axis-angle approach: rotation axis is cross product of v and x-axis\n            ax = 0\n            ay = -vz\n            az = vy\n            angle = math.acos(vx)\n            if math.isclose(angle, 0):\n                return [[1,0,0],[0,1,0],[0,0,1]]\n\n            s = math.sin(angle)\n            c = math.cos(angle)\n            t = 1 - c\n\n            # Normalize axis\n            axis_len = math.sqrt(ax*ax + ay*ay + az*az)\n            if axis_len == 0:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            ax /= axis_len\n            ay /= axis_len\n            az /= axis_len\n\n            return [\n                [t*ax*ax + c,     t*ax*ay - s*az, t*ax*az + s*ay],\n                [t*ax*ay + s*az,  t*ay*ay + c,    t*ay*az - s*ax],\n                [t*ax*az - s*ay,  t*ay*az + s*ax, t*az*az + c   ]\n            ]\n        else:\n            # Identity if other dims\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n    # Helper: matrix-vector multiplication for rotation\n    def _mat_vec_mult(self, mat, vec):\n        return tuple(sum(mat[i][j]*vec[j] for j in range(len(vec))) for i in range(len(mat)))\n\n    # Sample random point inside unit n-ball with rejection sampling\n    def _sample_unit_n_ball(self, n):\n        import random\n        while True:\n            point = [random.uniform(-1,1) for _ in range(n)]\n            if sum(x*x for x in point) <= 1:\n                return point\n\n    # Prune nodes and edges that cannot possibly improve current best cost\n    def _prune_tree(self, nodes, edges, start_position, goal_position, c_best, is_3d, obstacles):\n        pruned_nodes = []\n        pruned_edges = []\n        dim = len(start_position)\n\n        # For quick lookup: node to index mapping\n        node_set = set(nodes)\n\n        for node in nodes:\n            # Admissible heuristic: cost to come + heuristic to goal\n            h_cost = math.dist(node.position, goal_position)\n            if node.cost + h_cost <= c_best:\n                pruned_nodes.append(node)\n            else:\n                # Disconnect pruned node from parent\n                if node.parent is not None:\n                    node.parent.remove_child(node)\n                    node.parent = None\n                node.valid = False\n\n        # Rebuild edges on pruned nodes only\n        node_set_pruned = set(pruned_nodes)\n        for (p, c) in edges:\n            if p in node_set_pruned and c in node_set_pruned:\n                pruned_edges.append((p, c))\n\n        return pruned_nodes, pruned_edges",
          "objective": 1025.53043,
          "time_improvement": -3269.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.1981682538986207,
                    "num_nodes_avg": 2661.0,
                    "path_length_avg": 157.95477047547763,
                    "smoothness_avg": 0.01728095289776719,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4725.32268951618,
                    "length_improvement": 13.422487348881177,
                    "smoothness_improvement": 170.4844390399015,
                    "objective_score": -1464.059887189878
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.7487941265106202,
                    "num_nodes_avg": 3673.4,
                    "path_length_avg": 249.36026991199805,
                    "smoothness_avg": 0.028889447072236583,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -978.7497753515913,
                    "length_improvement": 16.756364465969455,
                    "smoothness_improvement": 643.3462813962985,
                    "objective_score": -337.05692830530205
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 2.017609453201294,
                    "num_nodes_avg": 4111.3,
                    "path_length_avg": 124.02512802185954,
                    "smoothness_avg": 0.03394362310736604,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4102.196522032754,
                    "length_improvement": 17.628415409829085,
                    "smoothness_improvement": 331.7603804680588,
                    "objective_score": -1275.4744716255202
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is an enhanced bidirectional Informed RRT* planner integrating adaptive sampling, dynamic neighbor radius, and heuristic-guided tree expansions to accelerate convergence and improve path quality. It grows two trees simultaneously from start and goal, using informed elliptical sampling focused around the current best path to reduce sampling of irrelevant space. Dynamic neighbor radius adapts based on node count to effectively balance exploration and optimization. Rewiring of nearby nodes dynamically refines the tree for optimal cost paths. Post-processing smoothing is applied for path refinement. Rigorous collision and boundary checks ensure robustness and safe expansions.",
          "planning_mechanism": "The planner alternates expanding two trees from start and goal toward sampled points generated inside an informed ellipsoidal region defined by the current best path. Each extension steers toward samples with step size limits, adds the new node with cost-based parent selection among neighbors within a dynamic radius, rewires neighbor nodes for optimal path costs, and attempts to connect the trees when proximity conditions are met. Once a connection is found, the combined path is extracted, shortcut-smoothed, and returned as the optimal collision-free path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_factor: float=30.0, smoothing_iter: int=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_position)]\n        nodes_goal = [Node(goal_position)]\n        edges = []\n\n        best_path_cost = float('inf')\n        best_connect_nodes = None\n        success_state = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(val, self.step_size * 1.5)\n\n        def near_nodes(nodes_list, pos, radius):\n            return [node for node in nodes_list if dist(node.position, pos) <= radius]\n\n        def sample_informed_ellipsoid():\n            # If no best path yet, sample uniformly\n            if not success_state or best_connect_nodes is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Define ellipsoid parameters around start-goal\n            start = start_position\n            goal = goal_position\n            c_best = best_path_cost\n            c_min = dist(start, goal)\n            if c_best < float('inf'):\n                # Construct rotation matrix C (dim x dim)\n                # For 2D/3D, rotation aligns x-axis to vector from start to goal\n                def unit_vector(v):\n                    l = math.dist((0,)*len(v), v)\n                    if l == 0:\n                        return v\n                    return tuple(vi / l for vi in v)\n                a1 = unit_vector(tuple(goal[i] - start[i] for i in range(dim)))\n                import numpy as np\n                I = np.eye(dim)\n                # Construct orthonormal basis\n                if dim == 2:\n                    # 2D rotation matrix to align x axis to a1\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    C = np.array([[cos_a, -sin_a],\n                                  [sin_a, cos_a]])\n                else:\n                    # For 3D, use Gram-Schmidt or scipy rotation; fallback to identity if complex\n                    C = np.eye(dim)\n                # Radii of ellipsoid (r1 = c_best/2, others sqrt(c_best^2 - c_min^2)/2)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                L = np.diag([r1] + [r_other]*(dim-1))\n\n                while True:\n                    # Sample inside unit ball with radius 1\n                    x = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x)\n                    if norm_x == 0:\n                        continue\n                    x = x / norm_x * (random.uniform(0,1) ** (1/dim))\n                    # Map sample into ellipsoid\n                    sample = C @ (L @ x) + np.array([(start[i] + goal[i]) / 2.0 for i in range(dim)])\n                    sample_tuple = tuple(float(sample[i]) for i in range(dim))\n                    if is_in_bounds(sample_tuple):\n                        return sample_tuple\n            else:\n                # No path found yet, uniform random\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extend(tree_nodes, other_tree_nodes):\n            # Sampling with goal biasing and informed method\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_position if tree_nodes is nodes_start else start_position\n            else:\n                sample_point = sample_informed_ellipsoid()\n\n            nearest_node = min(tree_nodes, key=lambda n: dist(n.position, sample_point))\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not is_in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Determine neighbor radius dynamically\n            radius = neighbor_radius(len(tree_nodes)+1)\n            neighbors = near_nodes(tree_nodes, new_pos, radius)\n\n            # Find best parent with minimal cost + collision free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in neighbors:\n                potential_cost = near_node.cost + dist(near_node.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path found via new_node\n            for near_node in neighbors:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                    # Update edges\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree (nearest node within step_size*1.5 radius)\n            radius_connect = self.step_size * 1.5\n            other_candidates = near_nodes(other_tree_nodes, new_node.position, radius_connect)\n\n            for other_node in other_candidates:\n                if self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                nonlocal best_path_cost, success_state, best_connect_nodes\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    success_state = True\n                    best_connect_nodes = (new_node, other_node)\n                    # Add connection edge to record (but don't append multiple times)\n                    if (new_node, other_node) not in edges and (other_node, new_node) not in edges:\n                        edges.append((new_node, other_node))\n                    # Since we want best path, keep searching; do not return here\n\n            return new_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connecting node (last start == last goal) if any\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def path_smoothing(path):\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_iter):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i+1, len(smoothed) -1)\n                if j == i + 1:\n                    continue\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Main planning loop alternating trees\n        extend_from_start = True\n        for _ in range(self.max_iter):\n            if extend_from_start:\n                extend(nodes_start, nodes_goal)\n            else:\n                extend(nodes_goal, nodes_start)\n            extend_from_start = not extend_from_start\n\n        if success_state and best_connect_nodes:\n            raw_path = extract_full_path(best_connect_nodes[0], best_connect_nodes[1])\n            extracted_path = path_smoothing(raw_path)\n        else:\n            extracted_path = []\n\n        all_nodes = nodes_start + [n for n in nodes_goal if n not in nodes_start]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1535.19465,
          "time_improvement": -5087.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 589.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 2.4822304010391236,
                    "num_nodes_avg": 2974.4,
                    "path_length_avg": 148.09170236608298,
                    "smoothness_avg": 0.025786133532472118,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -9896.561531127309,
                    "length_improvement": 18.828591269956053,
                    "smoothness_improvement": 303.6089852683932,
                    "objective_score": -3013.6846961578594
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.8884896993637086,
                    "num_nodes_avg": 3307.2,
                    "path_length_avg": 221.11222497769276,
                    "smoothness_avg": 0.03874162671416309,
                    "success_improvement": 0.0,
                    "time_improvement": -1064.921478211531,
                    "length_improvement": 26.186374939931834,
                    "smoothness_improvement": 896.8499598212317,
                    "objective_score": -309.7549186763667
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.1126710891723635,
                    "num_nodes_avg": 3444.5,
                    "path_length_avg": 112.34075821450124,
                    "smoothness_avg": 0.05242265744067859,
                    "success_improvement": 0.0,
                    "time_improvement": -4300.187107090009,
                    "length_improvement": 25.388617485976262,
                    "smoothness_improvement": 566.8123332073628,
                    "objective_score": -1282.1443469637707
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines informed sampling from Informed RRT* to accelerate convergence with goal-biased adaptive rewiring from goal-biased RRT*. It grows a single tree from the start, initially sampling uniformly and switching to ellipsoidal informed sampling once a solution is found. The adaptive neighbor radius balances exploration and local optimization for efficient rewiring. The planner uses goal biasing to direct growth and an explicit rewiring step with a clean parent update method to refine path quality, ensuring collision-free nodes and edges throughout.",
          "planning_mechanism": "The planner grows one tree starting from the start position, sampling points either uniformly, goal-biased, or informed ellipsoid-based after the first solution. Each new sampled point is steered towards from the nearest tree node within step size constraints. Neighbor nodes are found within an adaptive radius to select the best parent for minimal cost and perform rewiring to improve path quality. Planning ends either on iteration limit or when connecting directly to the goal is feasible, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path(self):\n        node, pth = self, []\n        while node:\n            pth.append(node.position)\n            node = node.parent\n        return pth[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability of sampling goal for bias\n        self.neighbor_factor = neighbor_factor      # Multiplier for adaptive neighbor radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = [Node(start)]\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        goal_node = None\n\n        c_min = math.dist(start, goal)\n        best_cost = float(\"inf\")\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return None\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            radius = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return max(radius, self.step_size * 1.8)\n\n        def nearby_nodes(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        def sample_informed(start, goal, c_best, c_min, bounds):\n            # Informed ellipsoidal sampling after initial solution\n            L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det_val = np.linalg.det(U) * np.linalg.det(Vt)\n            C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [det_val]), Vt))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-6:\n                    continue\n                x_ball = x_ball / norm_ball * random.random() ** (1.0 / dim)\n                x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        for iter_num in range(self.max_iter):\n            # Sample with goal bias and switch to informed sampling if solution found\n            if best_cost < float(\"inf\"):\n                if random.random() < self.goal_sample_rate:\n                    x_rand = goal\n                else:\n                    x_rand = sample_informed(start, goal, best_cost, c_min, bounds)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    x_rand = goal\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node and steer\n            nearest = min(nodes, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if new_pos is None:\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Find neighbors within adaptive radius\n            radius = neighbor_radius(len(nodes) + 1)\n            near_nodes = nearby_nodes(nodes, new_pos, radius)\n\n            # Choose best parent for minimal cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if (temp_cost < min_cost and\n                    not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check connection to goal\n            dist_to_goal = dist(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d)):\n                    potential_cost = new_node.cost + dist_to_goal\n                    if potential_cost < best_cost:\n                        best_cost = potential_cost\n                        # Remove previous goal_node if exists from edges/nodes\n                        if goal_node is not None:\n                            # Remove old goal edges and goal node\n                            edges = [(p,c) for (p,c) in edges if c != goal_node]\n                            try:\n                                nodes.remove(goal_node)\n                            except ValueError:\n                                pass\n                        goal_node = Node(goal)\n                        goal_node.update_parent(new_node, potential_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n\n        extracted_path = []\n        if success_state and goal_node is not None:\n            extracted_path = goal_node.path()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1668.27505,
          "time_improvement": -5580.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 155.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 2.1680412769317625,
                    "num_nodes_avg": 2553.9,
                    "path_length_avg": 144.73788066008166,
                    "smoothness_avg": 0.014889521487143948,
                    "success_improvement": 0.0,
                    "time_improvement": -8631.243488839451,
                    "length_improvement": 20.666874091721198,
                    "smoothness_improvement": 133.05334438722153,
                    "objective_score": -2584.574405111555
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.71335916519165,
                    "num_nodes_avg": 3442.5,
                    "path_length_avg": 220.47367297298075,
                    "smoothness_avg": 0.010481219375827907,
                    "success_improvement": 0.0,
                    "time_improvement": -1573.7450941346688,
                    "length_improvement": 26.39954197880507,
                    "smoothness_improvement": 169.68932385722277,
                    "objective_score": -465.9951732253535
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.1855071544647218,
                    "num_nodes_avg": 3877.5,
                    "path_length_avg": 110.45863755117375,
                    "smoothness_avg": 0.02061157904065871,
                    "success_improvement": 0.0,
                    "time_improvement": -6534.647287245136,
                    "length_improvement": 26.638632413603375,
                    "smoothness_improvement": 162.17776400867058,
                    "objective_score": -1954.2555708707766
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced bidirectional Informed RRT* planner integrating adaptive informed elliptical sampling, dynamic neighbor radius based on node count and dimensionality, goal biasing, and heuristic-guided rewiring for fast convergence to high-quality paths. It alternates expansion of two trees from the start and goal, steering towards sampled points within an informed ellipsoid around the current best path, while rigorously checking node validity and edge collisions. After a successful connection, the combined path undergoes shortcut smoothing for improved smoothness and length efficiency. Robust collision and boundary handling ensure safe and valid expansions throughout the planning process.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal. Each iteration samples points inside an ellipsoidal informed region focusing around the current best path if available, or uniformly otherwise, with goal-biased probability. Trees are extended toward the samples with a fixed step size, selecting optimal parents among neighbors within a dynamically computed radius. After inserting a new node, local rewiring optimizes path costs. When the trees connect within a proximity threshold collision-free, the path is extracted by concatenating root-to-connect nodes from both trees, then smoothing shortcuts iteratively to refine the path quality before returning the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, goal_sample_rate: float=0.15, neighbor_factor: float=30.0, smoothing_iter: int=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes_start = [Node(start_position)]\n        nodes_goal = [Node(goal_position)]\n        edges = []\n\n        best_path_cost = float('inf')\n        best_connect_nodes = None\n        success_state = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0.0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def neighbor_radius(num_nodes: int):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(val, self.step_size * 1.5)\n\n        def near_nodes(nodes_list, pos, radius):\n            return [node for node in nodes_list if dist(node.position, pos) <= radius]\n\n        def sample_informed_ellipsoid():\n            if not success_state or best_connect_nodes is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            start = np.array(start_position)\n            goal = np.array(goal_position)\n            c_best = best_path_cost\n            c_min = dist(start_position, goal_position)\n            if c_best < float('inf') and c_best > c_min:\n                def unit_vector(v):\n                    norm_v = np.linalg.norm(v)\n                    if norm_v == 0:\n                        return v\n                    return v / norm_v\n                a1 = unit_vector(goal - start)\n                I = np.eye(dim)\n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    C = np.array([[cos_a, -sin_a],\n                                  [sin_a, cos_a]])\n                else:\n                    # 3D: build orthonormal basis via Gram-Schmidt or fallback identity\n                    if np.allclose(a1, np.array([1.0,0.0,0.0])):\n                        C = np.eye(dim)\n                    else:\n                        # Gram-Schmidt to get basis with a1 first column\n                        v_temp = np.array([1.0,0.0,0.0])\n                        if np.allclose(a1, v_temp):\n                            C = np.eye(dim)\n                        else:\n                            v2 = v_temp - np.dot(v_temp, a1)*a1\n                            v2 /= np.linalg.norm(v2)\n                            v3 = np.cross(a1, v2)\n                            C = np.column_stack((a1, v2, v3))\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                L = np.diag([r1] + [r_other]*(dim-1))\n                for _ in range(100):\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x == 0:\n                        continue\n                    x_ball = x_ball / norm_x * (random.uniform(0,1) ** (1/dim))\n                    sample = C @ (L @ x_ball) + (start + goal)/2.0\n                    sample_tuple = tuple(float(sample[i]) for i in range(dim))\n                    if is_in_bounds(sample_tuple):\n                        return sample_tuple\n                # Fallback uniform if above fails\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extend(tree_nodes, other_tree_nodes):\n            nonlocal best_path_cost, success_state, best_connect_nodes\n\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_position if tree_nodes is nodes_start else start_position\n            else:\n                sample_point = sample_informed_ellipsoid()\n\n            nearest_node = min(tree_nodes, key=lambda n: dist(n.position, sample_point))\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not is_in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = neighbor_radius(len(tree_nodes)+1)\n            neighbors = near_nodes(tree_nodes, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in neighbors:\n                potential_cost = near_node.cost + dist(near_node.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in neighbors:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            radius_connect = self.step_size * 1.5\n            other_candidates = near_nodes(other_tree_nodes, new_node.position, radius_connect)\n\n            for other_node in other_candidates:\n                if self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    success_state = True\n                    best_connect_nodes = (new_node, other_node)\n                    if (new_node, other_node) not in edges and (other_node, new_node) not in edges:\n                        edges.append((new_node, other_node))\n            return new_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def path_smoothing(path):\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_iter):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i+1, len(smoothed) -1)\n                if j == i + 1:\n                    continue\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        extend_from_start = True\n        for _ in range(self.max_iter):\n            if extend_from_start:\n                extend(nodes_start, nodes_goal)\n            else:\n                extend(nodes_goal, nodes_start)\n            extend_from_start = not extend_from_start\n\n        if success_state and best_connect_nodes:\n            raw_path = extract_full_path(best_connect_nodes[0], best_connect_nodes[1])\n            extracted_path = path_smoothing(raw_path)\n        else:\n            extracted_path = []\n\n        all_nodes = nodes_start + [n for n in nodes_goal if n not in nodes_start]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1765.30856,
          "time_improvement": -5690.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 725.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 2.642981505393982,
                    "num_nodes_avg": 3041.1,
                    "path_length_avg": 148.75657119711417,
                    "smoothness_avg": 0.024129695930810248,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -10543.946360999385,
                    "length_improvement": 18.464166128147035,
                    "smoothness_improvement": 277.6821397905608,
                    "objective_score": -3208.1026643752334
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.8429227590560913,
                    "num_nodes_avg": 3225.5,
                    "path_length_avg": 221.76874637261182,
                    "smoothness_avg": 0.052791641420034674,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1036.8133516601333,
                    "length_improvement": 25.96720920138727,
                    "smoothness_improvement": 1258.366958019854,
                    "objective_score": -349.5587288676633
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 2.683323884010315,
                    "num_nodes_avg": 3988.8,
                    "path_length_avg": 111.72460077059638,
                    "smoothness_avg": 0.0580527123675322,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -5488.719994835685,
                    "length_improvement": 25.797839921953326,
                    "smoothness_improvement": 638.4262163095138,
                    "objective_score": -1738.2642993847671
               }
          ],
          "success_rate": 0.8666666666666667
     }
]