[
     {
          "operator": "e1",
          "algorithm_description": "This planner implements a bidirectional anytime RRT* algorithm with adaptive neighborhood radius and informed ellipsoidal sampling to accelerate convergence. It alternates growing trees from start and goal, performs incremental connection attempts with rewiring for cost improvements, and includes dynamic goal biasing. Efficient collision checks and boundary clamping ensure valid expansions. A post-processing shortcutting path smoother improves path quality. Planning is bounded by a strict 30-second time limit, returning the best path found within that time.",
          "planning_mechanism": "The planner maintains two trees growing towards each other with rewiring to optimize paths continuously. After an initial feasible path is discovered, sampling is focused in an informed ellipsoidal region between start and goal. Alternating expansions and incremental connections facilitate rapid and low-cost path discovery. The tree structure maintains parent-child relationships for efficient cost updates. The algorithm stops early upon time expiration or path convergence, returning a smoothed optimal path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return  # no change\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # update children's costs recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        \n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position)**2 <= radius_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n        \n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            r = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                r = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                curr = new_node\n        \n        def path_smoothing(path, trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # time expired or max_iter reached, return best found path if any\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed_path = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.22802,
          "time_improvement": 66.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1404.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013612937927246094,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 165.03221244566507,
                    "smoothness_avg": 0.03646262433818684,
                    "success_improvement": 0.0,
                    "time_improvement": 42.58610304712929,
                    "length_improvement": 9.543229255776668,
                    "smoothness_improvement": 470.71925074869193,
                    "objective_score": 17.038073019037583
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046164512634277344,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 234.5836663734471,
                    "smoothness_avg": 0.09856122135615505,
                    "success_improvement": 0.0,
                    "time_improvement": 80.75308184482866,
                    "length_improvement": 21.68922004808806,
                    "smoothness_improvement": 2436.0512162721434,
                    "objective_score": 40.74402464442693
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02616074085235596,
                    "num_nodes_avg": 153.9,
                    "path_length_avg": 121.35636821099396,
                    "smoothness_avg": 0.11038908453424479,
                    "success_improvement": 0.0,
                    "time_improvement": 75.00356518827157,
                    "length_improvement": 19.400878603520102,
                    "smoothness_improvement": 1304.1410072009455,
                    "objective_score": 32.90195031319021
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling. It grows two trees alternately from start and goal, dynamically rewiring neighbors to optimize path cost and smoothness. Rigorous collision checks for nodes and edges ensure path validity. The algorithm enforces a 30-second runtime limit, returns the best feasible path found so far, and applies path smoothing for improved quality and shorter lengths.",
          "planning_mechanism": "The planner alternately samples points biased towards the opposite tree\u2019s root, extends the current tree incrementally with step-size limits, rewires neighbors within an adaptive radius to minimize cost, and attempts incremental connections to the other tree. On successful connection or timeout, it reconstructs and smooths the combined path. Nodes and edges are tracked for roadmap analysis.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Update parent and cost, then propagate cost updates recursively to children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            # Goal-biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return tree_to_root_pos  # fallback\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                # Shortcut path\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Combine with no duplicated connect node\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=100)\n                    success_state = True\n\n                # Early termination when found a connection\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early stop but found best path, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=100)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.71144,
          "time_improvement": 64.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1391.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01094198226928711,
                    "num_nodes_avg": 71.9,
                    "path_length_avg": 159.3879990283421,
                    "smoothness_avg": 0.03611968111442979,
                    "success_improvement": 0.0,
                    "time_improvement": 53.851119734292496,
                    "length_improvement": 12.636912068096395,
                    "smoothness_improvement": 465.3514445837642,
                    "objective_score": 21.009475556825848
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055727267265319826,
                    "num_nodes_avg": 295.1,
                    "path_length_avg": 229.22588968501387,
                    "smoothness_avg": 0.0851665813883569,
                    "success_improvement": 0.0,
                    "time_improvement": 76.76617620629713,
                    "length_improvement": 23.477800121738362,
                    "smoothness_improvement": 2091.3974821314937,
                    "objective_score": 38.18240029689428
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04135787487030029,
                    "num_nodes_avg": 235.5,
                    "path_length_avg": 122.57216148158086,
                    "smoothness_avg": 0.13488954490947164,
                    "success_improvement": 0.0,
                    "time_improvement": 60.482792556160256,
                    "length_improvement": 18.593406603050504,
                    "smoothness_improvement": 1615.7850547379617,
                    "objective_score": 29.942444361147988
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive informed sampling, dynamic neighborhood rewiring, and incremental tree connection, designed to optimize path quality while enforcing a strict 30-second planning time limit. It grows two trees from start and goal, alternately extending towards sampled points drawn uniformly or from an ellipsoidal informed set after an initial solution is found. Rewiring and parent updates continuously improve path costs. Detailed collision and boundary checking ensure feasibility. Upon timeout or solution, the best smoothed path and graph are returned.",
          "planning_mechanism": "The planner alternates growing start and goal trees using informed sampling to focus exploration near the current best path. Each extension attempts rewiring with neighbors inside an adaptive radius for better paths. An incremental connection attempts to merge the two trees, updating the best path and enabling early stopping. Collision and boundary checks maintain robustness. Path smoothing post-processing refines the solution before returning. Planning halts when the max time or max iterations are met, returning the best found result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []             # Children nodes\n        self.valid = True              # Validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import time\n        import random\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 10.0\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 10.0, r))\n            return r\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position)**2 <= radius_sq]\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                while True:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(min(max(0.0, sample_pt[d]), bounds[d]) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n            iteration += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # If non-informed sample isn't collision free, try resample\n            if not collision_free_node(sample_pt):\n                continue\n\n            # Goal bias 10%\n            goal_biased_prob = 0.1\n            if not informed_sampling and random.random() < goal_biased_prob:\n                sample_pt = goal_pos if grow_start else start_pos\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                # Avoid duplicate node at connection\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                # Update edges for graph\n                all_nodes = tree_start + tree_goal\n                all_edges.clear()\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n\n                # Early return on improvement to reduce planning time\n                smoothed = path_smoothing(best_path)\n                return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Timeout or no perfect solution: return best found\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.43364,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1433.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015412139892578124,
                    "num_nodes_avg": 79.3,
                    "path_length_avg": 162.52070036275785,
                    "smoothness_avg": 0.035853767700235475,
                    "success_improvement": 0.0,
                    "time_improvement": 34.99779280968791,
                    "length_improvement": 10.919828825873822,
                    "smoothness_improvement": 461.189322211402,
                    "objective_score": 14.989250219138148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04072449207305908,
                    "num_nodes_avg": 216.7,
                    "path_length_avg": 240.54431513078626,
                    "smoothness_avg": 0.09615011166494618,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02113634231021,
                    "length_improvement": 19.6993839251266,
                    "smoothness_improvement": 2374.0116272652244,
                    "objective_score": 40.7162758240445
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029710674285888673,
                    "num_nodes_avg": 207.0,
                    "path_length_avg": 122.019026210482,
                    "smoothness_avg": 0.1229527530783372,
                    "success_improvement": 0.0,
                    "time_improvement": 71.61162456403329,
                    "length_improvement": 18.960772712643205,
                    "smoothness_improvement": 1463.9499437282534,
                    "objective_score": 32.59539163037989
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental tree connection, and rewiring for path cost improvement. It alternately grows trees from start and goal within given bounds and obstacles, ensuring collision-free expansions and edges, with realtime time limit enforcement and path smoothing for enhanced path quality.",
          "planning_mechanism": "The planner maintains two trees growing from start and goal respectively, sampling points either uniformly or within an ellipsoidal informed region biased by the best path cost. It extends one tree towards the sample, rewires neighbors for cost optimization, then incrementally connects to the opposite tree with rewiring. Upon a connection, it extracts and smooths the path, terminating early if time limit is reached or a path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0,\n                 max_planning_time: float=30.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path_nodes = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Sample point\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Compute combined cost\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += math.dist(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                edges.clear()\n                all_nodes = tree_start + tree_goal\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        edges.clear()\n        all_nodes = tree_start + tree_goal\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.86429,
          "time_improvement": 56.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1675.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01880507469177246,
                    "num_nodes_avg": 64.1,
                    "path_length_avg": 158.15395981511193,
                    "smoothness_avg": 0.04238641838992204,
                    "success_improvement": 0.0,
                    "time_improvement": 20.68775849014105,
                    "length_improvement": 13.313308515470546,
                    "smoothness_improvement": 563.4394913830222,
                    "objective_score": 11.686186707051533
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04519479274749756,
                    "num_nodes_avg": 223.3,
                    "path_length_avg": 232.93837097407726,
                    "smoothness_avg": 0.11965000592321515,
                    "success_improvement": 0.0,
                    "time_improvement": 81.15737766058118,
                    "length_improvement": 22.23846700959999,
                    "smoothness_improvement": 2978.6808328201532,
                    "objective_score": 43.68831086419512
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035725188255310056,
                    "num_nodes_avg": 197.3,
                    "path_length_avg": 120.17187027929853,
                    "smoothness_avg": 0.12455155358138663,
                    "success_improvement": 0.0,
                    "time_improvement": 65.86479165859849,
                    "length_improvement": 20.187565730021888,
                    "smoothness_improvement": 1484.2865681158646,
                    "objective_score": 31.218383484163247
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* path planner with adaptive informed sampling, incremental rewiring, and path smoothing under a strict 30-second time limit. It grows two trees from start and goal, samples points with goal bias and informed regions after initial solution, rewires neighbors to optimize path cost, connects both trees incrementally, and smooths the resulting path for quality and efficiency.",
          "planning_mechanism": "The planner alternately extends and rewires two trees rooted at the start and goal, using collision and boundary checks to validate nodes and edges. It adaptively samples points biased toward goal and informed ellipsoids to focus search. Upon successful connection of two trees via low-cost path, it extracts and smooths the combined path, and terminates early or when time runs out, returning the best feasible solution found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update to children recursively\n        for child in self.children:\n            dist_child = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.perf_counter()\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist_\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                while True:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos)**2) <= radius_sq]\n\n        def extend_and_rewire(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors to new_node if cheaper\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                curr_node = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Sampling with goal bias and informed sampling after initial solution\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    attempts = 0\n                    while True:\n                        sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(sample_pt):\n                            break\n                        attempts += 1\n                        if attempts > 50:\n                            sample_pt = goal_pos if grow_start else start_pos\n                            break\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n\n            if new_node and connected_node:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                combined_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    # Early return after smoothing for faster response\n                    smoothed_path = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Return best path found if any after smoothing\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed_path = []\n            success_state = False\n        all_nodes = tree_start + tree_goal\n        edges = []\n        for node in all_nodes:\n            for child in node.children:\n                edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.18988,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1620.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019385480880737306,
                    "num_nodes_avg": 61.5,
                    "path_length_avg": 158.05621068048927,
                    "smoothness_avg": 0.04121132340676565,
                    "success_improvement": 0.0,
                    "time_improvement": 18.23983862874656,
                    "length_improvement": 13.366886365091386,
                    "smoothness_improvement": 545.0467031370264,
                    "objective_score": 10.870562377327378
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04704251289367676,
                    "num_nodes_avg": 245.0,
                    "path_length_avg": 238.61043294917386,
                    "smoothness_avg": 0.10762290487831525,
                    "success_improvement": 0.0,
                    "time_improvement": 80.38702579509291,
                    "length_improvement": 20.344969461061062,
                    "smoothness_improvement": 2669.2148601641484,
                    "objective_score": 41.531175931560824
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031730484962463376,
                    "num_nodes_avg": 211.6,
                    "path_length_avg": 127.75992538845958,
                    "smoothness_avg": 0.13732494436800047,
                    "success_improvement": 0.0,
                    "time_improvement": 69.68170728095734,
                    "length_improvement": 15.147940830872631,
                    "smoothness_improvement": 1646.7631560879595,
                    "objective_score": 32.16791613090153
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed ellipsoidal sampling, adaptive neighbor rewiring, and incremental connection attempts to efficiently find smooth, low-cost paths within a 30-second limit. It maintains two trees grown alternately from start and goal, leveraging collision-free incremental expansions, dynamic rewiring to optimize path cost locally, and path shortcut smoothing to improve final solution quality. Early termination upon path discovery or timeout ensures time-bounded planning.",
          "planning_mechanism": "The planner grows two trees from start and goal positions by sampling points biased towards the goal and, after a path is found, within an informed ellipsoid. Nodes are incrementally connected and rewired using an adaptive neighbor radius to reduce path cost. The planner alternates tree growth, performs collision checks on nodes and edges, and applies path shortcutting to smooth the final path before returning the best solution found within 30 seconds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = None               # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 20.0\n            r = 20.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(8.0, min(20.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling_active else (\n                goal_pos if random.random() < 0.2 else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early return on improved path\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            success_state = True\n            smoothed = path_smoothing(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        nodes = start_tree + goal_tree\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.11571,
          "time_improvement": 55.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1604.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019519495964050292,
                    "num_nodes_avg": 70.2,
                    "path_length_avg": 155.1714439963092,
                    "smoothness_avg": 0.041852322405292755,
                    "success_improvement": 0.0,
                    "time_improvement": 17.674616909189453,
                    "length_improvement": 14.948072696743845,
                    "smoothness_improvement": 555.0797294155799,
                    "objective_score": 11.067398259183504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06700973510742188,
                    "num_nodes_avg": 318.4,
                    "path_length_avg": 232.16109678947745,
                    "smoothness_avg": 0.10635019012507274,
                    "success_improvement": 0.0,
                    "time_improvement": 72.06228738014165,
                    "length_improvement": 22.497943505016327,
                    "smoothness_improvement": 2636.4669928638355,
                    "objective_score": 39.30060987936494
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026527929306030273,
                    "num_nodes_avg": 182.2,
                    "path_length_avg": 124.3356742878965,
                    "smoothness_avg": 0.1352033003313838,
                    "success_improvement": 0.0,
                    "time_improvement": 74.65271876929245,
                    "length_improvement": 17.422165366551436,
                    "smoothness_improvement": 1619.7760005456682,
                    "objective_score": 33.979128706826366
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased and informed sampling, adaptive neighbor radius, incremental extend-and-rewire expansions, and progressive tree connection attempts. It dynamically rewires nodes to optimize path cost while respecting map boundaries and obstacles, applies multiple passes of path smoothing, and enforces a strict time limit of 30 seconds to ensure timely responses.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled points generated with a bias towards the goal and an ellipsoidal informed region after an initial solution is found. Each extension attempts to connect to the opposite tree incrementally. Adaptive neighbor radius ensures locally appropriate rewiring for cost optimization. On connection, best paths from both trees are combined, smoothed, and returned. The process halts if time runs out, returning the best available path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Cost from root\n        self.children: List[Node] = []        # List of child nodes\n        self.valid = True                     # For collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                           # Tuple[int, ...]\n        start_pos = map.start                       # Tuple[float, ...]\n        goal_pos = map.goal                         # Tuple[float, ...]\n        obstacles = map.obstacles                   # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning parameter\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors for potentially better paths\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n\n        iter_cnt = 0\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplication of connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Apply smoothing and return early\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or iteration limit, return best path found (if any)\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.07081,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1580.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01549065113067627,
                    "num_nodes_avg": 67.1,
                    "path_length_avg": 160.82071621613,
                    "smoothness_avg": 0.04018716215495074,
                    "success_improvement": 0.0,
                    "time_improvement": 34.666663985190205,
                    "length_improvement": 11.851617074613193,
                    "smoothness_improvement": 529.0163555443684,
                    "objective_score": 15.415404388201543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04627766609191895,
                    "num_nodes_avg": 218.8,
                    "path_length_avg": 234.7337667638325,
                    "smoothness_avg": 0.10335063168007959,
                    "success_improvement": 0.0,
                    "time_improvement": 80.70590588186646,
                    "length_improvement": 21.639112217377225,
                    "smoothness_improvement": 2559.2861935795413,
                    "objective_score": 41.33602517593309
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.049237298965454104,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 125.59843408327171,
                    "smoothness_avg": 0.13770665612117666,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95404893761946,
                    "length_improvement": 16.583500436623012,
                    "smoothness_improvement": 1651.6185014133298,
                    "objective_score": 27.46100727567709
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius, incremental extend-and-rewire expansions, and continuous path optimization. It employs goal bias and ellipsoidal informed sampling after the first solution to focus search, ensures collision-free node and edge placement, and manages trees with parent-child relationships for efficient rewiring and cost updates. It enforces a strict 30-second time limit, returning the best smoothed path found if time expires.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending towards sampled points drawn either uniformly or from an informed ellipsoidal region after an initial solution is found. Each extension rewires nearby nodes within an adaptive radius for cost optimization. Incremental connection attempts are made between trees to merge paths early. Efficient collision checks prevent invalid expansions. Path smoothing refines the solution before returning. The process halts upon time expiration or success, delivering an optimized, smooth, and low-cost path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []  # Child nodes list\n        self.valid = True               # For collision validity\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...] (W,H) or (W,H,D)\n        start_pos = map.start                  # Tuple[float, ...]\n        goal_pos = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles (rectangular)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning constant\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees from start and goal\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n        iteration = 0\n        success_state = False\n\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iteration += 1\n\n            # Sample point for tree extension\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            # Extend the chosen tree\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicate connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # After max iterations or timeout, return best found path if any\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.52708,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1634.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01539454460144043,
                    "num_nodes_avg": 62.4,
                    "path_length_avg": 162.07334389473203,
                    "smoothness_avg": 0.038528230647502874,
                    "success_improvement": 0.0,
                    "time_improvement": 35.07200267075055,
                    "length_improvement": 11.16503199481564,
                    "smoothness_improvement": 503.05047502538207,
                    "objective_score": 15.269859575315202
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.060103225708007815,
                    "num_nodes_avg": 246.0,
                    "path_length_avg": 235.23042013392615,
                    "smoothness_avg": 0.11139777289001798,
                    "success_improvement": 0.0,
                    "time_improvement": 74.94175070734124,
                    "length_improvement": 21.473315027065336,
                    "smoothness_improvement": 2766.3449330327885,
                    "objective_score": 40.60891288277938
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0526397705078125,
                    "num_nodes_avg": 220.7,
                    "path_length_avg": 123.26986202793978,
                    "smoothness_avg": 0.13625179478905936,
                    "success_improvement": 0.0,
                    "time_improvement": 49.70300728756376,
                    "length_improvement": 18.13002712108873,
                    "smoothness_improvement": 1633.1127726554907,
                    "objective_score": 26.702471473764327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an enhanced bidirectional informed RRT* planner with adaptive neighborhood rewiring, recursive cost propagation for cost consistency across children nodes, and informed ellipsoidal sampling after the first solution to focus the search space. It incorporates goal-biased sampling and incremental tree connection, with rigorous collision checking for nodes and edges. Path smoothing with randomized shortcutting is applied to improve path smoothness and shorten the path. The planner strictly enforces a 30-second execution time limit, returns early upon finding a high-quality path, and maintains a clear graph structure with parent-child relationships and edges.",
          "planning_mechanism": "The planner grows two trees starting from the start and goal positions alternately. It samples nodes with a goal bias initially and switches to informed ellipsoidal sampling once a solution is found. New nodes are connected using an adaptive neighbor radius to the best parent in terms of cost and rewired with neighbors to improve the tree cost optimally with recursive cost updates. Incremental connection tries to link the two trees stepwise, and path smoothing is performed on the extracted path. The process terminates early on exceeding the time limit or upon finding an improved feasible path, returning the best solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None                # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other:'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child:'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent:'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            # Recursive cost propagation\n            child.update_parent(self, self.cost + child._distance(self))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                   # Tuple[int, ...]\n        start_pos = map.start               # Tuple[float, ...]\n        goal_pos = map.goal                 # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(pos):\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                norm = math.sqrt(dx*dx + dy*dy)\n                if norm < 1e-14:\n                    return [[1,0],[0,1]]\n                dx /= norm\n                dy /= norm\n                cos_a = dx\n                sin_a = dy\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0, 1 - cos_t*cos_t))\n                K = [[0,-kz,ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n                return R\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * unit_dir[d] for d in range(n))\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(num_nodes + 1) / (num_nodes + 1)) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos)**2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend(tree, sample_pt):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n\n                if (not collision_free_node(step_pos)) or (not collision_free_edge(current_node.position, step_pos)):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n            return p\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n\n        grow_from_start = True\n        informed_sampling_enabled = False\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached - return best path found so far\n                if best_path_nodes:\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, path_smoothed, all_nodes, edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            # Sample point\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_from_start else start_pos\n                else:\n                    for _ in range(100):\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample_pt = candidate\n                            break\n                    else:\n                        sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            current_tree = tree_start if grow_from_start else tree_goal\n            other_tree = tree_goal if grow_from_start else tree_start\n\n            new_node = extend(current_tree, sample_pt)\n            if new_node is None:\n                grow_from_start = not grow_from_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_from_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    merged_path = path_start + path_goal[::-1]\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    merged_path = path_start + path_goal[::-1]\n\n                cost_path = 0.0\n                for i in range(len(merged_path) - 1):\n                    cost_path += dist(merged_path[i], merged_path[i+1])\n\n                if cost_path + 1e-12 < best_path_cost:\n                    best_path_cost = cost_path\n                    best_path_nodes = merged_path\n                    informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(True, path_smoothed, all_nodes, edges)\n\n            grow_from_start = not grow_from_start\n\n        # If max iter reached\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, path_smoothed, all_nodes, edges)\n        else:\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.44347,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1539.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018462204933166505,
                    "num_nodes_avg": 61.6,
                    "path_length_avg": 164.40391845790322,
                    "smoothness_avg": 0.039776554728749074,
                    "success_improvement": 0.0,
                    "time_improvement": 22.13384522718976,
                    "length_improvement": 9.887607146424283,
                    "smoothness_improvement": 522.5894576760151,
                    "objective_score": 11.23062228582186
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04775574207305908,
                    "num_nodes_avg": 241.0,
                    "path_length_avg": 237.6788275139789,
                    "smoothness_avg": 0.10840306495333914,
                    "success_improvement": 0.0,
                    "time_improvement": 80.08966613811563,
                    "length_improvement": 20.655966170104808,
                    "smoothness_improvement": 2689.2889408211017,
                    "objective_score": 41.604537779561156
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037290644645690915,
                    "num_nodes_avg": 220.3,
                    "path_length_avg": 126.74960539723338,
                    "smoothness_avg": 0.11825147057856991,
                    "success_improvement": 0.0,
                    "time_improvement": 64.3690072374461,
                    "length_improvement": 15.818947262776991,
                    "smoothness_improvement": 1404.1499773437909,
                    "objective_score": 29.49524151050818
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius rewiring. It combines efficient two-tree growth with incremental connection attempts and robust parent-child node management to ensure tree integrity and optimal cost paths. Incorporating goal biasing and ellipsoidal sampling directs exploration to promising regions, while collision checks and path smoothing guarantee feasible, smooth, and lower-cost solutions found within a strict 30-second time budget.",
          "planning_mechanism": "The algorithm grows two trees from start and goal positions alternately, sampling points biased towards the goal and within an informed ellipsoidal region after a feasible path is found. Each extension steers towards samples with step-size control, rewires neighbors in an adaptively scaled radius to optimize path cost, and tries incremental connections between trees for smoother path merging. Path smoothing via shortcutting is applied to improve smoothness before early return upon solution or after timeout, ensuring time-bounded, efficient planning with quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 25.0\n            r = 25.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(10.0, min(25.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_through = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, iterations=120):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < 0.2:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # update edges\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = start_tree + goal_tree\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.23958,
          "time_improvement": 54.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1479.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019574189186096193,
                    "num_nodes_avg": 58.2,
                    "path_length_avg": 152.38929996848267,
                    "smoothness_avg": 0.04437404688511375,
                    "success_improvement": 0.0,
                    "time_improvement": 17.443942896618015,
                    "length_improvement": 16.473009924288867,
                    "smoothness_improvement": 594.550193537133,
                    "objective_score": 11.500535821528842
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04689369201660156,
                    "num_nodes_avg": 219.4,
                    "path_length_avg": 236.19734015051682,
                    "smoothness_avg": 0.10009819150676033,
                    "success_improvement": 0.0,
                    "time_improvement": 80.44907222594205,
                    "length_improvement": 21.15052929427784,
                    "smoothness_improvement": 2475.59856528207,
                    "objective_score": 40.74282035304853
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03852677345275879,
                    "num_nodes_avg": 198.3,
                    "path_length_avg": 122.88093794791548,
                    "smoothness_avg": 0.11543046768317515,
                    "success_improvement": 0.0,
                    "time_improvement": 63.187893395175486,
                    "length_improvement": 18.388331976466336,
                    "smoothness_improvement": 1368.2670287391436,
                    "objective_score": 29.475369557541633
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive informed sampling confined within ellipsoidal bounds after an initial feasible path is found. It alternates growth between start and goal trees, performing incremental connection attempts and rewiring neighbors based on an adaptive radius that scales with the number of nodes and dimensionality, optimizing path cost. The planner ensures collision-free nodes and edges, leverages a goal bias for sampling efficiency, and applies randomized path shortcut smoothing. It respects a maximum execution time of 30 seconds, returning the best found solution upon timeout or success.",
          "planning_mechanism": "The planner initializes two trees from start and goal positions, sampling points with a bias to the goal and later constrained within an informed ellipsoid based on the best path cost discovered. It extends each tree toward sampled points with step-size limited steering and rewires neighbors to reduce path cost. Incremental connection attempts link the two trees efficiently. Upon first and subsequent successful connections, the path is extracted, shortcut smoothed, and returned early. If the 30-second time limit is reached without improvement, the best known path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 25.0\n        self.goal_sample_rate = 0.2  # Probability to sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            if not tree:\n                return None\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree)+1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_shortcutting(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            # Sampling strategy with goal bias and informed sampling\n            if informed_sampling:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            # Grow chosen tree\n            if grow_start:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed = path_shortcutting(best_path, iterations=50)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for n in nodes_all:\n                            for c in n.children:\n                                edges_all.append((n, c))\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed = path_shortcutting(best_path, iterations=50)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for n in nodes_all:\n                            for c in n.children:\n                                edges_all.append((n, c))\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n            grow_start = not grow_start\n\n        # Timeout or no solution found yet\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_shortcutting(best_path, iterations=50)\n        else:\n            smoothed = []\n\n        nodes_all = start_tree + goal_tree\n        edges_all = []\n        for n in nodes_all:\n            for c in n.children:\n                edges_all.append((n, c))\n\n        return PlannerResult(success_state, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.12699,
          "time_improvement": 60.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1196.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017078423500061037,
                    "num_nodes_avg": 74.7,
                    "path_length_avg": 159.03935609967442,
                    "smoothness_avg": 0.03220294156830893,
                    "success_improvement": 0.0,
                    "time_improvement": 27.970078744908122,
                    "length_improvement": 12.828008781899896,
                    "smoothness_improvement": 404.0459653509157,
                    "objective_score": 12.976855206606995
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048881125450134275,
                    "num_nodes_avg": 261.0,
                    "path_length_avg": 240.52605348480793,
                    "smoothness_avg": 0.0782806096721793,
                    "success_improvement": 0.0,
                    "time_improvement": 79.62047106779502,
                    "length_improvement": 19.705480188186502,
                    "smoothness_improvement": 1914.2164701092925,
                    "objective_score": 37.398319708522266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0283219575881958,
                    "num_nodes_avg": 174.1,
                    "path_length_avg": 129.62561851104118,
                    "smoothness_avg": 0.10758673024557733,
                    "success_improvement": 0.0,
                    "time_improvement": 72.93853524296814,
                    "length_improvement": 13.908836293613499,
                    "smoothness_improvement": 1268.4952674973724,
                    "objective_score": 31.005804169100003
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* techniques with adaptive informed sampling, incremental rewiring, and goal-biased sampling. It carefully manages parent-child relationships for nodes, enforces collision checks for nodes and edges, and applies path shortcut smoothing. Time-bounded execution ensures practical planning durations.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal within map bounds, biased initially towards the goal and later using ellipsoidal informed sampling based on the current best path cost. It incrementally extends and rewires nodes using an adaptive neighbor radius to optimize path cost. Upon connecting the two trees, it extracts and smooths the combined path, returning early when a better path is found or the time limit expires, ensuring efficient, robust, and high-quality planning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                   # For collision etc.\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 25.0\n        self.goal_sample_rate = 0.2  # Probability of direct goal sampling\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(src: Tuple[float, ...], tgt: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p: Tuple[float, ...]) -> bool:\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best: float, c_min: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Node:\n            if not tree:\n                return None\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_shortcutting(path: List[Tuple[float, ...]], iterations=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_shortcutting(best_path, iterations=50)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for n in nodes_all:\n                            for c in n.children:\n                                edges_all.append((n, c))\n                        # Early return on improved path\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_shortcutting(best_path, iterations=50)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for n in nodes_all:\n                            for c in n.children:\n                                edges_all.append((n, c))\n                        # Early return on improved path\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or no solution found yet\n        success = len(best_path) > 0\n        if success:\n            smoothed = path_shortcutting(best_path, iterations=50)\n        else:\n            smoothed = []\n\n        nodes_all = start_tree + goal_tree\n        edges_all = []\n        for n in nodes_all:\n            for c in n.children:\n                edges_all.append((n, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.71132,
          "time_improvement": 63.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 937.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016622161865234374,
                    "num_nodes_avg": 65.7,
                    "path_length_avg": 168.23638749818025,
                    "smoothness_avg": 0.029469696711196335,
                    "success_improvement": 0.0,
                    "time_improvement": 29.894406808805034,
                    "length_improvement": 7.786970136090249,
                    "smoothness_improvement": 361.264748000898,
                    "objective_score": 12.332039809864051
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.057538533210754396,
                    "num_nodes_avg": 262.4,
                    "path_length_avg": 236.78220682073623,
                    "smoothness_avg": 0.05852768417499068,
                    "success_improvement": 0.0,
                    "time_improvement": 76.01102283372273,
                    "length_improvement": 20.955283965304908,
                    "smoothness_improvement": 1405.9594696094716,
                    "objective_score": 34.02416099122516
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016658329963684083,
                    "num_nodes_avg": 137.8,
                    "path_length_avg": 125.48496845094992,
                    "smoothness_avg": 0.08995435075373796,
                    "success_improvement": 0.0,
                    "time_improvement": 84.08306319153832,
                    "length_improvement": 16.658858906958347,
                    "smoothness_improvement": 1044.2127018480476,
                    "objective_score": 33.7777542480934
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional anytime RRT* planner with dynamic informed sampling and adaptive neighborhood radius. It features incremental rewiring with recursive cost updates for efficient path cost optimization. The planner adaptively toggles between exploration and exploitation using heuristic cost bounds and maintains progressive path smoothing via iterative shortcutting. A robust collision checker ensures validity of nodes and edges, preventing invalid expansions. The planner respects a strict 30-second time limit and returns the best feasible path found within that time, supporting both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling collision-free points biased towards the goal or inside an ellipsoidal informed region once a current best path cost is available. Each iteration attempts to extend and rewire its chosen tree, connecting to the opposite tree if possible. Parent updates propagate cost improvements down children recursively, ensuring accurate path cost maintenance. Upon successful connection or time expiration, it smooths the current best path with randomized shortcuts and returns the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...] (2D or 3D)\n        self.parent = None                        # Node or None\n        self.cost = cost                         # Cost from root to this node\n        self.children = []                       # List[Node]\n        self.valid = True                        # Validity for collision check\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0):\n\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size                      # Tuple[int,...]\n        start_pos = map.start                  # Tuple[float,...]\n        goal_pos = map.goal                    # Tuple[float,...]\n        obstacles = map.obstacles              # List of obs (2D or 3D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w) and (y <= py <= y + h):\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[d] + (t[d] - f[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def collision_free_edge(a, b):\n            return not _is_edge_in_obstacle(a, b, resolution=self.step_size / 5)\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0  # tuned gamma for radius\n            r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if dist(n.position, pos)*dist(n.position, pos) <= radius_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Compute rotation matrix for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    result = []\n                    for i in range(3):\n                        row = []\n                        for j in range(3):\n                            val = sum(A[i][k]*B[k][j] for k in range(3))\n                            row.append(val)\n                        result.append(row)\n                    return result\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in sample)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                # rotate sample_scaled using R matrix\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not collision_free_node(new_pos):\n                return None\n\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            if not tree:\n                return None\n            current = min(tree, key=lambda n: dist(n.position, target_node.position))\n\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_shortcutting(path, iterations=120):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def extract_full_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate connection node\n            if path_goal and path_goal[0] == n_start.position:\n                path_goal = path_goal[1:]\n            return path_start + path_goal[::-1]\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start_tree = True\n        informed_sampling = False\n\n        while True:\n            iter_count = 0\n\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_planning_time:\n                    # Time limit exceeded\n                    if best_path:\n                        smoothed_path = path_shortcutting(best_path, iterations=150)\n                        success_state = True\n                    else:\n                        smoothed_path = []\n                        success_state = False\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n                iter_count += 1\n\n                if informed_sampling:\n                    sample_point = informed_sample(best_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample_point = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample_point = sample_uniform()\n\n                if grow_start_tree:\n                    new_node = extend_and_rewire(tree_start, sample_point)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connected_node = incremental_connect(tree_goal, new_node)\n                    if connected_node:\n                        new_path = extract_full_path(new_node, connected_node)\n                        combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = new_path\n                            informed_sampling = True\n                            # Immediate path smoothing & return for anytime planning\n                            smoothed = path_shortcutting(best_path, iterations=100)\n                            all_nodes = tree_start + tree_goal\n                            all_edges = []\n                            for node in all_nodes:\n                                for c in node.children:\n                                    all_edges.append((node,c))\n                            return PlannerResult(True, smoothed, all_nodes, all_edges)\n                else:\n                    new_node = extend_and_rewire(tree_goal, sample_point)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connected_node = incremental_connect(tree_start, new_node)\n                    if connected_node:\n                        new_path = extract_full_path(connected_node, new_node)\n                        combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = new_path\n                            informed_sampling = True\n                            smoothed = path_shortcutting(best_path, iterations=100)\n                            all_nodes = tree_start + tree_goal\n                            all_edges = []\n                            for node in all_nodes:\n                                for c in node.children:\n                                    all_edges.append((node,c))\n                            return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n                grow_start_tree = not grow_start_tree\n\n            # If max_iter reached without solution\n            if best_path:\n                smoothed = path_shortcutting(best_path, iterations=150)\n                success_state = True\n            else:\n                smoothed = []\n                success_state = False\n\n            all_nodes = tree_start + tree_goal\n            all_edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    all_edges.append((node,c))\n\n            return PlannerResult(success_state, smoothed, all_nodes, all_edges)",
          "objective": -26.6269,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1450.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017814135551452635,
                    "num_nodes_avg": 64.6,
                    "path_length_avg": 160.23453919790532,
                    "smoothness_avg": 0.04246171130377692,
                    "success_improvement": 0.0,
                    "time_improvement": 24.867141220963383,
                    "length_improvement": 12.172909986871392,
                    "smoothness_improvement": 564.6179889860304,
                    "objective_score": 12.717814308593445
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05599517822265625,
                    "num_nodes_avg": 245.7,
                    "path_length_avg": 241.94011810719567,
                    "smoothness_avg": 0.09577672337708686,
                    "success_improvement": 0.0,
                    "time_improvement": 76.6544787145554,
                    "length_improvement": 19.23342471564008,
                    "smoothness_improvement": 2364.404077677891,
                    "objective_score": 38.66504894588409
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04051084518432617,
                    "num_nodes_avg": 208.5,
                    "path_length_avg": 127.89412422756943,
                    "smoothness_avg": 0.11947296041588824,
                    "success_improvement": 0.0,
                    "time_improvement": 61.292124464937004,
                    "length_improvement": 15.058812351797874,
                    "smoothness_improvement": 1419.6872379134788,
                    "objective_score": 28.497835999408068
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire expansions, and goal-biased sampling. It grows two trees simultaneously from start and goal positions, alternately extending and rewiring nodes in each tree, while rigorously checking for collisions and edge validity. The planner adaptively computes neighbor radii based on tree size to balance exploration and rewiring efficiency. Upon finding a connection between the two trees or when the time limit (30 seconds) is reached, it reconstructs, smooths, and returns the best path found.",
          "planning_mechanism": "The planner alternates expansions of the start and goal trees by sampling new points biased toward the opposite tree root and within the free space. It incrementally extends the current tree toward the sample, chooses parent nodes for minimal cumulative cost among neighbors within an adaptive radius, and rewires neighbors for continuous path cost improvement. It then attempts an incremental connect-and-rewire towards the other tree to find a link. The process stops early when a better path is found or the maximum time elapses, ensuring efficient convergence and high-quality, smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float,...] (2D or 3D)\n        self.parent = None                # Parent Node or None\n        self.cost = cost                  # Cumulative cost from root\n        self.children = []                # List of child nodes\n        self.valid = True                 # For collision or validity checks\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of children\n        for child in self.children:\n            dist_child = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 12000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 7.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = max(0.0, min(goal_sample_rate, 1.0))\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import time\n        import random\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return goal_pos\n\n        def path_smoothing(path: list, trials: int = 120):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def add_node(tree: list, new_pos: tuple, best_parent: Node, cost: float):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            return new_node\n\n        def rewire(tree: list, new_node: Node, neighbors: list):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            max_steps = int(dist(current.position, target_pos) / self.step_size) + 3\n\n            for _ in range(max_steps):\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                current = new_node\n                if dist(current.position, target_pos) <= self.step_size:\n                    # Final edge check to target_pos (goal of connect)\n                    if collision_free_edge(current.position, target_pos):\n                        return current\n                    else:\n                        return None\n            return None\n\n        start_time = time.perf_counter()\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        best_cost = math.inf\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, return best path\n                break\n\n            # Sample point with goal bias toward opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos if grow_start_tree else start_pos\n            else:\n                sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n\n                    # Remove duplicate connection node position from one side\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    # Early stop if connecting path found\n                    break  # comment this line to allow full run until timeout\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    break  # comment this line to allow full run until timeout\n\n            grow_start_tree = not grow_start_tree\n\n        # If timeout or terminated early, smooth best path if found\n        if success_state and best_path:\n            extracted_path = path_smoothing(best_path, trials=120)\n        else:\n            extracted_path = []\n\n        # Collect all nodes and edges\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.54166,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1555.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01945180892944336,
                    "num_nodes_avg": 65.1,
                    "path_length_avg": 153.3277712843025,
                    "smoothness_avg": 0.04510695577154723,
                    "success_improvement": 0.0,
                    "time_improvement": 17.960093596935874,
                    "length_improvement": 15.958618925058389,
                    "smoothness_improvement": 606.0218091469374,
                    "objective_score": 11.609860909827127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0476423978805542,
                    "num_nodes_avg": 224.5,
                    "path_length_avg": 236.38194270374046,
                    "smoothness_avg": 0.10024175007223582,
                    "success_improvement": 0.0,
                    "time_improvement": 80.13692162229648,
                    "length_improvement": 21.088903648521907,
                    "smoothness_improvement": 2479.2924305728097,
                    "objective_score": 40.65531936925737
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04652514457702637,
                    "num_nodes_avg": 220.7,
                    "path_length_avg": 129.55202966549098,
                    "smoothness_avg": 0.13214863234166038,
                    "success_improvement": 0.0,
                    "time_improvement": 55.545496586303756,
                    "length_improvement": 13.957710500903683,
                    "smoothness_improvement": 1580.9208491885236,
                    "objective_score": 27.35979532201448
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius and ellipsoidal informed sampling. It grows two trees from start and goal alternately, incrementally connects them, rewires neighbors optimizing path costs with recursive parent updates, samples with goal bias and informed ellipsoidal regions after a solution is found, and applies randomized shortcut path smoothing. It enforces strict 30-second time limit, robust collision checks for nodes and edges, and manages tree integrity for efficient, high-quality, and smooth path planning with early termination on improved paths.",
          "planning_mechanism": "The planner alternates extending and rewiring two trees rooted at start and goal, sampling points with goal bias and informed ellipsoidal distribution when a solution exists. Each new node connects to the optimal neighbor within an adaptive radius, rewiring neighbors recursively to minimize costs. Incremental connections attempt smooth merges between trees. The path is extracted and smoothed by collision-checked shortcuts. If the time limit is exceeded or a quality path is found, the algorithm returns the best found path and tree structures.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Cumulative cost from root\n        self.children = []\n        self.valid = True                   # Node collision status\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, self.position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update costs for children\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d_] + factor*(tgt[d_] - src[d_]) for d_ in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1.0 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def uniform_sample():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos)**2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_try = nbr.cost + dist(nbr.position, new_pos)\n                if cost_try < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_try\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_try = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_try < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_try\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, max_trials=120):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n            return p\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # time elapsed, return best path found\n                if best_path:\n                    smoothed = path_smoothing(best_path)\n                    edges.clear()\n                    all_nodes = start_tree + goal_tree\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    all_nodes = start_tree + goal_tree\n                    edges.clear()\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    # Compute total cost precisely:\n                    combined_cost = 0.0\n                    for idx in range(len(combined_path)-1):\n                        combined_cost += dist(combined_path[idx], combined_path[idx+1])\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = start_tree + goal_tree\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                    path_smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, path_smoothed, all_nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = 0.0\n                    for idx in range(len(combined_path)-1):\n                        combined_cost += dist(combined_path[idx], combined_path[idx+1])\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = start_tree + goal_tree\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                    path_smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, path_smoothed, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # max iter reached\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n            extracted_path = smoothed\n        else:\n            success_state = False\n            extracted_path = []\n        all_nodes = start_tree + goal_tree\n        edges.clear()\n        for node in all_nodes:\n            for child in node.children:\n                edges.append((node, child))\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.38592,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1361.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020983338356018066,
                    "num_nodes_avg": 65.5,
                    "path_length_avg": 161.32467932360458,
                    "smoothness_avg": 0.04945382970295139,
                    "success_improvement": 0.0,
                    "time_improvement": 11.50071846809931,
                    "length_improvement": 11.575386909599898,
                    "smoothness_improvement": 674.0598255612371,
                    "objective_score": 9.135592050155957
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05672299861907959,
                    "num_nodes_avg": 253.7,
                    "path_length_avg": 234.57222995325628,
                    "smoothness_avg": 0.08260470633312732,
                    "success_improvement": 0.0,
                    "time_improvement": 76.35103568435166,
                    "length_improvement": 21.693037854326857,
                    "smoothness_improvement": 2025.47859171642,
                    "objective_score": 37.371311234752966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026766204833984376,
                    "num_nodes_avg": 157.9,
                    "path_length_avg": 124.94866239761761,
                    "smoothness_avg": 0.11667280520403618,
                    "success_improvement": 0.0,
                    "time_improvement": 74.42504789653893,
                    "length_improvement": 17.01504785143174,
                    "smoothness_improvement": 1384.0694703046786,
                    "objective_score": 32.65087129077142
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner that incorporates adaptive informed sampling within an ellipsoidal subset after the initial solution is found to effectively reduce the search space, together with dynamic neighbor radius tuning for local rewiring optimization. It balances exploration and exploitation by alternately growing trees from start and goal, employs collision-aware incremental tree expansion and rewiring for path cost improvement, and applies path smoothing with shortcutting to yield smooth, shorter paths. Planning is strictly time-limited to 30 seconds, returning the best feasible path found within that limit.",
          "planning_mechanism": "The planner grows two RRT* trees starting from the start and goal positions, sampling points with a goal bias initially, then switching to ellipsoidal informed sampling to concentrate on promising regions once a path is found. Each iteration extends one tree towards a sample, rewires neighbors within an adaptive radius to optimize costs, and tries connecting incrementally to the other tree in a collision-free manner. Upon connection, the best path is extracted, smoothed by shortcutting edges, and returned immediately. The planner tracks elapsed time to enforce a 30-second limit, returning the best path so far if time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision checking etc.\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 50000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0    # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def collision_free_edge(f, t, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(f, t, obstacles, is_3d, resolution)\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(p):\n                    return p\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            # rotation matrix to align x-axis with direction\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                ux, uy, uz = direction\n                norm_v = math.sqrt(ux*ux + uy*uy + uz*uz)\n                if norm_v < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    # Orthonormal basis\n                    if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                        vx_, vy_, vz_ = 1,0,0\n                    else:\n                        vx_, vy_, vz_ = -uy, ux, 0\n                    norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                    vx_ /= norm_v_\n                    vy_ /= norm_v_\n                    vz_ /= norm_v_\n                    wx = uy * vz_ - uz * vy_\n                    wy = uz * vx_ - ux * vz_\n                    wz = ux * vy_ - uy * vx_\n                    R = [\n                        [ux, vx_, wx],\n                        [uy, vy_, wy],\n                        [uz, vz_, wz]\n                    ]\n\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return 50.0\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(5.0, min(30.0, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr: \n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    best_path = path_smooth(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            sample = informed_sample(best_cost) if informed_sampling else sample_uniform()\n\n            # Occasionally bias towards goal/start to accelerate convergence\n            if not informed_sampling and random.random() < 0.15:\n                sample = goal_pos if grow_start else start_pos\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_goal)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_start)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        if best_path:\n            best_path = path_smooth(best_path)\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.11907,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1590.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022664451599121095,
                    "num_nodes_avg": 61.8,
                    "path_length_avg": 155.67271006932287,
                    "smoothness_avg": 0.04259113606946942,
                    "success_improvement": 0.0,
                    "time_improvement": 4.410458964862929,
                    "length_improvement": 14.673320819055819,
                    "smoothness_improvement": 566.6437676194951,
                    "objective_score": 7.091020691367518
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04650657176971436,
                    "num_nodes_avg": 226.6,
                    "path_length_avg": 243.12114397957802,
                    "smoothness_avg": 0.10152181093980923,
                    "success_improvement": 0.0,
                    "time_improvement": 80.610470479338,
                    "length_improvement": 18.839164285493958,
                    "smoothness_improvement": 2512.2293186860493,
                    "objective_score": 40.51212059433044
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03863036632537842,
                    "num_nodes_avg": 213.4,
                    "path_length_avg": 125.15582763118682,
                    "smoothness_avg": 0.14075418665353318,
                    "success_improvement": 0.0,
                    "time_improvement": 63.0889110115339,
                    "length_improvement": 16.877458567443405,
                    "smoothness_improvement": 1690.3828648395997,
                    "objective_score": 30.75407934114685
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius rewiring, goal-biased and informed ellipsoidal sampling, and incremental connection attempts to efficiently plan collision-free, near-optimal paths within a strict 30-second time budget. It maintains robust parent-child relationships in nodes for dynamic path cost updates and applies randomized path smoothing for improved path quality and smoothness.\n\nThe planning mechanism alternates growth between two trees rooted at start and goal positions using adaptive sampling strategies. Each extension attempts to connect to the opposite tree incrementally. Adaptive rewiring optimizes local tree structure. The planner prioritizes collision-free node and edge validations and employs early stopping upon time expiration or path discovery, returning the best available solution.",
          "planning_mechanism": "= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(f_p, t_p, resolution=None):\n            res = resolution if resolution is not None else self.step_size / 5\n            return not self._is_edge_in_obstacle(f_p, t_p, obstacles, is_3d, res)\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c = math.cos(angle)\n                s = math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        # informed sampling inside ellipsoid between start and goal based on c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + child._distance(self))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import time\n        import random\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(f_p, t_p, resolution=None):\n            res = resolution if resolution is not None else self.step_size / 5\n            return not self._is_edge_in_obstacle(f_p, t_p, obstacles, is_3d, res)\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c = math.cos(angle)\n                s = math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        # informed sampling inside ellipsoid between start and goal based on c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached - return best path found so far\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=True, path=smoothed, nodes=all_nodes, edges=edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    merged_path = path_start + path_goal[::-1]\n\n                    cost = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost += dist(merged_path[i], merged_path[i+1])\n\n                    if cost < best_path_cost:\n                        best_path_cost = cost\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    # Update edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=smoothed, nodes=all_nodes, edges=edges)\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    merged_path = path_start + path_goal[::-1]\n\n                    cost = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost += dist(merged_path[i], merged_path[i+1])\n\n                    if cost < best_path_cost:\n                        best_path_cost = cost\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=smoothed, nodes=all_nodes, edges=edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached, return best path found if any\n        if best_path_nodes:\n            smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(success=True, path=smoothed, nodes=all_nodes, edges=edges)\n\n        edges.clear()\n        all_nodes = tree_start + tree_goal\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.05133,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1521.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01991417407989502,
                    "num_nodes_avg": 64.8,
                    "path_length_avg": 155.04441879163704,
                    "smoothness_avg": 0.04466905159820611,
                    "success_improvement": 0.0,
                    "time_improvement": 16.010023359011814,
                    "length_improvement": 15.017697224267826,
                    "smoothness_improvement": 599.1676579100163,
                    "objective_score": 10.802384742107192
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06724052429199219,
                    "num_nodes_avg": 260.4,
                    "path_length_avg": 236.4182017339564,
                    "smoothness_avg": 0.10523091875880138,
                    "success_improvement": 0.0,
                    "time_improvement": 71.96606670557905,
                    "length_improvement": 21.076799340577505,
                    "smoothness_improvement": 2607.667334431094,
                    "objective_score": 38.84351655194469
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04058032035827637,
                    "num_nodes_avg": 192.7,
                    "path_length_avg": 125.22585054667861,
                    "smoothness_avg": 0.11437460966075522,
                    "success_improvement": 0.0,
                    "time_improvement": 61.2257413427433,
                    "length_improvement": 16.830952681106677,
                    "smoothness_improvement": 1354.8365926292943,
                    "objective_score": 28.508095902190796
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines a bidirectional RRT* framework with adaptive neighborhood rewiring, informed ellipsoidal sampling after initial solution, goal-biased sampling, incremental connection attempts, recursive cost propagation in the tree, and randomized path smoothing. It enforces strict 30-second time limits, robust collision checking for nodes and edges, and adaptive neighbor radius for balancing exploration and exploitation to improve planning efficiency, path quality, robustness, and smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions with goal-biased and informed sampling. Each new node is connected with lowest cost parent from neighbors found with an adaptive radius, followed by rewiring neighbors to reduce costs. Incremental connection attempts try to join the two trees progressively. Upon connection, the combined path is smoothed via randomized shortcutting. The algorithm terminates early if the time limit is exceeded or a sufficiently good path is found, immediately returning the best solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # Collision-free flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to children\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Rotation matrix aligning standard axis to vector direction (for informed sampling)\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                # Compute orthogonal vector k and Rodrigues formula components\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Informed sampling inside an ellipsoid between start and goal with current best cost c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best/2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                # Sample unit n-ball\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT* scaling)\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        # Rewire neighbors if cheaper path via new_node is found, with recursive cost update\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        # Extend tree towards target point, with rewiring and collision checks\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Incrementally connect new_node with the opposite tree by successive steps with rewiring\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        # Path smoothing by randomized shortcutting with collision checks\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached\n                if best_path_nodes:\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    # Rebuild edges from trees if needed\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n                else:\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n            iter_count += 1\n\n            # Select sample point respecting informed sampling after first solution\n            if informed_sampling_enabled:\n                sample = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node:\n                    # Build combined path\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                    # Remove duplicate joining node\n                    if path_from_goal and path_from_goal[0] == new_node.position:\n                        path_from_goal = path_from_goal[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    # Compute total cost of combined path\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    # Update edges to reflect current tree structure\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    # Early return with smoothed path if meaningful improvement\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node:\n                    path_from_goal = new_node.path_from_root()\n                    path_from_start = connect_node.path_from_root()\n                    if path_from_start and path_from_start[0] == new_node.position:\n                        path_from_start = path_from_start[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            grow_start = not grow_start\n\n        # Max iter reached - return best path if found\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            success_state = True\n        else:\n            path_smoothed = []\n            success_state = False\n\n        return PlannerResult(success_state, path_smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.0503,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01970551013946533,
                    "num_nodes_avg": 77.3,
                    "path_length_avg": 155.21948600660014,
                    "smoothness_avg": 0.04314336898114142,
                    "success_improvement": 0.0,
                    "time_improvement": 16.890083933565084,
                    "length_improvement": 14.921740109629011,
                    "smoothness_improvement": 575.2874118801233,
                    "objective_score": 10.927810261395944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05414080619812012,
                    "num_nodes_avg": 233.5,
                    "path_length_avg": 234.3512013169539,
                    "smoothness_avg": 0.09883281178837662,
                    "success_improvement": 0.0,
                    "time_improvement": 77.42760388254398,
                    "length_improvement": 21.76682357508114,
                    "smoothness_improvement": 2443.039433711886,
                    "objective_score": 39.79684304833885
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04749903678894043,
                    "num_nodes_avg": 216.4,
                    "path_length_avg": 124.7482991878453,
                    "smoothness_avg": 0.12755005669926972,
                    "success_improvement": 0.0,
                    "time_improvement": 54.614948276294115,
                    "length_improvement": 17.148119555091732,
                    "smoothness_improvement": 1522.4273064488602,
                    "objective_score": 27.42624492615088
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm with adaptive neighbor radius and ellipsoidal informed sampling. It grows two trees from start and goal, alternately extending and rewiring nodes to minimize path cost. The planner uses incremental steering and rewiring to connect trees efficiently, with rigorous collision checks on nodes and edges. Goal biasing combined with informed sampling after an initial solution improves convergence. A path smoothing process refines the final output. The planning halts either on a successful connection or upon exceeding a 30-second time limit, returning the best feasible path found so far.",
          "planning_mechanism": "The planner alternately samples points with goal bias and (when available) informed ellipsoidal sampling based on the best path cost. Each tree is extended by steering towards samples in step-size increments, selecting the best parent among neighbors within an adaptive radius to minimize cost, followed by rewiring neighbors to the new node if beneficial. Incremental connection attempts between trees use the same rewiring strategy to optimize connectivity. The path is extracted by concatenating the two connected tree paths and improved via shortcut path smoothing. Strict collision checks and boundary enforcement maintain path validity.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position           # Tuple[float, ...]: position in space\n        self.parent = parent               # reference to parent Node or None\n        self.cost = cost                   # cost-to-come from root\n        self.children: List[Node] = []    # list of child Nodes\n        self.valid = True                  # collision-free validity flag\n\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size / 5, 0.5))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 20.0\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position)**2 <= radius_sq]\n\n        # Informed sampling helper methods\n        c_min = dist(start, goal)\n        best_cost = math.inf\n        informed_sampling_enabled = False\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def rotation_matrix(direction):\n            # Returns rotation matrix aligning x-axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                # No solution found or negligible improvement, sample uniformly\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(p):\n                        return p\n                # fallback\n                return start\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x, y)\n                else:\n                    x = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x, y, z)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend(tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors if better with new_node as parent\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def try_connect_incremental(new_node, other_tree):\n            curr = nearest(other_tree, new_node.position)\n            max_steps = int(dist(curr.position, new_node.position) / self.step_size) + 5\n            for _ in range(max_steps):\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos, parent=best_parent, cost=min_cost)\n                other_tree.append(connect_node)\n\n                # Rewire neighbors to connect_node if cheaper path\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    cost_through_connect = connect_node.cost + dist(connect_node.position, nbr.position)\n                    if cost_through_connect < nbr.cost and collision_free_edge(connect_node.position, nbr.position):\n                        nbr.update_parent(connect_node, cost_through_connect)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n\n                curr = connect_node\n\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            path_smoothed = path[:]\n            length = len(path_smoothed)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(path_smoothed[i], path_smoothed[j]):\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n                    length = len(path_smoothed)\n            return path_smoothed\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        grow_start_tree = True\n        best_path: List[Tuple[float, ...]] = []\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time limit exceeded\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    # Rebuild edges for returned nodes\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Choose sample point\n            if informed_sampling_enabled:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal if grow_start_tree else start\n                else:\n                    for _ in range(100):\n                        sample_candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(sample_candidate):\n                            sample_point = sample_candidate\n                            break\n                    else:\n                        sample_point = start  # fallback\n\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect_incremental(new_node, tree_goal)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # Remove duplicated connecting node in concatenation if any\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n\n                    # Collect nodes and edges\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect_incremental(new_node, tree_start)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_enabled = True\n\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # After max iterations or no connection found\n        if best_path:\n            best_path = path_smoothing(best_path)\n            edges.clear()\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            edges.clear()\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.03083,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1732.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01930983066558838,
                    "num_nodes_avg": 70.1,
                    "path_length_avg": 160.67320291325643,
                    "smoothness_avg": 0.04443591589583589,
                    "success_improvement": 0.0,
                    "time_improvement": 18.558900809169035,
                    "length_improvement": 11.932471453416058,
                    "smoothness_improvement": 595.5185779056416,
                    "objective_score": 10.93175742296213
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06352660655975342,
                    "num_nodes_avg": 267.7,
                    "path_length_avg": 243.31306079876077,
                    "smoothness_avg": 0.12211454984647178,
                    "success_improvement": 0.0,
                    "time_improvement": 73.514474054612,
                    "length_improvement": 18.775096927231406,
                    "smoothness_improvement": 3042.0953231047833,
                    "objective_score": 41.019838217353794
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050828170776367185,
                    "num_nodes_avg": 238.3,
                    "path_length_avg": 128.62221762890337,
                    "smoothness_avg": 0.1304354255475066,
                    "success_improvement": 0.0,
                    "time_improvement": 51.43398023086018,
                    "length_improvement": 14.575247382713924,
                    "smoothness_improvement": 1559.1289852226587,
                    "objective_score": 26.14088847191413
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a hybrid bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius rewiring, and a max-time enforced incremental search. It grows two trees simultaneously from the start and goal, alternately extending each with goal bias and ellipsoidal informed sampling after a path is found. Rewiring optimizes the tree locally, and incremental connection attempts facilitate merging. The planner maintains the best path found, applies path smoothing, and respects strict collision and boundary checks while enforcing a 30-second runtime cap for real-time applicability.",
          "planning_mechanism": "The planner grows bidirectional trees, samples points informed by the current best path cost, alternates expansions, rewires neighbors to optimize cost, incrementally attempts to connect the two trees, and interrupts when the time budget or solution criteria are met. The final path is shortcut-smoothed to enhance smoothness and shortest path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, max_time_sec: float = 30.0,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time_sec = max_time_sec\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            r = self.neighbor_radius_max * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [rng.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                # Uniform sampling\n                while True:\n                    pt = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            attempts = 0\n            while True:\n                if attempts > 100:\n                    # fallback uniform\n                    while True:\n                        pt = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(pt):\n                            return pt\n                dir_sample = unit_ball_sample(n)\n                radius_sample = rng.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n                attempts += 1\n\n        def sample_free(best_cost, c_min):\n            if best_path_found and best_cost < math.inf:\n                return informed_sample(best_cost, c_min)\n            else:\n                if rng.random() < self.goal_sample_rate:\n                    return goal_pos if grow_start_tree else start_pos\n                while True:\n                    pt = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            max_steps = int(dist(current.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                if time.perf_counter() - start_time > self.max_time_sec:\n                    return None\n\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    c_candidate = nbr.cost + dist(nbr.position, new_pos)\n                    if c_candidate < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = c_candidate\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    c_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if c_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, c_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length < 3:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not collision_free_edge(path[i], path[j]):\n                    continue\n                # shortcut path segment\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        best_path_found = False\n        grow_start_tree = True\n\n        for i in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = sample_free(best_cost, dist(start_pos, goal_pos))\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        best_path_found = True\n                        smoothed_path = path_smoothing(best_path)\n                        # Early exit on improvement\n                        return PlannerResult(True, smoothed_path, start_tree + goal_tree,\n                                             [(node, c) for node in start_tree + goal_tree for c in node.children])\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        best_path_found = True\n                        smoothed_path = path_smoothing(best_path)\n                        # Early exit on improvement\n                        return PlannerResult(True, smoothed_path, start_tree + goal_tree,\n                                             [(node, c) for node in start_tree + goal_tree for c in node.children])\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path_found:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n            extracted_path = smoothed\n        else:\n            success_state = False\n            extracted_path = []\n\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, extracted_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.96555,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1486.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0238816499710083,
                    "num_nodes_avg": 71.6,
                    "path_length_avg": 157.26567604352437,
                    "smoothness_avg": 0.04133771368146112,
                    "success_improvement": 0.0,
                    "time_improvement": -0.7231942015752976,
                    "length_improvement": 13.8001909264348,
                    "smoothness_improvement": 547.024985396885,
                    "objective_score": 5.278204851798796
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05582742691040039,
                    "num_nodes_avg": 230.6,
                    "path_length_avg": 234.4029490709003,
                    "smoothness_avg": 0.09723789295059786,
                    "success_improvement": 0.0,
                    "time_improvement": 76.72441762635525,
                    "length_improvement": 21.749548685337324,
                    "smoothness_improvement": 2402.001023242233,
                    "objective_score": 39.3772401411852
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028737664222717285,
                    "num_nodes_avg": 177.2,
                    "path_length_avg": 120.98949986111673,
                    "smoothness_avg": 0.1265714947315003,
                    "success_improvement": 0.0,
                    "time_improvement": 72.54132998608097,
                    "length_improvement": 19.644535093115042,
                    "smoothness_improvement": 1509.980070448764,
                    "objective_score": 33.24120636669112
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* with adaptive informed sampling, dynamic rewiring, incremental connect-and-rewire procedures, and recursive parent-child cost updates. It alternates growth between start and goal trees with early termination upon finding improved feasible paths or timeout. Post-processing applies randomized path smoothing to enhance path quality and smoothness. The planner ensures robust collision checks for nodes and edges, bounds sampling within map limits, and limits execution time to 30 seconds.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal using goal-biased and informed ellipsoidal sampling after initial solution discovery. It extends each tree via adaptive neighbor-radius rewiring, incrementally attempts connection to the opposite tree, and upon connection, updates path costs recursively down the tree structure. Early termination occurs on improved solution discovery or timeout. Final path undergoes randomized shortcut smoothing to reduce unnecessary waypoints and improve smoothness. Collision checks are rigorously enforced for both nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cost from root to this node\n        self.children = []\n        self.valid = True                  # For collision and validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, self.position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist_child = self._dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_time_sec: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 6)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.neighbor_radius_max\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            rsq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= rsq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf:\n                return sample_free()\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][j] * sample_scaled[j] for j in range(n))\n                    y_rot = sum(R[1][j] * sample_scaled[j] for j in range(n))\n                    z_rot = sum(R[2][j] * sample_scaled[j] for j in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def extend_and_rewire(tree, sample_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample_pos))\n            new_pos = steer(nearest_node.position, sample_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c_cost = nbr.cost + dist(nbr.position, new_pos)\n                if c_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    c_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if c_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = c_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_tree_start = True\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        iteration = 0\n        while iteration < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit exceeded: break early and return best path found\n                break\n\n            iteration += 1\n\n            # Sampling: informed or uniform with goal bias\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            # Extend tree\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Remove duplicate connecting node if any\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost + 1e-10 < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        # Update edges\n                        all_edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost + 1e-10 < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # Timeout or max iterations reached without early return\n        success = len(best_path) > 0\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.77476,
          "time_improvement": 47.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1687.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022630143165588378,
                    "num_nodes_avg": 64.3,
                    "path_length_avg": 166.42205176774021,
                    "smoothness_avg": 0.039211761373336165,
                    "success_improvement": 0.0,
                    "time_improvement": 4.555158138398374,
                    "length_improvement": 8.781436299933878,
                    "smoothness_improvement": 513.7492151954013,
                    "objective_score": 5.691580777483295
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05379765033721924,
                    "num_nodes_avg": 200.2,
                    "path_length_avg": 241.56345352392373,
                    "smoothness_avg": 0.12764686894042654,
                    "success_improvement": 0.0,
                    "time_improvement": 77.57067249504186,
                    "length_improvement": 19.35916619522515,
                    "smoothness_improvement": 3184.4458781606168,
                    "objective_score": 43.06526437836067
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04204602241516113,
                    "num_nodes_avg": 211.0,
                    "path_length_avg": 121.95273865047264,
                    "smoothness_avg": 0.11507775551315051,
                    "success_improvement": 0.0,
                    "time_improvement": 59.82527160356018,
                    "length_improvement": 19.00479775372701,
                    "smoothness_improvement": 1363.7805559709343,
                    "objective_score": 28.567443811668127
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm using adaptive neighborhood rewiring, informed ellipsoidal sampling after the first solution, goal-biased sampling, incremental tree extension and connection, recursive cost propagation on rewiring, and randomized path smoothing. It strictly enforces a 30-second time limit, performs robust collision checking for both nodes and edges, and uses adaptive neighbor radius for efficient exploration and exploitation to deliver high-quality, smooth, and shorter paths with improved success rate and reduced planning time.",
          "planning_mechanism": "The planner grows two trees from start and goal points alternately. It samples points with goal bias and then informed ellipsoidal sampling once a path is found to focus search. Nodes are extended by steering towards samples respecting map bounds and collision constraints. Each new node connects to the best parent in an adaptive neighborhood, followed by rewiring neighbors to optimize costs with recursive propagation. Incremental connection steps try to link the two trees. Upon connection, the combined path is extracted and smoothed by randomized shortcutting. The process terminates early on time limit or upon finding a sufficiently good path, returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None                # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # Collision-free flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other:'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child:'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent:'Node', new_cost:float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate recursive cost update to children\n        for child in self.children:\n            child.update_parent(self, self.cost + child._distance(self))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = min(max(goal_sample_rate, 0.0), 1.0)\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                     # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start                 # Tuple[float, ...]\n        goal_pos = map.goal                   # Tuple[float, ...]\n        obstacles = map.obstacles             # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        # Internal helpers\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_]+ratio*(to_p[d_]-from_p[d_]) for d_ in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(min(max(0.0, pos[d_]), bounds[d_]) for d_ in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        # Rotation matrix aligning standard axis to vector direction (for informed sampling)\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                # No solution yet or invalid cost, do uniform sampling\n                return sample_free()\n            center = tuple((start_pos[d_] + goal_pos[d_]) * 0.5 for d_ in range(dim))\n            direction = tuple((goal_pos[d_]-start_pos[d_])/c_min for d_ in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best/2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d_]*radii[d_] for d_ in range(n))\n                # Rotate sample_scaled by R\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d_] + rotated[d_] for d_ in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # Fallback\n            return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(num_nodes + 1) / (num_nodes + 1)) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position)**2) <= r_sq]\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node or None:\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                # Check if connection to new_node possible\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n            return p\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes: List[Tuple[float, ...]] = []\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes: List[Node] = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        grow_from_start = True\n        informed_sampling_enabled = False\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached - return best path found so far\n                if best_path_nodes:\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    # Rebuild edges for final output\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_from_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_from_start:\n                new_node = extend(tree_start, sample_pt)\n                if new_node is None:\n                    grow_from_start = not grow_from_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # Avoid duplicate connecting node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    merged_path = path_start + path_goal[::-1]\n\n                    cost_path = 0.0\n                    for i in range(len(merged_path) - 1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    # Rebuild edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    # Early return with smoothed path\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            else:\n                new_node = extend(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_from_start = not grow_from_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    merged_path = path_start + path_goal[::-1]\n\n                    cost_path = 0.0\n                    for i in range(len(merged_path) - 1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            grow_from_start = not grow_from_start\n\n        # Max iterations reached, return best path if exists\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            success_state = True\n            extracted_path = path_smoothed\n        else:\n            success_state = False\n            extracted_path = []\n            all_nodes = tree_start + tree_goal\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    # Collision checks (unchanged)\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.72647,
          "time_improvement": 47.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1617.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022324228286743165,
                    "num_nodes_avg": 82.5,
                    "path_length_avg": 155.9321907805082,
                    "smoothness_avg": 0.043335521576774345,
                    "success_improvement": 0.0,
                    "time_improvement": 5.845384056142064,
                    "length_improvement": 14.531095329520156,
                    "smoothness_improvement": 578.2950172678186,
                    "objective_score": 7.551309369085743
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05632150173187256,
                    "num_nodes_avg": 240.0,
                    "path_length_avg": 239.18260027151123,
                    "smoothness_avg": 0.11625410215770893,
                    "success_improvement": 0.0,
                    "time_improvement": 76.51842784960311,
                    "length_improvement": 20.153963539941614,
                    "smoothness_improvement": 2891.3017829630635,
                    "objective_score": 41.442829977684575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04308841228485107,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 123.20387246592125,
                    "smoothness_avg": 0.11637992470482203,
                    "success_improvement": 0.0,
                    "time_improvement": 58.82927418234173,
                    "length_improvement": 18.173854246096166,
                    "smoothness_improvement": 1380.3440519728647,
                    "objective_score": 28.185273363786074
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling, designed for improved planning efficiency, path quality, and robustness. It grows two trees alternately from start and goal, rewiring neighbors to optimize path cost dynamically, performs rigorous collision checks, applies path smoothing, and respects a strict 30-second time limit, returning the best feasible solution found.",
          "planning_mechanism": "The planning mechanism alternates expansions between start and goal trees by sampling points biased toward the opposite root, incrementally extends trees within step-size limits, rewires neighbors within an adaptive radius for cost minimization, attempts incremental tree connection with rewiring, and upon connection or timeout, reconstructs and smooths the combined path to achieve shorter, feasible, and smoother paths efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates to children recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions: tree_a expands next\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def valid_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def sample_free(from_root, to_root):\n            if random.random() < self.goal_sample_rate:\n                return to_root\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if valid_node(p):\n                    return p\n            return to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(near_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost and valid_edge(nb.position, new_pos):\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nb in neighbors:\n                    cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost and valid_edge(nb.position, new_pos):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for iter_idx in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached - return best found so far\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Compute total cost including connection edge\n                connection_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connection_cost < best_cost:\n                    best_cost = connection_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]  # Avoid duplicating connect node\n                    extracted_path = path_smoothing(combined, max_iters=100)\n                    success_state = True\n                # Optionally break early on first found path for speed\n                break\n\n            # Swap trees to alternate expansions\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timed out or loop ended without early break but have best connection, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined, max_iters=100)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.60906,
          "time_improvement": 50.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1438.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018255233764648438,
                    "num_nodes_avg": 86.9,
                    "path_length_avg": 158.6310064628254,
                    "smoothness_avg": 0.03500431078560962,
                    "success_improvement": 0.0,
                    "time_improvement": 23.006766370665183,
                    "length_improvement": 13.051831688570914,
                    "smoothness_improvement": 447.89347687229304,
                    "objective_score": 11.751863633275203
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.044417715072631835,
                    "num_nodes_avg": 265.0,
                    "path_length_avg": 239.7954843297636,
                    "smoothness_avg": 0.1051344353301448,
                    "success_improvement": 0.0,
                    "time_improvement": 81.48135704550045,
                    "length_improvement": 19.949365200407478,
                    "smoothness_improvement": 2605.1847463175554,
                    "objective_score": 41.4602038853194
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05558626651763916,
                    "num_nodes_avg": 281.0,
                    "path_length_avg": 126.12447201816266,
                    "smoothness_avg": 0.10695029455126903,
                    "success_improvement": 0.0,
                    "time_improvement": 46.887647590821175,
                    "length_improvement": 16.23413108750312,
                    "smoothness_improvement": 1260.3998524425672,
                    "objective_score": 23.61511975695981
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive neighbor radius and informed sampling to efficiently find collision-free, optimized paths within a 30-second time limit. It alternates expansions from start and goal trees, rewires locally for cost improvements, and applies path smoothing to enhance smoothness and shorten the resulting path.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, samples points with goal bias and informed ellipsoidal distribution after an initial solution, incrementally extends and rewires both trees to reduce path cost, attempts connecting the trees progressively, and terminates early upon success or timeout, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 50000, step_size: float = 5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 20.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_informed(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                # fallback uniform random sampling\n                for _ in range(1000):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(p):\n                        return p\n                return start_pos  # fallback\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                unit_ball = self._unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * x for x in unit_ball)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    sample_rotated = (x, y)\n                else:\n                    x = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    sample_rotated = (x, y, z)\n                sample_pos = tuple(center[d] + sample_rotated[d] for d in range(dim))\n                sample_pos = clamp_to_bounds(sample_pos)\n                if collision_free_node(sample_pos):\n                    return sample_pos\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        c_min = dist(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    best_path = self._path_smoothing(best_path, obstacles, is_3d, bounds)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling:\n                sample = sample_informed(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    for _ in range(1000):\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n                    else:\n                        sample = start_pos\n\n            def extend(tree, target_pt):\n                nearest_node = min(tree, key=lambda n: dist(n.position, target_pt))\n                new_pos = steer(nearest_node.position, target_pt)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    return None\n                n_nodes = len(tree) + 1\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    if neighbor == nearest_node:\n                        continue\n                    tentative = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = tentative\n                        best_parent = neighbor\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                rewire(tree, new_node, neighbors)\n                return new_node\n\n            def incremental_connect(new_node, other_tree):\n                curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n                while True:\n                    next_pos = steer(curr.position, new_node.position)\n                    next_pos = clamp_to_bounds(next_pos)\n                    if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                        return None\n                    radius = adaptive_radius(len(other_tree) + 1)\n                    neighbors = near_nodes(other_tree, next_pos, radius)\n                    min_cost = curr.cost + dist(curr.position, next_pos)\n                    best_parent = curr\n                    for nbr in neighbors:\n                        if nbr == curr:\n                            continue\n                        tentative = nbr.cost + dist(nbr.position, next_pos)\n                        if tentative < min_cost and collision_free_edge(nbr.position, next_pos):\n                            min_cost = tentative\n                            best_parent = nbr\n                    connect_node = Node(next_pos)\n                    best_parent.add_child(connect_node)\n                    connect_node.cost = min_cost\n                    other_tree.append(connect_node)\n                    rewire(other_tree, connect_node, neighbors)\n\n                    if dist(connect_node.position, new_node.position) <= self.step_size:\n                        if collision_free_edge(connect_node.position, new_node.position):\n                            return connect_node\n                        else:\n                            return None\n                    curr = connect_node\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n                    best_path = self._path_smoothing(best_path, obstacles, is_3d, bounds)\n                    success_state = True\n                    break\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n                    best_path = self._path_smoothing(best_path, obstacles, is_3d, bounds)\n                    success_state = True\n                    break\n\n            grow_start = not grow_start\n\n        if not success_state and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d, bounds)\n            success_state = True\n\n        return PlannerResult(success_state, best_path, all_nodes, edges)\n\n    def _unit_ball_sample(self, n):\n        while True:\n            pt = [random.uniform(-1, 1) for _ in range(n)]\n            norm_sq = sum(x * x for x in pt)\n            if 1e-10 < norm_sq <= 1.0:\n                norm = math.sqrt(norm_sq)\n                return tuple(x / norm for x in pt)\n\n    def _path_smoothing(self, path, obstacles, is_3d, bounds, max_trials=150):\n        if len(path) < 3:\n            return path[:]\n        def collision_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=self.step_size / 5)\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if collision_free_edge(smoothed[i], smoothed[j]):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.56803,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1373.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02414531707763672,
                    "num_nodes_avg": 63.4,
                    "path_length_avg": 160.8159034432889,
                    "smoothness_avg": 0.0468834336653379,
                    "success_improvement": 0.0,
                    "time_improvement": -1.8352360084748123,
                    "length_improvement": 11.854255031670661,
                    "smoothness_improvement": 633.827545868252,
                    "objective_score": 4.989417933132948
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04464597702026367,
                    "num_nodes_avg": 214.7,
                    "path_length_avg": 242.8564212972105,
                    "smoothness_avg": 0.09198121268102702,
                    "success_improvement": 0.0,
                    "time_improvement": 81.38619002708492,
                    "length_improvement": 18.927536336488174,
                    "smoothness_improvement": 2266.7428536724183,
                    "objective_score": 39.535078543785204
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025367426872253417,
                    "num_nodes_avg": 148.5,
                    "path_length_avg": 125.28226140436504,
                    "smoothness_avg": 0.10365508882920574,
                    "success_improvement": 0.0,
                    "time_improvement": 75.76157205439134,
                    "length_improvement": 16.793487275427736,
                    "smoothness_improvement": 1218.4850788847077,
                    "objective_score": 32.17959446582648
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with ellipsoidal informed sampling, adaptive neighbor radius bounded by min and max limits, incremental extend-and-rewire mechanism, collision checking for nodes and edges, and progressive tree connection attempts within a 30-second time limit. It dynamically manages parent-child relationships for optimal path cost, performs focused sampling in promising regions after initial solution, and applies iterative path smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal by alternately sampling collision-free points biased toward goal and informed ellipsoids once an initial path is found. Each iteration extends one tree toward the sampled point with adaptive rewiring among nearby nodes to minimize cost while ensuring all edges avoid obstacles. It incrementally attempts to connect the opposite tree to newly added nodes. Upon successful connection or time expiration, the best combined path is smoothed and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                   # For collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start             # Tuple[float, ...]\n        goal_pos = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles         # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_pos(pos):\n            return tuple(max(0., min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d])*0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                rad_sample = random.random() ** (1.0 / n)\n                unit_sample = tuple(rad_sample * d for d in dir_sample)\n                sample_scaled = tuple(unit_sample[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_cnt = 0\n\n        while iter_cnt < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_edges.clear()\n        all_nodes = tree_start + tree_goal\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.54907,
          "time_improvement": 51.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1302.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019107961654663087,
                    "num_nodes_avg": 65.8,
                    "path_length_avg": 153.38330557355786,
                    "smoothness_avg": 0.042967766385333325,
                    "success_improvement": 0.0,
                    "time_improvement": 19.410303104043624,
                    "length_improvement": 15.92817970112039,
                    "smoothness_improvement": 572.5388499285865,
                    "objective_score": 11.871421121080097
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047547769546508786,
                    "num_nodes_avg": 220.5,
                    "path_length_avg": 234.3680431364739,
                    "smoothness_avg": 0.09164122434069168,
                    "success_improvement": 0.0,
                    "time_improvement": 80.17637408689761,
                    "length_improvement": 21.76120129096047,
                    "smoothness_improvement": 2257.9947087918863,
                    "objective_score": 39.695126028220805
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0493941068649292,
                    "num_nodes_avg": 228.0,
                    "path_length_avg": 121.53413898703361,
                    "smoothness_avg": 0.09249816497672032,
                    "success_improvement": 0.0,
                    "time_improvement": 52.80421990719121,
                    "length_improvement": 19.282811718609253,
                    "smoothness_improvement": 1076.5698309995487,
                    "objective_score": 25.080677470876957
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a hybrid bidirectional RRT* variant that combines adaptive neighbor radius calculation, dynamic switching between uniform, goal-biased, and informed ellipsoidal sampling, and rigorous collision checks. It incrementally grows two trees from start and goal, attempts to connect them progressively while rewiring for cost optimization, and applies iterative path smoothing. It enforces a strict 30-second timeout to ensure responsiveness and returns the best feasible path discovered so far.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees using adaptive sampling based on progress and best path cost, adaptively tunes neighbor search radius for efficient rewiring, and incrementally connects the two trees. When a connection is found, the combined path is smoothed via random shortcutting. The process stops early if time expires or upon finding the first improved path, maximizing efficiency and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = None                # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List of child nodes\n        self.valid = True                 # Validity flag (collision-free)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        for child in self.children:\n            child.update_parent(self, self.cost + child._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_pos(pos):\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma_rrt = 25.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size, min(self.step_size * 10.0, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in vec)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                norm_dir = math.sqrt(dx * dx + dy * dy)\n                if norm_dir < 1e-14:\n                    return [[1, 0], [0, 1]]\n                dx /= norm_dir\n                dy /= norm_dir\n                return [[dx, -dy], [dy, dx]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-14:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0, 1 - cos_t * cos_t))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(len(A[0]))] for i in range(len(A))]\n\n                def mat_mul(A, B):\n                    rows_A = len(A)\n                    cols_A = len(A[0])\n                    cols_B = len(B[0])\n                    result = [[0] * cols_B for _ in range(rows_A)]\n                    for i in range(rows_A):\n                        for j in range(cols_B):\n                            for k in range(cols_A):\n                                result[i][j] += A[i][k] * B[k][j]\n                    return result\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        grow_start = True\n        informed_sampling = False\n        iterations = 0\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-14 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            new_pos = clamp_pos(new_pos)\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current.position, new_node.position)\n                step_pos = clamp_pos(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current.position, step_pos):\n                    return None\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current.cost + dist(current.position, step_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current = connect_node\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                # Uniform sampling inside bounds\n                for _ in range(100):\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n                # fallback to any sample if none found in 100 tries\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction_vec)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n\n            for _ in range(100):\n                u = unit_ball_sample(n)\n                r_s = random.random() ** (1.0 / n)\n                sample_on_unit = tuple(r_s * u[d] for d in range(n))\n                sample_scaled = tuple(sample_on_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_pos(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n            # fallback uniform random if no informed sample found\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            length = len(smoothed)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[: i + 1] + smoothed[j:]\n                    length = len(smoothed)\n            return smoothed\n\n        while iterations < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n            iterations += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                goal_bias_prob = 0.15\n                if random.random() < goal_bias_prob:\n                    sample_pt = goal_pos if grow_start else start_pos\n                    if not collision_free_node(sample_pt):\n                        # fallback uniform collision-free sample\n                        for _ in range(30):\n                            sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                            if collision_free_node(sample_pt):\n                                break\n                else:\n                    for _ in range(30):\n                        sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(sample_pt):\n                            break\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    full_path = path_start + path_goal[::-1]\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    full_path = path_start + path_goal[::-1]\n\n                path_cost = 0.0\n                for i in range(len(full_path) - 1):\n                    path_cost += dist(full_path[i], full_path[i + 1])\n\n                if path_cost + 1e-14 < best_cost:\n                    best_cost = path_cost\n                    best_path = full_path\n                    informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Timeout or max iteration reached\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            all_nodes = tree_start + tree_goal\n            edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n        else:\n            all_nodes = tree_start + tree_goal\n            edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.5467,
          "time_improvement": 50.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1496.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021259188652038574,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 164.09996709417015,
                    "smoothness_avg": 0.03990725906357072,
                    "success_improvement": 0.0,
                    "time_improvement": 10.337292868512794,
                    "length_improvement": 10.05420770530395,
                    "smoothness_improvement": 524.6352643449796,
                    "objective_score": 7.735205723339526
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05081164836883545,
                    "num_nodes_avg": 226.6,
                    "path_length_avg": 236.8183044163185,
                    "smoothness_avg": 0.10058341779912365,
                    "success_improvement": 0.0,
                    "time_improvement": 78.81559705326173,
                    "length_improvement": 20.943233548887864,
                    "smoothness_improvement": 2488.08378727895,
                    "objective_score": 40.27374476215084
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041131114959716795,
                    "num_nodes_avg": 224.4,
                    "path_length_avg": 127.66588245991097,
                    "smoothness_avg": 0.12388821153342182,
                    "success_improvement": 0.0,
                    "time_improvement": 60.69946032389678,
                    "length_improvement": 15.21039966617158,
                    "smoothness_improvement": 1475.848906228569,
                    "objective_score": 28.631162561546194
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.46582,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1244.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019983816146850585,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 170.2199533723818,
                    "smoothness_avg": 0.03191661323621712,
                    "success_improvement": 0.0,
                    "time_improvement": 15.716301131147329,
                    "length_improvement": 6.6997462488276955,
                    "smoothness_improvement": 399.5643051817539,
                    "objective_score": 8.052661115018507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05431396961212158,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 236.52350437862407,
                    "smoothness_avg": 0.08310278940495856,
                    "success_improvement": 0.0,
                    "time_improvement": 77.35540855616505,
                    "length_improvement": 21.04164628681887,
                    "smoothness_improvement": 2038.2946279093733,
                    "objective_score": 37.606424963760155
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03142735958099365,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 125.86434766351888,
                    "smoothness_avg": 0.10952251178835211,
                    "success_improvement": 0.0,
                    "time_improvement": 69.97134180929318,
                    "length_improvement": 16.406893298066827,
                    "smoothness_improvement": 1293.1182658369369,
                    "objective_score": 30.738372531586002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a hybrid bidirectional anytime RRT* planner enhanced with dynamic informed sampling and cost-aware rewiring. It balances exploration and exploitation by adaptively switching between uniform, goal-biased, and ellipsoidal informed sampling. The planner maintains two trees grown from start and goal, continually rewiring neighbors for cost optimization, and attempts incremental connections for early convergence. It integrates time-based early stopping to guarantee responsiveness, while post-processing applies iterative shortcut smoothing to refine path quality and smoothness. Comprehensive collision and boundary checks ensure path feasibility in 2D/3D environments.",
          "planning_mechanism": "The planner alternately extends trees from start and goal with adaptive sampling strategies, using an adaptive neighbor radius informed by the current tree size. Each new node insertion triggers a rewiring phase to locally optimize costs. Incremental attempts connect the two trees, upon which the best path is extracted and smoothed. Execution is strictly bounded by 30 seconds to enforce practical runtime, returning the best solution found thus far if time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = cost                        # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True                       # Validity flag (e.g., collision-free)\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other_node) -> float:\n        return math.dist(self.position, other_node.position)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to children\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                # Tuple[int,...] e.g. (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float,...]\n        goal_position = map.goal         # Tuple[float,...]\n        obstacles = map.obstacles        # List of obstacle tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        # Helper functions\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        # Adaptive neighbor radius [min radius, max radius], logarithmic scaling\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma_rrt = 25.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size, min(self.step_size * 10.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= radius_sq]\n\n        # Rotation matrix aligning x-axis to the given vector (for informed sampling)\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                norm_dir = math.sqrt(dx*dx+dy*dy)\n                if norm_dir < 1e-14:\n                    return [[1,0],[0,1]]\n                dx /= norm_dir\n                dy /= norm_dir\n                return [[dx, -dy],[dy, dx]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0,1-cos_t*cos_t))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(len(A[0]))] for i in range(len(A))]\n                def mat_mul(A,B):\n                    rows_A = len(A)\n                    cols_A = len(A[0])\n                    cols_B = len(B[0])\n                    result = [[0]*cols_B for _ in range(rows_A)]\n                    for i in range(rows_A):\n                        for j in range(cols_B):\n                            for k in range(cols_A):\n                                result[i][j] += A[i][k]*B[k][j]\n                    return result\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1-cos_t))\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in vec)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in vec)\n\n        # Informed sampling within ellipsoid enclosing start and goal with current best cost c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                # Uniform sampling in bounds\n                while True:\n                    pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_position[d] + goal_position[d])*0.5 for d in range(dim))\n            direction_vec = tuple((goal_position[d]-start_position[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction_vec)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                u = unit_ball_sample(n)\n                r_s = random.random() ** (1.0 / n)\n                sample_on_unit = tuple(r_s * u[d] for d in range(n))\n                sample_scaled = tuple(sample_on_unit[d]*radii[d] for d in range(n))\n                # Rotate sample_scaled by R\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp\n                clamped = tuple(min(max(0.0, sample_pt[d]), bounds[d]) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        # Rewire neighbors to potentially reduce costs using new_node as parent\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-14 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current.position, new_node.position)\n                if not collision_free_node(step_pos):\n                    return None\n                if not collision_free_edge(current.position, step_pos):\n                    return None\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current.cost + dist(current.position, step_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current = connect_node\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        c_min = dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        grow_start = True\n        informed_sampling = False\n        iterations = 0\n\n        while iterations < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n            iterations += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                # 15% goal bias towards opposite root\n                goal_bias_prob = 0.15\n                if random.random() < goal_bias_prob:\n                    sample_pt = goal_position if grow_start else start_position\n                else:\n                    # Uniform collision-free sample\n                    attempts = 0\n                    while True:\n                        sample_pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                        if collision_free_node(sample_pt) or attempts > 50:\n                            break\n                        attempts += 1\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                # Extract combined path\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    full_path = path_start + path_goal[::-1]\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    full_path = path_start + path_goal[::-1]\n\n                # Compute cost\n                path_cost = 0.0\n                for i in range(len(full_path) - 1):\n                    path_cost += dist(full_path[i], full_path[i+1])\n\n                if path_cost + 1e-14 < best_cost:\n                    best_cost = path_cost\n                    best_path = full_path\n                    informed_sampling = True\n\n                    # Return early after smoothing best path to improve planning efficiency\n                    smoothed = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Time or iteration limit reached\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            all_nodes = tree_start + tree_goal\n            all_edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    all_edges.append((node, c))\n            return PlannerResult(True, smoothed, all_nodes, all_edges)\n        else:\n            all_nodes = tree_start + tree_goal\n            all_edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    all_edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_line = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_line / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.36826,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1585.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024482870101928712,
                    "num_nodes_avg": 75.6,
                    "path_length_avg": 164.6168368714141,
                    "smoothness_avg": 0.04505641111143337,
                    "success_improvement": 0.0,
                    "time_improvement": -3.258898898617071,
                    "length_improvement": 9.770903190070795,
                    "smoothness_improvement": 605.2306754566691,
                    "objective_score": 4.002664345712383
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04607145786285401,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 242.049862010141,
                    "smoothness_avg": 0.09723802089519261,
                    "success_improvement": 0.0,
                    "time_improvement": 80.79187825937596,
                    "length_improvement": 19.196789042033828,
                    "smoothness_improvement": 2402.004315348811,
                    "objective_score": 40.08694286296361
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03554985523223877,
                    "num_nodes_avg": 191.7,
                    "path_length_avg": 124.49725112154117,
                    "smoothness_avg": 0.14532344803513364,
                    "success_improvement": 0.0,
                    "time_improvement": 66.03232133622801,
                    "length_improvement": 17.31485372710666,
                    "smoothness_improvement": 1748.5035323457655,
                    "objective_score": 32.01518480801856
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with adaptive neighborhood rewiring, recursive cost propagation, and dynamic ellipsoidal informed sampling after the first solution. It alternates growth from start and goal, incorporates goal-biased and informed sampling to focus the search space efficiently, and performs incremental connection attempts with rigorous collision checks. Early termination occurs either on reaching the goal or upon exceeding a 30-second limit, ensuring practical runtime. Path smoothing by randomized shortcutting enhances smoothness and reduces path length without major overhead. The node structure maintains parent-child relations with recursive cost updates to ensure accurate and optimal paths.",
          "planning_mechanism": "The planner grows two trees from the start and goal positions alternately. Sampling is goal-biased initially and switches to informed ellipsoidal sampling to accelerate convergence after the first solution. Each new node is connected to the neighbor with minimal cost within an adaptive radius, followed by rewiring of surrounding neighbors to optimize the tree globally. Incremental connection attempts merge the two trees progressively, and upon connection, path extraction and smoothing is performed. The algorithm stops early if the time limit is reached or a valid path is found, returning the best solution obtained.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other_node):\n        # Euclidean distance\n        return math.dist(self.position, other_node.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of children to maintain consistency\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size              # Tuple[int,...]\n        start_pos = map.start          # Tuple[float,...]\n        goal_pos = map.goal            # Tuple[float,...]\n        obstacles = map.obstacles      # List of obstacle tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=self.step_size/5)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 20.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Unit n-ball sampling for informed sampling\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in vec)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in vec)\n\n        # Rotation matrix aligning x-axis to given vector (for informed sampling)\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                norm = math.sqrt(dx*dx + dy*dy)\n                if norm < 1e-14:\n                    return [[1,0],[0,1]]\n                dx /= norm\n                dy /= norm\n                cos_a = dx\n                sin_a = dy\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    # parallel to x-axis\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0,1-cos_t*cos_t))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1-cos_t))\n                return R\n\n        def informed_sample(c_best):\n            # If no solution yet or best < dist start-goal, do uniform sample\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            # Ellipsoid sampling centered between start and goal\n            center = tuple((start_pos[d] + goal_pos[d])*0.5 for d in range(dim))\n            direction_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction_vec)\n            if dim == 2:\n                a1 = c_best/2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*unit_dir[d] for d in range(n))\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                # Rotate sample_scaled by R\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-10 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_pt):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pt))\n            new_pos = steer(nearest_node.position, target_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos):\n                    return None\n                if not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-10 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            iter_count += 1\n            # Sample point\n            if informed_sampling:\n                sample = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                        if collision_free_node(sample):\n                            break\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node:\n                # Extract path\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    full_path = path_start + path_goal[::-1]\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    full_path = path_start + path_goal[::-1]\n\n                cost_path = 0.0\n                for i in range(len(full_path)-1):\n                    cost_path += dist(full_path[i], full_path[i+1])\n\n                if cost_path + 1e-12 < best_path_cost:\n                    best_path_cost = cost_path\n                    best_path_nodes = full_path\n                    informed_sampling = True\n\n                    # Update edges from whole trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    # Smooth path before early return\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(True, path_smoothed, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Time or iteration limit reached: return best path found if any\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, path_smoothed, all_nodes, edges)\n        else:\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.13323,
          "time_improvement": 49.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1454.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0255234956741333,
                    "num_nodes_avg": 93.0,
                    "path_length_avg": 168.13526069540995,
                    "smoothness_avg": 0.03338689018475478,
                    "success_improvement": 0.0,
                    "time_improvement": -7.6478390148791835,
                    "length_improvement": 7.842399339145382,
                    "smoothness_improvement": 422.577332183864,
                    "objective_score": 1.3870148242846412
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04260091781616211,
                    "num_nodes_avg": 228.3,
                    "path_length_avg": 238.5684871287258,
                    "smoothness_avg": 0.10783569118475118,
                    "success_improvement": 0.0,
                    "time_improvement": 82.23881653341562,
                    "length_improvement": 20.358972183270126,
                    "smoothness_improvement": 2674.6900050925265,
                    "objective_score": 42.11688942214134
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02856433391571045,
                    "num_nodes_avg": 177.7,
                    "path_length_avg": 122.29673028747024,
                    "smoothness_avg": 0.10736601540838424,
                    "success_improvement": 0.0,
                    "time_improvement": 72.70694608022926,
                    "length_improvement": 18.77633488755472,
                    "smoothness_improvement": 1265.687791059751,
                    "objective_score": 31.895789756878475
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation uses a bidirectional RRT* algorithm that simultaneously grows two trees from the start and goal positions, respectively. The planner incrementally extends each tree by sampling points with a goal bias, steering toward samples by a fixed step size, and choosing minimum cost parents from nearby neighbors while enforcing collision-free constraints. It dynamically rewires neighbors to optimize path costs. The algorithm attempts to connect the two trees at each iteration, returning the shortest found path upon connection or when the 30-second time limit expires. Finally, path smoothing via random shortcutting reduces unnecessary waypoints, improving path length and smoothness.",
          "planning_mechanism": "The planner alternately grows two search trees bidirectionally from start and goal, performing nearest neighbor queries and neighborhood rewiring for cost optimization. New nodes are added if collision-free, and trees are connected when possible to find paths faster. Rewiring and adaptive neighbor radius enhance path quality. The planning process respects map bounds and obstacles, employing collision checks on nodes and edges. Early termination occurs if a valid path is found or when time limits expire, ensuring efficiency and practical usability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # float\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_constant: float = 30.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        edges = []\n        connection_found = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        start_time = time.time()\n\n        def swap_trees():\n            nonlocal start_tree, goal_tree\n            start_tree, goal_tree = goal_tree, start_tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            dims = len(bounds)\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    yield goal_position\n                else:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        yield point\n\n        sample_iterator = sample_free()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            sample = next(sample_iterator)\n\n            # Extend start_tree towards sample\n            nearest_start = self._nearest(start_tree, sample)\n            new_pos_start = self._steer(nearest_start.position, sample)\n\n            if not self._in_bounds(new_pos_start, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_start, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d):\n                continue\n\n            # Find neighbors in start_tree for rewiring\n            neighbor_radius_start = self._adaptive_radius(len(start_tree))\n            neighbors_start = self._near_nodes(start_tree, new_pos_start, neighbor_radius_start)\n\n            # Choose best parent in start_tree\n            min_cost_start = nearest_start.cost + dist(nearest_start.position, new_pos_start)\n            best_parent_start = nearest_start\n            for neighbor in neighbors_start:\n                cost = neighbor.cost + dist(neighbor.position, new_pos_start)\n                if cost < min_cost_start and not self._is_edge_in_obstacle(neighbor.position, new_pos_start, obstacles, is_3d):\n                    min_cost_start = cost\n                    best_parent_start = neighbor\n\n            new_start_node = Node(new_pos_start)\n            best_parent_start.add_child(new_start_node)\n            new_start_node.cost = min_cost_start\n            start_tree.append(new_start_node)\n            edges.append((best_parent_start, new_start_node))\n\n            # Rewire neighbors in start_tree through new_start_node\n            for neighbor in neighbors_start:\n                if neighbor is best_parent_start:\n                    continue\n                new_cost = new_start_node.cost + dist(new_start_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_start_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_start_node, new_cost)\n                    edges.append((new_start_node, neighbor))\n\n            # Extend goal_tree towards new_start_node.position to attempt connection\n            nearest_goal = self._nearest(goal_tree, new_start_node.position)\n            new_pos_goal = self._steer(nearest_goal.position, new_start_node.position)\n\n            if not self._in_bounds(new_pos_goal, bounds):\n                pass  # don't connect if out of bounds\n            elif self._is_in_obstacle(new_pos_goal, obstacles, is_3d):\n                pass  # skip if in obstacle\n            elif self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d):\n                pass  # skip if edge collides\n            else:\n                neighbor_radius_goal = self._adaptive_radius(len(goal_tree))\n                neighbors_goal = self._near_nodes(goal_tree, new_pos_goal, neighbor_radius_goal)\n\n                min_cost_goal = nearest_goal.cost + dist(nearest_goal.position, new_pos_goal)\n                best_parent_goal = nearest_goal\n                for neighbor in neighbors_goal:\n                    cost = neighbor.cost + dist(neighbor.position, new_pos_goal)\n                    if cost < min_cost_goal and not self._is_edge_in_obstacle(neighbor.position, new_pos_goal, obstacles, is_3d):\n                        min_cost_goal = cost\n                        best_parent_goal = neighbor\n\n                new_goal_node = Node(new_pos_goal)\n                best_parent_goal.add_child(new_goal_node)\n                new_goal_node.cost = min_cost_goal\n                goal_tree.append(new_goal_node)\n                edges.append((best_parent_goal, new_goal_node))\n\n                # Rewire neighbors in goal_tree through new_goal_node\n                for neighbor in neighbors_goal:\n                    if neighbor is best_parent_goal:\n                        continue\n                    new_cost = new_goal_node.cost + dist(new_goal_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_goal_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_goal_node, new_cost)\n                        edges.append((new_goal_node, neighbor))\n\n                # Check if we can connect new_start_node and new_goal_node\n                if dist(new_start_node.position, new_goal_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_start_node.position, new_goal_node.position, obstacles, is_3d):\n                        cost_to_connect = new_start_node.cost + dist(new_start_node.position, new_goal_node.position) + new_goal_node.cost\n                        if cost_to_connect < best_cost:\n                            best_cost = cost_to_connect\n                            best_start_node = new_start_node\n                            best_goal_node = new_goal_node\n                            connection_found = True\n\n            if connection_found:\n                break\n\n            # Swap trees for balanced growth\n            swap_trees()\n\n        success_state = connection_found\n        extracted_path = []\n\n        if success_state and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            path_goal.reverse()  # reverse to goal root\n            # Concatenate paths avoiding duplication of connection point\n            full_path = path_start + path_goal[1:]\n            extracted_path = self._path_smoothing(full_path, obstacles, is_3d)\n        else:\n            # If no connection found, return best path among both trees' closest nodes to goal\n            # Find closest node in start_tree to goal and in goal_tree to start, pick shorter path\n            def best_approx_path(tree, target_pos):\n                best_node = min(tree, key=lambda n: dist(n.position, target_pos))\n                return best_node.path_from_root(), best_node.cost, best_node\n\n            start_path, start_cost, _ = best_approx_path(start_tree, goal_position)\n            goal_path, goal_cost, _ = best_approx_path(goal_tree, start_position)\n\n            # Pick the path with smaller heuristic cost to goal or start respectively\n            if start_cost + dist(start_path[-1], goal_position) < goal_cost + dist(goal_path[-1], start_position):\n                approx_path = start_path\n            else:\n                approx_path = goal_path[::-1]\n\n            extracted_path = self._path_smoothing(approx_path, obstacles, is_3d)\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree,\n            edges=edges\n        )\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _adaptive_radius(self, n_nodes):\n        # Algorithm adapts neighbor radius proportional to (log n / n)^{1/d} with constant scaling\n        if n_nodes <= 1:\n            return self.neighbor_radius_constant\n        dim = len(bounds) if hasattr(self, 'bounds') else 2  # fallback dim=2\n        gamma_rrt_star = self.neighbor_radius_constant\n        radius = min(gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim), self.step_size * 50)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_iterations=150):\n        if len(path) < 3:\n            return path[:]\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path",
          "objective": -25.04421,
          "time_improvement": 46.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1597.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024372053146362305,
                    "num_nodes_avg": 113.8,
                    "path_length_avg": 159.5915861709516,
                    "smoothness_avg": 0.04184470687683983,
                    "success_improvement": 0.0,
                    "time_improvement": -2.79151755143659,
                    "length_improvement": 12.52532272918742,
                    "smoothness_improvement": 554.9605298579069,
                    "objective_score": 4.442411929696042
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04618837833404541,
                    "num_nodes_avg": 284.8,
                    "path_length_avg": 242.9965020999087,
                    "smoothness_avg": 0.1070723847689884,
                    "success_improvement": 0.0,
                    "time_improvement": 80.74313175234548,
                    "length_improvement": 18.880773332545168,
                    "smoothness_improvement": 2655.0495812275612,
                    "objective_score": 41.27434209835048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041561317443847653,
                    "num_nodes_avg": 236.3,
                    "path_length_avg": 124.76782145766249,
                    "smoothness_avg": 0.13211293366663907,
                    "success_improvement": 0.0,
                    "time_improvement": 60.288404367526496,
                    "length_improvement": 17.135153793029748,
                    "smoothness_improvement": 1580.4667646772543,
                    "objective_score": 29.415885892250166
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances path planning by using a bidirectional RRT* algorithm with goal biasing and adaptive sampling regions. It alternates growing two trees from start and goal states, dynamically rewiring neighbors to minimize path cost, and incrementally attempts connections to combine trees efficiently. The planner enforces collision checks for nodes and edges in both 2D and 3D, employs path smoothing on discovered paths, and strictly respects a 30-second time limit to ensure responsiveness while striving for optimality and robustness.",
          "planning_mechanism": "The planner samples points biased toward the goal and, after a solution is found, switches to informed ellipsoidal sampling to focus exploration. It grows two trees alternately from start and goal by extending toward sampled points with rewiring performed on neighbors using an adaptively computed radius. The incremental connect step attempts to link the two trees efficiently. Upon connection, the combined path is smoothed and returned, with the planning halting if the time limit is reached or maximum iterations are exceeded.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position           # Tuple[float, ...]\n        self.parent = None                 # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map):\n        bounds = map.size                     # Tuple[int, ...]\n        start_pos = map.start                 # Tuple[float, ...]\n        goal_pos = map.goal                   # Tuple[float, ...]\n        obstacles = map.obstacles             # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def _rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = _rotation_matrix\n\n        def _unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = _unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n_dim = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n_dim)\n                radius_sample = random.random() ** (1.0 / n_dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n_dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n_dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n_dim))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to potentially better parents\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees with start and goal nodes\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if (time.perf_counter() - start_time) > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Choose sample point\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Build edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # On timeout or iteration exhaustion, return best found path if any\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.95355,
          "time_improvement": 49.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1436.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02865138053894043,
                    "num_nodes_avg": 93.8,
                    "path_length_avg": 169.549048732627,
                    "smoothness_avg": 0.039659607772506,
                    "success_improvement": 0.0,
                    "time_improvement": -20.839999316223512,
                    "length_improvement": 7.067479713041642,
                    "smoothness_improvement": 520.7589838564307,
                    "objective_score": -2.2347089329765715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043678903579711915,
                    "num_nodes_avg": 221.4,
                    "path_length_avg": 236.76909521808312,
                    "smoothness_avg": 0.09370031263811501,
                    "success_improvement": 0.0,
                    "time_improvement": 81.78938248592871,
                    "length_improvement": 20.959660995667072,
                    "smoothness_improvement": 2310.976533785942,
                    "objective_score": 40.28362961384174
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01450803279876709,
                    "num_nodes_avg": 113.7,
                    "path_length_avg": 123.58094854622793,
                    "smoothness_avg": 0.12399029295981442,
                    "success_improvement": 0.0,
                    "time_improvement": 86.13765955071794,
                    "length_improvement": 17.92341826798988,
                    "smoothness_improvement": 1477.147374437416,
                    "objective_score": 36.81171839100044
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias, adaptive neighbor radius, and incremental connection between trees. It efficiently explores the map by alternating growth from start and goal nodes, using rewiring to optimize path costs dynamically. The planner enforces collision-free node and edge expansions, boundary constraints, and a strict 30-second maximum planning time to ensure feasible, high-quality, and smooth paths with improved success rates.",
          "planning_mechanism": "The planner samples points with goal bias and alternates tree expansions from start and goal. Each extension attempts rewiring with neighbors to minimize cost, followed by incremental connection attempts to the other tree. On connecting, the best path is updated and smoothed. The process respects obstacle and boundary constraints and terminates early when time expires or a valid path is found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._dist(self.position, c.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start_tree = True\n        iter_count = 0\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos if grow_start_tree else start_pos\n            else:\n                sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached - return best found\n        smoothed = path_smoothing(best_path) if best_path else []\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                if self._is_edge_in_obstacle(node.position, c.position, obstacles, is_3d, resolution=self.step_size / 5) is False:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float = 1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.94934,
          "time_improvement": 48.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0190049409866333,
                    "num_nodes_avg": 67.6,
                    "path_length_avg": 157.39257073875143,
                    "smoothness_avg": 0.04700203512746762,
                    "success_improvement": 0.0,
                    "time_improvement": 19.844802846119116,
                    "length_improvement": 13.730637933205724,
                    "smoothness_improvement": 635.6839162977793,
                    "objective_score": 11.877988021965775
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06502346992492676,
                    "num_nodes_avg": 258.9,
                    "path_length_avg": 242.93112139859718,
                    "smoothness_avg": 0.09430911583896542,
                    "success_improvement": 0.0,
                    "time_improvement": 72.89040147082446,
                    "length_improvement": 18.902599292522094,
                    "smoothness_improvement": 2326.641478647044,
                    "objective_score": 37.28084769298698
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04951553344726563,
                    "num_nodes_avg": 226.7,
                    "path_length_avg": 120.57527423194975,
                    "smoothness_avg": 0.10061056714909011,
                    "success_improvement": 0.0,
                    "time_improvement": 52.68819751826447,
                    "length_improvement": 19.91964403270292,
                    "smoothness_improvement": 1179.7589878368517,
                    "objective_score": 25.68918300120418
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias and adaptive neighbor radius. It grows two trees from start and goal simultaneously, performing incremental extensions and rewiring steps to optimize path costs dynamically. The planner includes robust collision checks on nodes and edges, enforces boundary constraints, applies a 30-second maximum planning time limit, and performs path smoothing on the best found path, aiming for efficient planning, high-quality, and smooth paths with improved success rates.",
          "planning_mechanism": "The planner alternates expanding start and goal trees by sampling points with goal bias, extending trees toward samples with incremental steering and rewiring to minimize path costs, and tries to connect the two trees incrementally. If connection is made, the path is extracted, smoothed, and returned immediately. The process continuously updates best path within the time limit, and returns the best available solution if timeout or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs to maintain consistent cost tree\n        for c in self.children:\n            c.update_parent(self, self.cost + self._dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n        best_cost = math.inf\n        best_path = []\n        success_state = False\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos if grow_start_tree else start_pos\n            else:\n                sample_pt = sample_free()\n\n            # Extend and rewire tree\n            def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n                nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n                new_pos = steer(nearest_node.position, sample)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                # Choose best parent for new node to minimize cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for nbr in neighbors:\n                    if nbr == nearest_node:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors if better cost possible through new_node\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                return new_node\n\n            # Incremental connect tree to target pos\n            def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n                if not tree:\n                    return None\n                nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n                current = nearest\n                while True:\n                    new_pos = steer(current.position, target_pos)\n                    if not collision_free_node(new_pos):\n                        return None\n                    if not collision_free_edge(current.position, new_pos):\n                        return None\n\n                    n_nodes = len(tree)\n                    radius = adaptive_neighbor_radius(n_nodes + 1)\n                    neighbors = near_nodes(tree, new_pos, radius)\n\n                    min_cost = current.cost + dist(current.position, new_pos)\n                    best_parent = current\n                    for nbr in neighbors:\n                        if nbr == current:\n                            continue\n                        cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                        if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                            min_cost = cost_thru_nbr\n                            best_parent = nbr\n\n                    new_node = Node(new_pos)\n                    best_parent.add_child(new_node)\n                    new_node.cost = min_cost\n                    tree.append(new_node)\n\n                    for nbr in neighbors:\n                        if nbr is new_node.parent:\n                            continue\n                        cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                        if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                            nbr.update_parent(new_node, cost_thru_new)\n\n                    if dist(new_node.position, target_pos) <= self.step_size:\n                        if collision_free_edge(new_node.position, target_pos):\n                            return new_node\n                        else:\n                            return None\n                    current = new_node\n\n            # Path smoothing by shortcutting\n            def path_smoothing(path: list, trials: int = 150) -> list:\n                if len(path) < 3:\n                    return path[:]\n                for _ in range(trials):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if collision_free_edge(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                return path\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    # Combine paths\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    # Gather nodes and edges\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            # Check edge validity before adding\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        success_state = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            if collision_free_edge(node.position, c.position):\n                                all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached, return best found\n        smoothed = path_smoothing(best_path) if best_path else []\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                if self._is_edge_in_obstacle(node.position, c.position, obstacles, is_3d, resolution=self.step_size / 5) is False:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.90026,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025222420692443848,
                    "num_nodes_avg": 63.2,
                    "path_length_avg": 160.0580798305058,
                    "smoothness_avg": 0.04718916170306709,
                    "success_improvement": 0.0,
                    "time_improvement": -6.378025836696076,
                    "length_improvement": 12.269630162320688,
                    "smoothness_improvement": 638.6128535577737,
                    "objective_score": 3.7335825492441836
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05890662670135498,
                    "num_nodes_avg": 256.9,
                    "path_length_avg": 232.53460831884667,
                    "smoothness_avg": 0.10468998429038108,
                    "success_improvement": 0.0,
                    "time_improvement": 75.44063701267409,
                    "length_improvement": 22.373254605579614,
                    "smoothness_improvement": 2593.7487009392908,
                    "objective_score": 40.0755855296146
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03397202491760254,
                    "num_nodes_avg": 178.8,
                    "path_length_avg": 123.73967937037617,
                    "smoothness_avg": 0.11896354211628588,
                    "success_improvement": 0.0,
                    "time_improvement": 67.53992896960364,
                    "length_improvement": 17.817996812540226,
                    "smoothness_improvement": 1413.2074747438844,
                    "objective_score": 30.891615427108558
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates enhanced bidirectional RRT* with adaptive ellipsoidal informed sampling, dynamic neighbor radius tuning, incremental connection with rewiring, recursive parent-child cost updates, and randomized path smoothing. It enforces strict 30-second execution time, early terminates on first feasible or improved path, and combines efficient collision checking and exploration-exploitation balance to improve path planning efficiency, quality, and smoothness.",
          "planning_mechanism": "The planner grows two RRT* trees bidirectionally from start and goal. Sampling alternates between goal bias, uniform free space, and ellipsoidal informed sets after initial solution. Each extension steers toward samples, rewires neighbors using adaptive radius for cost improvements, and incrementally connects opposite trees via rewiring. Parent-child cost updates propagate recursively. Path smoothing is applied to shorten and smooth routes. Planning stops upon time limit or successful improved solution, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True                  # For collision check flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of children\n        for child in list(self.children):\n            dist_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0\n        self.goal_sample_rate = 0.15\n        self.neighbor_radius_min = 7.0\n        self.neighbor_radius_max = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def sample_free():\n            # Try 30 times to sample free node, fallback to start to avoid infinite loop\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_position\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        # Rotation matrix aligning x-axis with direction vector\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n\n                K = [\n                    [0, -kz, ky],\n                    [kz, 0, -kx],\n                    [-ky, kx, 0]\n                ]\n                I = [\n                    [1,0,0],\n                    [0,1,0],\n                    [0,0,1]\n                ]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-9:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius*radius\n            return [node for node in tree if (dist(node.position, pos)**2) <= radius_sq]\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            nodes_count = len(tree)\n            radius = adaptive_neighbor_radius(nodes_count + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            max_steps = int(dist(current.position, target_pos) / self.step_size) + 5\n            for _ in range(max_steps):\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                nodes_count = len(tree)\n                radius = adaptive_neighbor_radius(nodes_count + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n            return None\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_tree_start = True\n\n        success_state = False\n\n        iteration = 0\n        while iteration < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n            iteration += 1\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if grow_tree_start else start_position\n                else:\n                    sample = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smoothed = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smoothed = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # Time expired or max_iter reached - return best found path\n        if best_path:\n            smoothed = path_smooth(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.75582,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1649.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022797155380249023,
                    "num_nodes_avg": 70.6,
                    "path_length_avg": 159.38269023433446,
                    "smoothness_avg": 0.046426891731036,
                    "success_improvement": 0.0,
                    "time_improvement": 3.8507677905069704,
                    "length_improvement": 12.639821902215212,
                    "smoothness_improvement": 626.6816731997491,
                    "objective_score": 6.816603083593879
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06482598781585694,
                    "num_nodes_avg": 253.7,
                    "path_length_avg": 240.91783209309455,
                    "smoothness_avg": 0.11310799958442008,
                    "success_improvement": 0.0,
                    "time_improvement": 72.97273575258086,
                    "length_improvement": 19.574693212018445,
                    "smoothness_improvement": 2810.3502977062517,
                    "objective_score": 39.8585108567092
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04605889320373535,
                    "num_nodes_avg": 240.7,
                    "path_length_avg": 126.1520111909521,
                    "smoothness_avg": 0.12660238961349263,
                    "success_improvement": 0.0,
                    "time_improvement": 55.99099704533598,
                    "length_improvement": 16.215840880210862,
                    "smoothness_improvement": 1510.3730510672835,
                    "objective_score": 27.592332544979385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive informed sampling, dynamic neighbor radius, incremental extend-and-rewire expansions, and randomized path smoothing to efficiently find collision-free, low-cost, and smooth paths in 2D or 3D spaces. It performs rigorous collision checks and alternates tree growth between start and goal with early termination upon path discovery or 30-second timeout.",
          "planning_mechanism": "The planner simultaneously grows two trees rooted at start and goal positions by iterative sampling biased towards the goal and informed ellipsoidal regions after the first solution. It extends trees using adaptive neighbor radius rewiring to optimize path costs, incrementally connects opposing trees, and applies randomized shortcut smoothing post path extraction. The process enforces strict collision checks on nodes and edges, bounds sampling within map limits, and halts upon timeout or solution, returning the best smoothed path and graph structure.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist_child = self._dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_time_sec: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 6)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.neighbor_radius_max\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            rsq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= rsq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf:\n                return sample_free()\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min - 1e-10:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][j] * sample_scaled[j] for j in range(n))\n                    y_rot = sum(R[1][j] * sample_scaled[j] for j in range(n))\n                    z_rot = sum(R[2][j] * sample_scaled[j] for j in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def extend_and_rewire(tree, sample_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample_pos))\n            new_pos = steer(nearest_node.position, sample_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c_cost = nbr.cost + dist(nbr.position, new_pos)\n                if c_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    c_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if c_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = c_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_tree_start = True\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        iteration = 0\n\n        while iteration < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            iteration += 1\n\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # Timeout or max iterations reached\n        if best_path:\n            smoothed = path_smoothing(best_path, self.smoothing_trials)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.70832,
          "time_improvement": 47.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1511.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028668880462646484,
                    "num_nodes_avg": 77.5,
                    "path_length_avg": 168.2873898800887,
                    "smoothness_avg": 0.04080959990770674,
                    "success_improvement": 0.0,
                    "time_improvement": -20.91380695581698,
                    "length_improvement": 7.759014922381762,
                    "smoothness_improvement": 538.7588580202137,
                    "objective_score": -2.0285448121676732
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04112467765808105,
                    "num_nodes_avg": 206.5,
                    "path_length_avg": 239.22182105761507,
                    "smoothness_avg": 0.09643434019239773,
                    "success_improvement": 0.0,
                    "time_improvement": 82.85429088543695,
                    "length_improvement": 20.140870512632418,
                    "smoothness_improvement": 2381.325031998086,
                    "objective_score": 40.791086528148
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02079470157623291,
                    "num_nodes_avg": 133.9,
                    "path_length_avg": 126.05525499581356,
                    "smoothness_avg": 0.1347045573904963,
                    "success_improvement": 0.0,
                    "time_improvement": 80.13078431863899,
                    "length_improvement": 16.28010173798698,
                    "smoothness_improvement": 1613.4320271509537,
                    "objective_score": 35.362415778943856
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* path planner combining adaptive neighbor radius, goal-biased sampling, incremental rewiring with collision checks, and path smoothing to efficiently find high-quality feasible paths within obstacles and bounded map environments. It alternates growing trees from start and goal, attempts to connect them incrementally, and returns the best path found within a time limit.",
          "planning_mechanism": "The planner maintains two trees growing towards each other with alternate expansions. Each iteration samples a point biased toward the goal or randomly in free space, extends the current tree toward the sample, rewires neighbors to optimize cost, then incrementally attempts to connect the two trees. Upon connection or time expiry, it extracts and smooths the path, ensuring nodes and edges are collision-free and positions stay within bounds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants cost\n        for c in self.children:\n            c.update_parent(self, new_cost + math.dist(self.position, c.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim)) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = math.inf\n        best_path = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, c_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connected_node = Node(next_pos)\n                best_parent.add_child(connected_node)\n                connected_node.cost = min_cost\n                other_tree.append(connected_node)\n\n                rewire(other_tree, connected_node, neighbors)\n\n                if dist(connected_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connected_node.position, new_node.position):\n                        return connected_node\n                    else:\n                        return None\n\n                curr_node = connected_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    return PlannerResult(True, path_smoothing(best_path), all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if grow_start_tree else start_pos\n            else:\n                sample = sample_free()\n\n            tree_current = tree_start if grow_start_tree else tree_goal\n            tree_other = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(tree_current, sample)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect_trees(new_node, tree_other)\n            if connect_node:\n\n                path_from_start = new_node.path_from_root() if grow_start_tree else connect_node.path_from_root()\n                path_from_goal = connect_node.path_from_root() if grow_start_tree else new_node.path_from_root()\n                if path_from_goal and path_from_start[-1] == path_from_goal[0]:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted_path = path_smoothing(best_path)\n                    return PlannerResult(True, extracted_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            return PlannerResult(True, path_smoothing(best_path), all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.70721,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025034070014953613,
                    "num_nodes_avg": 85.2,
                    "path_length_avg": 160.83205557163677,
                    "smoothness_avg": 0.04271756748555565,
                    "success_improvement": 0.0,
                    "time_improvement": -5.583638435076933,
                    "length_improvement": 11.845401794176341,
                    "smoothness_improvement": 568.622693831459,
                    "objective_score": 3.537102297469483
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05883321762084961,
                    "num_nodes_avg": 262.7,
                    "path_length_avg": 230.1373557782327,
                    "smoothness_avg": 0.09222740725247403,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47124274170076,
                    "length_improvement": 23.17352650472507,
                    "smoothness_improvement": 2273.0776173225318,
                    "objective_score": 38.641466210067904
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031036186218261718,
                    "num_nodes_avg": 169.8,
                    "path_length_avg": 124.8629660544588,
                    "smoothness_avg": 0.12460987105239034,
                    "success_improvement": 0.0,
                    "time_improvement": 70.34510566853544,
                    "length_improvement": 17.07196328213648,
                    "smoothness_improvement": 1485.0283620424839,
                    "objective_score": 31.943066167200346
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed and goal-biased sampling, adaptive neighborhood rewiring, incremental tree connection, and time-bounded execution. It balances fast convergence and path quality by dynamically rewiring nodes for cost optimization, alternating expansions from start and goal, and smoothing the resulting path for improved smoothness and shorter length while respecting obstacle constraints and map boundaries.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, alternately sampling points biased toward the goal or informed ellipsoidal region after a first solution. Each extension steers within a step size, checks collisions for nodes and edges, rewires neighbors to reduce costs, and attempts incremental connection between trees. When a connection is established or time limit is reached, it extracts, smooths, and returns the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            # RRT* radius scaling for dimension dim\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def clamp_to_bounds(pos):\n            return tuple(\n                max(0.0, min(bounds[d], pos[d])) for d in range(dim)\n            )\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                # fallback to identity if direction is aligned with x-axis\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta*cos_theta)\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        # Connect the new_node to opposite tree incrementally with rewiring\n        def try_connect_trees(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    # Time limit reached \u2014 extract best path found so far\n                    if best_path:\n                        extracted_path_final = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path_final, all_nodes, edges)\n                    else:\n                        return PlannerResult(False, [], all_nodes, edges)\n\n                iter_count += 1\n                sample = None\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start_tree:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_goal)\n                    if connect_node:\n                        # Build path\n                        path_s = new_node.path_from_root()\n                        path_g = connect_node.path_from_root()\n\n                        # Avoid duplicate node position overlap in merged path\n                        if path_g and path_g[0] == new_node.position:\n                            path_g = path_g[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        # Update edges for all new nodes (maintain consistent edges)\n                        # Clear and re-build edges\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n                    connect_node = try_connect_trees(new_node, tree_start)\n                    if connect_node:\n                        path_g = new_node.path_from_root()\n                        path_s = connect_node.path_from_root()\n                        if path_s and path_s[0] == new_node.position:\n                            path_s = path_s[1:]\n                        combined_path = path_s + path_g[::-1]\n\n                        combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_path = combined_path\n                            informed_sampling_enabled = True\n\n                        edges.clear()\n                        all_nodes = tree_start + tree_goal\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        extracted_path = path_smoothing(best_path)\n                        return PlannerResult(True, extracted_path, all_nodes, edges)\n\n                grow_start_tree = not grow_start_tree\n            break  # exit outer while if max_iter reached\n\n        # No complete connection found, try best path extraction\n        if best_path:\n            extracted_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            success_state = False\n            extracted_path = []\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.40163,
          "time_improvement": 45.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1453.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02057945728302002,
                    "num_nodes_avg": 65.5,
                    "path_length_avg": 156.83014571172365,
                    "smoothness_avg": 0.03866421328032622,
                    "success_improvement": 0.0,
                    "time_improvement": 13.204126390052256,
                    "length_improvement": 14.038912002714524,
                    "smoothness_improvement": 505.1788985200809,
                    "objective_score": 9.294914810158986
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04782705307006836,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 235.04300669404265,
                    "smoothness_avg": 0.09978280006234666,
                    "success_improvement": 0.0,
                    "time_improvement": 80.05993514249408,
                    "length_improvement": 21.535879027695216,
                    "smoothness_improvement": 2467.483316250031,
                    "objective_score": 40.66257292953742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059801268577575686,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 124.49733655203302,
                    "smoothness_avg": 0.1167675547851698,
                    "success_improvement": 0.0,
                    "time_improvement": 42.86023778552829,
                    "length_improvement": 17.314796988241735,
                    "smoothness_improvement": 1385.2746779830118,
                    "objective_score": 23.247404123221894
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* approach with adaptive neighbor radius, goal-biased sampling, and incremental extend-and-rewire steps to efficiently grow two trees from start and goal towards each other. It performs rigorous collision and edge checks, dynamically rewires nodes to optimize path cost, and applies path smoothing for better quality. The planning process enforces a strict 30-second runtime limit, returning the best feasible path found at timeout or successful connection.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the opposite tree root. New nodes are added with step size limits, parents chosen from neighbors within an adaptive radius to minimize cost, and rewiring performed to improve the tree structure. Incremental connections from one tree to the other attempt efficient merges. On successful connection or timeout, the combined path is extracted and smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= r_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            to_remove = []\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            to_remove.append((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            for e in to_remove:\n                edges.remove(e)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined, max_iters=100)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined, max_iters=100)\n            success_state = True\n\n        return type('PlannerResult', (), {})() if False else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.38696,
          "time_improvement": 44.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018783712387084962,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 153.71064836573322,
                    "smoothness_avg": 0.04239088328876562,
                    "success_improvement": 0.0,
                    "time_improvement": 20.77785609923607,
                    "length_improvement": 15.748757929650598,
                    "smoothness_improvement": 563.5093767456073,
                    "objective_score": 12.200655299428979
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05699787139892578,
                    "num_nodes_avg": 298.5,
                    "path_length_avg": 243.06794856753677,
                    "smoothness_avg": 0.10890286053066733,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23643566812932,
                    "length_improvement": 18.856922445178366,
                    "smoothness_improvement": 2702.14904101396,
                    "objective_score": 40.15306039454427
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06685750484466553,
                    "num_nodes_avg": 274.5,
                    "path_length_avg": 123.54875955604457,
                    "smoothness_avg": 0.1082207456314781,
                    "success_improvement": 0.0,
                    "time_improvement": 36.11804532003545,
                    "length_improvement": 17.944796662594666,
                    "smoothness_improvement": 1276.5598964078824,
                    "objective_score": 20.80717241056898
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional informed RRT* with adaptive neighbor radius and ellipsoidal informed sampling, combining efficient rewiring, incremental connection, and robust collision checks. It balances exploration and exploitation by alternating tree growth from start and goal, dynamically focusing sampling around the best path found so far to speed convergence and improve path quality. Path smoothing by random shortcutting is applied to shorten and smooth the final trajectory. The planner operates under a strict 30-second time limit, ensuring prompt return of the best feasible path.",
          "planning_mechanism": "The planner grows two trees bidirectionally, alternately sampling points using goal bias and ellipsoidal informed sampling after a solution is found. It extends each tree by steering in step increments, selects best parents from neighbors within an adaptive radius to minimize cost, then rewires neighbors to improve their cost. Incremental connection attempts bridge the two trees efficiently. Collision checks on nodes and edges ensure path validity. The best path is extracted upon tree connection or time expiry, then improved via path smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []              # List[Node]\n        self.valid = True               # Collision-free flag\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist_c = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_c)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.perf_counter()\n\n        # Helpers\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp(p):\n            return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            factor = self.step_size / d\n            return tuple(frm[i] + factor * (to[i] - frm[i]) for i in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.5)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 20.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        # Sampling\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        informed_sampling_enabled = False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(p):\n                    return p\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return ((cos_a, -sin_a), (sin_a, cos_a))\n            # 3D rotation matrix aligning x-axis with direction (Rodrigues)\n            vx, vy, vz = direction\n            norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n            if norm_v < 1e-10:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n            # Orthogonal vector\n            if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                vx_, vy_, vz_ = 1,0,0\n            else:\n                vx_, vy_, vz_ = -uy, ux, 0\n            norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n            vx_, vy_, vz_ = vx_/norm_v_, vy_/norm_v_, vz_/norm_v_\n            wx = uy * vz_ - uz * vy_\n            wy = uz * vx_ - ux * vz_\n            wz = ux * vy_ - uy * vx_\n            return [\n                [ux, vx_, wx],\n                [uy, vy_, wy],\n                [uz, vz_, wz]\n            ]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(dim))\n                pt = clamp(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        # Nearest and neighbors\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position)**2 <= radius_sq]\n\n        # Tree extension with rewiring and cost minimization\n        def extend(tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors if beneficial\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n            return new_node\n\n        # Incremental connection tries from new_node toward nearest in other_tree\n        def try_connect_incremental(new_node, other_tree):\n            curr_node = nearest(other_tree, new_node.position)\n            max_steps = int(dist(curr_node.position, new_node.position) / self.step_size) + 5\n\n            for _ in range(max_steps):\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos, parent=best_parent, cost=min_cost)\n                other_tree.append(connect_node)\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    cost_via_connect = connect_node.cost + dist(connect_node.position, nbr.position)\n                    if cost_via_connect < nbr.cost and collision_free_edge(connect_node.position, nbr.position):\n                        nbr.update_parent(connect_node, cost_via_connect)\n\n                # If close enough and edge collision free, connection success\n                if dist(connect_node.position, new_node.position) <= self.step_size and collision_free_edge(connect_node.position, new_node.position):\n                    return connect_node\n                curr_node = connect_node\n\n            return None\n\n        # Path smoothing by random shortcutting edges\n        def path_smoothing(path: list, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            path_smoothed = path[:]\n            length = len(path_smoothed)\n            for _ in range(max_trials):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(path_smoothed[i], path_smoothed[j]):\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n                    length = len(path_smoothed)\n            return path_smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start_tree = True\n        best_path = []\n        best_cost = math.inf\n\n        for iter_idx in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time exceeded - return best found path\n                if best_path:\n                    best_path = path_smoothing(best_path)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Sample point selection\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    # Try multiple samples to avoid invalid points\n                    for _ in range(100):\n                        cand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(cand):\n                            sample_pt = cand\n                            break\n                    else:\n                        sample_pt = start_pos\n\n            # Extend tree\n            if grow_start_tree:\n                new_node = extend(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = try_connect_incremental(new_node, tree_goal)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_enabled = True\n\n                    # Prepare edges\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n            else:\n                new_node = extend(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = try_connect_incremental(new_node, tree_start)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_enabled = True\n\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    best_path = path_smoothing(best_path)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.28967,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1566.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025475263595581055,
                    "num_nodes_avg": 75.8,
                    "path_length_avg": 169.45631840452734,
                    "smoothness_avg": 0.040781944224026714,
                    "success_improvement": 0.0,
                    "time_improvement": -7.4444155068443045,
                    "length_improvement": 7.118306675279149,
                    "smoothness_improvement": 538.325986515343,
                    "objective_score": 1.8819666155792532
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04037721157073974,
                    "num_nodes_avg": 226.7,
                    "path_length_avg": 242.92506010646085,
                    "smoothness_avg": 0.10585049000476514,
                    "success_improvement": 0.0,
                    "time_improvement": 83.16592460116132,
                    "length_improvement": 18.904622726301824,
                    "smoothness_improvement": 2623.609348848872,
                    "objective_score": 41.84874866985312
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.040755057334899904,
                    "num_nodes_avg": 216.2,
                    "path_length_avg": 126.93296350452606,
                    "smoothness_avg": 0.12863655409492272,
                    "success_improvement": 0.0,
                    "time_improvement": 61.058781184007,
                    "length_improvement": 15.697169538488003,
                    "smoothness_improvement": 1536.2474731246707,
                    "objective_score": 29.138305628523053
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a time-bounded bidirectional RRT* planner with adaptive neighbor radius, progressive informed sampling, incremental connection and rewiring strategies, and path smoothing. It alternately grows two trees from start and goal positions, dynamically focusing sampling towards an ellipsoidal informed region as better paths are found. Robust collision checking, position clamping, and rewiring ensure path feasibility and cost optimization. Planning halts either on finding an improved path or upon hitting a 30-second time limit, returning the best smoothed path discovered.",
          "planning_mechanism": "The planner maintains two search trees growing from the start and goal respectively. It samples points either uniformly or within an ellipsoidal informed region biased by the best path cost. Each iteration extends one tree towards a sampled point with rewiring among neighbors to reduce path cost, then attempts incremental connection and rewiring to the opposite tree. Path smoothing shortcutting is applied to the best path found. The process runs until success or timeout, ensuring fast convergence and quality paths in both 2D and 3D environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_node_free(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 25.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                # Generate orthonormal basis using Gram-Schmidt like\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n\n                # u,v,w basis\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best: float):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            return goal_position\n\n        def rewire(tree, new_node, neighbors, edges):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree, sample_pt, nodes, edges):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors, edges)\n            return new_node\n\n        def try_connect(new_node, other_tree, nodes, edges):\n            if not other_tree:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors, edges)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(active_tree, sample_pt, nodes, edges)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect(new_node, other_tree, nodes, edges)\n            if connect_node:\n                if grow_start_tree:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n\n                if combined_cost + 1e-9 < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling_enabled = True\n\n                    # Rebuild edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.15224,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1620.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025473403930664062,
                    "num_nodes_avg": 75.6,
                    "path_length_avg": 159.417768565676,
                    "smoothness_avg": 0.04275585937355294,
                    "success_improvement": 0.0,
                    "time_improvement": -7.436572188195403,
                    "length_improvement": 12.620594912955186,
                    "smoothness_improvement": 569.2220450307822,
                    "objective_score": 3.1392575512863274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.057435011863708495,
                    "num_nodes_avg": 238.8,
                    "path_length_avg": 233.85118315702894,
                    "smoothness_avg": 0.11480701484099842,
                    "success_improvement": 0.0,
                    "time_improvement": 76.05418297514326,
                    "length_improvement": 21.933744029088825,
                    "smoothness_improvement": 2854.0671840092377,
                    "objective_score": 41.47333961840694
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044629597663879396,
                    "num_nodes_avg": 237.2,
                    "path_length_avg": 124.58131222307676,
                    "smoothness_avg": 0.12083883813233176,
                    "success_improvement": 0.0,
                    "time_improvement": 57.35668057052125,
                    "length_improvement": 17.259024346026223,
                    "smoothness_improvement": 1437.0611016480348,
                    "objective_score": 27.84411454860179
               }
          ],
          "success_rate": 1.0
     }
]