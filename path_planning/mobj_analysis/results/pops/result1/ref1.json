[
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation advances path planning by combining an anytime informed bidirectional RRT* approach with adaptive lazy collision checking and efficient nearest neighbor queries. It employs informed ellipsoidal and adaptive sampling biased toward the current best path, incrementally extending the smaller of two trees from start and goal. The planner performs rewiring to improve path costs, caches collision checks for efficiency, prunes nodes unlikely to yield better paths, and applies shortcut smoothing to enhance path quality and smoothness. This results in improved planning efficiency, shorter and smoother paths, higher success rates, and reduced search times in both 2D and 3D environments.",
          "planning_mechanism": "The planner initializes two trees from start and goal, iteratively sampling points within an informed ellipsoid or near the best path known so far. It extends the smaller tree toward the sample point while performing lazy collision checking and rewiring to minimize path costs. Incremental backward connections attempt to join the two trees. Periodic aggressive pruning removes nodes that cannot improve the solution, maintaining scalability. Upon finding a valid connection, the planner extracts the path and refines it through shortcut smoothing before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # For rewiring & pruning\n        self.valid = True               # Mark valid/pruned or for collision\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius)*math.sqrt(math.log(max(n_nodes,1)+1)/max(n_nodes,1))\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree brute-force for portability\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sampling biased by the best known cost c_best\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min*1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            direction = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            # Householder reflection matrix\n            u = direction - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sample near current best path with Gaussian noise\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0,len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d]+noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing by direct edge replacement\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0,len(smooth)-3)\n                j = random.randint(i+2,len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire tree B\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connection established\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    # Extract full path concatenating start-goal or goal-start accordingly\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Continue searching for better paths if desired\n                # Optional: could continue instead of break to get anytime property\n                break\n\n            # Periodic pruning for efficiency\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.02291,
          "time_improvement": 75.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1500.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009522128105163574,
                    "num_nodes_avg": 75.6,
                    "path_length_avg": 162.2711231859635,
                    "smoothness_avg": 0.03835325323781138,
                    "success_improvement": 0.0,
                    "time_improvement": 65.42032042224254,
                    "length_improvement": 11.056626031278256,
                    "smoothness_improvement": 500.3116985941833,
                    "objective_score": 24.33897982589933
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02523810863494873,
                    "num_nodes_avg": 227.8,
                    "path_length_avg": 243.17071095772354,
                    "smoothness_avg": 0.10067455341429248,
                    "success_improvement": 0.0,
                    "time_improvement": 86.10390457698458,
                    "length_improvement": 18.822617401482624,
                    "smoothness_improvement": 2490.428772299574,
                    "objective_score": 42.04783871488977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015049433708190918,
                    "num_nodes_avg": 143.0,
                    "path_length_avg": 125.26775168341048,
                    "smoothness_avg": 0.1264911902198619,
                    "success_improvement": 0.0,
                    "time_improvement": 72.58835126848885,
                    "length_improvement": 16.803123941207094,
                    "smoothness_improvement": 1508.9586029881864,
                    "objective_score": 32.68192318372901
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner integrates a bidirectional informed RRT* method with adaptive ellipsoidal sampling for targeted exploration within the informed subset defined by the current best path cost. Efficient KD-tree based nearest neighbor and radius queries accelerate rewiring and local path cost improvements. Collision caching prevents redundant checks, boosting speed. Periodic pruning removes nodes unlikely to contribute to better paths, reducing computational burden. The planner alternates tree growth between start and goal, performs incremental rewiring to refine connections, and applies shortcut smoothing on the final path to enhance smoothness and reduce length. Together, these enhancements optimize planning time, path quality, and robustness in both 2D and 3D spaces.",
          "planning_mechanism": "The planning procedure builds two trees growing simultaneously from start and goal. Sampling is biased inside an adaptive ellipsoid enclosing the best current solution, balancing exploration and focused refinement. Using KD-trees, nearest nodes are efficiently retrieved for expansion and rewiring in the graph. Collision checking results are cached to avoid repeated expensive queries, and pruning removes nodes that cannot improve the solution. The algorithm connects the two trees when possible, merges and smooths the resulting path, and iterates to improve until a maximum iteration count or success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection between trees\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.20767,
          "time_improvement": 70.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1565.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010985040664672851,
                    "num_nodes_avg": 83.1,
                    "path_length_avg": 164.17793782561992,
                    "smoothness_avg": 0.041958230745177696,
                    "success_improvement": 0.0,
                    "time_improvement": 60.10774249854543,
                    "length_improvement": 10.011470711871027,
                    "smoothness_improvement": 556.7374249184203,
                    "objective_score": 22.818304016529932
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024611353874206543,
                    "num_nodes_avg": 230.2,
                    "path_length_avg": 235.43250944634866,
                    "smoothness_avg": 0.10779172352331912,
                    "success_improvement": 0.0,
                    "time_improvement": 86.44899556966071,
                    "length_improvement": 21.405851797760366,
                    "smoothness_improvement": 2673.558685495253,
                    "objective_score": 43.58366245792655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020103073120117186,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 121.29542224910135,
                    "smoothness_avg": 0.12292121817603414,
                    "success_improvement": 0.0,
                    "time_improvement": 63.38344754509845,
                    "length_improvement": 19.44135600947434,
                    "smoothness_improvement": 1463.5488220986226,
                    "objective_score": 30.221049575917515
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm with efficient KD-tree based nearest neighbor searches, collision caching, adaptive neighborhood radius, pruning of non-promising nodes, and path shortcutting for smoothing. The approach balances exploration and exploitation by sampling within an ellipsoidal informed subset based on the current best solution cost, alternates tree growth from start and goal, performs incremental rewiring for path improvement, and prunes the search tree periodically to reduce computational load and improve robustness.",
          "planning_mechanism": "The planner grows two trees simultaneously from the start and the goal positions. It uses an adaptive ellipsoidal sampling to bias samples towards promising regions defined by the best found path. Efficient KD-tree structures enable fast nearest neighbor and radius queries for rewiring and local optimization. Collision results are cached to avoid redundant checks. Periodic pruning removes nodes that cannot improve the current best path. Once a connection between the two trees is found, the final path undergoes shortcut smoothing to improve length and smoothness before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_i in range(self.dim):\n                        delta = p[d_i] - pt[d_i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet found: uniform random + goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                if random.random() < self.goal_sample_rate:\n                    return goal if random.random() < 0.7 else start\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = np.eye(dim) - 2.0 * np.outer(v, v)\n            else:\n                rot = np.eye(dim)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(np.clip(sample, 0.0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth: extend the smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect trees attempt\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b == last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.06,
          "time_improvement": 69.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1641.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011839795112609863,
                    "num_nodes_avg": 88.2,
                    "path_length_avg": 161.13621726428488,
                    "smoothness_avg": 0.04269088410068969,
                    "success_improvement": 0.0,
                    "time_improvement": 57.00369531488101,
                    "length_improvement": 11.678685950685463,
                    "smoothness_improvement": 568.2050409144091,
                    "objective_score": 22.277870989173437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028751897811889648,
                    "num_nodes_avg": 259.0,
                    "path_length_avg": 240.98519182802505,
                    "smoothness_avg": 0.11489472185949993,
                    "success_improvement": 0.0,
                    "time_improvement": 84.16921325738566,
                    "length_improvement": 19.552206593656173,
                    "smoothness_improvement": 2856.3239487680935,
                    "objective_score": 43.4428250397874
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019392633438110353,
                    "num_nodes_avg": 173.8,
                    "path_length_avg": 123.76562160207109,
                    "smoothness_avg": 0.1257225550221179,
                    "success_improvement": 0.0,
                    "time_improvement": 64.67747118649956,
                    "length_improvement": 17.800767217484783,
                    "smoothness_improvement": 1499.1816200076312,
                    "objective_score": 30.45930289948498
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an improved bidirectional RRT*-based algorithm that employs adaptive informed ellipsoidal sampling guided by the current best solution cost, KD-tree accelerated nearest neighbor and radius queries for efficient rewiring, collision caching for faster feasibility checks, periodic pruning of non-promising nodes, and aggressive shortcut smoothing to minimize path length and reduce planning time. The planner balances exploration and exploitation, dynamically adjusts rewiring radius based on iteration and node count, ensures tree growth alternates to maintain balanced expansions, and leverages incremental rewiring to continuously improve path quality and robustness.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatively, sampling informed points from the ellipsoidal domain defined by the best path cost. KD-trees speed up queries for nearest neighbors and radius searches used in parent selection and rewiring. It caches collision checks to prevent redundant computations and prunes nodes periodically to reduce complexity. Upon a successful connection, the planner aggressively shortcut smooths the merged path to improve smoothness and shorten the solution. Iterative rewiring ensures path cost improvement, leading to faster convergence and high-quality, smooth, and safe paths within bounded environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Brute-force KDTree substitute for simplicity\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution yet or c_best < c_min, uniform random sampling with goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2)*(c_min/2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim -1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            # Check cache\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally extend tree_b towards new_node for connection\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce unpromising nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.12292,
          "time_improvement": 68.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1513.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011169075965881348,
                    "num_nodes_avg": 80.7,
                    "path_length_avg": 164.078281217285,
                    "smoothness_avg": 0.04550461297896471,
                    "success_improvement": 0.0,
                    "time_improvement": 59.43941692294905,
                    "length_improvement": 10.066094078059415,
                    "smoothness_improvement": 612.246007969468,
                    "objective_score": 22.90627393234394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02042250633239746,
                    "num_nodes_avg": 202.1,
                    "path_length_avg": 236.20206342039756,
                    "smoothness_avg": 0.09340105139051506,
                    "success_improvement": 0.0,
                    "time_improvement": 88.75537383260384,
                    "length_improvement": 21.148952530839864,
                    "smoothness_improvement": 2303.276326336031,
                    "objective_score": 42.37278428762928
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023964571952819824,
                    "num_nodes_avg": 181.7,
                    "path_length_avg": 127.48194658750042,
                    "smoothness_avg": 0.13550695879013402,
                    "success_improvement": 0.0,
                    "time_improvement": 56.3499570077386,
                    "length_improvement": 15.33256111454165,
                    "smoothness_improvement": 1623.638513727235,
                    "objective_score": 28.089691893866085
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This implementation is an enhanced bidirectional RRT* planner employing adaptive informed ellipsoidal sampling to focus search in promising regions, KD-tree accelerated nearest neighbor and radius searches for efficient rewiring, cached collision checks to minimize redundant work, incremental local connections for balanced tree growth, and aggressive pruning of non-promising nodes to sustain computational efficiency. The planner additionally performs iterative shortcut smoothing to refine the path length and smoothness before outputting the final trajectory. This combination improves planning speed, path quality, robustness, and success rate while maintaining search within map bounds and obstacle-free space.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal points with alternated expansions, sampling points biased in an adaptive ellipsoidal region shaped by the current best path cost for focused exploration. Each sampled point extends the smaller tree by steering towards it with step size constraints and validated collision-free node and edges. Rewiring in local neighborhoods identified by KD-tree optimizes the path incrementally. The opposite tree attempts incremental connections towards the newly added node, further refining connectivity. Periodic pruning discards dead-end and costly nodes, and repeated shortcut smoothing improves final path smoothness and length, balancing exploration and exploitation for efficient and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(120):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expansion to keep trees balanced\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = max(1, int(dist(last_b.position, new_node.position) / self.step_size) + 1)\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.11267,
          "time_improvement": 62.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1415.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01557331085205078,
                    "num_nodes_avg": 68.3,
                    "path_length_avg": 158.3725748297215,
                    "smoothness_avg": 0.04314863544165945,
                    "success_improvement": 0.0,
                    "time_improvement": 43.44540492616297,
                    "length_improvement": 13.19348216178646,
                    "smoothness_improvement": 575.3698434235326,
                    "objective_score": 18.549167127323848
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028561830520629883,
                    "num_nodes_avg": 227.8,
                    "path_length_avg": 238.0671706366546,
                    "smoothness_avg": 0.10543628565038435,
                    "success_improvement": 0.0,
                    "time_improvement": 84.27386425379521,
                    "length_improvement": 20.52632605791864,
                    "smoothness_improvement": 2612.9515724713165,
                    "objective_score": 42.45218235007887
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022870826721191406,
                    "num_nodes_avg": 167.7,
                    "path_length_avg": 123.79375098279574,
                    "smoothness_avg": 0.09084339387630629,
                    "success_improvement": 0.0,
                    "time_improvement": 58.342148918245215,
                    "length_improvement": 17.78208502218464,
                    "smoothness_improvement": 1055.5212647447793,
                    "objective_score": 26.336668003634387
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an improved bidirectional RRT* algorithm with enhanced informed ellipsoidal sampling, more efficient KD-tree based neighbor queries, adaptive neighbor radius, aggressive incremental rewiring to optimize path costs, and periodic pruning of non-promising nodes. It integrates a robust collision cache and conducts path shortcut smoothing frequently on improving solutions to minimize path length and increase smoothness. The approach balances exploration and exploitation, ensuring improved planning efficiency, higher success rates, reduced path lengths, and better overall path quality in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees alternatively from the start and goal positions, sampling informed by the current best path within an ellipsoidal domain. It uses a KD-tree structure for fast nearest and radius neighbors queries. After creating new nodes and connecting them, it rewires nearby nodes to improve cost consistency. It incrementally attempts to connect the two trees, shortcutting and pruning periodically to maintain efficiency and ensure near-optimal, smooth paths with minimized length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=3.0,\n                 max_neighbor_radius: float=25.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=200,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def adaptive_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute a Householder transformation to align ellipsoid axes\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.0] + [0.0]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-15:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1*r1 - (c_min/2.0)*(c_min/2.0), 0)\n            r_other = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1)\n                    # Uniform sampling inside unit ball\n                    u = radius_factor**(1/dim)\n                    sample = rot @ (radii * (x / norm_x) * u) + center\n                    sample_t = tuple(float(c) for c in sample)\n                    if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                        return sample_t\n\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expansion on smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors of new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting tree_b incrementally towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        # Aggressive shortcut smoothing on improved path\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # We can opt to continue search for better solutions or break early here\n                # For efficiency, break here:\n                break\n\n            # Periodic pruning to discard nodes unlikely to improve solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.81397,
          "time_improvement": 55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1621.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015974712371826173,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 157.34932763293077,
                    "smoothness_avg": 0.04712046382658774,
                    "success_improvement": 0.0,
                    "time_improvement": 41.9877122987837,
                    "length_improvement": 13.754340164736892,
                    "smoothness_improvement": 637.5375826110454,
                    "objective_score": 18.534869635637715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025428032875061034,
                    "num_nodes_avg": 212.6,
                    "path_length_avg": 231.78360388778964,
                    "smoothness_avg": 0.0981620223596258,
                    "success_improvement": 0.0,
                    "time_improvement": 85.99933234449605,
                    "length_improvement": 22.62396150113044,
                    "smoothness_improvement": 2425.7795385600307,
                    "objective_score": 42.45348969637506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0350804328918457,
                    "num_nodes_avg": 181.8,
                    "path_length_avg": 130.8478071708198,
                    "smoothness_avg": 0.14942212071146688,
                    "success_improvement": 0.0,
                    "time_improvement": 36.1030772036791,
                    "length_improvement": 13.097116780158464,
                    "smoothness_improvement": 1800.638346256177,
                    "objective_score": 22.453538248416308
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner leveraging adaptive informed sampling with KD-tree based nearest-neighbor searches, dynamic rewiring, periodic pruning of suboptimal nodes, and path shortcutting for smoothness. It grows two trees from start and goal, samples biased around the current best path estimate using ellipsoidal informed sampling, and actively prunes the search space to improve planning efficiency, path quality, and smoothness while maintaining robustness and fast convergence.",
          "planning_mechanism": "The planner alternates expanding start and goal trees using adaptive informed samples concentrated within an ellipsoidal subset based on the current best path cost. It performs local rewiring to optimize paths and prunes nodes exceeding cost thresholds to reduce computational overhead. Bidirectional connection attempts are made to stitch trees early. After success, shortcut smoothing is applied to reduce path complexity and length, resulting in high quality, efficient paths. KD-tree accelerates neighbor queries enabling scalability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]: spatial coordinate\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost to come\n        self.children = []\n        self.valid = True              # Node validity (for pruning, etc.)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius_factor: float = 1.5,\n                 prune_interval: int = 100, shortcut_iters: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor      # radius = radius_factor * (log(n)/n)^(1/d)\n        self.prune_interval = prune_interval    # How often to prune\n        self.shortcut_iters = shortcut_iters    # Shortcut smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize start and goal trees\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        # KD-tree substitute brute-force containers (for simplicity, replaceable by KDTree)\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            px, py, pz = point + (0,) * (3 - dim)  # pad to 3d for safety\n            for node in tree:\n                nx, ny, nz = node.position + (0,) * (3 - dim)\n                dx, dy, dz = nx - px, ny - py, nz - pz\n                if dx*dx + dy*dy + dz*dz <= r2:\n                    result.append(node)\n            return result\n\n        # Ellipsoidal informed sampling region parameters\n        def informed_sample(c_best, c_min, x_center, C, bounds):\n            # Sample unit ball in dimension dim\n            def unit_ball_sample():\n                while True:\n                    p = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum([x*x for x in p]))\n                    if norm > 1e-10:\n                        return tuple(x / norm for x in p)\n            if c_best < float('inf'):\n                # Define axes lengths for ellipsoid\n                a1 = c_best / 2.0\n                r_minor = math.sqrt(c_best*c_best - c_min*c_min) / 2.0 if (c_best*c_best - c_min*c_min) > 0 else 0.0\n                L = [[a1] + [0]*(dim-1)]\n                for i in range(1,dim):\n                    row = [0]*dim\n                    row[i] = r_minor\n                    L.append(row)\n                # Sample unit ball vector\n                x_ball = unit_ball_sample()\n                # Scale to ellipsoid\n                x_ellipsoid = [sum(L[i][j]*x_ball[j] for j in range(dim)) for i in range(dim)]\n                # Rotate and translate back\n                sample = []\n                for i in range(dim):\n                    val = sum(C[i][j]*x_ellipsoid[j] for j in range(dim)) + x_center[i]\n                    # Clamp to bounds\n                    val = max(0.0, min(val, bounds[i]))\n                    sample.append(val)\n                return tuple(sample)\n            else:\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Compute rotation matrix C from first axis e1 to unit vector from start to goal\n        def compute_C_unit_vector(e1):\n            # Create rotation matrix C that aligns e1 to unit vector along x axis\n            # For simplicity, identity matrix since we can assume start->goal along x-axis after transform\n            # But build a rotation matrix to rotate e1 to x-axis\n            import numpy as np\n\n            a = np.array(e1)\n            a = a / np.linalg.norm(a)\n            e_x = np.array([1] + [0]*(dim-1))\n            v = np.cross(a, e_x) if dim == 3 else np.array([0,0,0])  # For 2D cross -> scalar, 3D vector\n            s = np.linalg.norm(v)\n            c = np.dot(a, e_x)\n            if s < 1e-10:\n                return np.identity(dim)\n            vx = np.array([[0, -v[2], v[1]],\n                           [v[2], 0, -v[0]],\n                           [-v[1], v[0], 0]]) if dim == 3 else np.array([[0,-v[0]],\n                                                                         [v[0],0]])\n            R = np.identity(dim) + vx + (vx @ vx) * ((1 - c) / (s*s))\n            return R\n\n        # Shortcut smoothing of path\n        def shortcut_path(path, attempts):\n            length = len(path)\n            if length <= 2:\n                return path[:]\n            for _ in range(attempts):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 2)\n                j = random.randint(i + 1, length - 1)\n                if j == i + 1:\n                    continue\n                p_start = path[i]\n                p_end = path[j]\n                if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                    # shortcut possible\n                    new_path = path[:i+1] + path[j:]\n                    path = new_path\n                    length = len(path)\n            return path\n\n        # Prune nodes whose cost is greater than current best path cost + margin\n        def prune_nodes(tree, cost_threshold):\n            removed = []\n            for node in tree[:]:\n                if node.cost > cost_threshold:\n                    # prune subtree\n                    def invalidate_subtree(n):\n                        n.valid = False\n                        for c in n.children[:]:\n                            invalidate_subtree(c)\n                        n.children.clear()\n                    invalidate_subtree(node)\n                    # remove from tree if leaf or invalid\n                    tree.remove(node)\n                    removed.append(node)\n            return removed\n\n        # Initialize\n        c_best = float('inf')\n        c_min = distance(start_position, goal_position)\n        x_center = tuple((s+g)/2 for s,g in zip(start_position, goal_position))\n        unit_vector_start_goal = tuple((g - s)/c_min if c_min>0 else 1.0 for s,g in zip(start_position, goal_position))\n        # Setup rotation matrix C for ellipsoidal sampling (identity fallback)\n        use_numpy = False\n        try:\n            import numpy as np\n            use_numpy = True\n            C = compute_C_unit_vector(unit_vector_start_goal)\n        except:\n            # no numpy fallback identity\n            C = [[1.0 if i==j else 0.0 for j in range(dim)] for i in range(dim)]\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def extract_full_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return list(reversed(path_start)) + path_goal\n\n        # Radius calculation based on iteration and nodes count for rewiring\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 2\n            gamma_rrt = self.radius_factor * ((math.log(n) / n) ** (1 / dim))\n            return max(gamma_rrt, self.step_size)\n\n        # Main loop\n        tree_toggle = True  # True: start_tree expands, False: goal_tree expands\n\n        for iter in range(1, self.max_iter +1):\n\n            # Sample informed-biased point\n            if c_best < float('inf'):\n                sample = informed_sample(c_best, c_min, x_center, C, bounds)\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            tree_a = start_tree if tree_toggle else goal_tree\n            tree_b = goal_tree if tree_toggle else start_tree\n            tree_toggle = not tree_toggle\n\n            # Nearest in tree_a\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Bounds check\n            invalid_bound = False\n            for i in range(dim):\n                if new_pos[i] < 0 or new_pos[i] > bounds[i]:\n                    invalid_bound = True\n                    break\n            if invalid_bound:\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and find near nodes to rewire\n            new_node = Node(new_pos)\n            new_node.cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node.parent = nearest_node\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring: find neighbors in radius, choose best parent and rewire others\n            radius = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select best parent with lower cost if possible\n            min_cost = new_node.cost\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                dist_new = distance(near_node.position, new_pos)\n                tentative_cost = near_node.cost + dist_new\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_parent = near_node\n            if min_parent != new_node.parent:\n                # Update parent\n                edges.remove((new_node.parent, new_node))\n                new_node.update_parent(min_parent, min_cost)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if cost can be reduced by going through new_node\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist_to_near = distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_to_near\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Try to connect new_node to nearest node in other tree\n            connect_candidate = nearest(tree_b, new_node.position)\n            dist_connect = distance(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    # Connection found, extract path and update best cost\n                    success_state = True\n                    extracted_path = extract_full_path(new_node, connect_candidate)\n                    # Update c_best and other params\n                    path_len = 0.0\n                    for i in range(len(extracted_path)-1):\n                        path_len += distance(extracted_path[i], extracted_path[i+1])\n                    if path_len < c_best:\n                        c_best = path_len\n                        x_center = tuple((s + g)/2 for s,g in zip(start_position, goal_position))\n\n                    # After success, continue optimizing until max_iter or refine path\n                    # But here break early to favor fast return\n                    break\n\n            # Periodic pruning of nodes exceeding c_best + margin (1.2 factor to keep some buffer)\n            if (iter % self.prune_interval == 0) and (c_best < float('inf')):\n                cost_threshold = c_best * 1.2\n                prune_nodes(start_tree, cost_threshold)\n                prune_nodes(goal_tree, cost_threshold)\n                # Remove invalid nodes from global nodes list & edges cleanup\n                nodes = [n for n in nodes if n.valid]\n                new_edges = []\n                for (p,c) in edges:\n                    if p.valid and c.valid:\n                        new_edges.append((p,c))\n                edges = new_edges\n\n        # If succeeded, apply shortcut smoothing for path quality\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path, self.shortcut_iters)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.09278,
          "time_improvement": 67.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 749.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007432174682617187,
                    "num_nodes_avg": 93.9,
                    "path_length_avg": 177.6187679750588,
                    "smoothness_avg": 0.019366011863381008,
                    "success_improvement": 0.0,
                    "time_improvement": 73.01000193943425,
                    "length_improvement": 2.644338723380414,
                    "smoothness_improvement": 203.12013962977122,
                    "objective_score": 23.447469024655213
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022794437408447266,
                    "num_nodes_avg": 291.5,
                    "path_length_avg": 252.09119223129596,
                    "smoothness_avg": 0.050874495325825685,
                    "success_improvement": 0.0,
                    "time_improvement": 87.44938925799266,
                    "length_improvement": 15.844703990547238,
                    "smoothness_improvement": 1209.03740815134,
                    "objective_score": 35.44894461626395
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03218321800231934,
                    "num_nodes_avg": 273.3,
                    "path_length_avg": 129.53365006827633,
                    "smoothness_avg": 0.07348930713014253,
                    "success_improvement": 0.0,
                    "time_improvement": 41.38018187029365,
                    "length_improvement": 13.969917354231281,
                    "smoothness_improvement": 834.7785622790145,
                    "objective_score": 19.38193084332942
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.236516881212783,
          "time_improvement": 76.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011123085021972656,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 59.60643338043388,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 19.47723527738242
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020223259925842285,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 88.8650788472795,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 30.29781438390462
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010589408874511718,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 80.7120213311099,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.934500982351317
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.686646482648733,
          "time_improvement": 70.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008629989624023438,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 68.66012800265979,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 20.339674425874648
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017743754386901855,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 90.23029389050582,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.450156087820762
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027648019790649413,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 49.64077577147224,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 14.270108934250793
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner optimizing path quality by rewiring nodes and efficiently connecting two growing trees from start and goal positions, ensuring collision-free nodes and edges. It balances exploration and exploitation via informed sampling within bounds and local neighborhoods to improve planning efficiency and path smoothness.",
          "planning_mechanism": "The planner grows two trees simultaneously, alternating extensions toward sampled free-space points. Each new node rewires nearby nodes to optimize path costs while checking collision-free conditions. After each extension, it attempts to connect the trees directly to form a complete path. Successful connections yield an extracted path. The process repeats until a path is found or maximum iterations are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def sample_free():\n            while True:\n                point = tuple(\n                    min(max(random.uniform(0, bounds[i]), 0), bounds[i]) for i in range(len(bounds))\n                )\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            while node_a:\n                path_a.append(node_a.position)\n                node_a = node_a.parent\n            path_b = []\n            while node_b:\n                path_b.append(node_b.position)\n                node_b = node_b.parent\n            return list(reversed(path_a)) + path_b\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + distance(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                connect_node = nearest(tree_b, new_node.position)\n                if distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        success_state = True\n                        extracted_path = extract_path(new_node, connect_node)\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.79806,
          "time_improvement": 56.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 171.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.015959906578063964,
                    "num_nodes_avg": 124.3,
                    "path_length_avg": 176.18731378118582,
                    "smoothness_avg": 0.01661451830973254,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 42.041479649793594,
                    "length_improvement": 3.4289414498854387,
                    "smoothness_improvement": 160.0532905512883,
                    "objective_score": -35.90150136232839
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029958891868591308,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 254.75778835924976,
                    "smoothness_avg": 0.011133412186201206,
                    "success_improvement": 0.0,
                    "time_improvement": 83.50464267368856,
                    "length_improvement": 14.954517449322442,
                    "smoothness_improvement": 186.4707146236214,
                    "objective_score": 28.974649865089166
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032387804985046384,
                    "num_nodes_avg": 302.7,
                    "path_length_avg": 134.15030350767475,
                    "smoothness_avg": 0.021037995824514003,
                    "success_improvement": 0.0,
                    "time_improvement": 41.0075388450281,
                    "length_improvement": 10.903755961195786,
                    "smoothness_improvement": 167.60175402449696,
                    "objective_score": 15.321021615870071
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 14.040429579216145,
          "time_improvement": -46.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03423063755035401,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -24.308816806582996,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -7.334241520576589
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.25640091896057127,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -41.17427292039947,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -12.71054682752658
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09547178745269776,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -73.89618454536769,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -22.076500389545267
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 35.99506230191474,
          "time_improvement": 80.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00860438346862793,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 68.75311694788464,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 24.941182622741845
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.019841814041137697,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 89.07510284270805,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.52187990491308
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.009451961517333985,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 82.78381406498345,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.404489623573
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.67968564023809,
          "time_improvement": -138.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049904608726501466,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -81.22896060177874,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -21.056345940048022
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4500833749771118,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -147.8157780149155,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -38.42083438241184
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15669031143188478,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -185.40208621034077,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -50.56187659825441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.96081985328956,
          "time_improvement": 92.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.002695155143737793,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 90.21252389660044,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 28.691697356091538
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008399605751037598,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.3751794668759,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.37892570469852
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.005385470390319824,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 90.19068587856208,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -23.1952312112617
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an adaptive bidirectional RRT* planner that combines efficient nearest neighbor search, informed sampling biased by the current best solution, dynamic rewiring for path optimization, and path shortcutting to enhance path quality, smoothness, and planning speed in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within informed ellipsoids after the first solution to focus exploration. It performs collision and edge checks before node additions, rewires neighbors to shorten paths, prunes suboptimal branches, and applies shortcutting to smooth paths, iterating until max iterations or a high-quality path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def reset_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0, smoothing_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import math\n        import random\n        import numpy as np\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success_state = False\n        extracted_path = []\n\n        def sample(tree_has_solution: bool):\n            # Informed sampling after first solution; otherwise uniform with goal bias\n            if not tree_has_solution:\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                dim = len(start)\n                c_max = best_cost\n                L = np.diag([c_max / 2] + [math.sqrt(c_max**2 - c_min**2) / 2] * (dim - 1))\n                x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n                a1 = np.array(goal) - np.array(start)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    a1 = np.zeros(dim)\n                else:\n                    a1 = a1 / a1_norm\n                I = np.eye(dim)\n                M = np.outer(a1, I[:,0])\n                U, _, Vt = np.linalg.svd(M)\n                C_det = np.linalg.det(U) * np.linalg.det(Vt)\n                C = U @ np.diag([1]*(dim-1) + [C_det]) @ Vt\n\n                while True:\n                    x_ball = np.random.normal(0,1,dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x > 1e-6:\n                        x_ball = x_ball / norm_x * random.random()**(1.0/dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        return tuple(x_rand)\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Brute force nearest search\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point):\n            r = self.rewire_radius\n            return [node for node in tree if math.dist(node.position, point) <= r]\n\n        def collision_free(node_pos):\n            # Node collision test\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def path_free(pos_a, pos_b):\n            # Edge collision test\n            return not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d)\n\n        def connect_trees(node_a, node_b):\n            # Try to connect two trees by incremental steering from node_b towards node_a\n            curr = node_b\n            while True:\n                new_pos = steer(curr.position, node_a.position)\n                if collision_free(new_pos) and path_free(curr.position, new_pos):\n                    new_node = Node(new_pos, parent=curr, cost=curr.cost + math.dist(curr.position, new_pos))\n                    curr.add_child(new_node)\n                    return new_node\n                else:\n                    return None\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Goal tree path reversed, omit duplicate connecting node\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path_nodes):\n            # Attempt shortcutting by randomly connecting non-adjacent points if path between free\n            for _ in range(self.smoothing_iters):\n                if len(path_nodes) < 3:\n                    break\n                i, j = sorted(random.sample(range(len(path_nodes)), 2))\n                if j - i <= 1:\n                    continue\n                if path_free(path_nodes[i], path_nodes[j]):\n                    path_nodes = path_nodes[:i+1] + path_nodes[j:]\n            return path_nodes\n\n        for it in range(self.max_iter):\n            # Alternate tree growth\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                has_solution = best_cost < float(\"inf\")\n                x_rand = sample(has_solution)\n                x_nearest = nearest(tree_a, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n\n                if not collision_free(x_new_pos) or not path_free(x_nearest.position, x_new_pos):\n                    continue\n\n                x_new = Node(x_new_pos)\n                near_nodes = near(tree_a, x_new_pos)\n\n                # Choose parent with minimal cost if collision-free\n                min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    cost_candidate = n.cost + math.dist(n.position, x_new_pos)\n                    if cost_candidate < min_cost and path_free(n.position, x_new_pos):\n                        min_cost = cost_candidate\n                        best_parent = n\n\n                best_parent.add_child(x_new)\n                x_new.cost = min_cost\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors through x_new for possible cost improvement\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                    if alt_cost < n.cost and path_free(x_new.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            try:\n                                n.parent.children.remove(n)\n                            except ValueError:\n                                pass\n                        n.reset_parent(x_new, alt_cost)\n                        edges.append((x_new, n))\n\n                # Try connecting new node to other tree for path completion\n                node_connect = nearest(tree_b, x_new.position)\n                if path_free(x_new.position, node_connect.position):\n                    # Connect with incremental steps\n                    connected_node = node_connect\n                    # Attempt to extend tree_b towards x_new\n                    # Steer recursively until within step_size or blocked\n                    temp_curr = node_connect\n                    last_node = None\n                    while True:\n                        next_pos = steer(temp_curr.position, x_new.position)\n                        if not collision_free(next_pos) or not path_free(temp_curr.position, next_pos):\n                            break\n                        next_node = Node(next_pos, parent=temp_curr, cost=temp_curr.cost + math.dist(temp_curr.position, next_pos))\n                        temp_curr.add_child(next_node)\n                        tree_b.append(next_node)\n                        nodes.append(next_node)\n                        edges.append((temp_curr, next_node))\n                        last_node = next_node\n                        if math.dist(next_pos, x_new.position) < self.step_size:\n                            # Connect final node\n                            final_node = Node(x_new.position, parent=last_node, cost=last_node.cost + math.dist(last_node.position, x_new.position))\n                            last_node.add_child(final_node)\n                            tree_b.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((last_node, final_node))\n                            last_node = final_node\n                            break\n                        temp_curr = next_node\n\n                    if last_node and math.dist(last_node.position, x_new.position) < self.step_size:\n                        success_state = True\n                        path = extract_path(x_new, last_node)\n                        # Update best cost and path if improved\n                        path_cost = 0.0\n                        for p1, p2 in zip(path[:-1], path[1:]):\n                            path_cost += math.dist(p1, p2)\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            extracted_path = shortcut_path(path)\n\n            # Optional pruning or other improvements could be added here\n\n            if success_state and it > self.max_iter * 0.1:\n                # Early stop if good path found\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 93.66733,
          "time_improvement": -338.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 664.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.25658650398254396,
                    "num_nodes_avg": 1199.8,
                    "path_length_avg": 149.43589945331595,
                    "smoothness_avg": 0.03118988853131662,
                    "success_improvement": 0.0,
                    "time_improvement": -831.7958122073533,
                    "length_improvement": 18.091815546277754,
                    "smoothness_improvement": 388.189485442106,
                    "objective_score": -243.97943312573992
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09796781539916992,
                    "num_nodes_avg": 798.1,
                    "path_length_avg": 229.2193395994468,
                    "smoothness_avg": 0.03844679007087831,
                    "success_improvement": 0.0,
                    "time_improvement": 46.058948756324256,
                    "length_improvement": 23.479986728834408,
                    "smoothness_improvement": 889.2636006272639,
                    "objective_score": 22.95999997580048
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1796950101852417,
                    "num_nodes_avg": 1328.9,
                    "path_length_avg": 115.67133278187198,
                    "smoothness_avg": 0.06404544847167527,
                    "success_improvement": 0.0,
                    "time_improvement": -227.30377723928882,
                    "length_improvement": 23.17660844324665,
                    "smoothness_improvement": 714.6533772164469,
                    "objective_score": -59.98254459705508
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional informed sampling, adaptive step sizing near obstacles, rewiring for path quality, and goal biasing to accelerate convergence, improve path optimality, and enhance success rates in cluttered 2D and 3D environments. It incorporates pruning and node rejection to focus computational effort while ensuring smooth, short paths with robust collision avoidance.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions using heuristic-informed samples within an ellipsoidal domain constrained by the current best path cost, adaptively varies step sizes near obstacles for safer progress, rewires tree nodes to optimize local path costs, prunes nodes that cannot improve solutions, attempts connections between the two trees each iteration, and employs informed goal biasing to increase success chances efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start, tree_goal = [Node(start_position)], [Node(goal_position)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1_unit = a1 / norm_a1\n\n            # Build orthonormal basis via SVD\n            M = np.eye(dim)\n            M[0] = a1_unit\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                # Sample uniformly in the unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = C @ L @ x_ball + x_center\n                sample_tuple = tuple(sample)\n                if all(0 <= sample_tuple[d] <= bounds[d] for d in range(dim)):\n                    return sample_tuple\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        for iter_i in range(self.max_iter):\n            # Alternate trees\n            if iter_i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Goal biasing and informed sampling combined\n            if random.random() < self.goal_sample_rate and iter_i % 20 == 0:\n                sample = goal_position if tree_from is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Bound check\n            if not all(0 <= new_pos[d] <= bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes that cannot improve best solution\n            if cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in same tree\n            near_nodes = [n for n in tree_from if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                temp_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if temp_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                    near.update_parent(new_node, temp_cost)\n                    edges.append((new_node, near))\n\n            # Attempt to connect to other tree\n            other_nearest = min(tree_to, key=lambda n: math.dist(n.position, new_pos))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_from = new_node.path_from_root()\n                path_to = other_nearest.path_from_root()\n                # Connect two trees and prune nodes outside ellipsoid after new best found\n                best_path = path_from + path_to[::-1]\n                success_state = True\n\n                # Prune nodes that are unlikely to improve the solution\n                prune_radius = c_best\n                def can_improve(node):\n                    dc_start = math.dist(start_position, node.position)\n                    dc_goal = math.dist(node.position, goal_position)\n                    return (dc_start + dc_goal) < prune_radius * 1.02 # small buffer\n\n                pruned_nodes_start = [n for n in tree_start if not can_improve(n)]\n                pruned_nodes_goal = [n for n in tree_goal if not can_improve(n)]\n\n                for n in pruned_nodes_start:\n                    n.valid = False\n                for n in pruned_nodes_goal:\n                    n.valid = False\n\n                # Remove invalid nodes from trees\n                tree_start = [n for n in tree_start if n.valid]\n                tree_goal = [n for n in tree_goal if n.valid]\n\n                # Remove edges related to invalid nodes\n                edges = [(p,c) for (p,c) in edges if p.valid and c.valid]\n\n        # If success not yet true, try to directly connect closest nodes from trees near goal and start\n        if not success_state:\n            candidates_start = [n for n in tree_start if n.valid]\n            candidates_goal = [n for n in tree_goal if n.valid]\n            min_dist = float(\"inf\")\n            connect_nodes = (None, None)\n            for ns in candidates_start:\n                for ng in candidates_goal:\n                    dist_node = math.dist(ns.position, ng.position)\n                    if dist_node < min_dist and not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d):\n                        min_dist = dist_node\n                        connect_nodes = (ns, ng)\n            if connect_nodes[0] and connect_nodes[1]:\n                c = connect_nodes[0].cost + math.dist(connect_nodes[0].position, connect_nodes[1].position) + connect_nodes[1].cost\n                if c < c_best:\n                    c_best = c\n                    path_from = connect_nodes[0].path_from_root()\n                    path_to = connect_nodes[1].path_from_root()\n                    best_path = path_from + path_to[::-1]\n                    success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 752.73651,
          "time_improvement": -2525.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 146.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.1013382911682128,
                    "num_nodes_avg": 1601.0,
                    "path_length_avg": 156.18909394053804,
                    "smoothness_avg": 0.012735939785418263,
                    "success_improvement": 0.0,
                    "time_improvement": -3899.518258388053,
                    "length_improvement": 14.390282636616716,
                    "smoothness_improvement": 99.34511417769805,
                    "objective_score": -1166.4806954182038
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.0146764278411866,
                    "num_nodes_avg": 3086.9,
                    "path_length_avg": 230.80538747278115,
                    "smoothness_avg": 0.011303023729031126,
                    "success_improvement": 0.0,
                    "time_improvement": -1009.2802671042092,
                    "length_improvement": 22.950518296858608,
                    "smoothness_improvement": 190.83494178689156,
                    "objective_score": -297.2398017629566
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.5182529926300048,
                    "num_nodes_avg": 2724.4,
                    "path_length_avg": 117.5349638893726,
                    "smoothness_avg": 0.01958270655035075,
                    "success_improvement": 0.0,
                    "time_improvement": -2665.4075579527,
                    "length_improvement": 21.9388733982217,
                    "smoothness_improvement": 149.09058187542084,
                    "objective_score": -794.4890397967883
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 773.6755822135777,
          "time_improvement": -2595.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.1812242984771728,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "smoothness_avg": 0.0150601233961907,
                    "success_improvement": 0.0,
                    "time_improvement": -4189.6248926384615,
                    "length_improvement": 15.280155580980631,
                    "smoothness_improvement": 135.72363473177828,
                    "objective_score": -1253.1528185016834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.8513380289077759,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "smoothness_avg": 0.011376062771551485,
                    "success_improvement": 0.0,
                    "time_improvement": -919.3461911933799,
                    "length_improvement": 23.354217616048047,
                    "smoothness_improvement": 192.71428895883628,
                    "objective_score": -270.16944239001015
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.5240761041641235,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "smoothness_avg": 0.01876598180493872,
                    "success_improvement": 0.0,
                    "time_improvement": -2676.0140093975006,
                    "length_improvement": 22.0310377661009,
                    "smoothness_improvement": 138.7019033981297,
                    "objective_score": -797.7044857490393
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced and adaptive RRT* based planner that integrates goal biasing, informed sampling inside ellipsoidal subsets after an initial solution is found, and path smoothing via shortcutting to improve path quality and planning efficiency. It simultaneously balances exploration and exploitation to achieve faster convergence and robust performance in both 2D and 3D environments.",
          "planning_mechanism": "The planner starts sampling uniformly with goal bias to grow a tree. Upon finding the first feasible path, it uses informed sampling focused in a prolate hyperspheroid defined by start, goal, and current best cost to improve path quality. It rewires locally for optimality and applies periodic path smoothing via shortcut attempts between random node pairs on the current best path to enhance smoothness and reduce length. All node and edge additions are carefully checked for collision-free feasibility.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def reset_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 rewire_radius: float = 15.0, smoothing_iters: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        def sample():\n            if best_cost == float(\"inf\"):\n                # Uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                # Informed sampling inside prolate hyperspheroid\n                dim = len(start)\n                L = np.diag([best_cost / 2] + [math.sqrt(best_cost**2 - c_min**2) / 2] * (dim - 1))\n                x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n                a1 = np.array(goal) - np.array(start)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    a1 = np.zeros(dim)\n                else:\n                    a1 = a1 / a1_norm\n                I = np.eye(dim)\n                M = np.outer(a1, I[:, 0])\n                U, _, Vt = np.linalg.svd(M)\n                C_determinant = np.linalg.det(U) * np.linalg.det(Vt)\n                C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [C_determinant]), Vt))\n\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x > 1e-6:\n                        x_ball = x_ball / norm_x * random.random() ** (1.0 / dim)\n                    x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        return tuple(x_rand)\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        def near_nodes(new_pos):\n            return [n for n in tree if math.dist(n.position, new_pos) <= self.rewire_radius]\n\n        def try_path_smoothing(path_nodes: list):\n            # Attempts shortcuts in the path by connecting random pairs of nodes\n            for _ in range(self.smoothing_iters):\n                if len(path_nodes) < 3:\n                    return path_nodes\n                i, j = sorted(random.sample(range(len(path_nodes)), 2))\n                if j - i <= 1:\n                    continue\n                p_start = path_nodes[i]\n                p_end = path_nodes[j]\n                if (not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(p_start, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(p_end, obstacles, is_3d)):\n                    new_path = path_nodes[:i+1] + path_nodes[j:]\n                    path_nodes = new_path\n            return path_nodes\n\n        for iter_count in range(self.max_iter):\n            x_rand = sample()\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near = near_nodes(x_new_pos)\n\n            # Choose best parent minimizing cost + distance and collision free edge\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near:\n                temp_cost = n.cost + math.dist(n.position, x_new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = temp_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewiring neighbors if better through x_new\n            for n in near:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        try:\n                            n.parent.children.remove(n)\n                        except ValueError:\n                            pass\n                    n.reset_parent(x_new, alt_cost)\n                    edges.append((x_new, n))\n\n            # Check for reaching goal\n            if math.dist(x_new.position, goal) <= self.step_size:\n                if (not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                    goal_node = Node(goal, parent=x_new,\n                                     cost=x_new.cost + math.dist(x_new.position, goal))\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n\n                        # Path smoothing on current best path\n                        extracted_path = try_path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1934.10406,
          "time_improvement": -6473.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 534.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 3.0335252046585084,
                    "num_nodes_avg": 3029.1,
                    "path_length_avg": 144.23898214109826,
                    "smoothness_avg": 0.023788040309866476,
                    "success_improvement": 0.0,
                    "time_improvement": -10916.269515557033,
                    "length_improvement": 20.94032827552893,
                    "smoothness_improvement": 272.3344874057351,
                    "objective_score": -3269.3311165749756
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.9975845336914064,
                    "num_nodes_avg": 4005.6,
                    "path_length_avg": 216.90012311800783,
                    "smoothness_avg": 0.0339724204515744,
                    "success_improvement": 0.0,
                    "time_improvement": -1550.4691901139204,
                    "length_improvement": 27.592495779324437,
                    "smoothness_improvement": 774.1348475644022,
                    "objective_score": -455.7515836404892
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 3.871378517150879,
                    "num_nodes_avg": 4588.2,
                    "path_length_avg": 109.63720099407465,
                    "smoothness_avg": 0.05156373944097783,
                    "success_improvement": 0.0,
                    "time_improvement": -6951.48579518313,
                    "length_improvement": 27.184191462223122,
                    "smoothness_improvement": 555.886959649901,
                    "objective_score": -2077.229465464245
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm combines the advantages of RRT* with a heuristic-guided informed sampling to accelerate convergence towards an optimal path. It first grows a rapidly-exploring tree with rewiring (like RRT*) but focuses samples within an ellipsoidal informed region once a feasible path is found, thereby efficiently refining the solution. Additionally, it incorporates a path smoothing subroutine in post-processing to improve path smoothness and quality.",
          "planning_mechanism": "The planner incrementally builds a tree from start towards goal using goal-biased sampling. When a valid path is first found, all subsequent samples are drawn from an ellipsoidal region defined by the current best path cost to efficiently refine and shorten the path. The tree rewires neighbors to optimize cost during expansion. After planning terminates, the extracted path is smoothed by shortcutting collision-free edges, reducing unnecessary waypoints and improving smoothness. Throughout, collision checks ensure robustness and validity.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate   # Probability to sample the goal directly\n        self.neighbor_radius = neighbor_radius     # Radius for neighbor searching during rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        dimension = len(bounds)\n\n        def sample_informed_ellipsoid():\n            # Sampling inside an ellipsoid to bias sampling around best solution found\n            # Ellipsoid centered between start and goal with axes based on best_cost\n            c_best = best_cost\n            if c_best == float('inf'):\n                # No solution yet, sample uniformly\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n            c_min = math.dist(start_position, goal_position)\n            if c_min == 0:\n                return goal_position  # start==goal edge case\n\n            # Ellipsoid parameters\n            center = tuple((s + g)/2 for s, g in zip(start_position, goal_position))\n            # Coordinate rotation matrix (for 2D or 3D) to align with start-goal axis\n            def unit_vector(v):\n                mag = math.sqrt(sum(x*x for x in v))\n                return tuple(x/mag for x in v) if mag > 1e-12 else tuple(1.0 if i==0 else 0.0 for i in range(len(v)))\n\n            e1 = unit_vector(tuple(g - s for s, g in zip(start_position, goal_position)))\n            # Attempts for an orthonormal basis via Gram-Schmidt\n            import numpy as np\n            if dimension == 2:\n                # Orthogonal vector to e1\n                e2 = (-e1[1], e1[0])\n                rotation = np.array([e1, e2]).T\n            elif dimension == 3:\n                # Use numpy to form orthonormal matrix using e1 and two orthogonal vectors\n                e1_arr = np.array(e1)\n                # Pick arbitrary vector not colinear with e1\n                arbitrary = np.array([1,0,0]) if abs(e1_arr[0]) < 0.9 else np.array([0,1,0])\n                e2_arr = np.cross(e1_arr, arbitrary)\n                e2_arr /= (np.linalg.norm(e2_arr) + 1e-15)\n                e3_arr = np.cross(e1_arr, e2_arr)\n                rotation = np.array([e1_arr, e2_arr, e3_arr]).T\n            else:\n                # Fallback to uniform sampling\n                return tuple(random.uniform(0,bounds[d]) for d in range(dimension))\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = r3 = 0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                r3 = r2 if dimension == 3 else 0\n\n            while True:\n                # Sample a point within unit n-ball\n                if dimension == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    rho = math.sqrt(random.uniform(0,1))\n                    sample_ball = np.array([rho * math.cos(theta), rho * math.sin(theta)])\n                    sample_point = rotation @ (np.array([r1, r2]) * sample_ball) + np.array(center)\n                    sample_point = tuple(sample_point.tolist())\n                elif dimension == 3:\n                    # Uniform sampling in 3D unit ball\n                    # method: normal distribution and normalize + scaling with radius \n                    while True:\n                        point = np.random.normal(0,1,3)\n                        norm = np.linalg.norm(point)\n                        if norm > 1e-12:\n                            point = point / norm * (random.uniform(0,1) ** (1/3))\n                            break\n                    radii = np.array([r1, r2, r3])\n                    sample_point = rotation @ (radii * point) + np.array(center)\n                    sample_point = tuple(sample_point.tolist())\n                else:\n                    # Fallback uniform sampling\n                    sample_point = tuple(random.uniform(0,bounds[d]) for d in range(dimension))\n\n                # Check bounds\n                if all(0 <= sample_point[d] <= bounds[d] for d in range(dimension)):\n                    return sample_point\n\n        def nearest_node(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        for iter_num in range(self.max_iter):\n            # Informed sampling after first solution found, else uniform + goal bias\n            if best_goal_node:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_informed_ellipsoid()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n            # Nearest node in tree\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            # Validate new node position and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and find neighbors within radius for rewiring\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent among neighbors (including nearest)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_pos)\n                if cost_through_near < min_cost:\n                    # Check edge validity\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Check if new_node can connect to goal\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best if cost is better\n                    if goal_cost < best_cost:\n                        best_cost = goal_cost\n                        best_goal_node = goal_node\n                    success_state = True\n\n            # Optional: Early break if cost is already near optimal (close to straight distance)\n            if best_goal_node and best_cost <= math.dist(start_position, goal_position) * 1.01:\n                break\n\n        # Extract path from best goal node\n        if success_state and best_goal_node:\n            path = best_goal_node.path_from_root()\n\n            # Post-processing: Path smoothing by shortcutting\n            def is_collision_free_path(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = [path[0]]\n            idx = 0\n            while idx < len(path) -1:\n                next_idx = len(path)-1\n                # Find farthest reachable node without collision\n                for j in range(len(path)-1, idx, -1):\n                    if is_collision_free_path(path[idx], path[j]):\n                        next_idx = j\n                        break\n                smoothed_path.append(path[next_idx])\n                idx = next_idx\n            extracted_path = smoothed_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2161.28226,
          "time_improvement": -7237.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 948.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 3.4180971145629884,
                    "num_nodes_avg": 3554.4,
                    "path_length_avg": 144.03822751215034,
                    "smoothness_avg": 0.03570533474063342,
                    "success_improvement": 0.0,
                    "time_improvement": -12312.84528856011,
                    "length_improvement": 21.050365068815953,
                    "smoothness_improvement": 458.866024066299,
                    "objective_score": -3687.349183433938
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.4278370141983032,
                    "num_nodes_avg": 4461.4,
                    "path_length_avg": 216.157053852148,
                    "smoothness_avg": 0.06371003255057468,
                    "success_improvement": 0.0,
                    "time_improvement": -1787.3660832841824,
                    "length_improvement": 27.840553688331372,
                    "smoothness_improvement": 1539.3050260079065,
                    "objective_score": -522.9451891175489
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 4.233368182182312,
                    "num_nodes_avg": 5039.5,
                    "path_length_avg": 109.38945384294735,
                    "smoothness_avg": 0.0743143572488876,
                    "success_improvement": 0.0,
                    "time_improvement": -7610.828447849084,
                    "length_improvement": 27.348733323550285,
                    "smoothness_improvement": 845.2731388905871,
                    "objective_score": -2273.5524219955623
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal path planning algorithm that enhances RRT* by focusing exploration within an ellipsoidal subset of the search space after finding an initial solution. This ellipsoid is defined by the start and goal states as focal points and the current best path cost as its transverse diameter, significantly improving convergence speed and path quality.",
          "planning_mechanism": "The planner starts like RRT*, building a tree through uniform sampling. After discovering a valid path, it switches to informed sampling within a prolate hyperspheroid defined by the current best cost. Samples are drawn by transforming points from the unit n-ball to the ellipsoid, ensuring all new samples can potentially improve the path. Tree rewiring is done locally to maintain asymptotic optimality.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        solution_nodes = []\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        edges.remove((n.parent, n))\n                        n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                solution_nodes.append(goal_node)\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 2754.5872411232885,
          "time_improvement": -9205.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 350.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.399874663352966,
                    "num_nodes_avg": 3092.9,
                    "path_length_avg": 144.17782833834022,
                    "smoothness_avg": 0.025832904194730322,
                    "success_improvement": 0.0,
                    "time_improvement": -15878.177814950262,
                    "length_improvement": 20.97384764386463,
                    "smoothness_improvement": 304.3410476968528,
                    "objective_score": -4757.736869717822
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.282676768302918,
                    "num_nodes_avg": 4230.3,
                    "path_length_avg": 216.04260686110948,
                    "smoothness_avg": 0.019191384723471337,
                    "success_improvement": 0.0,
                    "time_improvement": -2258.040608314766,
                    "length_improvement": 27.878759388114016,
                    "smoothness_improvement": 393.80815193060414,
                    "objective_score": -669.867389857154
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 5.258355379104614,
                    "num_nodes_avg": 4590.3,
                    "path_length_avg": 109.81726433629747,
                    "smoothness_avg": 0.03559960377842232,
                    "success_improvement": 0.0,
                    "time_improvement": -9477.781686165177,
                    "length_improvement": 27.06460196401368,
                    "smoothness_improvement": 352.82433237211626,
                    "objective_score": -2836.1574637948897
               }
          ],
          "success_rate": 1.0
     }
]