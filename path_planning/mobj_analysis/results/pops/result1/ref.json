[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.306611905351744,
          "time_improvement": 77.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011097049713134766,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 59.68499408411129,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 19.500803488485644
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020037126541137696,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 89.09108090353095,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 30.365615000780053
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01040804386138916,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1084088125706,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 26.05341722678953
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.848431198744773,
          "time_improvement": 70.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008440661430358886,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 69.33551490751985,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 20.542290497332665
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01770792007446289,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 90.35918313624187,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.48882286154158
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02729644775390625,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 50.45434678183651,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 14.514180237360074
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* variant with rewiring to improve path quality and convergence speed. It grows two trees from the start and goal, extends them towards random samples, attempts to connect the trees, and performs rewiring around new nodes to shorten paths and smooth the solution. It includes collision checking for nodes and edges to ensure safety, and stops when a connection is found or maximum iterations are reached.",
          "planning_mechanism": "The planner alternates growing the start and goal trees by sampling free configurations, extending the nearest node towards sampled points up to a step size, checking collisions, and connecting the two trees when possible. After inserting new nodes, it performs local rewiring in their neighborhood to improve the path cost and smoothness. The final path is reconstructed by concatenating the paths from the start tree and goal tree once they are connected.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # Collision flag etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    NEIGHBOR_RADIUS_FACTOR = 20.0  # Multiplier for rewiring radius relative to step_size\n\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        \n        # Check start and goal validities\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        for iteration in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            # Alternate trees each iteration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n\n            connected_node = self._connect(tree_b, new_node.position, obstacles, is_3d, nodes, edges)\n            if connected_node:\n                success_state = True\n                # Extract path from start_root to new_node\n                if iteration % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n                else:\n                    path_from_start = connected_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1]\n\n                # Optional: smooth path here if desired (not implemented)\n                break\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_dist=None) -> Tuple[float, ...]:\n        dist = self._distance(from_pos, to_pos)\n        step = max_dist if max_dist is not None else self.step_size\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extend(self, tree: List[Node], point: Tuple[float, ...], obstacles, is_3d, nodes, edges) -> Node or None:\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point, self.step_size)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n\n        self._rewire(tree, new_node, obstacles, is_3d, nodes, edges)\n\n        return new_node\n\n    def _connect(self, tree: List[Node], target: Tuple[float, ...], obstacles, is_3d, nodes, edges) -> Node or None:\n        \"\"\"\n        Attempts to connect tree nodes toward the target position by iterative steering.\n        Returns last node inserted if connection within step_size to target is successful\n        \"\"\"\n        nearest_node = self._nearest(tree, target)\n        while True:\n            new_pos = self._steer(nearest_node.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            if self._distance(new_pos, target) <= self.step_size:\n                return new_node\n\n            nearest_node = new_node\n\n    def _rewire(self, tree: List[Node], new_node: Node, obstacles, is_3d, nodes, edges):\n        \"\"\"\n        Attempt to rewire nodes in neighborhood around new_node if it can reduce their path cost.\n        Neighborhood radius scales with step_size.\n        \"\"\"\n        radius = self.NEIGHBOR_RADIUS_FACTOR * self.step_size\n        neighbors = [node for node in tree if node != new_node and self._distance(node.position, new_node.position) <= radius]\n\n        for neighbor in neighbors:\n            potential_cost = new_node.cost + self._distance(new_node.position, neighbor.position)\n            if potential_cost < neighbor.cost:\n                # Check collision between new_node and neighbor\n                if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire: change neighbor's parent to new_node\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        if neighbor in old_parent.children:\n                            old_parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    new_node.children.append(neighbor)\n                    neighbor.cost = potential_cost\n                    # Recursively update costs of descendants\n                    self._update_descendants_costs(neighbor)\n\n    def _update_descendants_costs(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._distance(node.position, child.position)\n            if child.cost < old_cost:\n                self._update_descendants_costs(child)\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -3.29132,
          "time_improvement": 56.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 226.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018826937675476073,
                    "num_nodes_avg": 94.1,
                    "path_length_avg": 177.0456869858047,
                    "smoothness_avg": 0.013921323384339514,
                    "success_improvement": 0.0,
                    "time_improvement": 31.602712127485244,
                    "length_improvement": 2.958453494639981,
                    "smoothness_improvement": 117.89894160250063,
                    "objective_score": 10.661999045186073
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.03453934192657471,
                    "num_nodes_avg": 219.0,
                    "path_length_avg": 239.94982137989717,
                    "smoothness_avg": 0.017256393246681354,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 81.19556284935798,
                    "length_improvement": 19.89784305072722,
                    "smoothness_improvement": 344.0194275147717,
                    "objective_score": -19.941665397473294
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025054192543029784,
                    "num_nodes_avg": 193.5,
                    "path_length_avg": 137.68408237690392,
                    "smoothness_avg": 0.024921386851609478,
                    "success_improvement": 0.0,
                    "time_improvement": 54.524253610237196,
                    "length_improvement": 8.55678829672085,
                    "smoothness_improvement": 216.9982012470426,
                    "objective_score": 19.153624748650543
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified and generalized variant of RRT*, designed to incrementally build an optimized path from start to goal by rewiring nodes for lower-cost connections. It balances planning efficiency and path quality by pruning unnecessary complexity while ensuring collision-free connections and smoother paths.",
          "planning_mechanism": "The planner samples random points with goal biasing, extends the nearest node towards these points, selects the best parent from nearby nodes minimizing cumulative cost, rewires neighbors for better paths, and terminates early when a safe connection to the goal is found. Collision checks ensure robustness and valid path construction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            # Sample point with goal biasing\n            sample = goal_position if random.random() < self.goal_sample_rate else \\\n                tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            unit_dir = tuple(d / dist for d in direction)\n            new_pos = tuple(nearest_node.position[d] + unit_dir[d] * min(self.step_size, dist) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within radius\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + math.dist(near.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if path improves\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_via_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    edges.remove((near.parent, near))\n                    near.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, near))\n\n            # Early goal check and connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.14339,
          "time_improvement": -54.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 218.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.045577192306518556,
                    "num_nodes_avg": 290.1,
                    "path_length_avg": 164.59504545029057,
                    "smoothness_avg": 0.016911817058357547,
                    "success_improvement": 0.0,
                    "time_improvement": -65.57957519934726,
                    "length_improvement": 9.782847413295771,
                    "smoothness_improvement": 164.70666156183543,
                    "objective_score": -16.893769769335844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.26395955085754397,
                    "num_nodes_avg": 1168.7,
                    "path_length_avg": 224.79959830235856,
                    "smoothness_avg": 0.01350253593251018,
                    "success_improvement": 0.0,
                    "time_improvement": -43.70889853559595,
                    "length_improvement": 24.955423589002063,
                    "smoothness_improvement": 247.42997502701215,
                    "objective_score": -6.884434967743309
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08391327857971191,
                    "num_nodes_avg": 610.6,
                    "path_length_avg": 114.16670644476169,
                    "smoothness_avg": 0.02682451808496583,
                    "success_improvement": 0.0,
                    "time_improvement": -52.3105950778738,
                    "length_improvement": 24.17590961374845,
                    "smoothness_improvement": 241.2058900608001,
                    "objective_score": -9.651967150308447
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 14.473798407158705,
          "time_improvement": -48.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0351090669631958,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -27.549418891693335,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -8.306422146109691
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2585805177688599,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -40.78036301623335,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -12.592373856276746
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09662477970123291,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -75.38318064384907,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -22.52259921908968
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 35.877106040810695,
          "time_improvement": 81.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008462762832641602,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 69.25522165960166,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 25.091814036256952
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02008676528930664,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 89.0640558165399,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.52519401276352
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.009105682373046875,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 83.47231899047512,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.1979381459255
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.79827767667016,
          "time_improvement": -139.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05019955635070801,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -82.3723839732252,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -21.39937295148196
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.453693151473999,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -147.0065692249161,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -38.17807174541201
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1577073097229004,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -186.25379199321446,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -50.81738833311652
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.798589955710725,
          "time_improvement": 92.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0024698495864868162,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 91.02716458296882,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 28.936089562002053
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008279967308044433,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.49209347460973,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.34385150237837
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.005023741722106933,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 90.88143016024823,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -22.988007926755852
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 746.2243427227614,
          "time_improvement": -2503.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.1400249242782592,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "smoothness_avg": 0.0150601233961907,
                    "success_improvement": 0.0,
                    "time_improvement": -4041.6514077736338,
                    "length_improvement": 15.280155580980631,
                    "smoothness_improvement": 135.72363473177828,
                    "objective_score": -1208.760773042235
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.784014844894409,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "smoothness_avg": 0.011376062771551485,
                    "success_improvement": 0.0,
                    "time_improvement": -871.2806659126815,
                    "length_improvement": 23.354217616048047,
                    "smoothness_improvement": 192.71428895883628,
                    "objective_score": -255.74978480580063
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.486170268058777,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "smoothness_avg": 0.01876598180493872,
                    "success_improvement": 0.0,
                    "time_improvement": -2597.5406246348653,
                    "length_improvement": 22.0310377661009,
                    "smoothness_improvement": 138.7019033981297,
                    "objective_score": -774.1624703202488
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed sampling and adaptive step sizing from the second algorithm, together with incremental space-filling exploration and goal biasing from the first. It integrates node rewiring for path cost optimization and prune-based node rejection to focus search efficiently. The approach adaptively adjusts step size near obstacles and smooths the extracted path using shortcutting to improve path quality and success rate in cluttered environments.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal respectively, sampling mostly in an informed ellipsoidal domain based on the current best path cost with occasional full-space exploration and goal biasing. Adaptive step sizing is used near obstacles to carefully extend nodes. Upon adding new nodes, local rewiring optimizes path cost. Trees attempt to connect at each iteration, and when successful, a shortcut-based path smoothing refines the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate  # Probability to sample whole space instead of informed ellipsoid\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path_positions = []\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                # Uniform random sample across whole bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed sampling within prolate hyperspheroid (ellipsoid)\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n            e1 = a1 / a1_norm\n            # Rotation matrix calculation from standard basis to e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                # Sample unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Near obstacle \u2013 reduce step size up to minimum of 1.0, or 30% base step\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(new_node, tree):\n            # Find nearby nodes to possibly rewire through new_node\n            for near_node in tree:\n                if near_node is new_node or near_node.parent is None:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    if new_cost + 1e-9 < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Remove old parent link and edge\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def connect_nodes(node_from, tree_to):\n            # Try to connect node_from to any node in tree_to\n            closest = min(tree_to, key=lambda n: math.dist(n.position, node_from.position))\n            dist_connect = math.dist(node_from.position, closest.position)\n            if dist_connect <= self.base_step:\n                if (not self._is_edge_in_obstacle(node_from.position, closest.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(closest.position, obstacles, is_3d)):\n                    return closest\n            else:\n                # Try stepping toward closest node, check edge free\n                step = adaptive_step(node_from.position, closest.position)\n                new_pos = steer(node_from.position, closest.position, step)\n                if (not self._is_in_obstacle(new_pos, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(node_from.position, new_pos, obstacles, is_3d)):\n                    return None\n            return None\n\n        def extract_path(meet_node_start, meet_node_goal):\n            # Extract path from start tree root to meet_node_start\n            path_start = meet_node_start.path_from_root()\n            # Extract path from goal tree root to meet_node_goal\n            path_goal = meet_node_goal.path_from_root()\n            # Connect (goal path reversed excluding duplicated meeting node)\n            full_path = path_start + path_goal[-2::-1]\n            return full_path\n\n        def shortcut_path(path, max_trials=100):\n            # Simple shortcut smoothing: try to connect random pairs if collision-free, remove intermediate points\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate growing trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sample with goal biasing and informed sampling\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample()\n\n            # Find nearest node to sample in tree_a\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size based on obstacles near path\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cost cannot lead to improvement\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring nearby nodes\n            rewire(new_node, tree_a)\n\n            # Try to connect to tree_b\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_other.position)\n\n            if dist_between <= self.base_step and not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                # Form connecting node to link trees\n                total_cost = new_node.cost + dist_between + nearest_other.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    success_state = True\n                    # Create connection node in other tree if needed\n                    connect_node = Node(nearest_other.position, new_node, new_node.cost + dist_between)\n                    new_node.add_child(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    # Extract full path\n                    if tree_a is tree_start:\n                        best_path_positions = extract_path(new_node, nearest_other)\n                    else:\n                        best_path_positions = extract_path(nearest_other, new_node)\n\n                    # Smooth the path by shortcutting\n                    best_path_positions = shortcut_path(best_path_positions, max_trials=150)\n\n                    # Early stop on finding a good path with cost near minimum\n                    if c_best <= c_min * 1.05:\n                        break\n\n        # If success, finalize extraction, else empty path\n        extracted_path = best_path_positions if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 760.097,
          "time_improvement": -2402.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 1180.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.0986209869384767,
                    "num_nodes_avg": 1598.5,
                    "path_length_avg": 148.1153176016661,
                    "smoothness_avg": 0.041239978281850484,
                    "success_improvement": 0.0,
                    "time_improvement": -3891.2330513686234,
                    "length_improvement": 18.81564738512559,
                    "smoothness_improvement": 545.4952141571613,
                    "objective_score": -1160.8793098627762
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 1.803820300102234,
                    "num_nodes_avg": 2812.2,
                    "path_length_avg": 221.18189424481244,
                    "smoothness_avg": 0.07640054707083399,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -882.0634549561763,
                    "length_improvement": 26.16311733324862,
                    "smoothness_improvement": 1865.8411052223212,
                    "objective_score": -400.0572074940916
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.395304012298584,
                    "num_nodes_avg": 2545.3,
                    "path_length_avg": 114.4902045698116,
                    "smoothness_avg": 0.0964821067327423,
                    "success_improvement": 0.0,
                    "time_improvement": -2432.6097135611635,
                    "length_improvement": 23.96105756241564,
                    "smoothness_improvement": 1127.2452760721567,
                    "objective_score": -719.354476175505
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT*-like tree growth with informed ellipsoidal sampling and adaptive step sizing near obstacles, enhanced node pruning and rewiring for path cost optimization, and integrated path smoothing through shortcutting. It applies goal biasing and intermittent full-space exploration to improve robustness. The planner dynamically prunes nodes unlikely to improve the current best path, ensures collision-free node and edge additions, and alternates tree expansion to connect start and goal efficiently, producing high-quality, smooth paths with reduced search time and improved success rates in cluttered 2D/3D environments.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal using informed and biased sampling with occasional global exploration. Adaptive step sizes near obstacles prevent collision while extending nodes. Each new node triggers local rewiring within a radius to optimize path costs and pruning of nodes and branches that cannot yield better solutions. Connection attempts between trees update the best path, which is then smoothed using shortcutting. Early termination occurs if near-optimal solutions are found, increasing efficiency and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, rewire_radius: float=15.0,\n                 goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        # Initialize trees at start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        success_state = False\n        best_path = []\n\n        # Precompute identity for rotation matrix\n        id_mat = np.eye(dim)\n\n        def informed_sample():\n            if c_best == float(\"inf\") or random.random() < self.full_sample_rate:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(center)\n            e1 = a1 / a1_norm\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            det_term = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det_term]) @ Vt\n\n            r1 = c_best / 2\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2 if val > 0 else 0.0\n\n            L = np.diag([r1] + [r2] * (dim -1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def goal_biased_sample(current_tree):\n            # With probability goal_sample_rate, sample goal to bias growth\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if current_tree is tree_start else start_pos\n            return informed_sample()\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            steps = max(2, int(dist))\n            for i in range(1, steps +1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def rewire(new_node, tree):\n            for near_node in tree:\n                if near_node is new_node:\n                    continue\n                dist = math.dist(new_node.position, near_node.position)\n                if dist <= self.rewire_radius:\n                    new_cost = new_node.cost + dist\n                    # Small epsilon to avoid floating point issues\n                    if new_cost + 1e-9 < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n        def prune_tree(tree):\n            # Remove invalid or unpromising nodes (with cost > c_best)\n            to_remove = []\n            for node in tree:\n                est_total = node.cost + math.dist(node.position, goal_pos)\n                if est_total >= c_best:\n                    # Mark node and children invalid for pruning\n                    self._invalidate_subtree(node, edges)\n                    to_remove.append(node)\n            for node in to_remove:\n                if node in tree:\n                    tree.remove(node)\n\n        def connect_trees(new_node, other_tree):\n            # Find nearest node in other tree to try connect\n            nearest_other = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between <= self.base_step:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d)\n                    and not self._is_in_obstacle(nearest_other.position, obstacles, is_3d)):\n                    total_cost = new_node.cost + dist_between + nearest_other.cost\n                    return nearest_other, total_cost\n            return None, float(\"inf\")\n\n        def extract_full_path(meet_start_node, meet_goal_node):\n            path_start = meet_start_node.path_from_root()\n            path_goal = meet_goal_node.path_from_root()\n            full = path_start + path_goal[-2::-1]\n            return full\n\n        def shortcut_path(path, trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num %2 == 0 else (tree_goal, tree_start)\n\n            sample = goal_biased_sample(tree_a)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Check new node and edge collision and bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total = new_cost + math.dist(new_pos, goal_pos)\n\n            if est_total >= c_best:\n                continue  # Prune branch unlikely to improve solution\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire surrounding nodes to optimize cost\n            rewire(new_node, tree_a)\n\n            # Prune nodes that cannot improve solution\n            prune_tree(tree_a)\n            prune_tree(tree_b)\n\n            # Try to connect trees\n            nearest_other, total_cost = connect_trees(new_node, tree_b)\n            if nearest_other and total_cost < c_best:\n                c_best = total_cost\n                success_state = True\n\n                # Link trees bidirectionally with connection node (ghost)\n                connection_node = Node(nearest_other.position, new_node,\n                                       new_node.cost + math.dist(new_node.position, nearest_other.position))\n                new_node.add_child(connection_node)\n                nodes.append(connection_node)\n                edges.append((new_node, connection_node))\n\n                # Extract and smooth path\n                if tree_a is tree_start:\n                    best_path = extract_full_path(new_node, nearest_other)\n                else:\n                    best_path = extract_full_path(nearest_other, new_node)\n\n                best_path = shortcut_path(best_path, trials=150)\n\n                # Early exit if near optimal\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _invalidate_subtree(self, node, edges):\n        # Mark node and descendants invalid and remove edges\n        node.valid = False\n        for child in list(node.children):\n            self._invalidate_subtree(child, edges)\n            if (node, child) in edges:\n                edges.remove((node, child))\n            node.remove_child(child)\n        # Also remove node from parent's children if possible\n        if node.parent:\n            node.parent.remove_child(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 829.36714,
          "time_improvement": -2688.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 1180.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.8,
                    "time_avg": 1.1848379135131837,
                    "num_nodes_avg": 1658.7,
                    "path_length_avg": 148.72207728684697,
                    "smoothness_avg": 0.03924745158642927,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -4204.45467285915,
                    "length_improvement": 18.483072786955475,
                    "smoothness_improvement": 514.3078445328466,
                    "objective_score": -1355.0682480776898
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.12278950214386,
                    "num_nodes_avg": 2777.2,
                    "path_length_avg": 222.60788497651976,
                    "smoothness_avg": 0.07957845577560209,
                    "success_improvement": 0.0,
                    "time_improvement": -1055.72154970312,
                    "length_improvement": 25.687080582137302,
                    "smoothness_improvement": 1947.610985151124,
                    "objective_score": -301.8409938687529
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.6003721475601196,
                    "num_nodes_avg": 2519.0,
                    "path_length_avg": 113.90158083598541,
                    "smoothness_avg": 0.09254465830039778,
                    "success_improvement": 0.0,
                    "time_improvement": -2804.827915994097,
                    "length_improvement": 24.35199341917283,
                    "smoothness_improvement": 1077.1612226449458,
                    "objective_score": -831.1921700011699
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* with informed sampling to accelerate convergence and improve path quality. It adapts the step size near obstacles, performs local rewiring to optimize paths, prunes non-promising nodes based on cost estimates, and applies shortcut smoothing on the final path to enhance smoothness and reduce length. The approach balances exploration and exploitation using goal biasing and occasional full-space sampling to improve robustness and success rate.",
          "planning_mechanism": "The planner grows two search trees simultaneously from start and goal, sampling mainly in an ellipsoidal informed subset defined by the best-found path cost to focus search. Nodes are extended with adaptive steps to avoid collisions near obstacles. Upon adding a node, local rewiring tries to optimize path costs of nearby nodes. The two trees attempt connection each iteration, and successful connection yields a candidate path. This path is then shortcut-smoothed for improved quality before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]: Position in space\n        self.parent = parent             # Parent node reference or None\n        self.cost = cost                 # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0, goal_sample_rate: float=0.1, full_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.full_sample_rate = full_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def sample():\n            # Informed ellipsoidal sampling if a solution exists, else uniform\n            if c_best == float('inf') or random.random() < self.full_sample_rate:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n            e1 = a1 / norm_a1\n            # Rotation matrix from first standard basis vector to e1\n            id_mat = np.eye(dim)\n            M = np.outer(e1, id_mat[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val)/2 if val > 0 else 0\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                point = C @ L @ (x_ball * radius) + center\n                if in_bounds(point):\n                    return tuple(point)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            steps = max(int(dist), 2)\n            for i in range(1, steps+1):\n                interm = tuple(from_p[d] + (to_p[d]-from_p[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interm, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, point):\n            r = self.rewire_radius\n            return [n for n in tree if math.dist(n.position, point) <= r]\n\n        def rewire(new_node, tree):\n            neighbors = near_nodes(tree, new_node.position)\n            for near in neighbors:\n                if near is new_node or near.parent is None:\n                    continue\n                d = math.dist(new_node.position, near.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(n_from, tree_to):\n            nearest_to = nearest(tree_to, n_from.position)\n            dist_c = math.dist(n_from.position, nearest_to.position)\n            if dist_c <= self.step_size:\n                if (not self._is_edge_in_obstacle(n_from.position, nearest_to.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(nearest_to.position, obstacles, is_3d)):\n                    return nearest_to\n            else:\n                step = adaptive_step(n_from.position, nearest_to.position)\n                new_pos = steer(n_from.position, nearest_to.position, step)\n                if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(n_from.position, new_pos, obstacles, is_3d)):\n                    return None\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        def shortcut(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal if tree_a is tree_start else start\n            else:\n                sample_point = sample()\n\n            nearest_node = nearest(tree_a, sample_point)\n            step_sz = adaptive_step(nearest_node.position, sample_point)\n            new_pos = steer(nearest_node.position, sample_point, step_sz)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, tree_a)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success = True\n                        connect_node = Node(nearest_other.position, new_node, new_node.cost + dist_connect)\n                        new_node.add_child(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n                        best_path = extract_path(new_node, nearest_other) if tree_a is tree_start else extract_path(nearest_other, new_node)\n                        best_path = shortcut(best_path)\n                        if c_best <= c_min * 1.05:\n                            break\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 840.38513,
          "time_improvement": -2671.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 1288.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.3037487030029298,
                    "num_nodes_avg": 1630.6,
                    "path_length_avg": 149.98501157576,
                    "smoothness_avg": 0.044665988683405926,
                    "success_improvement": 0.0,
                    "time_improvement": -4636.4514022301955,
                    "length_improvement": 17.79083849072777,
                    "smoothness_improvement": 599.1197166421674,
                    "objective_score": -1384.3816543877022
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 1.806183671951294,
                    "num_nodes_avg": 2785.0,
                    "path_length_avg": 221.76517271062556,
                    "smoothness_avg": 0.07814939769268921,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -883.350158029261,
                    "length_improvement": 25.968402192620438,
                    "smoothness_improvement": 1910.8402913688433,
                    "objective_score": -400.25716551341
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.429310917854309,
                    "num_nodes_avg": 2564.9,
                    "path_length_avg": 112.80878058843521,
                    "smoothness_avg": 0.11428536493227788,
                    "success_improvement": 0.0,
                    "time_improvement": -2494.335486997953,
                    "length_improvement": 25.07777931003985,
                    "smoothness_improvement": 1353.701406270423,
                    "objective_score": -736.5165832060258
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced Informed RRT* planner with tuned parameters aiming to improve efficiency, success rate, and path quality by using a refined informed sampling strategy within the ellipsoidal subset, reduced step size for smoother trajectories, adaptive neighbor radius for rewiring, and strict collision checks. It carefully balances exploration and exploitation for faster convergence to optimal paths.",
          "planning_mechanism": "The planner starts by sampling uniformly until an initial feasible path is found, then focuses sampling within a prolate hyperspheroid defined by start, goal, and best solution cost. Candidate nodes are connected with dynamic neighborhood rewiring based on radius scaled with the number of nodes for asymptotic optimality. Each extension filters out invalid or colliding nodes and edges, gradually yielding shorter, smoother paths with improved success rates within bounded space.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_constant = 50.0  # Tuned for rewiring neighborhood radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        unit_vec_norm = np.linalg.norm(unit_vec)\n        if unit_vec_norm < 1e-10:\n            unit_vec_norm = 1.0\n        a1 = unit_vec / unit_vec_norm\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        def calc_neighbor_radius(n_nodes: int) -> float:\n            \u03b3_rrt = self.neighbor_radius_constant\n            radius = \u03b3_rrt * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)\n            return max(radius, self.step_size)  # radius lower bounded by step_size\n\n        for _ in range(self.max_iter):\n            # Sample\n            if best_cost == float(\"inf\"):\n                # Uniform sampling\n                x_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                r1 = best_cost / 2.0\n                r2 = math.sqrt(best_cost ** 2 - c_min ** 2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm > 1e-10:\n                        x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n                        x_rand_np = np.dot(C, np.dot(L, x_ball)) + x_center\n                        if all(0 <= x_rand_np[d] <= bounds[d] for d in range(dim)):\n                            x_rand = tuple(x_rand_np)\n                            break\n                    else:\n                        # rare case norm~0, retry\n                        continue\n            \n            # Nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            # Steer towards x_rand from x_nearest by step_size, capped at x_rand\n            dist = math.dist(x_nearest.position, x_rand)\n            if dist <= self.step_size:\n                x_new_pos = x_rand\n            else:\n                ratio = self.step_size / dist\n                x_new_pos = tuple(x_nearest.position[d] + (x_rand[d] - x_nearest.position[d]) * ratio for d in range(dim))\n\n            # Check feasibility of new node and edge\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node\n            x_new = Node(x_new_pos)\n            # Find near nodes within radius\n            radius = calc_neighbor_radius(len(tree))\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge cost and collision free\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                if n.cost + math.dist(n.position, x_new_pos) < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = n.cost + math.dist(n.position, x_new_pos)\n\n            # Attach new node to best parent\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            nodes.append(x_new)\n            tree.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes if can improve cost via x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            try:\n                                n.parent.children.remove(n)\n                            except ValueError:\n                                pass\n                        # Re-parent to x_new\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n            # Check if goal can be connected:\n            dist_to_goal = math.dist(x_new.position, goal)\n            if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node = Node(goal)\n                goal_node.cost = x_new.cost + dist_to_goal\n                goal_node.parent = x_new\n                x_new.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    # Shrink informed sampling ellipsoid parameters for convergence\n                    x_center = (np.array(start) + np.array(goal)) / 2.0\n                    # keep C and a1 updated (redundant here but safe)\n                    unit_vec = np.array(goal) - np.array(start)\n                    unit_vec_norm = np.linalg.norm(unit_vec)\n                    if unit_vec_norm < 1e-10:\n                        unit_vec_norm = 1.0\n                    a1 = unit_vec / unit_vec_norm\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1097.87432,
          "time_improvement": -3625.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 570.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.608111524581909,
                    "num_nodes_avg": 3138.5,
                    "path_length_avg": 160.50524128461177,
                    "smoothness_avg": 0.11022324878331846,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -5742.185743314526,
                    "length_improvement": 12.024533883598524,
                    "smoothness_improvement": 1625.2331970746543,
                    "objective_score": -1762.124650232265
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.8152109861373902,
                    "num_nodes_avg": 3840.5,
                    "path_length_avg": 249.32373787276893,
                    "smoothness_avg": 0.004259259399231272,
                    "success_improvement": 0.0,
                    "time_improvement": -888.2649465800221,
                    "length_improvement": 16.76855991218058,
                    "smoothness_improvement": 9.593812162763655,
                    "objective_score": -263.07780293075666
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.3929309844970703,
                    "num_nodes_avg": 4476.1,
                    "path_length_avg": 118.76701761604329,
                    "smoothness_avg": 0.013753052111040085,
                    "success_improvement": 0.0,
                    "time_improvement": -4243.397712470627,
                    "length_improvement": 21.12060197706096,
                    "smoothness_improvement": 74.93780770771956,
                    "objective_score": -1268.4205043072373
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a finely tuned Informed RRT* planner with adaptive sampling within a shrinking ellipsoidal subset, enhanced rewiring strategy that dynamically adjusts neighborhood radius for optimal connectivity, and reduced step size for smoother, high-quality trajectories. It incorporates strict collision checking and efficient node reparenting to improve path quality, convergence speed, and success rates in complex environments.",
          "planning_mechanism": "The planner begins with uniform sampling until an initial path to the goal is found. Subsequently, it restricts sampling inside a prolate hyperspheroid defined by the start, goal, and the cost of the current best path to focus exploration on promising regions. For each iteration, it selects the nearest node, extends toward the sampled point by a limited step size, and performs feasibility checks. Near nodes are identified based on an adaptive radius for rewiring to improve path cost. Nodes are connected and rewired only if collision-free, with the goal node attached as soon as it is reachable within a step. The informed set updates as better paths are found, shrinking the sampling region and converging toward an optimal path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_constant = 45.0  # Tuned constant for neighborhood radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False # Path navigation success or not\n        extracted_path: List[Tuple[float, ...]] = [] # Final path from start to goal\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n        unit_vec = np.array(goal_position) - np.array(start_position)\n        unit_vec_norm = np.linalg.norm(unit_vec)\n        if unit_vec_norm < 1e-10:\n            unit_vec_norm = 1.0\n        a1 = unit_vec / unit_vec_norm\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        def calc_neighbor_radius(n_nodes: int) -> float:\n            \u03b3_rrt = self.neighbor_radius_constant\n            radius = \u03b3_rrt * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)\n            return max(radius, self.step_size*1.2)  # radius lower bounded slightly above step size\n\n        for _ in range(self.max_iter):\n            # Sampling: Uniform until path found, then informed sampling inside ellipsoid\n            if best_cost == float(\"inf\"):\n                # Uniform sampling in bounds\n                x_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                r1 = best_cost / 2.0\n                r2 = math.sqrt(best_cost**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim -1))\n                # Sample inside unit ball with uniform distribution\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm > 1e-10:\n                        unit_ball_sample = x_ball / norm * (random.random() ** (1.0 / dim))\n                        x_rand_np = np.dot(C, np.dot(L, unit_ball_sample)) + x_center\n                        # Clamp within bounds\n                        if all(0 <= x_rand_np[d] <= bounds[d] for d in range(dim)):\n                            x_rand = tuple(x_rand_np)\n                            break\n\n            # Find nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n\n            # Steer towards x_rand with max step size\n            dist = math.dist(x_nearest.position, x_rand)\n            if dist <= self.step_size:\n                x_new_pos = x_rand\n            else:\n                ratio = self.step_size / dist\n                x_new_pos = tuple(x_nearest.position[d] + (x_rand[d] - x_nearest.position[d]) * ratio for d in range(dim))\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d, resolution=0.25):\n                continue\n\n            # Create new node\n            x_new = Node(x_new_pos)\n            # Compute neighbors for rewiring\n            radius = calc_neighbor_radius(len(tree))\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge cost and collision free\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                edge_dist = math.dist(n.position, x_new_pos)\n                candidate_cost = n.cost + edge_dist\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d, resolution=0.25):\n                        min_cost = candidate_cost\n                        best_parent = n\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            nodes.append(x_new)\n            tree.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes to improve cost through x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-7 < n.cost:  # Add small tolerance for numerical stability\n                    if not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d, resolution=0.25):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n            # Check if goal can be connected with edge from x_new node\n            dist_to_goal = math.dist(x_new.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(x_new.position, goal_position, obstacles, is_3d, resolution=0.25):\n                    goal_node = Node(goal_position)\n                    goal_node.cost = x_new.cost + dist_to_goal\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    tree.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n                        # Update ellipsoid center and matrix for next informed sampling\n                        x_center = (np.array(start_position) + np.array(goal_position)) / 2.0\n                        unit_vec = np.array(goal_position) - np.array(start_position)\n                        unit_vec_norm = np.linalg.norm(unit_vec)\n                        if unit_vec_norm < 1e-10:\n                            unit_vec_norm = 1.0\n                        a1 = unit_vec / unit_vec_norm\n                        M = np.outer(a1, I[:, 0])\n                        U, _, Vt = np.linalg.svd(M)\n                        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1153.5349,
          "time_improvement": -3808.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 554.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.6804368495941162,
                    "num_nodes_avg": 3101.1,
                    "path_length_avg": 164.05503695188074,
                    "smoothness_avg": 0.10874258734192348,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -6004.939896995976,
                    "length_improvement": 10.078834628256445,
                    "smoothness_improvement": 1602.05763020904,
                    "objective_score": -1841.4559140220963
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.7701423168182373,
                    "num_nodes_avg": 3742.7,
                    "path_length_avg": 264.0912188011822,
                    "smoothness_avg": 0.003834546257751223,
                    "success_improvement": 0.0,
                    "time_improvement": -863.7279718606799,
                    "length_improvement": 11.838749719905707,
                    "smoothness_improvement": -1.3343628760288935,
                    "objective_score": -256.7573134286029
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.5645769834518433,
                    "num_nodes_avg": 4500.9,
                    "path_length_avg": 122.01995217860642,
                    "smoothness_avg": 0.012609523288596741,
                    "success_improvement": 0.0,
                    "time_improvement": -4554.951553364866,
                    "length_improvement": 18.96015772870483,
                    "smoothness_improvement": 60.39220549275783,
                    "objective_score": -1362.3914734362554
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "Hybrid Anytime RRT* with Adaptive Sampling and Path Smoothing",
          "planning_mechanism": "This algorithm combines the asymptotic optimality of RRT* with adaptive sampling that focuses exploration on promising regions guided by a heuristic cost-to-go estimate. It incorporates vertex rewiring for improved path quality, plus an anytime framework to iteratively improve the solution while maintaining valid paths. After finding an initial feasible path, adaptive biased sampling narrows the search space near the current best path to accelerate convergence. Finally, a post-processing smoothing step refines the path for smoothness and shorter length without violating constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        self.cost = new_cost\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        def heuristic(pos):\n            # Euclidean distance to goal as heuristic\n            return math.dist(pos, goal_position)\n\n        def sample():\n            # Adaptive sampling: with probability p, sample near current best path corridor to improve convergence\n            p = 0.7 if success_state else 0.0\n            dim = len(bounds)\n            if success_state and best_goal_node is not None:\n                if random.random() < p:\n                    # Sample along bounding box of current best path + small margin\n                    path_positions = [n.position for n in nodes if n.cost + heuristic(n.position) <= best_cost * 1.5]\n                    if not path_positions:\n                        # fallback uniform sampling\n                        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                    mins = [min(p[d] for p in path_positions) for d in range(dim)]\n                    maxs = [max(p[d] for p in path_positions) for d in range(dim)]\n                    margin = [self.step_size*2]*(dim)\n                    sample_point = []\n                    for d in range(dim):\n                        low = max(0, mins[d] - margin[d])\n                        high = min(bounds[d], maxs[d] + margin[d])\n                        sample_point.append(random.uniform(low, high))\n                    return tuple(sample_point)\n            # otherwise uniform random sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def try_add_node(x_nearest, x_new_pos):\n            # Collision checks\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                return None\n\n            # Create new node with cost estimate via x_nearest\n            new_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            x_new = Node(x_new_pos, parent=x_nearest, cost=new_cost)\n            x_nearest.add_child(x_new)\n\n            return x_new\n\n        # Radius for near neighbors depends on number of nodes (adaptive radius for rewiring)\n        def radius(n_nodes):\n            gamma_rrt_star = 50.0  # tuning parameter\n            dim = len(bounds)\n            eta = gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n            return min(eta, self.step_size * 10)\n\n        # Path smoothing by shortcutting\n        def smooth_path(path_positions):\n            if len(path_positions) <= 2:\n                return path_positions\n            smoothed = [path_positions[0]]\n            i = 0\n            while i < len(path_positions) -1:\n                j = len(path_positions) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path_positions[i], path_positions[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smoothed.append(path_positions[j])\n                i = j\n            return smoothed\n\n        for iter_num in range(self.max_iter):\n            x_rand = sample()\n            x_nearest = nearest(tree, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n            x_new = try_add_node(x_nearest, x_new_pos)\n            if x_new is None:\n                continue\n\n            # Near neighbors for rewiring\n            rewiring_radius = radius(len(tree))\n            near_nodes = near(tree, x_new.position, rewiring_radius)\n\n            # Choose best parent among near nodes\n            min_cost = x_new.cost\n            best_parent = x_new.parent\n            for n in near_nodes:\n                if n == x_new.parent:\n                    continue\n                potential_cost = n.cost + math.dist(n.position, x_new.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = n\n\n            if best_parent != x_new.parent:\n                # Re-parent x_new\n                if x_new.parent:\n                    x_new.parent.children.remove(x_new)\n                x_new.parent = best_parent\n                best_parent.children.append(x_new)\n                x_new.cost = min_cost\n\n            # Rewire near nodes through x_new if it reduces cost\n            for n in near_nodes:\n                if n == x_new:\n                    continue\n                new_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        # Remove old edge\n                        edges = [e for e in edges if e != (n.parent, n)]\n                        n.parent.children.remove(n)\n                    # Add new edge\n                    n.parent = x_new\n                    n.cost = new_cost\n                    x_new.children.append(n)\n                    edges.append((x_new, n))\n                    # Propagate cost update downstream recursively\n                    self._update_children_costs(n, obstacles, is_3d)\n\n            nodes.append(x_new)\n            edges.append((x_new.parent, x_new))\n            tree.append(x_new)\n\n            # Check if can connect to goal\n            if math.dist(x_new.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(x_new.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + math.dist(x_new.position, goal_position)\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    tree.append(goal_node)\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n\n        # Post processing: smooth path if available\n        if success_state and extracted_path:\n            extracted_path = smooth_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_children_costs(self, node, obstacles, is_3d):\n        import math\n        # Recursively update cost of descendants during rewiring\n        for child in node.children:\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child, obstacles, is_3d)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2190.26536,
          "time_improvement": -7337.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1328.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 3.135515332221985,
                    "num_nodes_avg": 3206.9,
                    "path_length_avg": 157.1358679062836,
                    "smoothness_avg": 0.04959477800117372,
                    "success_improvement": 0.0,
                    "time_improvement": -11291.164537928382,
                    "length_improvement": 13.871340823398024,
                    "smoothness_improvement": 676.265972502545,
                    "objective_score": -3381.193763351322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 3.8707536935806273,
                    "num_nodes_avg": 4185.9,
                    "path_length_avg": 222.97147117541553,
                    "smoothness_avg": 0.08666540232631718,
                    "success_improvement": 0.0,
                    "time_improvement": -2007.37496711104,
                    "length_improvement": 25.565705043697417,
                    "smoothness_improvement": 2129.9632244222976,
                    "objective_score": -586.449533002461
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 4.855652832984925,
                    "num_nodes_avg": 4674.5,
                    "path_length_avg": 112.93986490021885,
                    "smoothness_avg": 0.10048535844640197,
                    "success_improvement": 0.0,
                    "time_improvement": -8713.472492091449,
                    "length_improvement": 24.99071935171731,
                    "smoothness_improvement": 1178.1663423806033,
                    "objective_score": -2603.152772045188
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal path planning algorithm that enhances RRT* by focusing exploration within an ellipsoidal subset of the search space after finding an initial solution. This ellipsoid is defined by the start and goal states as focal points and the current best path cost as its transverse diameter, significantly improving convergence speed and path quality.",
          "planning_mechanism": "The planner starts like RRT*, building a tree through uniform sampling. After discovering a valid path, it switches to informed sampling within a prolate hyperspheroid defined by the current best cost. Samples are drawn by transforming points from the unit n-ball to the ellipsoid, ensuring all new samples can potentially improve the path. Tree rewiring is done locally to maintain asymptotic optimality.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        solution_nodes = []\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        edges.remove((n.parent, n))\n                        n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n                solution_nodes.append(goal_node)\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 2669.723740566707,
          "time_improvement": -8922.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 350.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 4.326739621162415,
                    "num_nodes_avg": 3092.9,
                    "path_length_avg": 144.17782833834022,
                    "smoothness_avg": 0.025832904194730322,
                    "success_improvement": 0.0,
                    "time_improvement": -15618.8205814028,
                    "length_improvement": 20.97384764386463,
                    "smoothness_improvement": 304.3410476968528,
                    "objective_score": -4679.929699653583
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 4.172705101966858,
                    "num_nodes_avg": 4230.3,
                    "path_length_avg": 216.04260686110948,
                    "smoothness_avg": 0.019191384723471337,
                    "success_improvement": 0.0,
                    "time_improvement": -2171.767974181566,
                    "length_improvement": 27.878759388114016,
                    "smoothness_improvement": 393.80815193060414,
                    "objective_score": -643.985599617194
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 4.9996144533157345,
                    "num_nodes_avg": 4590.3,
                    "path_length_avg": 109.81726433629747,
                    "smoothness_avg": 0.03559960377842232,
                    "success_improvement": 0.0,
                    "time_improvement": -8974.776548280024,
                    "length_improvement": 27.06460196401368,
                    "smoothness_improvement": 352.82433237211626,
                    "objective_score": -2685.255922429344
               }
          ],
          "success_rate": 1.0
     }
]