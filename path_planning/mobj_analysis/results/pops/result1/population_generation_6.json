[
     {
          "operator": "m3",
          "algorithm_description": "This algorithm presents an enhanced bidirectional RRT with goal biasing and simplified structure to improve efficiency and path quality. It grows two trees simultaneously\u2014from start and goal\u2014and attempts to connect them, alternating expansion in each iteration. Goal biasing increases convergence speed toward the goal. The approach includes collision checks for nodes and edges, pruning redundant exploration, and incremental connection attempts to improve robustness and success rate. Path extraction merges the two trees into a smooth, feasible path.",
          "planning_mechanism": "The planner alternates growing start and goal trees by steering towards samples, employs goal biasing to guide exploration, performs collision-free extension checks, and attempts to connect the two trees incrementally. Upon connecting, it extracts a final path by tracing parents from both trees, ensuring a feasible, smooth solution with reduced search overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for itr in range(self.max_iter):\n            # Alternate start and goal tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try connecting trees\n                near_connect = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_connect = math.dist(new_pos, near_connect.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, near_connect.position, obstacles, is_3d):\n                        conn_node = Node(near_connect.position, parent=new_node, cost=new_node.cost + dist_connect)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Reconstruct path\n                        path = self._extract_path(conn_node, near_connect)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        # Extract path from node_a up to root start tree\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        # Extract path from node_b up to root goal tree\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        # Since node_b belongs to opposite tree, append its reversed path (excluding first duplicate node)\n        return path_a + path_b[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.73192,
          "time_improvement": 85.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0071019411087036135,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 183.5187018824448,
                    "smoothness_avg": 0.010997871352320374,
                    "success_improvement": 0.0,
                    "time_improvement": 71.70916792508382,
                    "length_improvement": -0.5895085416933348,
                    "smoothness_improvement": 72.14056892370422,
                    "objective_score": 21.755551513805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011534762382507325,
                    "num_nodes_avg": 259.9,
                    "path_length_avg": 309.6814971266057,
                    "smoothness_avg": 0.0064039069277323805,
                    "success_improvement": 0.0,
                    "time_improvement": 93.00682632435114,
                    "length_improvement": -3.3805974285229334,
                    "smoothness_improvement": 64.77713779827361,
                    "objective_score": 27.549814100592123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004734683036804199,
                    "num_nodes_avg": 190.4,
                    "path_length_avg": 169.66580872434636,
                    "smoothness_avg": 0.01221306295668852,
                    "success_improvement": 0.0,
                    "time_improvement": 90.50144735658925,
                    "length_improvement": -12.68395153709525,
                    "smoothness_improvement": 55.34925933454292,
                    "objective_score": 24.89039019623044
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.708608753841677,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010948657989501953,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.38563599927819,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 18.510996063035716
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02024111747741699,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 87.7284294886342,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 29.95681957631103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01007375717163086,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.7903867971998,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.65801062217829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm improves bidirectional RRT by integrating goal biasing, adaptive neighborhood rewiring for asymptotic optimality, and incremental connection attempts. It dynamically adjusts search radius for rewiring based on the current tree size, promoting better path quality and smoother solution convergence while maintaining computational efficiency.",
          "planning_mechanism": "The planner grows two trees simultaneously\u2014from start and goal\u2014alternating expansion with goal biasing to accelerate convergence. At each iteration, it samples free points biased towards the opposite tree\u2019s root, extends the tree towards the sample with collision checks, and rewires neighbors within an adaptive radius to optimize path cost. Incremental connections are attempted to link the two trees. On success, the combined path is extracted, ensuring a smooth, collision-free solution with reduced planning time and improved robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = 50.0  # Base radius factor for rewiring; adaptive with tree size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def get_rewire_radius(tree_size):\n            # Adaptive radius: decreases as tree grows, promoting efficiency & quality\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)  # never too small\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-6 < neighbor.cost:  # small tolerance for floating\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor's parent link to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass  # safety\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def steer_and_add(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # Rewire neighbors for optimization\n            rewire(tree, new_node)\n            return new_node\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_pos), (goal_tree, start_tree, start_pos)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = steer_and_add(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Try incrementally connecting tree_b to new_node\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n                connection_made = False\n                min_cost_connect = float('inf')\n                best_node_b = None\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_cost_connect:\n                            min_cost_connect = total_cost\n                            best_node_b = nb\n                if best_node_b is not None:\n                    # Connect best_node_b to new_node\n                    # Attach new connection node in tree_b to unify paths\n                    conn_pos = best_node_b.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n                    # Rewire around conn_node\n                    rewire(tree_a, conn_node)\n\n                    # Extract path\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    path_goal = []\n                    cur = best_node_b\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    extracted_path = path_start + path_goal[1:]\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # Failed to find path\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.73056,
          "time_improvement": 73.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 121.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009549236297607422,
                    "num_nodes_avg": 121.2,
                    "path_length_avg": 192.66512918026064,
                    "smoothness_avg": 0.013418041999981825,
                    "success_improvement": 0.0,
                    "time_improvement": 61.96028150554178,
                    "length_improvement": -5.602810278041514,
                    "smoothness_improvement": 110.0214950442843,
                    "objective_score": 18.01762987127565
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011700725555419922,
                    "num_nodes_avg": 221.2,
                    "path_length_avg": 276.3360727399123,
                    "smoothness_avg": 0.009187848167700855,
                    "success_improvement": 0.0,
                    "time_improvement": 92.90620792811096,
                    "length_improvement": 7.751065026579014,
                    "smoothness_improvement": 136.40995109448716,
                    "objective_score": 30.104125139221527
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017450571060180664,
                    "num_nodes_avg": 268.9,
                    "path_length_avg": 150.66020077595874,
                    "smoothness_avg": 0.017056656809840934,
                    "success_improvement": 0.0,
                    "time_improvement": 64.9912852488248,
                    "length_improvement": -0.06133168757321738,
                    "smoothness_improvement": 116.95941562973272,
                    "objective_score": 20.06991631528146
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.068321752434553,
          "time_improvement": 67.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008623981475830078,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 65.64606661538022,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 19.43545600969078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017321276664733886,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.49863967859932,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.230659824248814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026317262649536134,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 47.2032440685165,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 13.53884942336407
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm integrates a hybrid approach combining informed sampling, bidirectional growth, and heuristic-driven rewiring to improve convergence speed, path quality, and robustness. It grows two trees from start and goal simultaneously using informed sampling within ellipsoidal informed sets when solutions exist, aggressively rewires locally to optimize paths during bidirectional expansions, and uses dynamic goal biasing. This approach balances exploration and exploitation efficiently for faster, smoother, and shorter paths with high success rates.",
          "planning_mechanism": "The planner alternates expansions of two trees rooted at start and goal. Initially, uniform random samples guide exploration; after a valid path is found, sampling is restricted inside an ellipsoidal informed subset around the best path to focus search. Each new node connects to the best local parent and triggers rewiring to reduce path costs. The two trees attempt connection after each expansion, producing a refined, smooth path by merging. Collision and boundary checks prevent invalid nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Initialize cost and solution tracking\n        best_cost = float(\"inf\")\n        c_min = self._euclidean(start_pos, goal_pos)\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Helper: check if pos within map bounds\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Ellipsoidal informed sampling: sample in unit ball scaled and rotated\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            import random\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute ellipse parameters\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            length = np.linalg.norm(a1)\n            a1 = a1 / length\n\n            L = np.diag([c_best / 2.0] + [((c_best ** 2 - c_min ** 2) ** 0.5) / 2.0] * (dim - 1))\n\n            # Rotation matrix via SVD\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            while True:\n                # Sample from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball = x_ball / norm * (random.random() ** (1.0 / dim))\n                x_rand = C @ (L @ x_ball) + center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n\n        # Find nearest node in a tree to given point\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: self._euclidean(n.position, point))\n\n        # Find nodes near a position within a radius\n        def near_nodes(tree, pos, radius=15.0):\n            return [node for node in tree if self._euclidean(node.position, pos) <= radius]\n\n        # Rewire nodes in near_nodes to new_node if cheaper and collision free\n        def rewire(tree, new_node, near_n):\n            for node in near_n:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + self._euclidean(new_node.position, node.position)\n                if potential_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        # Merge paths from two nodes, stitching start and goal trees\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal[1:]\n\n        for itr in range(self.max_iter):\n            # Alternate between start_tree and goal_tree for expansion\n            for tree_a, tree_b, is_start_tree_expansion in [(start_tree, goal_tree, True), (goal_tree, start_tree, False)]:\n\n                # Determine sampling strategy: informed sampling if solution found else uniform\n                if best_cost < float(\"inf\"):\n                    sample = informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if is_start_tree_expansion else start_pos\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                # Find nearest node & steer towards sample\n                nearest = nearest_node(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest.cost + self._euclidean(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire near nodes to new_node in tree_a\n                near_n = near_nodes(tree_a, new_pos, radius=20.0)\n                rewire(tree_a, new_node, near_n)\n\n                # Attempt connection to opposite tree\n                near_in_b = near_nodes(tree_b, new_pos, radius=self.step_size * 1.5)\n                connect_node = None\n                min_connect_cost = float(\"inf\")\n                for nbr in near_in_b:\n                    dist = self._euclidean(new_pos, nbr.position)\n                    if dist <= self.step_size and not self._is_edge_in_obstacle(new_pos, nbr.position, obstacles, is_3d):\n                        total_cost = new_node.cost + dist + nbr.cost\n                        if total_cost < min_connect_cost:\n                            min_connect_cost = total_cost\n                            connect_node = nbr\n\n                if connect_node is not None:\n                    # Connect trees by adding edge and update solution if better\n                    if is_start_tree_expansion:\n                        # Connect connect_node parent rewritten to new_node\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in start tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        # Update solution path if cost improved\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = conn_node\n                            solution_node_goal = connect_node\n                            success = True\n                    else:\n                        # Connecting from goal tree expansion\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in goal tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = connect_node\n                            solution_node_goal = conn_node\n                            success = True\n\n            if success and solution_node_start and solution_node_goal:\n                extracted_path = extract_path(solution_node_start, solution_node_goal)\n                break\n\n        # Post-process path smoothing via shortcutting (optional, simple straight-line shortcuts)\n        if success and len(extracted_path) > 3:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _euclidean(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._euclidean(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _smooth_path(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            p_start = smoothed[i]\n            p_end = smoothed[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = self._euclidean(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.36588,
          "time_improvement": 33.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1240.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022878527641296387,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 180.38439431350918,
                    "smoothness_avg": 0.02957517506587525,
                    "success_improvement": 0.0,
                    "time_improvement": 8.862580847365873,
                    "length_improvement": 1.128455103121995,
                    "smoothness_improvement": 362.9157133015363,
                    "objective_score": 4.699043841341842
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03743283748626709,
                    "num_nodes_avg": 288.3,
                    "path_length_avg": 237.52161712099596,
                    "smoothness_avg": 0.08105711587400938,
                    "success_improvement": 0.0,
                    "time_improvement": 77.30561540558567,
                    "length_improvement": 20.708447524332772,
                    "smoothness_improvement": 1985.6579745189633,
                    "objective_score": 37.26166399913707
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044042229652404785,
                    "num_nodes_avg": 294.7,
                    "path_length_avg": 129.5781252975168,
                    "smoothness_avg": 0.11565553498213739,
                    "success_improvement": 0.0,
                    "time_improvement": 11.644045940418264,
                    "length_improvement": 13.940379024652591,
                    "smoothness_improvement": 1371.1298681692033,
                    "objective_score": 13.136938927902015
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive ellipsoidal informed sampling, dynamic neighbor radius, KD-tree accelerated nearest neighbor search, incremental rewiring, aggressive pruning of non-promising nodes, collision check caching, and iterative shortcut path smoothing. Parameter tuning balances exploration-exploitation, accelerates convergence, improves success rate, path optimality, and smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates expansions of two trees rooted at the start and goal, biased by the current best path cost through ellipsoidal informed sampling; neighbor radius shrinks dynamically to balance exploration and refinement. KD-trees accelerate nearest and radius neighbor queries enabling efficient rewiring. Collision checks are cached to minimize redundancy. Periodic pruning removes futile nodes, and shortcut smoothing refines the final path for enhanced smoothness and shorter length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 120,\n                 prune_threshold: int = 200,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 0.4,\n                 goal_sample_rate: float = 0.18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if (not node.children) or (node.cost + heuristic(node.position) >= best_cost - 1e-12):\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0\n                else:\n                    iteration += 1\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.52638,
          "time_improvement": 17.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1368.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023497653007507325,
                    "num_nodes_avg": 91.4,
                    "path_length_avg": 158.55454962507443,
                    "smoothness_avg": 0.0451878173496607,
                    "success_improvement": 0.0,
                    "time_improvement": 6.396273185742368,
                    "length_improvement": 13.093738892878351,
                    "smoothness_improvement": 607.2874684381404,
                    "objective_score": 7.574067076489083
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03952329158782959,
                    "num_nodes_avg": 267.8,
                    "path_length_avg": 235.59660813744208,
                    "smoothness_avg": 0.09339958230957038,
                    "success_improvement": 0.0,
                    "time_improvement": 76.03823701421378,
                    "length_improvement": 21.351070931354453,
                    "smoothness_improvement": 2303.2385258251884,
                    "objective_score": 38.59787791966097
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06504204273223876,
                    "num_nodes_avg": 261.4,
                    "path_length_avg": 123.60544267814672,
                    "smoothness_avg": 0.10175022439068415,
                    "success_improvement": 0.0,
                    "time_improvement": -30.48503186480369,
                    "length_improvement": 17.907150431854646,
                    "smoothness_improvement": 1194.2553438291804,
                    "objective_score": 0.4071972460757243
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates bidirectional RRT* with informed sampling and adaptive rewiring. It alternates expanding two trees from start and goal while focusing search inside an ellipsoidal informed set around the best solution cost. Adaptive step sizing ensures safe exploration near obstacles. Continuous rewiring optimizes costs, and pruning discards inefficient nodes. A final smoothing step improves path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally, samples points inside an informed ellipsoid to bias search toward promising areas, uses adaptive stepping to navigate safely near obstacles, performs rewiring of neighbors to optimize costs in both trees, prunes nodes unlikely to improve the solution, attempts to connect the two trees for path updates, and performs path shortcutting for smoothness before returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_heuristic(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy as np\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample in unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            # Check points along the path; reduce step if near obstacle\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            # Try connect trees\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                # Optional: continue to improve path, here break for speed\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -13.0185,
          "time_improvement": 4.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1743.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049403262138366696,
                    "num_nodes_avg": 268.8,
                    "path_length_avg": 165.4484773217101,
                    "smoothness_avg": 0.05793713667543628,
                    "success_improvement": 0.0,
                    "time_improvement": -96.79963149746891,
                    "length_improvement": 9.315067881077315,
                    "smoothness_improvement": 806.8420014765672,
                    "objective_score": -23.142665865642375
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03950042724609375,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 238.45172325330878,
                    "smoothness_avg": 0.1098670141892697,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0520989653694,
                    "length_improvement": 20.397951325746124,
                    "smoothness_improvement": 2726.957409101609,
                    "objective_score": 40.530007000268085
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0327894926071167,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 128.51545696165562,
                    "smoothness_avg": 0.14109008407790408,
                    "success_improvement": 0.0,
                    "time_improvement": 34.21888661639979,
                    "length_improvement": 14.646152734503213,
                    "smoothness_improvement": 1694.655455284229,
                    "objective_score": 21.668173808241725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed elliptical sampling, dynamic adaptive step sizing near obstacles, node rewiring for cost optimization, and pruning of inefficient nodes. It grows two trees from start and goal, alternates expansion, employs sampling within an informed subset to focus search towards promising regions, adapts step sizes considering obstacle proximity to safely explore narrow passages, applies rewiring to improve path cost continuously, and prunes branches unlikely to yield better solutions.",
          "planning_mechanism": "The planner iteratively samples random points within an ellipsoidal informed subset defined by the current best path cost to goal, steers from the nearest node with an adaptive step size, validates node and edge collisions rigorously, attempts to rewire neighbors within a radius to minimize costs, prunes nodes with costs exceeding the current best, and tries to connect two trees to update the best path. The process stops upon success or iteration limit, returning an optimized, feasible path with improved efficiency and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_with_heuristic(node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        for iter_num in range(self.max_iter):\n            # Alternate trees\n            if iter_num % 2 == 0:\n                active_tree, other_tree = tree_a, tree_b\n            else:\n                active_tree, other_tree = tree_b, tree_a\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Do not exceed bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes with cost + heuristic worse than best known path\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius to reduce cost\n            neighbors = [node for node in active_tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                    # Add new edge\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes in active tree that have cost + heuristic worse than c_best\n            to_remove = []\n            for node in active_tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node != new_node and node != start_root and node != goal_root:\n                        to_remove.append(node)\n            for node in to_remove:\n                # Remove from parent's children\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                # Remove children links to avoid dangling references\n                node.children = []\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Try to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            # Early termination if found a path\n            if success_state:\n                # Optionally continue to improve path or break to return first good path\n                # Here, break after first path found\n                break\n\n        # Path smoothing: shortcut path by removing unnecessary nodes if possible\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shorten_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            # Start and goal are basically the same point, return it\n            return tuple(x_center)\n\n        a1 = diff / norm_diff\n\n        # Create rotation matrix C to rotate the unit vector to a1 direction\n        # Reference: https://arxiv.org/pdf/1109.4115.pdf\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim -1) + [det]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample uniformly inside unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            radius = random.random() ** (1 / dim)\n            x_ball = x_ball * radius\n\n            # Transform to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacles, but at least 1.0\n                return max(self.base_step * 0.25, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shorten_path(self, path, obstacles, is_3d):\n        # Attempts to shortcut the path by removing intermediate nodes when the\n        # straight-line path between non-adjacent nodes is collision-free.\n        import math\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.35232,
          "time_improvement": 6.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04930014610290527,
                    "num_nodes_avg": 240.5,
                    "path_length_avg": 169.95054568747466,
                    "smoothness_avg": 0.05415383468147165,
                    "success_improvement": 0.0,
                    "time_improvement": -96.38886514516909,
                    "length_improvement": 6.84741286996326,
                    "smoothness_improvement": 747.6251096992462,
                    "objective_score": -23.80905142106184
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047037577629089354,
                    "num_nodes_avg": 372.1,
                    "path_length_avg": 237.86859110536346,
                    "smoothness_avg": 0.09317261083841849,
                    "success_improvement": 0.0,
                    "time_improvement": 71.4825551897902,
                    "length_improvement": 20.59261762125851,
                    "smoothness_improvement": 2297.3983863915073,
                    "objective_score": 37.0502820131463
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028564262390136718,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 128.01701657407608,
                    "smoothness_avg": 0.13383198531076218,
                    "success_improvement": 0.0,
                    "time_improvement": 42.6953931395489,
                    "length_improvement": 14.977193106752848,
                    "smoothness_improvement": 1602.332974703307,
                    "objective_score": 23.815721436731774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner advances bidirectional RRT* by combining adaptive ellipsoidal informed sampling with a dynamically shrinking neighbor radius optimized for fast convergence and enhanced path quality. Leveraging KD-tree accelerated nearest neighbor searches, it performs incremental rewiring, aggressive pruning of non-promising nodes, and caches collision checks for efficiency. After path discoveries, it applies an iterative shortcut smoothing strategy to refine path smoothness while maintaining robustness in complex 2D and 3D spaces. These improvements minimize planning time and path length while maximizing success rates and smoothness.",
          "planning_mechanism": "The planner grows two balanced trees rooted at start and goal positions, extending alternately towards samples biased by the current best path cost using ellipsoidal informed sampling. KD-trees accelerate nearest and radius neighbor queries for efficient rewiring and incremental connections. Collision checking is aggressively cached to reduce redundancy. It prunes nodes unlikely to improve the solution periodically, thereby controlling tree size and focusing search. Once a better connection is found, extensive shortcut smoothing refines the path. The process iterates until success or maximum iterations, yielding fast, reliable, and high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        \n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.000001 or random.random() < self.goal_sample_rate:\n                # Uniform random samples inside bounds avoiding obstacles\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Householder transform to align sampling axis\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0.0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):  # Increased trials for better samples\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if 1e-15 < norm_x <= 1:\n                    radius_factor = np.random.uniform(0, 1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor * radii\n                    sample = rot @ x_scaled + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        # Cache to accelerate collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos): \n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                # Prune dead ends and nodes that can't improve path\n                if not node.children or node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_s:\n                    try:\n                        tree_s.remove(rm_node)\n                    except ValueError:\n                        pass\n                if rm_node in tree_g:\n                    try:\n                        tree_g.remove(rm_node)\n                    except ValueError:\n                        pass\n                removed += 1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iteration = 0\n            while iteration < self.smoothing_iterations:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    iteration = 0  # restart smoothing after successful shortcut\n                else:\n                    iteration += 1\n            return path\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Expand smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node (incremental rewiring)\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Apply additional smoothing after initial success for improved smoothness\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Periodic pruning to remove obsolete nodes and clear cache\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        # Final smoothing if success and extracted_path is non-empty\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.92451,
          "time_improvement": 50.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1480.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.02080519199371338,
                    "num_nodes_avg": 79.8,
                    "path_length_avg": 164.45684423843875,
                    "smoothness_avg": 0.05039011432391068,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 17.121786287526948,
                    "length_improvement": 9.858597687450098,
                    "smoothness_improvement": 688.7147130538465,
                    "objective_score": -39.44817101098266
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03086545467376709,
                    "num_nodes_avg": 234.7,
                    "path_length_avg": 239.50461596305007,
                    "smoothness_avg": 0.09143793467005715,
                    "success_improvement": 0.0,
                    "time_improvement": 81.2872187606693,
                    "length_improvement": 20.046465433398186,
                    "smoothness_improvement": 2252.7639191428284,
                    "objective_score": 39.65927831059457
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023805689811706544,
                    "num_nodes_avg": 155.2,
                    "path_length_avg": 124.96929160458971,
                    "smoothness_avg": 0.1256230970077935,
                    "success_improvement": 0.0,
                    "time_improvement": 52.24187213135454,
                    "length_improvement": 17.001346914418143,
                    "smoothness_improvement": 1497.9165214066518,
                    "objective_score": 26.56241362932325
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with informed sampling and adaptive rewiring for improved convergence speed and path quality. It grows two trees from start and goal positions simultaneously, biasing sampling within an ellipsoidal informed subset to focus on promising regions, adaptively adjusting step sizes near obstacles, continuously rewiring to optimize path costs, pruning non-promising nodes, and applying path shortcutting to smooth the final path.",
          "planning_mechanism": "The planner iteratively samples points biased by the current best path cost to limit exploration to relevant areas. It alternates tree expansions from both start and goal, steering towards samples with adaptive step sizes to navigate safely near obstacles. Rewiring optimizes local paths while pruning removes nodes unlikely to improve the solution. When the two trees connect, the planner extracts and smooths the path, minimizing length and improving smoothness before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        import numpy as np  # allowed internally\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):  # limit retries\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Fallback uniform random if fails\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.55653,
          "time_improvement": -15.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1742.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06790504455566407,
                    "num_nodes_avg": 335.1,
                    "path_length_avg": 175.69567130624606,
                    "smoothness_avg": 0.06361610002435195,
                    "success_improvement": 0.0,
                    "time_improvement": -170.50213218603682,
                    "length_improvement": 3.6984184809734817,
                    "smoothness_improvement": 895.7301099533913,
                    "objective_score": -45.93230540984939
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04278788566589355,
                    "num_nodes_avg": 366.0,
                    "path_length_avg": 239.82044278321973,
                    "smoothness_avg": 0.10830022940011286,
                    "success_improvement": 0.0,
                    "time_improvement": 74.0590134627154,
                    "length_improvement": 19.941033350254575,
                    "smoothness_improvement": 2686.6429079671343,
                    "objective_score": 39.639125248701205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02438187599182129,
                    "num_nodes_avg": 239.9,
                    "path_length_avg": 132.33767217613973,
                    "smoothness_avg": 0.13703623037701726,
                    "success_improvement": 0.0,
                    "time_improvement": 51.08594791812151,
                    "length_improvement": 12.107619383372741,
                    "smoothness_improvement": 1643.090735433303,
                    "objective_score": 25.962761929277516
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional RRT's dual-tree growth and adaptive rewiring for path quality and convergence speed with single-tree incremental extension and goal biasing from classic RRT. It uses adaptive neighborhood rewiring, incremental attempts to connect the two trees, and refined collision checks to improve path smoothness, robustness, and planning efficiency. The planner dynamically adjusts rewiring radius, integrates both exploration and exploitation, and ensures collision-free nodes and edges, aiming for shorter, smoother paths with higher success rates and reduced computation time.",
          "planning_mechanism": "The planner grows two trees simultaneously, rooted at start and goal, alternately expanding them with goal biasing towards the opposite root to accelerate convergence. It incrementally extends each tree towards sampled points, performs adaptive rewiring around new nodes, and attempts to connect the two trees within an adaptive radius. On successful connection, it extracts a smooth, optimized path. The connection attempts are collision-checked for both nodes and edges, and rewiring dynamically refines the path quality during search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, rewire_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # base factor for adaptive rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def get_rewire_radius(tree_size):\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            # Adaptive radius shrinks as tree grows, remains above step_size*1.5\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def extend(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        # Initialize trees and data\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Alternate growing start and goal trees\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                # Sampling with goal biasing towards opposite root to accelerate connection\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = extend(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Attempt incremental connection from opposite tree within rewiring radius\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node is not None:\n                    # Link the two trees by connecting new_node and best_connect_node\n                    # Attach best_connect_node as child of new_node to unify paths directionally\n                    conn_pos = best_connect_node.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire around new connecting node for further optimization\n                    rewire(tree_a, conn_node)\n\n                    # Extract path from start tree root to conn_node\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    # Extract path from goal tree root to best_connect_node\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    # Merge and finalize path (avoid duplicate connecting node)\n                    extracted_path = path_start + path_goal[1:]\n                    success = True\n                    break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.52794,
          "time_improvement": 65.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.014651799201965332,
                    "num_nodes_avg": 146.2,
                    "path_length_avg": 190.64801818491756,
                    "smoothness_avg": 0.011628860455521643,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 41.63404279568054,
                    "length_improvement": -4.497199778324836,
                    "smoothness_improvement": 82.01691860357275,
                    "objective_score": -37.999142523942936
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021097254753112794,
                    "num_nodes_avg": 292.1,
                    "path_length_avg": 307.3481346225392,
                    "smoothness_avg": 0.006738894083969708,
                    "success_improvement": 0.0,
                    "time_improvement": 87.20937964082658,
                    "length_improvement": -2.601653862549766,
                    "smoothness_improvement": 73.39659860975604,
                    "objective_score": 26.0094661127868
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0170501708984375,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 154.6829914042549,
                    "smoothness_avg": 0.013864129032996206,
                    "success_improvement": 0.0,
                    "time_improvement": 65.79455380665306,
                    "length_improvement": -2.7330776781827977,
                    "smoothness_improvement": 76.35069795615588,
                    "objective_score": 19.573504096140137
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a Hybrid Informed PRM-RRT Planner that combines Probabilistic Roadmap (PRM) sampling within an informed ellipsoidal heuristic to focus node generation around the promising region and a bidirectional RRT for fast tree growth between the start and goal. It adaptively refines the roadmap connections with collision-free edge rewiring to improve path quality. A shortcut smoothing step post planning reduces unnecessary turns, improving path smoothness while maintaining feasibility. This integration leverages heuristic guidance, roadmap efficiency, and RRT explorative strength to enhance planning efficiency, robustness, and path optimality.",
          "planning_mechanism": "The planner initially samples nodes biased within an ellipsoidal region defined by start, goal, and the best current solution cost, constructing a dense roadmap with collision-free connections. Two trees (start and goal) are grown simultaneously using RRT extensions connected via the roadmap nodes. When a connection between the two trees occurs via roadmap nodes, the path is reconstructed and subsequently smoothed by iterative random shortcutting checks. Collision checks are strictly enforced for nodes and edges. The strategy reduces the search space smartly and improves convergence speed and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def reconstruct_path(node_from_start, node_from_goal):\n        # Path from start tree root to node_from_start\n        path_start = []\n        node = node_from_start\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        # Path from goal tree root to node_from_goal\n        path_goal = []\n        node = node_from_goal\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        # Merge paths with no duplication at connection point\n        return path_start + path_goal[1:]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 6.0, roadmap_node_count: int = 150,\n                 connection_radius: float = 25.0, shortcut_trials: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.roadmap_node_count = roadmap_node_count         # Number of PRM nodes sampled\n        self.connection_radius = connection_radius           # Radius for PRM connections and rewiring\n        self.shortcut_trials = shortcut_trials               # Number of shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        # --- Helper: Euclidean distance ---\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        # --- Build informed ellipsoid for heuristic sampling ---\n        def informed_sample(c_best):\n            # If no path found yet, sample entire space uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Ellipsoidal heuristic sampling between start and goal\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # No path shorter than c_min possible so fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(bounds)))\n\n            # Rotation matrix aligns the ellipsoid with start-goal vector\n            dx = [goal_pos[d] - start_pos[d] for d in range(len(bounds))]\n            length = dist(start_pos, goal_pos)\n            if length == 0:\n                return center\n\n            unit_vec = tuple(x / length for x in dx)\n\n            # Construct orthonormal basis (QR or Gram-Schmidt)\n            # For 2D or 3D, construct orthogonal basis via cross products or perpendicular vectors.\n\n            def ortho_basis_2d(vec):\n                # vec is unit vector in 2D\n                return (-vec[1], vec[0])\n\n            def ortho_basis_3d(vec):\n                import numpy as np\n                v = np.array(vec)\n                # Find one vector orthogonal to v:\n                if abs(v[0]) < 1e-6 and abs(v[1]) < 1e-6:\n                    ortho1 = np.array([0,1,0])\n                else:\n                    ortho1 = np.array([-v[1], v[0], 0])\n                ortho1 /= np.linalg.norm(ortho1)\n                # Second orthogonal vector:\n                ortho2 = np.cross(v, ortho1)\n                ortho2 /= np.linalg.norm(ortho2)\n                return ortho1, ortho2\n\n            # Axes lengths of ellipsoid\n            a1 = c_best / 2\n            if is_3d:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n                a3 = a2\n            else:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n            import numpy as np\n\n            if is_3d:\n                # Sample random point in unit ball\n                while True:\n                    sample = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(sample) <= 1:\n                        break\n                # Scale by ellipsoid axis lengths\n                sample[0] *= a1\n                sample[1] *= a2\n                sample[2] *= a3\n\n                # Rotation matrix\n                ex = np.array(unit_vec)\n                ey, ez = ortho_basis_3d(unit_vec)\n                R = np.column_stack((ex, ey, ez))  # 3x3 rotation\n\n                mapped = R.dot(sample) + np.array(center)\n                m = tuple(mapped.tolist())\n\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n            else:\n                # 2D case\n                # Sample random point in ellipse\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x**2 + y**2 <= 1:\n                        break\n                sample_local = (x * a1, y * a2)\n\n                orth = ortho_basis_2d(unit_vec)\n                mapped = (center[0] + unit_vec[0] * sample_local[0] + orth[0] * sample_local[1],\n                          center[1] + unit_vec[1] * sample_local[0] + orth[1] * sample_local[1])\n                m = mapped\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n        # --- Roadmap Sampling ---\n        # Initialize nodes list with start and goal nodes\n        nodes = [Node(start_pos, cost=0.0), Node(goal_pos, cost=0.0)]\n        edges = []\n\n        # Roadmap nodes sampled inside the informed ellipsoid or whole space early\n        c_best = float('inf')\n\n        # Sample roadmap nodes\n        for _ in range(self.roadmap_node_count):\n            p = informed_sample(c_best)\n            if not in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            # Add roadmap node with no parent (initially disconnected)\n            nodes.append(Node(p, parent=None, cost=float('inf')))\n\n        # Connect roadmap nodes if within radius and collision free\n        def near_nodes_rd(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        # Build connection edges in roadmap with rewiring (similar to PRM*)\n        for n in nodes[2:]:\n            near = near_nodes_rd(nodes, n.position, self.connection_radius)\n            best_parent = None\n            best_cost = float('inf')\n            for other in near:\n                if other == n:\n                    continue\n                # Check collision of edge\n                if other.cost == float('inf'):\n                    # Not connected yet, ignore as parent candidate\n                    continue\n                if self._is_edge_in_obstacle(other.position, n.position, obstacles, is_3d):\n                    continue\n                cost_through_other = other.cost + dist(other.position, n.position)\n                if cost_through_other < best_cost:\n                    best_cost = cost_through_other\n                    best_parent = other\n            if best_parent:\n                n.parent = best_parent\n                n.cost = best_cost\n                best_parent.add_child(n)\n                edges.append((best_parent, n))\n\n        # Try rewiring for better costs after initial connections\n        improved = True\n        while improved:\n            improved = False\n            for n in nodes[2:]:\n                near = near_nodes_rd(nodes, n.position, self.connection_radius)\n                for other in near:\n                    if other == n or n.parent is None:\n                        continue\n                    cost_through_n = n.cost + dist(n.position, other.position)\n                    if cost_through_n + 1e-6 < other.cost and not self._is_edge_in_obstacle(n.position, other.position, obstacles, is_3d):\n                        # Rewire other under n\n                        if other.parent:\n                            try:\n                                edges.remove((other.parent, other))\n                                other.parent.children.remove(other)\n                            except ValueError:\n                                pass\n                        other.parent = n\n                        other.cost = cost_through_n\n                        n.add_child(other)\n                        edges.append((n, other))\n                        improved = True\n\n        # --- Bidirectional RRT growing on roadmap nodes ---\n        start_tree = [nodes[0]]   # start node\n        goal_tree = [nodes[1]]    # goal node\n\n        tree_nodes_set_start = {nodes[0]}\n        tree_nodes_set_goal = {nodes[1]}\n\n        def nearest(tree_nodes, p):\n            return min(tree_nodes, key=lambda n: dist(n.position, p))\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Heuristic: always try connecting through roadmap nodes for faster path\n        connected = False\n        connecting_node_start = None\n        connecting_node_goal = None\n\n        for itr in range(self.max_iter):\n            # Alternate trees\n            for tree_a, tree_b, set_a, set_b in [(start_tree, goal_tree, tree_nodes_set_start, tree_nodes_set_goal),\n                                                 (goal_tree, start_tree, tree_nodes_set_goal, tree_nodes_set_start)]:\n                # Sample in informed space\n                sample = informed_sample(c_best)\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_a = nearest(tree_a, sample)\n                new_pos = steer(nearest_a.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n                new_node.parent = nearest_a\n                nearest_a.add_child(new_node)\n                tree_a.append(new_node)\n                # Add to set for quick search\n                set_a.add(new_node)\n\n                # Try connect with nodes in tree_b via roadmap filtering for efficiency:\n                # Check roadmap nodes near new_node with radius\n                candidates_b = [n for n in tree_b if dist(n.position, new_node.position) <= self.connection_radius]\n                candidates_b.sort(key=lambda nn: dist(nn.position, new_node.position))\n\n                for candidate_b in candidates_b:\n                    d_connect = dist(new_node.position, candidate_b.position)\n                    if d_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, candidate_b.position, obstacles, is_3d):\n                        # Connect found, build connecting nodes in tree_a and tree_b appropriately\n                        connect_node_b = Node(candidate_b.position, parent=new_node,\n                                              cost=new_node.cost + d_connect)\n                        new_node.add_child(connect_node_b)\n                        tree_a.append(connect_node_b)\n                        set_a.add(connect_node_b)\n                        edges.append((new_node, connect_node_b))\n\n                        connected = True\n                        connecting_node_start = connect_node_b if tree_a is start_tree else candidate_b\n                        connecting_node_goal = candidate_b if tree_b is goal_tree else connect_node_b\n                        break\n                if connected:\n                    break\n            if connected:\n                break\n\n        if not connected:\n            # No path found\n            return PlannerResult(False, [], nodes, edges)\n\n        # Reconstruct path using Node static method\n        path = Node.reconstruct_path(connecting_node_start, connecting_node_goal)\n\n        # Append all nodes from start_tree and goal_tree plus roadmap nodes to nodes list\n        # (Avoid duplicates)\n        all_tree_nodes = set(start_tree + goal_tree + nodes[2:])\n\n        # Update edges with parent-child in the tree expansions\n        # We track edges from roadmap plus tree expansions\n        # Edges between roadmap nodes already added\n        # Add tree expansions edges\n        def update_edges(tree):\n            for n in tree:\n                if n.parent is not None and (n.parent, n) not in edges:\n                    edges.append((n.parent, n))\n\n        update_edges(start_tree)\n        update_edges(goal_tree)\n\n        # --- Shortcut smoothing ---\n        # Iteratively attempt random shortcuts on path\n        def path_smoothing(path):\n            smoothed_path = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                a = smoothed_path[i]\n                b = smoothed_path[j]\n                if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                    # Shortcut possible: replace intermediate points\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        path = path_smoothing(path)\n\n        return PlannerResult(True, path, list(all_tree_nodes), edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.83708,
          "time_improvement": -32.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1518.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.056850218772888185,
                    "num_nodes_avg": 212.3,
                    "path_length_avg": 173.14105868688912,
                    "smoothness_avg": 0.03300778700001848,
                    "success_improvement": 0.0,
                    "time_improvement": -126.46484504848468,
                    "length_improvement": 5.0986421380704305,
                    "smoothness_improvement": 416.64354410699883,
                    "objective_score": -34.83650736639632
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06818621158599854,
                    "num_nodes_avg": 375.5,
                    "path_length_avg": 239.8833934812037,
                    "smoothness_avg": 0.11265474635194206,
                    "success_improvement": 0.0,
                    "time_improvement": 58.66078519063724,
                    "length_improvement": 19.92001859533215,
                    "smoothness_improvement": 2798.687765569485,
                    "objective_score": 35.57567810410502
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06357545852661133,
                    "num_nodes_avg": 394.7,
                    "path_length_avg": 125.41948934045914,
                    "smoothness_avg": 0.1131210894393732,
                    "success_improvement": 0.0,
                    "time_improvement": -27.542822814089774,
                    "length_improvement": 16.702347014366147,
                    "smoothness_improvement": 1338.891907938553,
                    "objective_score": 1.7720820983390633
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner that grows two trees from start and goal positions while ensuring collision-free extension and rewiring for path cost optimization. It balances exploration by random sampling and exploitation through rewiring, with robust collision checks on both nodes and connecting edges. The planner attempts connections between trees at each iteration to find a feasible path efficiently, then returns the optimized path and explored graph.",
          "planning_mechanism": "The planner initializes two trees at start and goal, sampling points uniformly within bounds. In each iteration, it extends each tree towards the sample with collision-checked nodes and edges, rewires neighbors to improve costs, and attempts to connect the two trees. If connected, it extracts the full path by concatenating tree branches. The process repeats until success or iteration limit, returning the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d])**2 for d in range(dim)) <= r2]\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                neighbors = near_nodes(tree_a, new_pos, self.radius)\n                for neighbor in neighbors:\n                    if neighbor is new_node or neighbor is nearest_node:\n                        continue\n                    potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                try:\n                                    neighbor.parent.children.remove(neighbor)\n                                    edges.remove((neighbor.parent, neighbor))\n                                except ValueError:\n                                    pass\n                            neighbor.parent = new_node\n                            neighbor.cost = potential_cost\n                            new_node.add_child(neighbor)\n                            edges.append((new_node, neighbor))\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                        # extract full path\n                        path_a = new_node.path_from_root()\n                        path_b = nearest_other.path_from_root()\n                        final_path = path_a + path_b[::-1][1:]\n                        success = True\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.10511,
          "time_improvement": 48.0,
          "length_improvement": 3.0,
          "smoothness_improvement": 120.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011091971397399902,
                    "num_nodes_avg": 150.1,
                    "path_length_avg": 187.84179597993017,
                    "smoothness_avg": 0.012363766462785824,
                    "success_improvement": 0.0,
                    "time_improvement": 55.8147420007408,
                    "length_improvement": -2.9590649203348067,
                    "smoothness_improvement": 93.51979349119479,
                    "objective_score": 16.62020858361125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0326352596282959,
                    "num_nodes_avg": 286.5,
                    "path_length_avg": 275.0283720240446,
                    "smoothness_avg": 0.009391425218857656,
                    "success_improvement": 0.0,
                    "time_improvement": 80.21424014103054,
                    "length_improvement": 8.187613165613756,
                    "smoothness_improvement": 141.64813525137475,
                    "objective_score": 26.410035351688787
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.04579734802246094,
                    "num_nodes_avg": 280.1,
                    "path_length_avg": 146.04954231216885,
                    "smoothness_avg": 0.01756855771566413,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 8.122989915377943,
                    "length_improvement": 3.000848128113153,
                    "smoothness_improvement": 123.47075736720929,
                    "objective_score": -46.34557961292793
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional growth and connection of RRT trees with informed elliptical sampling, adaptive step sizing near obstacles, cost-based node pruning, and efficient rewiring to optimize path quality and computational efficiency. It balances exploration and exploitation by alternating between start and goal trees while guiding sampling within an informed ellipsoidal region that shrinks with better solutions. The planner dynamically adjusts step size near obstacles to navigate cluttered spaces robustly, prunes unpromising branches early based on heuristic cost bounds, and rewires nodes to improve path costs. Post-planning, the path is smoothed by shortcutting to enhance path quality and smoothness.",
          "planning_mechanism": "The planner starts two trees from start and goal points, alternately sampling points mostly within an informed ellipsoidal space defined by the current best solution cost. Each sampled point is connected by an adaptive step that shrinks near obstacles, ensuring collision-free growth. Branches unlikely to improve the current best cost are pruned. Nearby nodes are rewired if a lower-cost path is found. When the two trees can be connected collision-free within a proximity threshold, the path is updated. Finally, a shortcut smoothing step improves the path\u2019s smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n            except Exception:\n                r2 = 0.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n            for _ in range(100):  # limit tries to avoid infinite loop\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback random sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicated connecting position\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune nodes that cannot improve best cost\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Early stop if a good path is found\n            if success and i % 100 == 0 and c_best < float(\"inf\"):\n                break\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.12117,
          "time_improvement": -35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1039.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06026041507720947,
                    "num_nodes_avg": 332.6,
                    "path_length_avg": 166.996413064366,
                    "smoothness_avg": 0.016269651188625004,
                    "success_improvement": 0.0,
                    "time_improvement": -140.04948191203425,
                    "length_improvement": 8.466619771916111,
                    "smoothness_improvement": 154.6553712150155,
                    "objective_score": -39.54824376315197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06673438549041748,
                    "num_nodes_avg": 500.6,
                    "path_length_avg": 237.0038545493059,
                    "smoothness_avg": 0.07697310282156793,
                    "success_improvement": 0.0,
                    "time_improvement": 59.54098295254645,
                    "length_improvement": 20.88129157373222,
                    "smoothness_improvement": 1880.5733770839436,
                    "objective_score": 31.441420085930098
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06200351715087891,
                    "num_nodes_avg": 431.8,
                    "path_length_avg": 123.09804183051456,
                    "smoothness_avg": 0.09294490050814501,
                    "success_improvement": 0.0,
                    "time_improvement": -24.389249957430696,
                    "length_improvement": 18.244141915019977,
                    "smoothness_improvement": 1082.2522739846838,
                    "objective_score": 1.7433147656982069
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a novel hybrid RRT* planner incorporating bidirectional trees, adaptive informed sampling, dynamic step sizing near obstacles, cost-based pruning, and integrated path smoothing. It balances exploration and exploitation by growing two trees from start and goal, biases sampling inside an informed ellipsoid that shrinks as better paths are found, rewires nodes for cost improvement, prunes suboptimal branches early, and performs shortcut smoothing to enhance path quality and efficiency. This structure aims to improve planning success, robustness, and path optimality with reduced computational effort.",
          "planning_mechanism": "The planner alternates between expanding two RRT* trees from start and goal using adaptive step sizes and informed elliptical sampling. Nodes are connected only if collision checks pass, and rewiring optimizes the cost locally. Suboptimal nodes are pruned using heuristic cost bounds to speed up convergence. When trees connect, the solution path is extracted and shortcut smoothed to reduce unnecessary detours and ensure smoother, shorter paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_step) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (max_step/dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire_tree(tree: List[Node], new_node: Node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                heuristic_remain = distance(near_node.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                    new_node.add_child(near_node)\n                    near_node.cost = new_cost\n                    edges.append((new_node, near_node))\n\n        def extract_path(node_start: Node, node_goal: Node):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicated connection node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(tree: List[Node]):\n            # Remove nodes that cannot possibly improve solution cost\n            retained = []\n            for node in tree:\n                heuristic = distance(node.position, goal)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    # Disconnect subtree\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        for iteration in range(self.max_iter):\n            # Alternate growth direction\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire_tree(tree_a, new_node)\n\n            # Attempt to connect opposite tree\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Prune suboptimal nodes every 200 iterations to improve search speed\n            if iteration > 0 and iteration % 200 == 0 and success:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early stop\n            if success and iteration % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.4129,
          "time_improvement": -61.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 784.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06880130767822265,
                    "num_nodes_avg": 374.2,
                    "path_length_avg": 166.806844724353,
                    "smoothness_avg": 0.014419319321817486,
                    "success_improvement": 0.0,
                    "time_improvement": -174.07242784283554,
                    "length_improvement": 8.57052518297982,
                    "smoothness_improvement": 125.69365943951777,
                    "objective_score": -49.87915501905711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06566660404205323,
                    "num_nodes_avg": 490.7,
                    "path_length_avg": 243.85745597358306,
                    "smoothness_avg": 0.04399399704507752,
                    "success_improvement": 0.0,
                    "time_improvement": 60.18834618972689,
                    "length_improvement": 18.59336214832944,
                    "smoothness_improvement": 1031.997231565094,
                    "objective_score": 26.93516244440943
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08384654521942139,
                    "num_nodes_avg": 497.1,
                    "path_length_avg": 126.5300559409724,
                    "smoothness_avg": 0.10181377497082089,
                    "success_improvement": 0.0,
                    "time_improvement": -68.20995567051928,
                    "length_improvement": 15.96476155780388,
                    "smoothness_improvement": 1195.0637025177039,
                    "objective_score": -11.294715877006485
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a tuned and enhanced bidirectional RRT* planner incorporating informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, and efficient rewiring to improve path quality and planning speed across 2D and 3D maps. It balances exploration and exploitation for robust navigation in cluttered spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using informed elliptical sampling within a heuristic cost-bound, adaptively adjusts step size to avoid obstacles, prunes nodes unlikely to improve the solution, rewires neighbors to reduce path cost, and connects the two trees when proximity and collision-free conditions are met. The best path is updated dynamically to optimize both quality and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        a1_unit = a1 / norm_a1\n\n        # Precompute rotation matrix C for informed sampling\n        # Construct orthonormal basis via SVD for rotation\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune branch if potential cost worse than current best\n            heuristic_remaining = math.dist(new_pos, goal)\n            if cost + heuristic_remaining >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes within radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection between trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connection_dist = math.dist(new_node.position, other_nearest.position)\n            if connection_dist <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + connection_dist + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # Remove duplicate connecting node position\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            if success and (i % 100 == 0):\n                # Early stop if path found and improved recently\n                if c_best < float(\"inf\"):\n                    break\n\n        # Optional path smoothing (simple shortcut)\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:  # numerical issues if c_best < c_min due to float rounding\n            r2 = 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance * 1.5))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.35, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut path segment between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.79647,
          "time_improvement": -65.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 917.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0779529094696045,
                    "num_nodes_avg": 434.8,
                    "path_length_avg": 167.29084808809012,
                    "smoothness_avg": 0.01983996215756792,
                    "success_improvement": 0.0,
                    "time_improvement": -210.52815530292239,
                    "length_improvement": 8.305235269791412,
                    "smoothness_improvement": 210.53849093333312,
                    "objective_score": -60.44470708225177
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08757963180541992,
                    "num_nodes_avg": 652.5,
                    "path_length_avg": 239.06042775471852,
                    "smoothness_avg": 0.06625774840202739,
                    "success_improvement": 0.0,
                    "time_improvement": 46.90314760246064,
                    "length_improvement": 20.19474824258794,
                    "smoothness_improvement": 1604.8595899113393,
                    "objective_score": 26.13419187881248
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06488139629364013,
                    "num_nodes_avg": 509.2,
                    "path_length_avg": 125.80514296258566,
                    "smoothness_avg": 0.08145784525964582,
                    "success_improvement": 0.0,
                    "time_improvement": -30.162748695657164,
                    "length_improvement": 16.446214241401773,
                    "smoothness_improvement": 936.1377791099944,
                    "objective_score": -1.0788928648668232
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 15.397605499726785,
          "time_improvement": -51.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03258261680603027,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -29.793999487135647,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -8.979796324742384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23828883171081544,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -44.46723130147098,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -13.698434341848035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08907036781311035,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -78.68980268884992,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -23.514585832589937
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an Adaptive Bidirectional RRT* with Dynamic Informed Sampling and Progressive Randomized Shortcut Smoothing. It integrates elliptical informed sampling that tightens progressively on improved solutions, adaptive step sizes based on obstacle proximity, and neighborhood rewiring for continual path quality enhancement. The planner balances exploration and exploitation by alternating tree expansions bidirectionally and pruning nodes that cannot improve current best solutions. A multi-pass randomized smoothing phase refines the final path, promoting smoothness and shorter lengths while strictly maintaining collision-free constraints, thus achieving improved efficiency, robustness, quality, and success rate.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points within an adaptively shrinking ellipsoidal informed set guided by the best path cost found so far. It uses adaptive stepping controlled by local obstacle density, adds nodes only if they are collision-free, and rewires neighborhoods for path improvement dynamically. On finding a connecting path, it prunes nodes that can't improve and performs iterative randomized shortcut smoothing in multiple passes, resulting in higher-quality smooth paths and reduced overall planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, base_step: float = 6.0, rewire_radius: float = 15.0,\n                 smoothing_passes: int = 3, smoothing_trials_per_pass: int = 50):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.rewire_radius = rewire_radius\n        self.smoothing_passes = smoothing_passes\n        self.smoothing_trials_per_pass = smoothing_trials_per_pass\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Compute minimal possible path length between start and goal\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min < 1e-14:\n            # Start == goal\n            return PlannerResult(True, [start_pos], [], [])\n\n        # Initialization\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_sign = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1.0] * (dim - 1) + [det_sign]) @ Vt\n\n        def informed_sample():\n            # If no solution found, sample uniformly in space\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = best_cost / 2.0\n            val = best_cost ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample uniformly inside unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if in_bounds(x_rand):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            steps_check = max(8, int(dist_ * 3.0))\n            reduction = 1.0\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction = 0.35\n                    break\n            return max(self.base_step * reduction, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, node):\n            return [n for n in tree if n is not node and math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            neighs = neighbors(tree, new_node)\n            for near in neighs:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, new_cost)\n                        # Update edges: Remove old edge and add new edge\n                        replaced = False\n                        for i, (p, c) in enumerate(edges):\n                            if c == near:\n                                edges[i] = (new_node, near)\n                                replaced = True\n                                break\n                        if not replaced:\n                            edges.append((new_node, near))\n\n        def prune_nodes(tree, other_goal_pos):\n            nonlocal best_cost, all_nodes, edges\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                heuristic = node.cost + math.dist(node.position, other_goal_pos)\n                if heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in all_nodes:\n                    all_nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n\n        def try_connection(new_node, other_tree):\n            nonlocal best_cost, best_path, success\n            # Check all nodes within step distance for possible connection\n            for other_node in other_tree:\n                dist_conn = math.dist(new_node.position, other_node.position)\n                if dist_conn <= self.base_step:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_conn + other_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            path_from_start = new_node.path_from_root() if new_node in tree_start else other_node.path_from_root()\n                            path_from_goal = other_node.path_from_root() if other_node in tree_goal else new_node.path_from_root()\n                            if path_from_start[-1] == path_from_goal[-1]:\n                                combined_path = path_from_start + path_from_goal[-2::-1]\n                            else:\n                                combined_path = path_from_start + path_from_goal[::-1]\n                            best_path = combined_path\n                            success = True\n\n        def multi_pass_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_passes):\n                if len(smoothed) < 3:\n                    break\n                for _ in range(self.smoothing_trials_per_pass):\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) - 1)\n                    a, b = smoothed[i], smoothed[j]\n                    if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                        smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < 0.1 and tree_b:\n                sample = tree_b[0].position  # Goal bias to opposite root\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal_pos if tree_a is tree_start else start_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                # Discard node that can\u2019t improve the best cost\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune_nodes(tree_a, goal_pos if tree_a is tree_start else start_pos)\n\n            try_connection(new_node, tree_b)\n\n            if success and itr > 200 and itr % 50 == 0:\n                # Early stopping if stable solution\n                break\n\n        if success and best_path:\n            best_path = multi_pass_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.06124,
          "time_improvement": -34.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1522.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.07142696380615235,
                    "num_nodes_avg": 222.3,
                    "path_length_avg": 160.100417602488,
                    "smoothness_avg": 0.0443990807496148,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -184.5318213332574,
                    "length_improvement": 12.246424158612312,
                    "smoothness_improvement": 594.9420278784813,
                    "objective_score": -99.93555142886234
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05235316753387451,
                    "num_nodes_avg": 316.9,
                    "path_length_avg": 237.2054630413984,
                    "smoothness_avg": 0.104299823465584,
                    "success_improvement": 0.0,
                    "time_improvement": 68.25987559224068,
                    "length_improvement": 20.81398885609306,
                    "smoothness_improvement": 2583.7095818957787,
                    "objective_score": 37.55930835836971
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04286811351776123,
                    "num_nodes_avg": 264.3,
                    "path_length_avg": 127.52484700111665,
                    "smoothness_avg": 0.11685377250645593,
                    "success_improvement": 0.0,
                    "time_improvement": 13.999515953447347,
                    "length_improvement": 15.304068702515913,
                    "smoothness_improvement": 1386.3713610338411,
                    "objective_score": 14.192525331706593
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* style planner with simplified adaptive sampling, collision checking, rewiring, and path smoothing to efficiently find high-quality paths. It balances exploration and exploitation inside an ellipsoidal informed subset around the current best path cost, employs collision-aware node and edge validations to ensure feasibility and robustness, and refines the solution with rewiring and shortcutting to minimize path length and unnecessary turns.",
          "planning_mechanism": "The planner initializes with start and goal nodes, then iteratively samples points within an informed ellipsoid defined by the current best path cost. It grows two trees bidirectionally towards these samples using an adaptive step size that respects obstacle proximity and bounds. Nodes and edges are collision-checked before addition. Nearby nodes are rewired to improve path costs. The trees try to connect when close enough to form a feasible path, which is then smoothed by shortcutting. The process repeats until success or iteration limit, returning the optimized path along with explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        c_best = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path = []\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n\n            # Create rotation matrix C to align x-axis with a1\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim -1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = 0.0 if c_best**2 - c_min**2 < 0 else math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            steps = max(3, int(d))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[j] + (to_pos[j] - from_pos[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.25, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = sum((node.position[d] - pos[d])**2 for d in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_pos)\n\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            neighbors = near_nodes(active_tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes with costs exceeding best path cost in active tree\n            to_remove = []\n            for node in active_tree:\n                if node is start_root or node is goal_root or node is new_node:\n                    continue\n                if node.cost + dist(node.position, goal_pos) >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Attempt connection to other tree\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_start = new_node.path_from_root()\n                        path_goal = other_nearest.path_from_root()\n                        best_path = path_start + path_goal[::-1][1:]\n                        success = True\n\n            if success:\n                break\n\n        def path_shortcut(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = path_shortcut(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.63367,
          "time_improvement": -37.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1558.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.05051796436309815,
                    "num_nodes_avg": 271.3,
                    "path_length_avg": 161.6651415840813,
                    "smoothness_avg": 0.044095160834522154,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -101.2400869969893,
                    "length_improvement": 11.388774149662845,
                    "smoothness_improvement": 590.1850212346226,
                    "objective_score": -75.1433461629911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07712218761444092,
                    "num_nodes_avg": 437.4,
                    "path_length_avg": 236.53986249586342,
                    "smoothness_avg": 0.09541272410526459,
                    "success_improvement": 0.0,
                    "time_improvement": 53.24317620520197,
                    "length_improvement": 21.03618547644208,
                    "smoothness_improvement": 2355.038114235826,
                    "objective_score": 31.955380528028137
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0808384895324707,
                    "num_nodes_avg": 365.9,
                    "path_length_avg": 125.75606212823922,
                    "smoothness_avg": 0.14377095677032287,
                    "success_improvement": 0.0,
                    "time_improvement": -62.17530138115893,
                    "length_improvement": 16.478811394596494,
                    "smoothness_improvement": 1728.7559580503575,
                    "objective_score": -6.713048345176592
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates bidirectional tree growth with dynamic informed sampling inside an ellipsoidal region, adaptive step sizing based on local obstacle proximity, cost-aware node pruning, and local rewiring to enhance convergence speed, path quality, and robustness. The planner further applies iterative shortcut smoothing on the final path to improve smoothness and path length reduction. It alternates tree growing direction each iteration to maintain balanced exploration, and prunes nodes and edges unlikely to improve the current best solution, thus reducing search time and improving efficiency.",
          "planning_mechanism": "The planning mechanism initializes two trees from start and goal, alternately samples points informed by the current best path cost, and adaptively extends towards samples using collision-free checks and adaptive step sizing. It rewires neighbors to optimize local costs, prunes branches exceeding best cost, and attempts to connect the two trees. Once a connecting path is found, iterative shortcut smoothing is applied to generate a smoother, shorter final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...] (W,H) or (W,H,D)\n        goal = map.goal                    # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1]*(dim-1) + [det_val]) @ Vt\n\n        def informed_sample():\n            # With goal_sample_rate, sample goal directly (to encourage connection)\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float('inf'):\n                # Uniform random sampling in entire bounds\n                for _ in range(100):\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                x_rand_t = tuple(x_rand)\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                    return x_rand_t\n            # fallback uniform\n            for _ in range(100):\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Use finer sampling to detect nearby obstacle on the segment\n            steps = max(5, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # If near obstacle, reduce step size conservatively\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n is not new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node under new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicate connecting node if exists\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def shortcut_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path\n            length = len(path)\n            for _ in range(max_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iter_idx in range(self.max_iter):\n            # Alternate tree selection for growth\n            tree_a, tree_b = (tree_start, tree_goal) if iter_idx % 2 == 0 else (tree_goal, tree_start)\n            root_a = tree_a[0]\n            root_b = tree_b[0]\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Enforce map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision node check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Collision edge check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Calculate cost to new node\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal if tree_a is tree_start else start)\n            if new_cost + heuristic_remain >= best_cost:\n                # Prune unpromising node\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring to reduce costs\n            rewire(tree_a, new_node)\n\n            # Try connecting trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    success_state = True\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n\n            # Early break if a good path is found and iter multiples of 100\n            if success_state and iter_idx % 100 == 0 and best_cost < float('inf'):\n                break\n\n        if success_state and best_path:\n            best_path = shortcut_smoothing(best_path, max_iters=150)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 18.84234,
          "time_improvement": -41.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1391.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.06633493900299073,
                    "num_nodes_avg": 315.7,
                    "path_length_avg": 159.59419174422138,
                    "smoothness_avg": 0.03602485481774475,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -164.24756151997798,
                    "length_improvement": 12.5238945731903,
                    "smoothness_improvement": 463.8672071220442,
                    "objective_score": -94.4501535057451
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06623361110687256,
                    "num_nodes_avg": 479.3,
                    "path_length_avg": 237.2645867834746,
                    "smoothness_avg": 0.08928854718770776,
                    "success_improvement": 0.0,
                    "time_improvement": 59.84458714657445,
                    "length_improvement": 20.79425164920546,
                    "smoothness_improvement": 2197.4586310807517,
                    "objective_score": 33.099519629217184
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059464025497436526,
                    "num_nodes_avg": 398.6,
                    "path_length_avg": 127.5776912157896,
                    "smoothness_avg": 0.12670194869028087,
                    "success_improvement": 0.0,
                    "time_improvement": -19.294612160091233,
                    "length_improvement": 15.268972091301238,
                    "smoothness_improvement": 1511.6394351753434,
                    "objective_score": 4.823607946109594
               }
          ],
          "success_rate": 0.9666666666666667
     }
]