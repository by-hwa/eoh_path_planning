[
     {
          "operator": "m3",
          "algorithm_description": "This algorithm presents an enhanced bidirectional RRT with goal biasing and simplified structure to improve efficiency and path quality. It grows two trees simultaneously\u2014from start and goal\u2014and attempts to connect them, alternating expansion in each iteration. Goal biasing increases convergence speed toward the goal. The approach includes collision checks for nodes and edges, pruning redundant exploration, and incremental connection attempts to improve robustness and success rate. Path extraction merges the two trees into a smooth, feasible path.",
          "planning_mechanism": "The planner alternates growing start and goal trees by steering towards samples, employs goal biasing to guide exploration, performs collision-free extension checks, and attempts to connect the two trees incrementally. Upon connecting, it extracts a final path by tracing parents from both trees, ensuring a feasible, smooth solution with reduced search overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for itr in range(self.max_iter):\n            # Alternate start and goal tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try connecting trees\n                near_connect = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_connect = math.dist(new_pos, near_connect.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, near_connect.position, obstacles, is_3d):\n                        conn_node = Node(near_connect.position, parent=new_node, cost=new_node.cost + dist_connect)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Reconstruct path\n                        path = self._extract_path(conn_node, near_connect)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        # Extract path from node_a up to root start tree\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        # Extract path from node_b up to root goal tree\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        # Since node_b belongs to opposite tree, append its reversed path (excluding first duplicate node)\n        return path_a + path_b[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.73192,
          "time_improvement": 85.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0071019411087036135,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 183.5187018824448,
                    "smoothness_avg": 0.010997871352320374,
                    "success_improvement": 0.0,
                    "time_improvement": 71.70916792508382,
                    "length_improvement": -0.5895085416933348,
                    "smoothness_improvement": 72.14056892370422,
                    "objective_score": 21.755551513805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011534762382507325,
                    "num_nodes_avg": 259.9,
                    "path_length_avg": 309.6814971266057,
                    "smoothness_avg": 0.0064039069277323805,
                    "success_improvement": 0.0,
                    "time_improvement": 93.00682632435114,
                    "length_improvement": -3.3805974285229334,
                    "smoothness_improvement": 64.77713779827361,
                    "objective_score": 27.549814100592123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004734683036804199,
                    "num_nodes_avg": 190.4,
                    "path_length_avg": 169.66580872434636,
                    "smoothness_avg": 0.01221306295668852,
                    "success_improvement": 0.0,
                    "time_improvement": 90.50144735658925,
                    "length_improvement": -12.68395153709525,
                    "smoothness_improvement": 55.34925933454292,
                    "objective_score": 24.89039019623044
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.708608753841677,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010948657989501953,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.38563599927819,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 18.510996063035716
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02024111747741699,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 87.7284294886342,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 29.95681957631103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01007375717163086,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.7903867971998,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.65801062217829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm improves bidirectional RRT by integrating goal biasing, adaptive neighborhood rewiring for asymptotic optimality, and incremental connection attempts. It dynamically adjusts search radius for rewiring based on the current tree size, promoting better path quality and smoother solution convergence while maintaining computational efficiency.",
          "planning_mechanism": "The planner grows two trees simultaneously\u2014from start and goal\u2014alternating expansion with goal biasing to accelerate convergence. At each iteration, it samples free points biased towards the opposite tree\u2019s root, extends the tree towards the sample with collision checks, and rewires neighbors within an adaptive radius to optimize path cost. Incremental connections are attempted to link the two trees. On success, the combined path is extracted, ensuring a smooth, collision-free solution with reduced planning time and improved robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = 50.0  # Base radius factor for rewiring; adaptive with tree size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def get_rewire_radius(tree_size):\n            # Adaptive radius: decreases as tree grows, promoting efficiency & quality\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)  # never too small\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-6 < neighbor.cost:  # small tolerance for floating\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor's parent link to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass  # safety\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def steer_and_add(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # Rewire neighbors for optimization\n            rewire(tree, new_node)\n            return new_node\n\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_pos), (goal_tree, start_tree, start_pos)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = steer_and_add(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Try incrementally connecting tree_b to new_node\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n                connection_made = False\n                min_cost_connect = float('inf')\n                best_node_b = None\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_cost_connect:\n                            min_cost_connect = total_cost\n                            best_node_b = nb\n                if best_node_b is not None:\n                    # Connect best_node_b to new_node\n                    # Attach new connection node in tree_b to unify paths\n                    conn_pos = best_node_b.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n                    # Rewire around conn_node\n                    rewire(tree_a, conn_node)\n\n                    # Extract path\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    path_goal = []\n                    cur = best_node_b\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    extracted_path = path_start + path_goal[1:]\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # Failed to find path\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.73056,
          "time_improvement": 73.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 121.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009549236297607422,
                    "num_nodes_avg": 121.2,
                    "path_length_avg": 192.66512918026064,
                    "smoothness_avg": 0.013418041999981825,
                    "success_improvement": 0.0,
                    "time_improvement": 61.96028150554178,
                    "length_improvement": -5.602810278041514,
                    "smoothness_improvement": 110.0214950442843,
                    "objective_score": 18.01762987127565
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011700725555419922,
                    "num_nodes_avg": 221.2,
                    "path_length_avg": 276.3360727399123,
                    "smoothness_avg": 0.009187848167700855,
                    "success_improvement": 0.0,
                    "time_improvement": 92.90620792811096,
                    "length_improvement": 7.751065026579014,
                    "smoothness_improvement": 136.40995109448716,
                    "objective_score": 30.104125139221527
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017450571060180664,
                    "num_nodes_avg": 268.9,
                    "path_length_avg": 150.66020077595874,
                    "smoothness_avg": 0.017056656809840934,
                    "success_improvement": 0.0,
                    "time_improvement": 64.9912852488248,
                    "length_improvement": -0.06133168757321738,
                    "smoothness_improvement": 116.95941562973272,
                    "objective_score": 20.06991631528146
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.068321752434553,
          "time_improvement": 67.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008623981475830078,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 65.64606661538022,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 19.43545600969078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017321276664733886,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.49863967859932,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.230659824248814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026317262649536134,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 47.2032440685165,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 13.53884942336407
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm integrates a hybrid approach combining informed sampling, bidirectional growth, and heuristic-driven rewiring to improve convergence speed, path quality, and robustness. It grows two trees from start and goal simultaneously using informed sampling within ellipsoidal informed sets when solutions exist, aggressively rewires locally to optimize paths during bidirectional expansions, and uses dynamic goal biasing. This approach balances exploration and exploitation efficiently for faster, smoother, and shorter paths with high success rates.",
          "planning_mechanism": "The planner alternates expansions of two trees rooted at start and goal. Initially, uniform random samples guide exploration; after a valid path is found, sampling is restricted inside an ellipsoidal informed subset around the best path to focus search. Each new node connects to the best local parent and triggers rewiring to reduce path costs. The two trees attempt connection after each expansion, producing a refined, smooth path by merging. Collision and boundary checks prevent invalid nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Initialize cost and solution tracking\n        best_cost = float(\"inf\")\n        c_min = self._euclidean(start_pos, goal_pos)\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Helper: check if pos within map bounds\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Ellipsoidal informed sampling: sample in unit ball scaled and rotated\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            import random\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute ellipse parameters\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            length = np.linalg.norm(a1)\n            a1 = a1 / length\n\n            L = np.diag([c_best / 2.0] + [((c_best ** 2 - c_min ** 2) ** 0.5) / 2.0] * (dim - 1))\n\n            # Rotation matrix via SVD\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            while True:\n                # Sample from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball = x_ball / norm * (random.random() ** (1.0 / dim))\n                x_rand = C @ (L @ x_ball) + center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n\n        # Find nearest node in a tree to given point\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: self._euclidean(n.position, point))\n\n        # Find nodes near a position within a radius\n        def near_nodes(tree, pos, radius=15.0):\n            return [node for node in tree if self._euclidean(node.position, pos) <= radius]\n\n        # Rewire nodes in near_nodes to new_node if cheaper and collision free\n        def rewire(tree, new_node, near_n):\n            for node in near_n:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + self._euclidean(new_node.position, node.position)\n                if potential_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        # Merge paths from two nodes, stitching start and goal trees\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal[1:]\n\n        for itr in range(self.max_iter):\n            # Alternate between start_tree and goal_tree for expansion\n            for tree_a, tree_b, is_start_tree_expansion in [(start_tree, goal_tree, True), (goal_tree, start_tree, False)]:\n\n                # Determine sampling strategy: informed sampling if solution found else uniform\n                if best_cost < float(\"inf\"):\n                    sample = informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if is_start_tree_expansion else start_pos\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                # Find nearest node & steer towards sample\n                nearest = nearest_node(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest.cost + self._euclidean(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire near nodes to new_node in tree_a\n                near_n = near_nodes(tree_a, new_pos, radius=20.0)\n                rewire(tree_a, new_node, near_n)\n\n                # Attempt connection to opposite tree\n                near_in_b = near_nodes(tree_b, new_pos, radius=self.step_size * 1.5)\n                connect_node = None\n                min_connect_cost = float(\"inf\")\n                for nbr in near_in_b:\n                    dist = self._euclidean(new_pos, nbr.position)\n                    if dist <= self.step_size and not self._is_edge_in_obstacle(new_pos, nbr.position, obstacles, is_3d):\n                        total_cost = new_node.cost + dist + nbr.cost\n                        if total_cost < min_connect_cost:\n                            min_connect_cost = total_cost\n                            connect_node = nbr\n\n                if connect_node is not None:\n                    # Connect trees by adding edge and update solution if better\n                    if is_start_tree_expansion:\n                        # Connect connect_node parent rewritten to new_node\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in start tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        # Update solution path if cost improved\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = conn_node\n                            solution_node_goal = connect_node\n                            success = True\n                    else:\n                        # Connecting from goal tree expansion\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in goal tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = connect_node\n                            solution_node_goal = conn_node\n                            success = True\n\n            if success and solution_node_start and solution_node_goal:\n                extracted_path = extract_path(solution_node_start, solution_node_goal)\n                break\n\n        # Post-process path smoothing via shortcutting (optional, simple straight-line shortcuts)\n        if success and len(extracted_path) > 3:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _euclidean(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._euclidean(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _smooth_path(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            p_start = smoothed[i]\n            p_end = smoothed[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = self._euclidean(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.36588,
          "time_improvement": 33.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1240.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022878527641296387,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 180.38439431350918,
                    "smoothness_avg": 0.02957517506587525,
                    "success_improvement": 0.0,
                    "time_improvement": 8.862580847365873,
                    "length_improvement": 1.128455103121995,
                    "smoothness_improvement": 362.9157133015363,
                    "objective_score": 4.699043841341842
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03743283748626709,
                    "num_nodes_avg": 288.3,
                    "path_length_avg": 237.52161712099596,
                    "smoothness_avg": 0.08105711587400938,
                    "success_improvement": 0.0,
                    "time_improvement": 77.30561540558567,
                    "length_improvement": 20.708447524332772,
                    "smoothness_improvement": 1985.6579745189633,
                    "objective_score": 37.26166399913707
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044042229652404785,
                    "num_nodes_avg": 294.7,
                    "path_length_avg": 129.5781252975168,
                    "smoothness_avg": 0.11565553498213739,
                    "success_improvement": 0.0,
                    "time_improvement": 11.644045940418264,
                    "length_improvement": 13.940379024652591,
                    "smoothness_improvement": 1371.1298681692033,
                    "objective_score": 13.136938927902015
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates bidirectional RRT* with informed sampling and adaptive rewiring. It alternates expanding two trees from start and goal while focusing search inside an ellipsoidal informed set around the best solution cost. Adaptive step sizing ensures safe exploration near obstacles. Continuous rewiring optimizes costs, and pruning discards inefficient nodes. A final smoothing step improves path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally, samples points inside an informed ellipsoid to bias search toward promising areas, uses adaptive stepping to navigate safely near obstacles, performs rewiring of neighbors to optimize costs in both trees, prunes nodes unlikely to improve the solution, attempts to connect the two trees for path updates, and performs path shortcutting for smoothness before returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_heuristic(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy as np\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample in unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            # Check points along the path; reduce step if near obstacle\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            # Try connect trees\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                # Optional: continue to improve path, here break for speed\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -13.0185,
          "time_improvement": 4.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1743.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049403262138366696,
                    "num_nodes_avg": 268.8,
                    "path_length_avg": 165.4484773217101,
                    "smoothness_avg": 0.05793713667543628,
                    "success_improvement": 0.0,
                    "time_improvement": -96.79963149746891,
                    "length_improvement": 9.315067881077315,
                    "smoothness_improvement": 806.8420014765672,
                    "objective_score": -23.142665865642375
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03950042724609375,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 238.45172325330878,
                    "smoothness_avg": 0.1098670141892697,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0520989653694,
                    "length_improvement": 20.397951325746124,
                    "smoothness_improvement": 2726.957409101609,
                    "objective_score": 40.530007000268085
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0327894926071167,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 128.51545696165562,
                    "smoothness_avg": 0.14109008407790408,
                    "success_improvement": 0.0,
                    "time_improvement": 34.21888661639979,
                    "length_improvement": 14.646152734503213,
                    "smoothness_improvement": 1694.655455284229,
                    "objective_score": 21.668173808241725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed elliptical sampling, dynamic adaptive step sizing near obstacles, node rewiring for cost optimization, and pruning of inefficient nodes. It grows two trees from start and goal, alternates expansion, employs sampling within an informed subset to focus search towards promising regions, adapts step sizes considering obstacle proximity to safely explore narrow passages, applies rewiring to improve path cost continuously, and prunes branches unlikely to yield better solutions.",
          "planning_mechanism": "The planner iteratively samples random points within an ellipsoidal informed subset defined by the current best path cost to goal, steers from the nearest node with an adaptive step size, validates node and edge collisions rigorously, attempts to rewire neighbors within a radius to minimize costs, prunes nodes with costs exceeding the current best, and tries to connect two trees to update the best path. The process stops upon success or iteration limit, returning an optimized, feasible path with improved efficiency and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_with_heuristic(node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        for iter_num in range(self.max_iter):\n            # Alternate trees\n            if iter_num % 2 == 0:\n                active_tree, other_tree = tree_a, tree_b\n            else:\n                active_tree, other_tree = tree_b, tree_a\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Do not exceed bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes with cost + heuristic worse than best known path\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius to reduce cost\n            neighbors = [node for node in active_tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                    # Add new edge\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes in active tree that have cost + heuristic worse than c_best\n            to_remove = []\n            for node in active_tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node != new_node and node != start_root and node != goal_root:\n                        to_remove.append(node)\n            for node in to_remove:\n                # Remove from parent's children\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                # Remove children links to avoid dangling references\n                node.children = []\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Try to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            # Early termination if found a path\n            if success_state:\n                # Optionally continue to improve path or break to return first good path\n                # Here, break after first path found\n                break\n\n        # Path smoothing: shortcut path by removing unnecessary nodes if possible\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shorten_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            # Start and goal are basically the same point, return it\n            return tuple(x_center)\n\n        a1 = diff / norm_diff\n\n        # Create rotation matrix C to rotate the unit vector to a1 direction\n        # Reference: https://arxiv.org/pdf/1109.4115.pdf\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim -1) + [det]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample uniformly inside unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            radius = random.random() ** (1 / dim)\n            x_ball = x_ball * radius\n\n            # Transform to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacles, but at least 1.0\n                return max(self.base_step * 0.25, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shorten_path(self, path, obstacles, is_3d):\n        # Attempts to shortcut the path by removing intermediate nodes when the\n        # straight-line path between non-adjacent nodes is collision-free.\n        import math\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.35232,
          "time_improvement": 6.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04930014610290527,
                    "num_nodes_avg": 240.5,
                    "path_length_avg": 169.95054568747466,
                    "smoothness_avg": 0.05415383468147165,
                    "success_improvement": 0.0,
                    "time_improvement": -96.38886514516909,
                    "length_improvement": 6.84741286996326,
                    "smoothness_improvement": 747.6251096992462,
                    "objective_score": -23.80905142106184
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047037577629089354,
                    "num_nodes_avg": 372.1,
                    "path_length_avg": 237.86859110536346,
                    "smoothness_avg": 0.09317261083841849,
                    "success_improvement": 0.0,
                    "time_improvement": 71.4825551897902,
                    "length_improvement": 20.59261762125851,
                    "smoothness_improvement": 2297.3983863915073,
                    "objective_score": 37.0502820131463
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028564262390136718,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 128.01701657407608,
                    "smoothness_avg": 0.13383198531076218,
                    "success_improvement": 0.0,
                    "time_improvement": 42.6953931395489,
                    "length_improvement": 14.977193106752848,
                    "smoothness_improvement": 1602.332974703307,
                    "objective_score": 23.815721436731774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional RRT's dual-tree growth and adaptive rewiring for path quality and convergence speed with single-tree incremental extension and goal biasing from classic RRT. It uses adaptive neighborhood rewiring, incremental attempts to connect the two trees, and refined collision checks to improve path smoothness, robustness, and planning efficiency. The planner dynamically adjusts rewiring radius, integrates both exploration and exploitation, and ensures collision-free nodes and edges, aiming for shorter, smoother paths with higher success rates and reduced computation time.",
          "planning_mechanism": "The planner grows two trees simultaneously, rooted at start and goal, alternately expanding them with goal biasing towards the opposite root to accelerate convergence. It incrementally extends each tree towards sampled points, performs adaptive rewiring around new nodes, and attempts to connect the two trees within an adaptive radius. On successful connection, it extracts a smooth, optimized path. The connection attempts are collision-checked for both nodes and edges, and rewiring dynamically refines the path quality during search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, rewire_factor: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # base factor for adaptive rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def get_rewire_radius(tree_size):\n            dim = len(bounds)\n            gamma = self.rewire_factor\n            # Adaptive radius shrinks as tree grows, remains above step_size*1.5\n            r = gamma * (math.log(tree_size + 1) / (tree_size + 1)) ** (1/dim)\n            return max(r, self.step_size * 1.5)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def can_connect(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node):\n            radius = get_rewire_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            improved = False\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        improved = True\n            return improved\n\n        def extend(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            new_pos = steer(nearest.position, target_pos)\n            if not can_connect(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            rewire(tree, new_node)\n            return new_node\n\n        # Initialize trees and data\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Alternate growing start and goal trees\n        for itr in range(self.max_iter):\n            for tree_a, tree_b, bias_target in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                # Sampling with goal biasing towards opposite root to accelerate connection\n                if random.random() < self.goal_sample_rate:\n                    sample = bias_target\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                new_node = extend(tree_a, sample)\n                if new_node is None:\n                    continue\n\n                # Attempt incremental connection from opposite tree within rewiring radius\n                radius = get_rewire_radius(len(tree_b))\n                neighbors_b = near_nodes(tree_b, new_node.position, radius)\n\n                best_connect_node = None\n                min_total_cost = float('inf')\n                for nb in neighbors_b:\n                    dist_connect = math.dist(nb.position, new_node.position)\n                    if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d):\n                        total_cost = nb.cost + dist_connect + new_node.cost\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            best_connect_node = nb\n\n                if best_connect_node is not None:\n                    # Link the two trees by connecting new_node and best_connect_node\n                    # Attach best_connect_node as child of new_node to unify paths directionally\n                    conn_pos = best_connect_node.position\n                    conn_node = Node(conn_pos, parent=new_node, cost=new_node.cost + math.dist(new_node.position, conn_pos))\n                    new_node.children.append(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Rewire around new connecting node for further optimization\n                    rewire(tree_a, conn_node)\n\n                    # Extract path from start tree root to conn_node\n                    path_start = []\n                    cur = conn_node\n                    while cur:\n                        path_start.append(cur.position)\n                        cur = cur.parent\n                    path_start.reverse()\n\n                    # Extract path from goal tree root to best_connect_node\n                    path_goal = []\n                    cur = best_connect_node\n                    while cur:\n                        path_goal.append(cur.position)\n                        cur = cur.parent\n\n                    # Merge and finalize path (avoid duplicate connecting node)\n                    extracted_path = path_start + path_goal[1:]\n                    success = True\n                    break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.52794,
          "time_improvement": 65.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.014651799201965332,
                    "num_nodes_avg": 146.2,
                    "path_length_avg": 190.64801818491756,
                    "smoothness_avg": 0.011628860455521643,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 41.63404279568054,
                    "length_improvement": -4.497199778324836,
                    "smoothness_improvement": 82.01691860357275,
                    "objective_score": -37.999142523942936
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021097254753112794,
                    "num_nodes_avg": 292.1,
                    "path_length_avg": 307.3481346225392,
                    "smoothness_avg": 0.006738894083969708,
                    "success_improvement": 0.0,
                    "time_improvement": 87.20937964082658,
                    "length_improvement": -2.601653862549766,
                    "smoothness_improvement": 73.39659860975604,
                    "objective_score": 26.0094661127868
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0170501708984375,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 154.6829914042549,
                    "smoothness_avg": 0.013864129032996206,
                    "success_improvement": 0.0,
                    "time_improvement": 65.79455380665306,
                    "length_improvement": -2.7330776781827977,
                    "smoothness_improvement": 76.35069795615588,
                    "objective_score": 19.573504096140137
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a Hybrid Informed PRM-RRT Planner that combines Probabilistic Roadmap (PRM) sampling within an informed ellipsoidal heuristic to focus node generation around the promising region and a bidirectional RRT for fast tree growth between the start and goal. It adaptively refines the roadmap connections with collision-free edge rewiring to improve path quality. A shortcut smoothing step post planning reduces unnecessary turns, improving path smoothness while maintaining feasibility. This integration leverages heuristic guidance, roadmap efficiency, and RRT explorative strength to enhance planning efficiency, robustness, and path optimality.",
          "planning_mechanism": "The planner initially samples nodes biased within an ellipsoidal region defined by start, goal, and the best current solution cost, constructing a dense roadmap with collision-free connections. Two trees (start and goal) are grown simultaneously using RRT extensions connected via the roadmap nodes. When a connection between the two trees occurs via roadmap nodes, the path is reconstructed and subsequently smoothed by iterative random shortcutting checks. Collision checks are strictly enforced for nodes and edges. The strategy reduces the search space smartly and improves convergence speed and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def reconstruct_path(node_from_start, node_from_goal):\n        # Path from start tree root to node_from_start\n        path_start = []\n        node = node_from_start\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        # Path from goal tree root to node_from_goal\n        path_goal = []\n        node = node_from_goal\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        # Merge paths with no duplication at connection point\n        return path_start + path_goal[1:]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 6.0, roadmap_node_count: int = 150,\n                 connection_radius: float = 25.0, shortcut_trials: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.roadmap_node_count = roadmap_node_count         # Number of PRM nodes sampled\n        self.connection_radius = connection_radius           # Radius for PRM connections and rewiring\n        self.shortcut_trials = shortcut_trials               # Number of shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        # --- Helper: Euclidean distance ---\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        # --- Build informed ellipsoid for heuristic sampling ---\n        def informed_sample(c_best):\n            # If no path found yet, sample entire space uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Ellipsoidal heuristic sampling between start and goal\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # No path shorter than c_min possible so fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(bounds)))\n\n            # Rotation matrix aligns the ellipsoid with start-goal vector\n            dx = [goal_pos[d] - start_pos[d] for d in range(len(bounds))]\n            length = dist(start_pos, goal_pos)\n            if length == 0:\n                return center\n\n            unit_vec = tuple(x / length for x in dx)\n\n            # Construct orthonormal basis (QR or Gram-Schmidt)\n            # For 2D or 3D, construct orthogonal basis via cross products or perpendicular vectors.\n\n            def ortho_basis_2d(vec):\n                # vec is unit vector in 2D\n                return (-vec[1], vec[0])\n\n            def ortho_basis_3d(vec):\n                import numpy as np\n                v = np.array(vec)\n                # Find one vector orthogonal to v:\n                if abs(v[0]) < 1e-6 and abs(v[1]) < 1e-6:\n                    ortho1 = np.array([0,1,0])\n                else:\n                    ortho1 = np.array([-v[1], v[0], 0])\n                ortho1 /= np.linalg.norm(ortho1)\n                # Second orthogonal vector:\n                ortho2 = np.cross(v, ortho1)\n                ortho2 /= np.linalg.norm(ortho2)\n                return ortho1, ortho2\n\n            # Axes lengths of ellipsoid\n            a1 = c_best / 2\n            if is_3d:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n                a3 = a2\n            else:\n                a2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n            import numpy as np\n\n            if is_3d:\n                # Sample random point in unit ball\n                while True:\n                    sample = np.random.uniform(-1, 1, 3)\n                    if np.linalg.norm(sample) <= 1:\n                        break\n                # Scale by ellipsoid axis lengths\n                sample[0] *= a1\n                sample[1] *= a2\n                sample[2] *= a3\n\n                # Rotation matrix\n                ex = np.array(unit_vec)\n                ey, ez = ortho_basis_3d(unit_vec)\n                R = np.column_stack((ex, ey, ez))  # 3x3 rotation\n\n                mapped = R.dot(sample) + np.array(center)\n                m = tuple(mapped.tolist())\n\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n            else:\n                # 2D case\n                # Sample random point in ellipse\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x**2 + y**2 <= 1:\n                        break\n                sample_local = (x * a1, y * a2)\n\n                orth = ortho_basis_2d(unit_vec)\n                mapped = (center[0] + unit_vec[0] * sample_local[0] + orth[0] * sample_local[1],\n                          center[1] + unit_vec[1] * sample_local[0] + orth[1] * sample_local[1])\n                m = mapped\n                # Clamp to bounds\n                return tuple(min(max(m[d], 0), bounds[d]) for d in range(len(bounds)))\n\n        # --- Roadmap Sampling ---\n        # Initialize nodes list with start and goal nodes\n        nodes = [Node(start_pos, cost=0.0), Node(goal_pos, cost=0.0)]\n        edges = []\n\n        # Roadmap nodes sampled inside the informed ellipsoid or whole space early\n        c_best = float('inf')\n\n        # Sample roadmap nodes\n        for _ in range(self.roadmap_node_count):\n            p = informed_sample(c_best)\n            if not in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            # Add roadmap node with no parent (initially disconnected)\n            nodes.append(Node(p, parent=None, cost=float('inf')))\n\n        # Connect roadmap nodes if within radius and collision free\n        def near_nodes_rd(nodes_list, pos, radius):\n            return [n for n in nodes_list if dist(n.position, pos) <= radius]\n\n        # Build connection edges in roadmap with rewiring (similar to PRM*)\n        for n in nodes[2:]:\n            near = near_nodes_rd(nodes, n.position, self.connection_radius)\n            best_parent = None\n            best_cost = float('inf')\n            for other in near:\n                if other == n:\n                    continue\n                # Check collision of edge\n                if other.cost == float('inf'):\n                    # Not connected yet, ignore as parent candidate\n                    continue\n                if self._is_edge_in_obstacle(other.position, n.position, obstacles, is_3d):\n                    continue\n                cost_through_other = other.cost + dist(other.position, n.position)\n                if cost_through_other < best_cost:\n                    best_cost = cost_through_other\n                    best_parent = other\n            if best_parent:\n                n.parent = best_parent\n                n.cost = best_cost\n                best_parent.add_child(n)\n                edges.append((best_parent, n))\n\n        # Try rewiring for better costs after initial connections\n        improved = True\n        while improved:\n            improved = False\n            for n in nodes[2:]:\n                near = near_nodes_rd(nodes, n.position, self.connection_radius)\n                for other in near:\n                    if other == n or n.parent is None:\n                        continue\n                    cost_through_n = n.cost + dist(n.position, other.position)\n                    if cost_through_n + 1e-6 < other.cost and not self._is_edge_in_obstacle(n.position, other.position, obstacles, is_3d):\n                        # Rewire other under n\n                        if other.parent:\n                            try:\n                                edges.remove((other.parent, other))\n                                other.parent.children.remove(other)\n                            except ValueError:\n                                pass\n                        other.parent = n\n                        other.cost = cost_through_n\n                        n.add_child(other)\n                        edges.append((n, other))\n                        improved = True\n\n        # --- Bidirectional RRT growing on roadmap nodes ---\n        start_tree = [nodes[0]]   # start node\n        goal_tree = [nodes[1]]    # goal node\n\n        tree_nodes_set_start = {nodes[0]}\n        tree_nodes_set_goal = {nodes[1]}\n\n        def nearest(tree_nodes, p):\n            return min(tree_nodes, key=lambda n: dist(n.position, p))\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Heuristic: always try connecting through roadmap nodes for faster path\n        connected = False\n        connecting_node_start = None\n        connecting_node_goal = None\n\n        for itr in range(self.max_iter):\n            # Alternate trees\n            for tree_a, tree_b, set_a, set_b in [(start_tree, goal_tree, tree_nodes_set_start, tree_nodes_set_goal),\n                                                 (goal_tree, start_tree, tree_nodes_set_goal, tree_nodes_set_start)]:\n                # Sample in informed space\n                sample = informed_sample(c_best)\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_a = nearest(tree_a, sample)\n                new_pos = steer(nearest_a.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n                new_node.parent = nearest_a\n                nearest_a.add_child(new_node)\n                tree_a.append(new_node)\n                # Add to set for quick search\n                set_a.add(new_node)\n\n                # Try connect with nodes in tree_b via roadmap filtering for efficiency:\n                # Check roadmap nodes near new_node with radius\n                candidates_b = [n for n in tree_b if dist(n.position, new_node.position) <= self.connection_radius]\n                candidates_b.sort(key=lambda nn: dist(nn.position, new_node.position))\n\n                for candidate_b in candidates_b:\n                    d_connect = dist(new_node.position, candidate_b.position)\n                    if d_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, candidate_b.position, obstacles, is_3d):\n                        # Connect found, build connecting nodes in tree_a and tree_b appropriately\n                        connect_node_b = Node(candidate_b.position, parent=new_node,\n                                              cost=new_node.cost + d_connect)\n                        new_node.add_child(connect_node_b)\n                        tree_a.append(connect_node_b)\n                        set_a.add(connect_node_b)\n                        edges.append((new_node, connect_node_b))\n\n                        connected = True\n                        connecting_node_start = connect_node_b if tree_a is start_tree else candidate_b\n                        connecting_node_goal = candidate_b if tree_b is goal_tree else connect_node_b\n                        break\n                if connected:\n                    break\n            if connected:\n                break\n\n        if not connected:\n            # No path found\n            return PlannerResult(False, [], nodes, edges)\n\n        # Reconstruct path using Node static method\n        path = Node.reconstruct_path(connecting_node_start, connecting_node_goal)\n\n        # Append all nodes from start_tree and goal_tree plus roadmap nodes to nodes list\n        # (Avoid duplicates)\n        all_tree_nodes = set(start_tree + goal_tree + nodes[2:])\n\n        # Update edges with parent-child in the tree expansions\n        # We track edges from roadmap plus tree expansions\n        # Edges between roadmap nodes already added\n        # Add tree expansions edges\n        def update_edges(tree):\n            for n in tree:\n                if n.parent is not None and (n.parent, n) not in edges:\n                    edges.append((n.parent, n))\n\n        update_edges(start_tree)\n        update_edges(goal_tree)\n\n        # --- Shortcut smoothing ---\n        # Iteratively attempt random shortcuts on path\n        def path_smoothing(path):\n            smoothed_path = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                a = smoothed_path[i]\n                b = smoothed_path[j]\n                if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                    # Shortcut possible: replace intermediate points\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        path = path_smoothing(path)\n\n        return PlannerResult(True, path, list(all_tree_nodes), edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.83708,
          "time_improvement": -32.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1518.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.056850218772888185,
                    "num_nodes_avg": 212.3,
                    "path_length_avg": 173.14105868688912,
                    "smoothness_avg": 0.03300778700001848,
                    "success_improvement": 0.0,
                    "time_improvement": -126.46484504848468,
                    "length_improvement": 5.0986421380704305,
                    "smoothness_improvement": 416.64354410699883,
                    "objective_score": -34.83650736639632
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06818621158599854,
                    "num_nodes_avg": 375.5,
                    "path_length_avg": 239.8833934812037,
                    "smoothness_avg": 0.11265474635194206,
                    "success_improvement": 0.0,
                    "time_improvement": 58.66078519063724,
                    "length_improvement": 19.92001859533215,
                    "smoothness_improvement": 2798.687765569485,
                    "objective_score": 35.57567810410502
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06357545852661133,
                    "num_nodes_avg": 394.7,
                    "path_length_avg": 125.41948934045914,
                    "smoothness_avg": 0.1131210894393732,
                    "success_improvement": 0.0,
                    "time_improvement": -27.542822814089774,
                    "length_improvement": 16.702347014366147,
                    "smoothness_improvement": 1338.891907938553,
                    "objective_score": 1.7720820983390633
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional growth and connection of RRT trees with informed elliptical sampling, adaptive step sizing near obstacles, cost-based node pruning, and efficient rewiring to optimize path quality and computational efficiency. It balances exploration and exploitation by alternating between start and goal trees while guiding sampling within an informed ellipsoidal region that shrinks with better solutions. The planner dynamically adjusts step size near obstacles to navigate cluttered spaces robustly, prunes unpromising branches early based on heuristic cost bounds, and rewires nodes to improve path costs. Post-planning, the path is smoothed by shortcutting to enhance path quality and smoothness.",
          "planning_mechanism": "The planner starts two trees from start and goal points, alternately sampling points mostly within an informed ellipsoidal space defined by the current best solution cost. Each sampled point is connected by an adaptive step that shrinks near obstacles, ensuring collision-free growth. Branches unlikely to improve the current best cost are pruned. Nearby nodes are rewired if a lower-cost path is found. When the two trees can be connected collision-free within a proximity threshold, the path is updated. Finally, a shortcut smoothing step improves the path\u2019s smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n            except Exception:\n                r2 = 0.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n            for _ in range(100):  # limit tries to avoid infinite loop\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback random sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicated connecting position\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune nodes that cannot improve best cost\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Early stop if a good path is found\n            if success and i % 100 == 0 and c_best < float(\"inf\"):\n                break\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.12117,
          "time_improvement": -35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1039.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06026041507720947,
                    "num_nodes_avg": 332.6,
                    "path_length_avg": 166.996413064366,
                    "smoothness_avg": 0.016269651188625004,
                    "success_improvement": 0.0,
                    "time_improvement": -140.04948191203425,
                    "length_improvement": 8.466619771916111,
                    "smoothness_improvement": 154.6553712150155,
                    "objective_score": -39.54824376315197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06673438549041748,
                    "num_nodes_avg": 500.6,
                    "path_length_avg": 237.0038545493059,
                    "smoothness_avg": 0.07697310282156793,
                    "success_improvement": 0.0,
                    "time_improvement": 59.54098295254645,
                    "length_improvement": 20.88129157373222,
                    "smoothness_improvement": 1880.5733770839436,
                    "objective_score": 31.441420085930098
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06200351715087891,
                    "num_nodes_avg": 431.8,
                    "path_length_avg": 123.09804183051456,
                    "smoothness_avg": 0.09294490050814501,
                    "success_improvement": 0.0,
                    "time_improvement": -24.389249957430696,
                    "length_improvement": 18.244141915019977,
                    "smoothness_improvement": 1082.2522739846838,
                    "objective_score": 1.7433147656982069
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a novel hybrid RRT* planner incorporating bidirectional trees, adaptive informed sampling, dynamic step sizing near obstacles, cost-based pruning, and integrated path smoothing. It balances exploration and exploitation by growing two trees from start and goal, biases sampling inside an informed ellipsoid that shrinks as better paths are found, rewires nodes for cost improvement, prunes suboptimal branches early, and performs shortcut smoothing to enhance path quality and efficiency. This structure aims to improve planning success, robustness, and path optimality with reduced computational effort.",
          "planning_mechanism": "The planner alternates between expanding two RRT* trees from start and goal using adaptive step sizes and informed elliptical sampling. Nodes are connected only if collision checks pass, and rewiring optimizes the cost locally. Suboptimal nodes are pruned using heuristic cost bounds to speed up convergence. When trees connect, the solution path is extracted and shortcut smoothed to reduce unnecessary detours and ensure smoother, shorter paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_step) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (max_step/dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire_tree(tree: List[Node], new_node: Node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                heuristic_remain = distance(near_node.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                    new_node.add_child(near_node)\n                    near_node.cost = new_cost\n                    edges.append((new_node, near_node))\n\n        def extract_path(node_start: Node, node_goal: Node):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicated connection node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(tree: List[Node]):\n            # Remove nodes that cannot possibly improve solution cost\n            retained = []\n            for node in tree:\n                heuristic = distance(node.position, goal)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    # Disconnect subtree\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        for iteration in range(self.max_iter):\n            # Alternate growth direction\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire_tree(tree_a, new_node)\n\n            # Attempt to connect opposite tree\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Prune suboptimal nodes every 200 iterations to improve search speed\n            if iteration > 0 and iteration % 200 == 0 and success:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early stop\n            if success and iteration % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.4129,
          "time_improvement": -61.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 784.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06880130767822265,
                    "num_nodes_avg": 374.2,
                    "path_length_avg": 166.806844724353,
                    "smoothness_avg": 0.014419319321817486,
                    "success_improvement": 0.0,
                    "time_improvement": -174.07242784283554,
                    "length_improvement": 8.57052518297982,
                    "smoothness_improvement": 125.69365943951777,
                    "objective_score": -49.87915501905711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06566660404205323,
                    "num_nodes_avg": 490.7,
                    "path_length_avg": 243.85745597358306,
                    "smoothness_avg": 0.04399399704507752,
                    "success_improvement": 0.0,
                    "time_improvement": 60.18834618972689,
                    "length_improvement": 18.59336214832944,
                    "smoothness_improvement": 1031.997231565094,
                    "objective_score": 26.93516244440943
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08384654521942139,
                    "num_nodes_avg": 497.1,
                    "path_length_avg": 126.5300559409724,
                    "smoothness_avg": 0.10181377497082089,
                    "success_improvement": 0.0,
                    "time_improvement": -68.20995567051928,
                    "length_improvement": 15.96476155780388,
                    "smoothness_improvement": 1195.0637025177039,
                    "objective_score": -11.294715877006485
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a tuned and enhanced bidirectional RRT* planner incorporating informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, and efficient rewiring to improve path quality and planning speed across 2D and 3D maps. It balances exploration and exploitation for robust navigation in cluttered spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using informed elliptical sampling within a heuristic cost-bound, adaptively adjusts step size to avoid obstacles, prunes nodes unlikely to improve the solution, rewires neighbors to reduce path cost, and connects the two trees when proximity and collision-free conditions are met. The best path is updated dynamically to optimize both quality and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        a1_unit = a1 / norm_a1\n\n        # Precompute rotation matrix C for informed sampling\n        # Construct orthonormal basis via SVD for rotation\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune branch if potential cost worse than current best\n            heuristic_remaining = math.dist(new_pos, goal)\n            if cost + heuristic_remaining >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes within radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection between trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connection_dist = math.dist(new_node.position, other_nearest.position)\n            if connection_dist <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + connection_dist + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # Remove duplicate connecting node position\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            if success and (i % 100 == 0):\n                # Early stop if path found and improved recently\n                if c_best < float(\"inf\"):\n                    break\n\n        # Optional path smoothing (simple shortcut)\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:  # numerical issues if c_best < c_min due to float rounding\n            r2 = 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance * 1.5))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.35, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut path segment between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.79647,
          "time_improvement": -65.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 917.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0779529094696045,
                    "num_nodes_avg": 434.8,
                    "path_length_avg": 167.29084808809012,
                    "smoothness_avg": 0.01983996215756792,
                    "success_improvement": 0.0,
                    "time_improvement": -210.52815530292239,
                    "length_improvement": 8.305235269791412,
                    "smoothness_improvement": 210.53849093333312,
                    "objective_score": -60.44470708225177
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08757963180541992,
                    "num_nodes_avg": 652.5,
                    "path_length_avg": 239.06042775471852,
                    "smoothness_avg": 0.06625774840202739,
                    "success_improvement": 0.0,
                    "time_improvement": 46.90314760246064,
                    "length_improvement": 20.19474824258794,
                    "smoothness_improvement": 1604.8595899113393,
                    "objective_score": 26.13419187881248
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06488139629364013,
                    "num_nodes_avg": 509.2,
                    "path_length_avg": 125.80514296258566,
                    "smoothness_avg": 0.08145784525964582,
                    "success_improvement": 0.0,
                    "time_improvement": -30.162748695657164,
                    "length_improvement": 16.446214241401773,
                    "smoothness_improvement": 936.1377791099944,
                    "objective_score": -1.0788928648668232
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 15.397605499726785,
          "time_improvement": -51.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03258261680603027,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -29.793999487135647,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -8.979796324742384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23828883171081544,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -44.46723130147098,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -13.698434341848035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08907036781311035,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -78.68980268884992,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -23.514585832589937
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* style planner with simplified adaptive sampling, collision checking, rewiring, and path smoothing to efficiently find high-quality paths. It balances exploration and exploitation inside an ellipsoidal informed subset around the current best path cost, employs collision-aware node and edge validations to ensure feasibility and robustness, and refines the solution with rewiring and shortcutting to minimize path length and unnecessary turns.",
          "planning_mechanism": "The planner initializes with start and goal nodes, then iteratively samples points within an informed ellipsoid defined by the current best path cost. It grows two trees bidirectionally towards these samples using an adaptive step size that respects obstacle proximity and bounds. Nodes and edges are collision-checked before addition. Nearby nodes are rewired to improve path costs. The trees try to connect when close enough to form a feasible path, which is then smoothed by shortcutting. The process repeats until success or iteration limit, returning the optimized path along with explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        c_best = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path = []\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            diff = np.array(goal_pos) - np.array(start_pos)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n\n            # Create rotation matrix C to align x-axis with a1\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim -1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = 0.0 if c_best**2 - c_min**2 < 0 else math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            steps = max(3, int(d))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[j] + (to_pos[j] - from_pos[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.25, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = sum((node.position[d] - pos[d])**2 for d in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        for itr in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            heuristic = dist(new_pos, goal_pos)\n\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            neighbors = near_nodes(active_tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes with costs exceeding best path cost in active tree\n            to_remove = []\n            for node in active_tree:\n                if node is start_root or node is goal_root or node is new_node:\n                    continue\n                if node.cost + dist(node.position, goal_pos) >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Attempt connection to other tree\n            other_nearest = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            if dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist(new_node.position, other_nearest.position) + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_start = new_node.path_from_root()\n                        path_goal = other_nearest.path_from_root()\n                        best_path = path_start + path_goal[::-1][1:]\n                        success = True\n\n            if success:\n                break\n\n        def path_shortcut(path):\n            path = list(path)\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if success and best_path:\n            best_path = path_shortcut(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.63367,
          "time_improvement": -37.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1558.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.05051796436309815,
                    "num_nodes_avg": 271.3,
                    "path_length_avg": 161.6651415840813,
                    "smoothness_avg": 0.044095160834522154,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -101.2400869969893,
                    "length_improvement": 11.388774149662845,
                    "smoothness_improvement": 590.1850212346226,
                    "objective_score": -75.1433461629911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07712218761444092,
                    "num_nodes_avg": 437.4,
                    "path_length_avg": 236.53986249586342,
                    "smoothness_avg": 0.09541272410526459,
                    "success_improvement": 0.0,
                    "time_improvement": 53.24317620520197,
                    "length_improvement": 21.03618547644208,
                    "smoothness_improvement": 2355.038114235826,
                    "objective_score": 31.955380528028137
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0808384895324707,
                    "num_nodes_avg": 365.9,
                    "path_length_avg": 125.75606212823922,
                    "smoothness_avg": 0.14377095677032287,
                    "success_improvement": 0.0,
                    "time_improvement": -62.17530138115893,
                    "length_improvement": 16.478811394596494,
                    "smoothness_improvement": 1728.7559580503575,
                    "objective_score": -6.713048345176592
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT growth with informed sampling inside an adaptive ellipsoidal region, adaptive step sizing, cost-based pruning, and local rewiring to improve efficiency and path quality. The planner dynamically focuses sampling as better solutions are found, prunes nodes unlikely to produce better paths, and rewires neighbors to optimize cost. Post-processing smooths the path by shortcutting. The approach balances exploration, exploitation, and robustness to obstacles by adaptively adjusting step sizes and sampling strategy.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately sampling points informed by the current best cost and adaptively stepping towards samples with collision checking. Rewiring of neighbors improves path cost and pruning discards unpromising branches early. When trees connect within a step-size distance collision-free, the path is updated. Finally, a shortcut smoothing refines the path length and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float('inf')\n        best_path = []\n\n        # Distance between start and goal\n        c_min = math.dist(start, goal)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            # Sample goal with goal_sample_rate chance\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if best_cost == float('inf'):\n                # Uniform random sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost ** 2 - c_min ** 2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1.0 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fall back\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Check intermediate points to detect nearby obstacles\n            steps = max(5, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= best_cost:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node under new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                # Avoid duplicate connecting point\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Swap growing direction to alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune if cannot improve best cost\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring to optimize cost locally\n            rewire(tree_a, new_node)\n\n            # Attempt connect tree_b\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success_state = True\n\n            # Early stop if good path found\n            if success_state and i % 100 == 0 and best_cost < float('inf'):\n                break\n\n        if success_state and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 20.66653,
          "time_improvement": -39.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1000.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.062411928176879884,
                    "num_nodes_avg": 330.1,
                    "path_length_avg": 167.17785158767057,
                    "smoothness_avg": 0.018509807095481248,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -148.62010998091006,
                    "length_improvement": 8.367170442215494,
                    "smoothness_improvement": 189.71867573372768,
                    "objective_score": -91.96400552716128
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06956179141998291,
                    "num_nodes_avg": 503.3,
                    "path_length_avg": 239.59967121352528,
                    "smoothness_avg": 0.06647143366904831,
                    "success_improvement": 0.0,
                    "time_improvement": 57.82681320536589,
                    "length_improvement": 20.01473325477588,
                    "smoothness_improvement": 1610.3578657430642,
                    "objective_score": 29.402779941280265
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06351680755615234,
                    "num_nodes_avg": 476.6,
                    "path_length_avg": 129.51948982360113,
                    "smoothness_avg": 0.10209670594631756,
                    "success_improvement": 0.0,
                    "time_improvement": -27.425159324018466,
                    "length_improvement": 13.979321914506155,
                    "smoothness_improvement": 1198.6625636422293,
                    "objective_score": 0.5616294039068368
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed sampling inside an ellipsoid defined by the current best path cost, adaptive step sizing to improve obstacle navigation, and local rewiring to optimize path cost. It alternates expansions from start and goal trees, checks for collision-safe connections, prunes suboptimal nodes periodically, and performs shortcut smoothing to enhance path quality. The approach balances exploration and exploitation to efficiently find shorter, smoother, and feasible paths.",
          "planning_mechanism": "The planner grows two RRT* trees from start and goal using informed elliptical sampling once a solution is found, performing adaptive steering steps to avoid obstacles. Each new node triggers local rewiring to improve path costs. The trees attempt to connect when close and collision-free, updating the best path. Suboptimal nodes are pruned to speed convergence, and final smoothing reduces unnecessary detours.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees, nodes, edges\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float(\"inf\")\n        success = False\n        best_path = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        if c_min == 0:\n            return PlannerResult(True, [start_pos], nodes, edges)\n\n        x_center = np.array([(s + g) / 2.0 for s, g in zip(start_pos, goal_pos)])\n        a1 = np.array(goal_pos) - np.array(start_pos)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix for ellipsoid sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if not success or best_cost == float(\"inf\"):\n                # Uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            r1 = best_cost / 2.0\n            r2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball *= scale\n                sample = C @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n            # Fallback uniform\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            near = near_nodes(tree, new_node.position, self.rewire_radius)\n            for node in near:\n                if node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                if new_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            if (node.parent, node) in edges:\n                                edges.remove((node.parent, node))\n                        new_node.add_child(node)\n                        node.cost = new_cost\n                        edges.append((new_node, node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def prune_nodes(tree):\n            retained = []\n            for node in tree:\n                heuristic = math.dist(node.position, goal_pos)\n                if node.cost + heuristic < best_cost:\n                    retained.append(node)\n                else:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    node.valid = False\n            return retained\n\n        def shortcut_smoothing(path, max_trials=50):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate trees each iteration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            if not in_bounds(sample): \n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal_pos)\n            if new_cost + heuristic_remain >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try to connect opposite tree\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, nearest_b)\n                        success = True\n\n            # Prune every 250 iterations if solution found\n            if success and iteration > 0 and iteration % 250 == 0:\n                tree_start = prune_nodes(tree_start)\n                tree_goal = prune_nodes(tree_goal)\n\n            # Early termination if path quality sufficient\n            if success and iteration % 100 == 0:\n                if best_cost < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = shortcut_smoothing(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 21.8305,
          "time_improvement": -43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 949.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.06928391456604004,
                    "num_nodes_avg": 349.4,
                    "path_length_avg": 170.71329222276952,
                    "smoothness_avg": 0.023730501630408452,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -175.99490934647784,
                    "length_improvement": 6.429339407475842,
                    "smoothness_improvement": 271.43388212497473,
                    "objective_score": -100.1554355118233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06339704990386963,
                    "num_nodes_avg": 494.4,
                    "path_length_avg": 237.1998653462102,
                    "smoothness_avg": 0.06470154955002734,
                    "success_improvement": 0.0,
                    "time_improvement": 61.564307456052994,
                    "length_improvement": 20.8158575278676,
                    "smoothness_improvement": 1564.8174725646516,
                    "objective_score": 30.456551105212675
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05720210075378418,
                    "num_nodes_avg": 439.4,
                    "path_length_avg": 123.58877931024256,
                    "smoothness_avg": 0.08727695637180613,
                    "success_improvement": 0.0,
                    "time_improvement": -14.75681922104857,
                    "length_improvement": 17.918217447392276,
                    "smoothness_improvement": 1010.1564429345709,
                    "objective_score": 4.207379937836739
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an advanced bidirectional informed RRT* planner with adaptive parameters and dynamic rewiring for improved path quality and efficiency. It incorporates ellipsoidal informed sampling, adaptive step size shrinking near obstacles, heuristic node pruning, balanced alternate tree growth, and robust path smoothing to enhance success rate, robustness, and shortened search times while ensuring collision-free paths in 2D and 3D spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, sampling new points within an ellipsoidal informed space bounded by the current best solution cost. Each new sample is steered with adaptive step size considering obstacle proximity to ensure safe progress. Nodes that cannot improve the best current solution are pruned early. The trees attempt connection when close, creating or updating the best path. Neighborhood rewiring optimizes sub-paths continuously. Finally, the path is smoothed by shortcutting collision-free segments to produce a high-quality feasible trajectory efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        # Adaptive rewiring radius balancing exploration and rewiring cost\n        self.rewire_radius = 10.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        success = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        if c_min < 1e-12:\n            # Start and goal are effectively the same\n            return PlannerResult(success=True, path=[start], nodes=nodes, edges=edges)\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for informed sampling via SVD\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1.0] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            steps_check = max(6, int(dist_ * 2.5))\n            reduction = 1.0\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    reduction = 0.3\n                    break\n            return max(self.base_step * reduction, 1.0)\n\n        def steer(from_pos, to_pos, step):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, node):\n            return [n for n in tree if n is not node and math.dist(n.position, node.position) <= self.rewire_radius]\n\n        def rewire(tree, new_node):\n            neighs = neighbors(tree, new_node)\n            for near in neighs:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if near.cost - potential_cost > 1e-8:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        # update edges: remove old edge and add new\n                        for i, (p, c) in enumerate(edges):\n                            if c == near:\n                                edges[i] = (new_node, near)\n                                break\n                        else:\n                            edges.append((new_node, near))\n\n        def node_heuristic(node, goal_pos):\n            return node.cost + math.dist(node.position, goal_pos)\n\n        def prune_nodes(tree, goal_pos):\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                h_cost = node_heuristic(node, goal_pos)\n                if h_cost >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n\n        def connect_trees(new_node, other_tree):\n            nonlocal c_best, best_path, success\n            near_other = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            dist_conn = math.dist(new_node.position, near_other.position)\n            if dist_conn <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, near_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + near_other.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = near_other.path_from_root()\n                        if path_a[-1] == path_b[-1]:\n                            combined = path_a + path_b[-2::-1]\n                        else:\n                            combined = path_a + path_b[::-1]\n                        best_path[:] = combined\n                        success = True\n\n        def smooth_path(path, max_iterations=80):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(max_iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            # Alternate tree roles for balanced expansion\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            sample = None\n            # Goal bias 10% towards opposite tree root\n            if random.random() < 0.10:\n                sample = tree_b[0].position\n            else:\n                sample = informed_sample()\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal if tree_a is tree_start else start)\n            if new_cost + heuristic_remain >= c_best:\n                # Skip nodes that cannot improve best solution\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune_nodes(tree_a, goal if tree_a is tree_start else start)\n\n            # Attempt to connect trees\n            connect_trees(new_node, tree_b)\n\n            if success and itr > 150 and itr % 50 == 0:\n                # Early stopping if stable good solution found\n                break\n\n        if success and best_path:\n            best_path = smooth_path(best_path, max_iterations=100)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.53951,
          "time_improvement": -59.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1369.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07836000919342041,
                    "num_nodes_avg": 327.1,
                    "path_length_avg": 166.60132035833274,
                    "smoothness_avg": 0.030201232220188223,
                    "success_improvement": 0.0,
                    "time_improvement": -212.14985136431417,
                    "length_improvement": 8.683176344737511,
                    "smoothness_improvement": 372.71486727140456,
                    "objective_score": -60.04474580398972
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.05514779090881348,
                    "num_nodes_avg": 401.2,
                    "path_length_avg": 236.05978277206486,
                    "smoothness_avg": 0.08622974041979233,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 66.56558090537187,
                    "length_improvement": 21.196449906574706,
                    "smoothness_improvement": 2118.7533297728255,
                    "objective_score": -15.19726909820936
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06517646312713624,
                    "num_nodes_avg": 375.8,
                    "path_length_avg": 129.695420445783,
                    "smoothness_avg": 0.13486578703122842,
                    "success_improvement": 0.0,
                    "time_improvement": -30.754701278227298,
                    "length_improvement": 13.862477172168944,
                    "smoothness_improvement": 1615.482856280332,
                    "objective_score": 1.6234993323672615
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed ellipsoidal sampling biased by the current best solution cost to guide exploration efficiently. It incorporates adaptive step sizing near obstacles to improve safety during expansions, continuous rewiring within a dynamic radius for cost optimization, pruning of nodes unlikely to yield better paths, and bidirectional tree connection attempts to quickly discover feasible trajectories. Post-processing uses iterative shortcut smoothing that respects collision constraints to enhance path smoothness and reduce length, resulting in improved planning efficiency, path quality, and success rate.",
          "planning_mechanism": "The planner alternately expands two trees rooted at start and goal positions by sampling points within an ellipsoidal informed set once a feasible path exists. Each sampled point is connected via safe, adaptively-sized steps considering obstacle proximity. Neighboring nodes within a rewiring radius are re-evaluated for better parent connections to optimize costs. Nodes that cannot improve the solution are pruned to focus computational effort. The planner tries to connect the two trees when nodes are close. Once a path is found, an iterative shortcut smoothing is applied to improve path quality while ensuring collision-free validity.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size                # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...]\n        goal_position = map.goal         # Tuple[float, ...]\n        obstacles = map.obstacles        # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-12:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            step = self.base_step\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbors(tree, node):\n            radius = min(self.rewire_radius, 50.0 * (math.log(len(tree)+1) / (len(tree)+1))**(1/dim))\n            return [nd for nd in tree if math.dist(nd.position, node.position) <= radius]\n\n        def rewire(new_node, tree):\n            for neighbor in neighbors(tree, new_node):\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + math.dist(neighbor.position, goal_position) >= c_best:\n                    continue\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges\n                    for i, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges[i] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node in (start_root, goal_root):\n                    continue\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def connect_trees(node_new, tree_other):\n            nearest_other = nearest(tree_other, node_new.position)\n            if not self._is_edge_in_obstacle(node_new.position, nearest_other.position, obstacles, is_3d):\n                total_cost = node_new.cost + math.dist(node_new.position, nearest_other.position) + nearest_other.cost\n                return total_cost, nearest_other\n            return float('inf'), None\n\n        def backtrack_path(node_a, node_b) -> list:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b:\n                path_b.reverse()\n            return path_a + path_b\n\n        def smooth_path(path, max_iter=60):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if (iter_num % 2 == 0) else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest_node = nearest(active_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            # Heuristic pruning\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            total_cost, connecting_node = connect_trees(new_node, other_tree)\n            if total_cost < c_best:\n                c_best = total_cost\n                if active_tree is tree_a:\n                    extracted_path = backtrack_path(new_node, connecting_node)\n                else:\n                    extracted_path = backtrack_path(connecting_node, new_node)\n                success_state = True\n\n            # Early stop if path found and iterated sufficiently to refine\n            if success_state and iter_num > int(self.max_iter * 0.15):\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = smooth_path(extracted_path, max_iter=80)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 29.45856,
          "time_improvement": -130.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1353.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10019102096557617,
                    "num_nodes_avg": 397.2,
                    "path_length_avg": 169.02609650410264,
                    "smoothness_avg": 0.020410635067261866,
                    "success_improvement": 0.0,
                    "time_improvement": -299.114454226857,
                    "length_improvement": 7.354118116204196,
                    "smoothness_improvement": 219.47076120610146,
                    "objective_score": -87.16615883878575
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06587653160095215,
                    "num_nodes_avg": 434.8,
                    "path_length_avg": 236.23318488013552,
                    "smoothness_avg": 0.0948845070674083,
                    "success_improvement": 0.0,
                    "time_improvement": 60.061073530784945,
                    "length_improvement": 21.13856329179778,
                    "smoothness_improvement": 2341.4467093924295,
                    "objective_score": 33.95326826455719
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12576160430908204,
                    "num_nodes_avg": 631.8,
                    "path_length_avg": 127.65621057843518,
                    "smoothness_avg": 0.12552540358739323,
                    "success_improvement": 0.0,
                    "time_improvement": -152.29845583410025,
                    "length_improvement": 15.216823269322303,
                    "smoothness_improvement": 1496.6738683101385,
                    "objective_score": -35.162802754814926
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.42959013485686,
          "time_improvement": 79.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00851597785949707,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 66.07630281790466,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 24.13813838374785
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.01951591968536377,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 88.16809473190929,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.7939823381527
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008961200714111328,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 82.02235797634103,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.63292645016573
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.98377245334827,
          "time_improvement": 92.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0025066375732421876,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 90.01472110626739,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 28.63235651899162
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007862114906311035,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.23344017202118,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.42144749315494
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004834747314453125,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 90.30070196316272,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -23.162226385881503
               }
          ],
          "success_rate": 0.8666666666666667
     }
]