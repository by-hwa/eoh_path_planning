[
     {
          "operator": "m3",
          "algorithm_description": "This algorithm presents an enhanced bidirectional RRT with goal biasing and simplified structure to improve efficiency and path quality. It grows two trees simultaneously\u2014from start and goal\u2014and attempts to connect them, alternating expansion in each iteration. Goal biasing increases convergence speed toward the goal. The approach includes collision checks for nodes and edges, pruning redundant exploration, and incremental connection attempts to improve robustness and success rate. Path extraction merges the two trees into a smooth, feasible path.",
          "planning_mechanism": "The planner alternates growing start and goal trees by steering towards samples, employs goal biasing to guide exploration, performs collision-free extension checks, and attempts to connect the two trees incrementally. Upon connecting, it extracts a final path by tracing parents from both trees, ensuring a feasible, smooth solution with reduced search overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for itr in range(self.max_iter):\n            # Alternate start and goal tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try connecting trees\n                near_connect = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n                dist_connect = math.dist(new_pos, near_connect.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, near_connect.position, obstacles, is_3d):\n                        conn_node = Node(near_connect.position, parent=new_node, cost=new_node.cost + dist_connect)\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Reconstruct path\n                        path = self._extract_path(conn_node, near_connect)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        # Extract path from node_a up to root start tree\n        path_a = []\n        cur = node_a\n        while cur:\n            path_a.append(cur.position)\n            cur = cur.parent\n        path_a.reverse()\n\n        # Extract path from node_b up to root goal tree\n        path_b = []\n        cur = node_b\n        while cur:\n            path_b.append(cur.position)\n            cur = cur.parent\n\n        # Since node_b belongs to opposite tree, append its reversed path (excluding first duplicate node)\n        return path_a + path_b[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.73192,
          "time_improvement": 85.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0071019411087036135,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 183.5187018824448,
                    "smoothness_avg": 0.010997871352320374,
                    "success_improvement": 0.0,
                    "time_improvement": 71.70916792508382,
                    "length_improvement": -0.5895085416933348,
                    "smoothness_improvement": 72.14056892370422,
                    "objective_score": 21.755551513805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011534762382507325,
                    "num_nodes_avg": 259.9,
                    "path_length_avg": 309.6814971266057,
                    "smoothness_avg": 0.0064039069277323805,
                    "success_improvement": 0.0,
                    "time_improvement": 93.00682632435114,
                    "length_improvement": -3.3805974285229334,
                    "smoothness_improvement": 64.77713779827361,
                    "objective_score": 27.549814100592123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004734683036804199,
                    "num_nodes_avg": 190.4,
                    "path_length_avg": 169.66580872434636,
                    "smoothness_avg": 0.01221306295668852,
                    "success_improvement": 0.0,
                    "time_improvement": 90.50144735658925,
                    "length_improvement": -12.68395153709525,
                    "smoothness_improvement": 55.34925933454292,
                    "objective_score": 24.89039019623044
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.708608753841677,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010948657989501953,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.38563599927819,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 18.510996063035716
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02024111747741699,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 87.7284294886342,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 29.95681957631103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01007375717163086,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.7903867971998,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 25.65801062217829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.068321752434553,
          "time_improvement": 67.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008623981475830078,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 65.64606661538022,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 19.43545600969078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017321276664733886,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.49863967859932,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.230659824248814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026317262649536134,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 47.2032440685165,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 13.53884942336407
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm integrates a hybrid approach combining informed sampling, bidirectional growth, and heuristic-driven rewiring to improve convergence speed, path quality, and robustness. It grows two trees from start and goal simultaneously using informed sampling within ellipsoidal informed sets when solutions exist, aggressively rewires locally to optimize paths during bidirectional expansions, and uses dynamic goal biasing. This approach balances exploration and exploitation efficiently for faster, smoother, and shorter paths with high success rates.",
          "planning_mechanism": "The planner alternates expansions of two trees rooted at start and goal. Initially, uniform random samples guide exploration; after a valid path is found, sampling is restricted inside an ellipsoidal informed subset around the best path to focus search. Each new node connects to the best local parent and triggers rewiring to reduce path costs. The two trees attempt connection after each expansion, producing a refined, smooth path by merging. Collision and boundary checks prevent invalid nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        extracted_path = []\n\n        # Initialize cost and solution tracking\n        best_cost = float(\"inf\")\n        c_min = self._euclidean(start_pos, goal_pos)\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Helper: check if pos within map bounds\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Ellipsoidal informed sampling: sample in unit ball scaled and rotated\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            import random\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Compute ellipse parameters\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            length = np.linalg.norm(a1)\n            a1 = a1 / length\n\n            L = np.diag([c_best / 2.0] + [((c_best ** 2 - c_min ** 2) ** 0.5) / 2.0] * (dim - 1))\n\n            # Rotation matrix via SVD\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            while True:\n                # Sample from unit ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball = x_ball / norm * (random.random() ** (1.0 / dim))\n                x_rand = C @ (L @ x_ball) + center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n\n        # Find nearest node in a tree to given point\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: self._euclidean(n.position, point))\n\n        # Find nodes near a position within a radius\n        def near_nodes(tree, pos, radius=15.0):\n            return [node for node in tree if self._euclidean(node.position, pos) <= radius]\n\n        # Rewire nodes in near_nodes to new_node if cheaper and collision free\n        def rewire(tree, new_node, near_n):\n            for node in near_n:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + self._euclidean(new_node.position, node.position)\n                if potential_cost + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        # Merge paths from two nodes, stitching start and goal trees\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal[1:]\n\n        for itr in range(self.max_iter):\n            # Alternate between start_tree and goal_tree for expansion\n            for tree_a, tree_b, is_start_tree_expansion in [(start_tree, goal_tree, True), (goal_tree, start_tree, False)]:\n\n                # Determine sampling strategy: informed sampling if solution found else uniform\n                if best_cost < float(\"inf\"):\n                    sample = informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    import random\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if is_start_tree_expansion else start_pos\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                # Find nearest node & steer towards sample\n                nearest = nearest_node(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest.cost + self._euclidean(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire near nodes to new_node in tree_a\n                near_n = near_nodes(tree_a, new_pos, radius=20.0)\n                rewire(tree_a, new_node, near_n)\n\n                # Attempt connection to opposite tree\n                near_in_b = near_nodes(tree_b, new_pos, radius=self.step_size * 1.5)\n                connect_node = None\n                min_connect_cost = float(\"inf\")\n                for nbr in near_in_b:\n                    dist = self._euclidean(new_pos, nbr.position)\n                    if dist <= self.step_size and not self._is_edge_in_obstacle(new_pos, nbr.position, obstacles, is_3d):\n                        total_cost = new_node.cost + dist + nbr.cost\n                        if total_cost < min_connect_cost:\n                            min_connect_cost = total_cost\n                            connect_node = nbr\n\n                if connect_node is not None:\n                    # Connect trees by adding edge and update solution if better\n                    if is_start_tree_expansion:\n                        # Connect connect_node parent rewritten to new_node\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in start tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        # Update solution path if cost improved\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = conn_node\n                            solution_node_goal = connect_node\n                            success = True\n                    else:\n                        # Connecting from goal tree expansion\n                        conn_node = Node(connect_node.position, parent=new_node,\n                                        cost=new_node.cost + self._euclidean(new_node.position, connect_node.position))\n                        new_node.add_child(conn_node)\n                        tree_a.append(conn_node)\n                        nodes.append(conn_node)\n                        edges.append((new_node, conn_node))\n                        # Rewire near nodes in goal tree to conn_node\n                        near_conn = near_nodes(tree_a, conn_node.position, radius=20.0)\n                        rewire(tree_a, conn_node, near_conn)\n                        if min_connect_cost < best_cost:\n                            best_cost = min_connect_cost\n                            solution_node_start = connect_node\n                            solution_node_goal = conn_node\n                            success = True\n\n            if success and solution_node_start and solution_node_goal:\n                extracted_path = extract_path(solution_node_start, solution_node_goal)\n                break\n\n        # Post-process path smoothing via shortcutting (optional, simple straight-line shortcuts)\n        if success and len(extracted_path) > 3:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _euclidean(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._euclidean(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _smooth_path(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            p_start = smoothed[i]\n            p_end = smoothed[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = self._euclidean(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.36588,
          "time_improvement": 33.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1240.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022878527641296387,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 180.38439431350918,
                    "smoothness_avg": 0.02957517506587525,
                    "success_improvement": 0.0,
                    "time_improvement": 8.862580847365873,
                    "length_improvement": 1.128455103121995,
                    "smoothness_improvement": 362.9157133015363,
                    "objective_score": 4.699043841341842
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03743283748626709,
                    "num_nodes_avg": 288.3,
                    "path_length_avg": 237.52161712099596,
                    "smoothness_avg": 0.08105711587400938,
                    "success_improvement": 0.0,
                    "time_improvement": 77.30561540558567,
                    "length_improvement": 20.708447524332772,
                    "smoothness_improvement": 1985.6579745189633,
                    "objective_score": 37.26166399913707
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044042229652404785,
                    "num_nodes_avg": 294.7,
                    "path_length_avg": 129.5781252975168,
                    "smoothness_avg": 0.11565553498213739,
                    "success_improvement": 0.0,
                    "time_improvement": 11.644045940418264,
                    "length_improvement": 13.940379024652591,
                    "smoothness_improvement": 1371.1298681692033,
                    "objective_score": 13.136938927902015
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates bidirectional RRT* with informed sampling and adaptive rewiring. It alternates expanding two trees from start and goal while focusing search inside an ellipsoidal informed set around the best solution cost. Adaptive step sizing ensures safe exploration near obstacles. Continuous rewiring optimizes costs, and pruning discards inefficient nodes. A final smoothing step improves path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally, samples points inside an informed ellipsoid to bias search toward promising areas, uses adaptive stepping to navigate safely near obstacles, performs rewiring of neighbors to optimize costs in both trees, prunes nodes unlikely to improve the solution, attempts to connect the two trees for path updates, and performs path shortcutting for smoothness before returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_heuristic(node: Node) -> float:\n            return node.cost + math.dist(node.position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy as np\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            diff = np.array(goal_position) - np.array(start_position)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff < 1e-10:\n                return tuple(x_center)\n\n            a1 = diff / norm_diff\n            unit_vec = np.zeros(dim)\n            unit_vec[0] = 1.0\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample in unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius = random.random() ** (1 / dim)\n                x_ball *= radius\n\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(3, int(distance))\n            step = self.base_step\n            # Check points along the path; reduce step if near obstacle\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step = max(self.base_step * 0.25, 1.0)\n                    break\n            return step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def rewire(new_node, tree):\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, potential_cost)\n                    # Update edges list\n                    for idx, e in enumerate(edges):\n                        if e[1] == neighbor:\n                            edges[idx] = (new_node, neighbor)\n                            break\n\n        def prune(tree):\n            to_remove = []\n            for node in tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node not in (start_root, goal_root):\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                node.children.clear()\n                if node in tree:\n                    tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for iter_num in range(self.max_iter):\n            active_tree, other_tree = (tree_a, tree_b) if iter_num % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(new_node, active_tree)\n            prune(active_tree)\n\n            # Try connect trees\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            if success_state:\n                # Optional: continue to improve path, here break for speed\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -13.0185,
          "time_improvement": 4.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1743.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049403262138366696,
                    "num_nodes_avg": 268.8,
                    "path_length_avg": 165.4484773217101,
                    "smoothness_avg": 0.05793713667543628,
                    "success_improvement": 0.0,
                    "time_improvement": -96.79963149746891,
                    "length_improvement": 9.315067881077315,
                    "smoothness_improvement": 806.8420014765672,
                    "objective_score": -23.142665865642375
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03950042724609375,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 238.45172325330878,
                    "smoothness_avg": 0.1098670141892697,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0520989653694,
                    "length_improvement": 20.397951325746124,
                    "smoothness_improvement": 2726.957409101609,
                    "objective_score": 40.530007000268085
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0327894926071167,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 128.51545696165562,
                    "smoothness_avg": 0.14109008407790408,
                    "success_improvement": 0.0,
                    "time_improvement": 34.21888661639979,
                    "length_improvement": 14.646152734503213,
                    "smoothness_improvement": 1694.655455284229,
                    "objective_score": 21.668173808241725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed elliptical sampling, dynamic adaptive step sizing near obstacles, node rewiring for cost optimization, and pruning of inefficient nodes. It grows two trees from start and goal, alternates expansion, employs sampling within an informed subset to focus search towards promising regions, adapts step sizes considering obstacle proximity to safely explore narrow passages, applies rewiring to improve path cost continuously, and prunes branches unlikely to yield better solutions.",
          "planning_mechanism": "The planner iteratively samples random points within an ellipsoidal informed subset defined by the current best path cost to goal, steers from the nearest node with an adaptive step size, validates node and edge collisions rigorously, attempts to rewire neighbors within a radius to minimize costs, prunes nodes with costs exceeding the current best, and tries to connect two trees to update the best path. The process stops upon success or iteration limit, returning an optimized, feasible path with improved efficiency and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def node_cost_with_heuristic(node):\n            return node.cost + math.dist(node.position, goal_position)\n\n        for iter_num in range(self.max_iter):\n            # Alternate trees\n            if iter_num % 2 == 0:\n                active_tree, other_tree = tree_a, tree_b\n            else:\n                active_tree, other_tree = tree_b, tree_a\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(active_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Do not exceed bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes with cost + heuristic worse than best known path\n            if new_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius to reduce cost\n            neighbors = [node for node in active_tree if math.dist(node.position, new_node.position) <= self.rewire_radius]\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                    # Add new edge\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Prune nodes in active tree that have cost + heuristic worse than c_best\n            to_remove = []\n            for node in active_tree:\n                if node.cost + math.dist(node.position, goal_position) >= c_best:\n                    if node != new_node and node != start_root and node != goal_root:\n                        to_remove.append(node)\n            for node in to_remove:\n                # Remove from parent's children\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                # Remove children links to avoid dangling references\n                node.children = []\n                if node in active_tree:\n                    active_tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n            # Try to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_a = new_node.path_from_root()\n                    path_b = other_nearest.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n\n            # Early termination if found a path\n            if success_state:\n                # Optionally continue to improve path or break to return first good path\n                # Here, break after first path found\n                break\n\n        # Path smoothing: shortcut path by removing unnecessary nodes if possible\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shorten_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            # Start and goal are basically the same point, return it\n            return tuple(x_center)\n\n        a1 = diff / norm_diff\n\n        # Create rotation matrix C to rotate the unit vector to a1 direction\n        # Reference: https://arxiv.org/pdf/1109.4115.pdf\n        unit_vec = np.zeros(dim)\n        unit_vec[0] = 1.0\n        M = np.outer(a1, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim -1) + [det]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample uniformly inside unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            radius = random.random() ** (1 / dim)\n            x_ball = x_ball * radius\n\n            # Transform to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacles, but at least 1.0\n                return max(self.base_step * 0.25, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _shorten_path(self, path, obstacles, is_3d):\n        # Attempts to shortcut the path by removing intermediate nodes when the\n        # straight-line path between non-adjacent nodes is collision-free.\n        import math\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.35232,
          "time_improvement": 6.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04930014610290527,
                    "num_nodes_avg": 240.5,
                    "path_length_avg": 169.95054568747466,
                    "smoothness_avg": 0.05415383468147165,
                    "success_improvement": 0.0,
                    "time_improvement": -96.38886514516909,
                    "length_improvement": 6.84741286996326,
                    "smoothness_improvement": 747.6251096992462,
                    "objective_score": -23.80905142106184
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047037577629089354,
                    "num_nodes_avg": 372.1,
                    "path_length_avg": 237.86859110536346,
                    "smoothness_avg": 0.09317261083841849,
                    "success_improvement": 0.0,
                    "time_improvement": 71.4825551897902,
                    "length_improvement": 20.59261762125851,
                    "smoothness_improvement": 2297.3983863915073,
                    "objective_score": 37.0502820131463
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028564262390136718,
                    "num_nodes_avg": 258.8,
                    "path_length_avg": 128.01701657407608,
                    "smoothness_avg": 0.13383198531076218,
                    "success_improvement": 0.0,
                    "time_improvement": 42.6953931395489,
                    "length_improvement": 14.977193106752848,
                    "smoothness_improvement": 1602.332974703307,
                    "objective_score": 23.815721436731774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional growth and connection of RRT trees with informed elliptical sampling, adaptive step sizing near obstacles, cost-based node pruning, and efficient rewiring to optimize path quality and computational efficiency. It balances exploration and exploitation by alternating between start and goal trees while guiding sampling within an informed ellipsoidal region that shrinks with better solutions. The planner dynamically adjusts step size near obstacles to navigate cluttered spaces robustly, prunes unpromising branches early based on heuristic cost bounds, and rewires nodes to improve path costs. Post-planning, the path is smoothed by shortcutting to enhance path quality and smoothness.",
          "planning_mechanism": "The planner starts two trees from start and goal points, alternately sampling points mostly within an informed ellipsoidal space defined by the current best solution cost. Each sampled point is connected by an adaptive step that shrinks near obstacles, ensuring collision-free growth. Branches unlikely to improve the current best cost are pruned. Nearby nodes are rewired if a lower-cost path is found. When the two trees can be connected collision-free within a proximity threshold, the path is updated. Finally, a shortcut smoothing step improves the path\u2019s smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=10.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(False, [], nodes, edges)\n        a1_unit = a1 / norm_a1\n\n        # Rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            try:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n            except Exception:\n                r2 = 0.0\n            L = np.diag([r1] + [r2]*(dim - 1))\n            for _ in range(100):  # limit tries to avoid infinite loop\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm == 0:\n                    continue\n                x_ball /= norm\n                radius = random.random() ** (1.0/dim)\n                x_ball *= radius\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback random sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / dist) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(5, int(dist * 2.0))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.35, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and distance(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + distance(new_node.position, near.position)\n                heuristic_remain = distance(near.position, goal)\n                if new_cost + heuristic_remain >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicated connecting position\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(50):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: distance(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            heuristic_remain = distance(new_pos, goal)\n            # Prune nodes that cannot improve best cost\n            if new_cost + heuristic_remain >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Attempt connect trees\n            other_nearest = min(tree_b, key=lambda n: distance(n.position, new_node.position))\n            conn_dist = distance(new_node.position, other_nearest.position)\n            if conn_dist <= self.base_step and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + conn_dist + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_path = extract_path(new_node, other_nearest)\n                    success = True\n\n            # Early stop if a good path is found\n            if success and i % 100 == 0 and c_best < float(\"inf\"):\n                break\n\n        if success and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.12117,
          "time_improvement": -35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1039.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06026041507720947,
                    "num_nodes_avg": 332.6,
                    "path_length_avg": 166.996413064366,
                    "smoothness_avg": 0.016269651188625004,
                    "success_improvement": 0.0,
                    "time_improvement": -140.04948191203425,
                    "length_improvement": 8.466619771916111,
                    "smoothness_improvement": 154.6553712150155,
                    "objective_score": -39.54824376315197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06673438549041748,
                    "num_nodes_avg": 500.6,
                    "path_length_avg": 237.0038545493059,
                    "smoothness_avg": 0.07697310282156793,
                    "success_improvement": 0.0,
                    "time_improvement": 59.54098295254645,
                    "length_improvement": 20.88129157373222,
                    "smoothness_improvement": 1880.5733770839436,
                    "objective_score": 31.441420085930098
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06200351715087891,
                    "num_nodes_avg": 431.8,
                    "path_length_avg": 123.09804183051456,
                    "smoothness_avg": 0.09294490050814501,
                    "success_improvement": 0.0,
                    "time_improvement": -24.389249957430696,
                    "length_improvement": 18.244141915019977,
                    "smoothness_improvement": 1082.2522739846838,
                    "objective_score": 1.7433147656982069
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a tuned and enhanced bidirectional RRT* planner incorporating informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, and efficient rewiring to improve path quality and planning speed across 2D and 3D maps. It balances exploration and exploitation for robust navigation in cluttered spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using informed elliptical sampling within a heuristic cost-bound, adaptively adjusts step size to avoid obstacles, prunes nodes unlikely to improve the solution, rewires neighbors to reduce path cost, and connects the two trees when proximity and collision-free conditions are met. The best path is updated dynamically to optimize both quality and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        c_best = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start, goal)\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        a1_unit = a1 / norm_a1\n\n        # Precompute rotation matrix C for informed sampling\n        # Construct orthonormal basis via SVD for rotation\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune branch if potential cost worse than current best\n            heuristic_remaining = math.dist(new_pos, goal)\n            if cost + heuristic_remaining >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes within radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection between trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connection_dist = math.dist(new_node.position, other_nearest.position)\n            if connection_dist <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + connection_dist + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # Remove duplicate connecting node position\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            if success and (i % 100 == 0):\n                # Early stop if path found and improved recently\n                if c_best < float(\"inf\"):\n                    break\n\n        # Optional path smoothing (simple shortcut)\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:  # numerical issues if c_best < c_min due to float rounding\n            r2 = 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(3, int(distance * 1.5))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.35, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut path segment between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.79647,
          "time_improvement": -65.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 917.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0779529094696045,
                    "num_nodes_avg": 434.8,
                    "path_length_avg": 167.29084808809012,
                    "smoothness_avg": 0.01983996215756792,
                    "success_improvement": 0.0,
                    "time_improvement": -210.52815530292239,
                    "length_improvement": 8.305235269791412,
                    "smoothness_improvement": 210.53849093333312,
                    "objective_score": -60.44470708225177
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08757963180541992,
                    "num_nodes_avg": 652.5,
                    "path_length_avg": 239.06042775471852,
                    "smoothness_avg": 0.06625774840202739,
                    "success_improvement": 0.0,
                    "time_improvement": 46.90314760246064,
                    "length_improvement": 20.19474824258794,
                    "smoothness_improvement": 1604.8595899113393,
                    "objective_score": 26.13419187881248
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06488139629364013,
                    "num_nodes_avg": 509.2,
                    "path_length_avg": 125.80514296258566,
                    "smoothness_avg": 0.08145784525964582,
                    "success_improvement": 0.0,
                    "time_improvement": -30.162748695657164,
                    "length_improvement": 16.446214241401773,
                    "smoothness_improvement": 936.1377791099944,
                    "objective_score": -1.0788928648668232
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 15.397605499726785,
          "time_improvement": -51.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03258261680603027,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -29.793999487135647,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -8.979796324742384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23828883171081544,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -44.46723130147098,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -13.698434341848035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08907036781311035,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -78.68980268884992,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -23.514585832589937
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 36.42959013485686,
          "time_improvement": 79.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00851597785949707,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 66.07630281790466,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 24.13813838374785
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.01951591968536377,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 88.16809473190929,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -65.7939823381527
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008961200714111328,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 82.02235797634103,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -67.63292645016573
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 37.98377245334827,
          "time_improvement": 92.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0025066375732421876,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 90.01472110626739,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 28.63235651899162
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007862114906311035,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 95.23344017202118,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -119.42144749315494
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004834747314453125,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 90.30070196316272,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -23.162226385881503
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 41.25826788450296,
          "time_improvement": -153.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04882934093475342,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -94.51339620670333,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -25.0416766215254
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.43369991779327394,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -162.93899671851912,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -42.95779999349292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1509249448776245,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -202.78025434446133,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -55.77532703849057
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner combining informed sampling, adaptive step size near obstacles, node pruning based on cost heuristics, efficient rewiring, and aggressive path smoothing to improve path quality, success rate, and planning efficiency in both 2D and 3D spaces. It dynamically tunes parameters such as step size and rewiring radius to balance exploration and exploitation optimally.",
          "planning_mechanism": "The planner alternately grows two trees initialized at start and goal by sampling points using an informed elliptical distribution confined by the best current solution cost. Nodes are extended with adaptive step sizes that shrink near obstacles to enhance collision avoidance. Each new node is pruned if it cannot improve the current best path based on a heuristic cost bound. Nearby nodes are rewired to minimize path cost. When trees are sufficiently close and connected without collisions, the best path is updated. Finally, a robust path smoothing is performed to yield a shorter, smoother feasible route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        # Adaptive rewire radius tuned for balanced rewiring and computation time\n        self.rewire_radius = 10.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success = False\n        best_path = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n        x_center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        a1_unit = a1 / norm_a1\n\n        # Compute rotation matrix C for informed sampling\n        unit_vec = np.eye(dim)[0]\n        M = np.outer(a1_unit, unit_vec)\n        U, _, Vt = np.linalg.svd(M)\n        det_val = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det_val]) @ Vt\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        for itr in range(self.max_iter):\n            # Alternate trees for balanced growth\n            tree_a, tree_b = (tree_a, tree_b) if itr % 2 == 0 else (tree_b, tree_a)\n\n            # Sampling with goal bias and informed ellipsoidal bounds\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is not tree_b else start  # bias towards opposite tree goal\n            else:\n                sample = self._informed_sample(x_center, C, c_best, c_min, bounds, dim)\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size reduces near obstacles, maintaining minimum scale for progress\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic_remain = math.dist(new_pos, goal)\n            if new_cost + heuristic_remain >= c_best:\n                # Prune nodes that cannot improve current best solution\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors in radius to lower cost paths where possible\n            neighbors = [n for n in tree_a if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + math.dist(near.position, goal) >= c_best:\n                    continue\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connection between trees \u2013 if close enough and collision free\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_conn = math.dist(new_node.position, other_nearest.position)\n            if dist_conn <= self.base_step:\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        # remove duplicate node at connection\n                        if path_a[-1] == path_b[-1]:\n                            best_path = path_a + path_b[-2::-1]\n                        else:\n                            best_path = path_a + path_b[::-1]\n                        success = True\n\n            # Early stopping if a path is found with good cost and no improvements will likely happen\n            if success and itr > 200 and itr % 100 == 0:\n                if c_best < float(\"inf\"):\n                    break\n\n        if success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d, max_trials=75)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, x_center, C, c_best, c_min, bounds, dim):\n        import random\n        import numpy as np\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        r1 = c_best / 2.0\n        try:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        except ValueError:\n            r2 = 0.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm == 0:\n                continue\n            x_ball /= norm\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps_eval = max(4, int(distance * 2.0))  # increased sampling for finer obstacle proximity\n        for i in range(1, steps_eval + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_eval) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Shrink step when close to obstacles but not less than a threshold\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=75):\n        import random\n\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(max_trials):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 45.31364,
          "time_improvement": -70.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1153.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.09132659435272217,
                    "num_nodes_avg": 446.0,
                    "path_length_avg": 163.18307516793513,
                    "smoothness_avg": 0.02216380666201768,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -263.8026991860653,
                    "length_improvement": 10.556770699155697,
                    "smoothness_improvement": 246.91170373708226,
                    "objective_score": -125.79489709730304
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07148153781890869,
                    "num_nodes_avg": 579.2,
                    "path_length_avg": 237.82330371688914,
                    "smoothness_avg": 0.08623212393261678,
                    "success_improvement": 0.0,
                    "time_improvement": 56.66292967350841,
                    "length_improvement": 20.60773585505644,
                    "smoothness_improvement": 2118.8146592745734,
                    "objective_score": 31.71449936943668
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.05156354904174805,
                    "num_nodes_avg": 448.4,
                    "path_length_avg": 122.63782065239172,
                    "smoothness_avg": 0.09375835259243642,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -3.444957401990151,
                    "length_improvement": 18.549798908151658,
                    "smoothness_improvement": 1092.5993244540837,
                    "objective_score": -41.86053081669629
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm combines bidirectional RRT with adaptive informed sampling and dynamic rewiring to efficiently explore the space, improve path quality, and quickly converge to near-optimal solutions. It incorporates adaptive step size based on obstacle proximity, node pruning, and smoothing after path extraction to enhance path smoothness and reduce length.",
          "planning_mechanism": "The planner grows two trees from start and goal with goal biasing and informed sampling within an ellipsoidal heuristic region limiting samples to promising areas; it dynamically adjusts step size near obstacles to safely extend nodes; performs rewiring to reduce path cost; prunes unpromising branches; and upon successful connection, extracts the path and applies smoothing for improved quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        # Rotation matrix for ellipse sampling\n        def rotation_to_world(unit_vec):\n            # Constructs a rotation matrix that aligns the x-axis with unit_vec\n            # For 2D and 3D only\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                # Use Householder reflection to rotate unit_vec to x-axis\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    return p\n            else:\n                r1 = c_best / 2.0\n                if c_best**2 - c_min**2 < 0:\n                    r2 = 0\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball = x_ball / norm_x_ball\n                    # Scale by random radius within unit ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            # Find nearest node in other tree to new_node\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            # Check edge collision\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                # Connect the two paths\n                path_from_start = new_node.path_from_root() if tree_source is tree_start else nearest_other.path_from_root()\n                path_from_goal = nearest_other.path_from_root() if tree_source is tree_start else new_node.path_from_root()\n                # Reverse goal tree path except start node duplication\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        # Main loop\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            # Find nearest node in tree_a\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step based steering\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            # Prune nodes that cannot improve solution\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes for optimality\n            rewire(tree_a, new_node)\n\n            # Try to connect with other tree\n            try_connect(tree_a, tree_b, new_node)\n\n            # Early stop if path found with close to minimal cost\n            if success_state and best_cost <= c_min * 1.01:\n                break\n\n        # If success, smooth path\n        if success_state and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int = 15):\n        if len(path) < 3:\n            return path[:]\n        import random\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # Shortcut path\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 574.45011,
          "time_improvement": -1878.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 309.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.8320957899093628,
                    "num_nodes_avg": 1549.5,
                    "path_length_avg": 153.74607634589862,
                    "smoothness_avg": 0.017201347478274894,
                    "success_improvement": 0.0,
                    "time_improvement": -3214.6828313910974,
                    "length_improvement": 15.729339292329675,
                    "smoothness_improvement": 169.23844135891187,
                    "objective_score": -960.4127893520687
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.272113823890686,
                    "num_nodes_avg": 2684.4,
                    "path_length_avg": 228.69847223546608,
                    "smoothness_avg": 0.021039148225681644,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -671.2437075559052,
                    "length_improvement": 23.653867247266973,
                    "smoothness_improvement": 441.35243773273106,
                    "objective_score": -244.4355766286545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.9213220596313476,
                    "num_nodes_avg": 2213.8,
                    "path_length_avg": 117.31109101069724,
                    "smoothness_avg": 0.03266645968614169,
                    "success_improvement": 0.0,
                    "time_improvement": -1748.323534419919,
                    "length_improvement": 22.087559104556973,
                    "smoothness_improvement": 315.51495602048266,
                    "objective_score": -518.5019737249619
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with informed elliptical sampling, adaptive step sizing near obstacles, dynamic rewiring for path cost optimization, and path smoothing. It balances exploration and exploitation by sampling within an ellipsoidal informed subset based on the current best path cost, grows two trees from start and goal alternately, and connects them efficiently when possible. It prunes unpromising nodes to improve performance and applies shortcut smoothing to enhance path quality and reduce length.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling new points from an ellipsoidal informed subset centered between start and goal. Adaptive step sizing reduces step length near obstacles, ensuring safe exploration through narrow passages. Upon adding new nodes, nearby nodes are rewired to reduce path cost incrementally. When two trees connect without collision, the best path is updated. After search, path smoothing shortcuts unnecessary nodes to produce a smooth, optimized path. The process respects bounds and obstacles strictly, terminating early once a near-optimal path is found or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_from_parent(self, edges):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        diff = np.array(goal) - np.array(start)\n        norm_diff = np.linalg.norm(diff)\n        if norm_diff < 1e-10:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = diff / norm_diff\n\n        # Rotation matrix to align x-axis with unit_vec\n        def rotation_to_world(vector):\n            if dim == 2:\n                angle = math.atan2(vector[1], vector[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                a = vector\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.eye(3)\n                v /= np.linalg.norm(v)\n                H = np.eye(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.eye(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                radius = random.random() ** (1/dim)\n                x_ball *= radius\n                sample = rotation_matrix @ L @ x_ball + x_center\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d]-from_pos[d])/dist for d in range(dim))\n            return tuple(from_pos[d] + direction[d]*step for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            checks = max(3, int(dist))\n            for i in range(1, checks+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/checks) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_a, tree_b, new_node):\n            nonlocal c_best\n            if not tree_b:\n                return None\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return None\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < c_best:\n                c_best = total_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else nearest_other.path_from_root()\n                path_goal = nearest_other.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                return path_start + path_goal[::-1][1:]\n            return None\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iter_num in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if iter_num % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            heuristic = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            path = try_connect(tree_a, tree_b, new_node)\n            if path:\n                extracted_path = path\n                success_state = True\n                # Early stop if near optimal\n                if c_best <= c_min * 1.01:\n                    break\n\n        if success_state and extracted_path:\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, iterations=15):\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 582.98385,
          "time_improvement": -1907.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 324.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.8374725103378295,
                    "num_nodes_avg": 1537.6,
                    "path_length_avg": 153.29053691440865,
                    "smoothness_avg": 0.02027216892882408,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -3236.10118623624,
                    "length_improvement": 15.97902767321355,
                    "smoothness_improvement": 217.30346545551785,
                    "objective_score": -1016.5480330089518
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.3020658493041992,
                    "num_nodes_avg": 2675.2,
                    "path_length_avg": 226.33134727867179,
                    "smoothness_avg": 0.01992788664063618,
                    "success_improvement": 0.0,
                    "time_improvement": -689.4027045692981,
                    "length_improvement": 24.444081691759003,
                    "smoothness_improvement": 412.75887674014433,
                    "objective_score": -199.8682006487369
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.9451454877853394,
                    "num_nodes_avg": 2232.9,
                    "path_length_avg": 116.03641363004617,
                    "smoothness_avg": 0.03479643616259932,
                    "success_improvement": 0.0,
                    "time_improvement": -1796.117248319708,
                    "length_improvement": 22.93413912717119,
                    "smoothness_improvement": 342.60809958251434,
                    "objective_score": -532.5353061725656
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm integrates bidirectional RRT* with informed sampling, adaptive step sizing, dynamic rewiring, node pruning, and post-processing path smoothing. It focuses on rapidly exploring promising regions via ellipsoidal informed sampling, optimizing path cost using rewiring, adapting step sizes near obstacles for safe extensions, and improving path smoothness and length with shortcut smoothing.",
          "planning_mechanism": "The planner alternates between growing two trees from start and goal positions, samples points inside an ellipsoidal heuristic region considering the current best path cost, steers adaptively with collision-aware step sizes, rewires nearby nodes for optimality, prunes nodes unlikely to improve the solution, and attempts connection between trees at each iteration. Once connected, the planner extracts, shortcuts, and returns the optimized and smoothed path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges: List[Tuple[\"Node\", \"Node\"]]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        def rotation_to_world(unit_vec):\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                if np.linalg.norm(v) < 1e-10:\n                    return np.identity(3)\n                v = v / np.linalg.norm(v)\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    return p\n            else:\n                r1 = c_best / 2.0\n                if c_best**2 - c_min**2 < 0:\n                    r2 = 0\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball = x_ball / norm_x_ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        return tuple(sample)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist * 2))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                path_from_start = new_node.path_from_root() if tree_source is tree_start else nearest_other.path_from_root()\n                path_from_goal = nearest_other.path_from_root() if tree_source is tree_start else new_node.path_from_root()\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        def prune_nodes(tree, best_cost):\n            # Remove nodes with heuristic cost > best_cost\n            for node in tree[:]:\n                heuristic = node.cost + math.dist(node.position, goal if tree is tree_start else start)\n                if heuristic >= best_cost and node.parent:\n                    node.remove_from_parent(edges)\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n\n        # Main loop\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n            try_connect(tree_a, tree_b, new_node)\n            prune_nodes(tree_a, best_cost)\n\n            if success_state and best_cost <= c_min * 1.01:\n                break\n\n        if success_state and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations: int = 20) -> List[Tuple[float, ...]]:\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        for _ in range(iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 631.59921,
          "time_improvement": -2070.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 403.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.8705846548080445,
                    "num_nodes_avg": 1312.3,
                    "path_length_avg": 152.93352302094502,
                    "smoothness_avg": 0.017624281799916444,
                    "success_improvement": 0.0,
                    "time_improvement": -3368.004577789175,
                    "length_improvement": 16.17471264546813,
                    "smoothness_improvement": 175.8582819091813,
                    "objective_score": -1006.287139398113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.4767683029174805,
                    "num_nodes_avg": 2606.3,
                    "path_length_avg": 229.84137329304548,
                    "smoothness_avg": 0.030802338742556466,
                    "success_improvement": 0.0,
                    "time_improvement": -795.3194594330506,
                    "length_improvement": 23.27233397766403,
                    "smoothness_improvement": 692.5663618738082,
                    "objective_score": -230.47853922501332
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 1.070005440711975,
                    "num_nodes_avg": 2068.6,
                    "path_length_avg": 118.59917910232939,
                    "smoothness_avg": 0.03464946658341625,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -2046.6068432320533,
                    "length_improvement": 21.232072326258557,
                    "smoothness_improvement": 340.73865738347155,
                    "objective_score": -658.031945217447
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner incorporating informed sampling within an elliptical heuristic region, adaptive step sizing near obstacles, branch pruning based on current best path cost, and rewiring to improve path optimality. The planner efficiently explores the search space to find asymptotically optimal paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from the start and goal positions by sampling points inside an informed ellipsoidal subset to focus search around promising regions. Adaptive step size reduces step length near obstacles, preventing collisions. New nodes that cannot lead to better solutions are discarded. Nearby nodes are rewired to reduce path costs while ensuring collision-free connections. Whenever the two trees connect via an obstacle-free edge with a lower cost, the current best path updates accordingly.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        for i in range(self.max_iter):\n            # Alternate tree expansion\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue  # Prune nodes that cannot improve path\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring near nodes for path cost improvement\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_pos) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire node\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            if not self._is_edge_in_obstacle(new_pos, other_nearest.position, obstacles, is_3d):\n                total_cost = new_node.cost + math.dist(new_pos, other_nearest.position) + other_nearest.cost\n                if total_cost < c_best:\n                    c_best = total_cost\n                    path_from_start = new_node.path_from_root() if tree_a is tree_start else other_nearest.path_from_root()\n                    path_from_goal = other_nearest.path_from_root() if tree_a is tree_start else new_node.path_from_root()\n                    best_path = path_from_start + path_from_goal[::-1]\n                    success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        import numpy as np\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            return tuple(x_center)\n        a1 = a1 / norm_a1\n\n        # Create rotation matrix C aligning unit vector a1 with first axis\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            radius = random.random() ** (1 / dim)\n            x_ball *= radius\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.step_size * 0.3, 1.0)\n        return self.step_size\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
          "objective": 784.83187,
          "time_improvement": -2632.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 153.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.1159339189529418,
                    "num_nodes_avg": 1776.4,
                    "path_length_avg": 153.90446328974247,
                    "smoothness_avg": 0.014004260415998549,
                    "success_improvement": 0.0,
                    "time_improvement": -4345.361996751859,
                    "length_improvement": 15.642524898607125,
                    "smoothness_improvement": 119.19708624861136,
                    "objective_score": -1299.8841086145933
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.6665050506591796,
                    "num_nodes_avg": 3076.7,
                    "path_length_avg": 230.88634558573963,
                    "smoothness_avg": 0.011678293031371662,
                    "success_improvement": 0.0,
                    "time_improvement": -910.3510470470864,
                    "length_improvement": 22.923492148502987,
                    "smoothness_improvement": 200.49089123166658,
                    "objective_score": -267.518161228267
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.3661439180374146,
                    "num_nodes_avg": 2805.9,
                    "path_length_avg": 117.23608224498957,
                    "smoothness_avg": 0.01874205820490164,
                    "success_improvement": 0.0,
                    "time_improvement": -2640.7093195223824,
                    "length_improvement": 22.137376355206406,
                    "smoothness_improvement": 138.39759697151447,
                    "objective_score": -787.0933326008159
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a tuned bidirectional informed RRT* planner with adaptive step sizing, dynamic rewiring, informed sampling within an ellipsoidal heuristic, goal biasing, node pruning, and post-processing path smoothing. The tuning improves planning efficiency, path quality, robustness, success rate, and reduces search time through parameter adjustment and code refinements.",
          "planning_mechanism": "The planner grows two trees from start and goal by sampling points focused within an ellipsoidal informed region defined by the current best path cost, adapts step sizes near obstacles for safer expansions, rewires nodes to improve path cost, prunes unpromising nodes, attempts early connection between trees, and smooths the final path via shortcut shortcuts.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position  \n        self.parent = parent      \n        self.cost = cost          \n        self.children = []\n        self.valid = True         \n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_from_parent(self, edges: List[Tuple[\"Node\", \"Node\"]]):\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n            try:\n                edges.remove((self.parent, self))\n            except ValueError:\n                pass\n            self.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=6.0, rewire_radius: float=10.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            c_min = 1e-6 # to avoid division by zero\n        c_best = float(\"inf\")\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        unit_vec = np.array(goal) - np.array(start)\n        norm_unit = np.linalg.norm(unit_vec)\n        if norm_unit == 0:\n            unit_vec = np.array([1.0] + [0.0] * (dim - 1))\n        else:\n            unit_vec = unit_vec / norm_unit\n\n        def rotation_to_world(unit_vec):\n            if dim == 2:\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            elif dim == 3:\n                a = unit_vec\n                b = np.array([1.0, 0.0, 0.0])\n                v = a - b\n                norm_v = np.linalg.norm(v)\n                if norm_v < 1e-10:\n                    return np.identity(3)\n                v = v / norm_v\n                H = np.identity(3) - 2.0 * np.outer(v, v)\n                return H\n            else:\n                return np.identity(dim)\n\n        rotation_matrix = rotation_to_world(unit_vec)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in whole space\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                r1 = c_best / 2.0\n                val = c_best**2 - c_min**2\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n                L = np.diag([r1] + [r2] * (dim - 1))\n                for _ in range(100):  # max trials for valid sample\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x_ball = np.linalg.norm(x_ball)\n                    if norm_x_ball == 0:\n                        continue\n                    x_ball /= norm_x_ball\n                    radius = random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    sample = rotation_matrix @ L @ x_ball + x_center\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                        tup_sample = tuple(sample)\n                        if not self._is_in_obstacle(tup_sample, obstacles, is_3d):\n                            return tup_sample\n                # fallback uniform sampling\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d] * step for d in range(dim))\n            return new_pos\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            # Denser checks for collisions on longer expansions\n            steps_check = max(3, int(dist * 3))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step size on obstacle proximity\n                    return max(self.base_step * 0.4, 1.5)\n            return min(self.base_step, dist)\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=0.5):\n                        near.remove_from_parent(edges)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_source, tree_target, new_node):\n            nonlocal best_cost, best_path, success_state, c_best\n            if not tree_target:\n                return\n            nearest_other = min(tree_target, key=lambda n: math.dist(n.position, new_node.position))\n            if nearest_other is None:\n                return\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d, resolution=0.5):\n                return\n            total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                c_best = total_cost\n                if tree_source is tree_start:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = nearest_other.path_from_root()\n                else:\n                    path_from_start = nearest_other.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                combined = path_from_start + path_from_goal[::-1][1:]\n                best_path = combined\n                success_state = True\n\n        def prune_nodes(tree, best_cost):\n            # Remove nodes with heuristic cost >= best_cost to reduce tree size\n            heuristic_limit = best_cost if best_cost != float(\"inf\") else float(\"inf\")\n            to_remove = []\n            for node in tree:\n                heuristic = node.cost + math.dist(node.position, goal if tree is tree_start else start)\n                if heuristic >= heuristic_limit and node.parent is not None:\n                    to_remove.append(node)\n            for node in to_remove:\n                node.remove_from_parent(edges)\n                tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations: int=30) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.5):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Enforce map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n\n            heuristic_cost = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if heuristic_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n            try_connect(tree_a, tree_b, new_node)\n            prune_nodes(tree_a, best_cost)\n\n            # Early termination if solution is near optimal\n            if success_state and best_cost <= c_min * 1.005:\n                break\n\n        if success_state and best_path:\n            best_path = path_smoothing(best_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 822.0677,
          "time_improvement": -2596.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 515.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.2337754011154174,
                    "num_nodes_avg": 1490.8,
                    "path_length_avg": 151.75212631964249,
                    "smoothness_avg": 0.017597088539586338,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4814.7876836576725,
                    "length_improvement": 16.822254897880757,
                    "smoothness_improvement": 175.4326483339052,
                    "objective_score": -1490.1946908760563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.5396240234375,
                    "num_nodes_avg": 2565.2,
                    "path_length_avg": 229.6466576607132,
                    "smoothness_avg": 0.038857983083720946,
                    "success_improvement": 0.0,
                    "time_improvement": -833.4269605265401,
                    "length_improvement": 23.337335660315265,
                    "smoothness_improvement": 899.8438930180606,
                    "objective_score": -240.86140156080867
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 1.1164541721343995,
                    "num_nodes_avg": 1972.7,
                    "path_length_avg": 117.14830796645765,
                    "smoothness_avg": 0.04482812544376626,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -2139.790635516773,
                    "length_improvement": 22.195671851645315,
                    "smoothness_improvement": 470.21044677667885,
                    "objective_score": -735.1470040508194
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 825.8837295426457,
          "time_improvement": -2769.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.1454006433486938,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "smoothness_avg": 0.0150601233961907,
                    "success_improvement": 0.0,
                    "time_improvement": -4462.743729283604,
                    "length_improvement": 15.280155580980631,
                    "smoothness_improvement": 135.72363473177828,
                    "objective_score": -1335.088469495226
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.7989979982376099,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "smoothness_avg": 0.011376062771551485,
                    "success_improvement": 0.0,
                    "time_improvement": -990.6774692558113,
                    "length_improvement": 23.354217616048047,
                    "smoothness_improvement": 192.71428895883628,
                    "objective_score": -291.5688258087396
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.4722847938537598,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "smoothness_avg": 0.01876598180493872,
                    "success_improvement": 0.0,
                    "time_improvement": -2853.6453679806077,
                    "length_improvement": 22.0310377661009,
                    "smoothness_improvement": 138.7019033981297,
                    "objective_score": -850.9938933239715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is an enhanced RRT* planner which incrementally builds a single tree from the start toward the goal. It improves upon traditional RRT by rewiring nodes nearby newly added nodes to reduce path cost and improve path quality. The algorithm uses goal biasing for faster convergence and employs informed sampling after an initial solution to focus exploration within an ellipsoidal informed subset of the search space, thereby improving planning efficiency and success rates.",
          "planning_mechanism": "The planner samples random points in free space with goal biasing. If a solution is found, it switches to informed sampling (an ellipsoidal region constrained by current best path cost) to refine the solution. Each new node connects to the best parent from its neighbors minimizing cost, and nearby nodes are rewired if the new node can provide a lower cost path. Collision checks are performed for nodes and their edges. The process continues until max iterations or convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius    # Radius for rewiring neighbors\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def sample():\n            # If a solution found, use informed sampling inside ellipsoid\n            if success_state:\n                c_best = best_cost\n                c_min = math.dist(start_position, goal_position)\n                if c_best < float('inf'):\n                    # Informed sampling ellipsoid parameters\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    a1 = [(goal_position[d] - start_position[d]) / c_min for d in range(dim)]\n                    import numpy as np\n                    L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n                    # Rotation matrix aligning x-axis to a1\n                    def rotation_matrix(vec):\n                        import numpy as np\n                        e1 = np.array([1] + [0]*(dim-1))\n                        v = np.array(vec)\n                        v_norm = np.linalg.norm(v)\n                        if v_norm == 0:\n                            return np.eye(dim)\n                        v = v / v_norm\n                        if np.allclose(v, e1):\n                            return np.eye(dim)\n                        if np.allclose(v, -e1):\n                            # 180 deg rotation\n                            R = -np.eye(dim)\n                            R[0,0] = 1\n                            return R\n                        axis = np.cross(e1, v) if dim == 3 else ((e1 - v) / np.linalg.norm(e1 - v))\n                        s = np.linalg.norm(np.cross(e1, v)) if dim == 3 else 0\n                        c = np.dot(e1, v)\n                        # Rodrigues formula for 3D else identity\n                        if dim == 3:\n                            K = np.array([[0, -axis[2], axis[1]],\n                                          [axis[2], 0, -axis[0]],\n                                          [-axis[1], axis[0], 0]])\n                            R = np.eye(3) + K + K @ K * ((1 - c) / (s**2))\n                            return R\n                        else:\n                            return np.eye(dim)\n                    try:\n                        R = rotation_matrix(a1)\n                    except Exception:\n                        R = np.eye(dim)\n\n                    while True:\n                        # Sample unit ball\n                        sample_ball = np.random.normal(0,1,dim)\n                        sample_ball /= np.linalg.norm(sample_ball)\n                        # scale by random radius in unit ball\n                        r = random.random()\n                        sample_ball = sample_ball * (r ** (1/dim))\n                        # Scale by L and rotate and translate by center\n                        pt = R @ (L @ sample_ball) + np.array(center)\n                        pt_tuple = tuple(float(pt[d]) for d in range(dim))\n                        # Check bounds and obstacles\n                        if all(0 <= pt_tuple[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(pt_tuple, obstacles, is_3d):\n                            return pt_tuple\n                # If no proper informed sampling possible fallback to uniform\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near(nodes_list, new_node_pos, radius):\n            return [node for node in nodes_list if math.dist(node.position, new_node_pos) <= radius]\n\n        for _ in range(self.max_iter):\n            sample_point = sample()\n\n            nearest_node = nearest(nodes, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find near neighbors for RRT* rewiring\n            neighbor_nodes = near(nodes, new_pos, self.neighbor_radius)\n\n            # Choose the best parent minimizing cost to new_pos\n            best_parent = nearest_node\n            best_cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            for neighbor in neighbor_nodes:\n                cost_to_new = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_to_new < best_cost_to_new:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        best_parent = neighbor\n                        best_cost_to_new = cost_to_new\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire the neighbors if going through new_node is cheaper\n            for neighbor in neighbor_nodes:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except Exception:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_via_new\n                        new_node.children.append(neighbor)\n\n            # Check if new_node can connect to goal with collision-free edge\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best goal node if cost improves\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1889.64293,
          "time_improvement": -6318.0,
          "length_improvement": 25.0,
          "smoothness_improvement": 163.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 3.134256386756897,
                    "num_nodes_avg": 4621.6,
                    "path_length_avg": 145.17747491397782,
                    "smoothness_avg": 0.015451391233048662,
                    "success_improvement": 0.0,
                    "time_improvement": -12385.420501277411,
                    "length_improvement": 20.425925515343994,
                    "smoothness_improvement": 141.84782603031226,
                    "objective_score": -3710.8317261500024
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.1785389184951782,
                    "num_nodes_avg": 4265.0,
                    "path_length_avg": 216.89395587738153,
                    "smoothness_avg": 0.01101867112745796,
                    "success_improvement": 0.0,
                    "time_improvement": -1220.7815220624732,
                    "length_improvement": 27.594554581759674,
                    "smoothness_improvement": 183.5183445375136,
                    "objective_score": -359.7979539797024
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.715884828567505,
                    "num_nodes_avg": 4800.3,
                    "path_length_avg": 109.67961211616895,
                    "smoothness_avg": 0.02080417819421633,
                    "success_improvement": 0.0,
                    "time_improvement": -5348.511509019911,
                    "length_improvement": 27.156024014328693,
                    "smoothness_improvement": 164.6276110257328,
                    "objective_score": -1598.2991098479786
               }
          ],
          "success_rate": 1.0
     }
]