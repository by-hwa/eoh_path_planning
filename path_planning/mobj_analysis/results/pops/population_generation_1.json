[
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
          "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.33585,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 259.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.654359830512174,
          "time_improvement": 54.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020609617233276367,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 17.306726487427596,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 6.787323209480537
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03164470195770264,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 80.42008291490608,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.76431560419259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01710929870605469,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.63515364948351,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 21.411440677863403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
          "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.50088,
          "time_improvement": 36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.974939814675388,
          "time_improvement": 44.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012398910522460938,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 50.2510654377263,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 14.8169556563946
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027178692817687988,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 83.18339188143196,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 25.336085485098604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05079307556152344,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": -2.020326334253888,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": -1.2282216974670441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional growth and rewiring strategies of bidirectional RRT* with goal-biased sampling and dynamic incremental connection attempts. It features two trees grown from start and goal that alternate expansions. Each expansion uses neighborhood rewiring to reduce path cost, and after each new node is added, an incremental connection attempt with rewiring is made to join the two trees as early as possible. Collision checks ensure validity of nodes and edges, and careful cost-based parent selection with children management maintains tree consistency and path quality. The planner terminates early upon finding a valid connecting path, outputting an optimized, smooth, and low-cost route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased random sampling. Each iteration extends one tree by steering towards a sampled point with step size limits and rewiring neighbors within a radius to minimize path cost. Then, it attempts an incremental connection from the other tree to the newly added node with rewiring to further optimize cost and connect paths. Collision checks ensure nodes and edges are valid, preventing invalid expansions. This bidirectional, rewiring-based approach accelerates convergence, improves path quality and smoothness, and reduces planning time by rapidly discovering a valid optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost of descendants\n        for child in self.children:\n            dist = self._distance(child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def is_collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    prev_parent = neighbor.parent\n                    if prev_parent:\n                        if (prev_parent, neighbor) in edges:\n                            edges.remove((prev_parent, neighbor))\n                        prev_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample):\n            # Find nearest node\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, connect_node):\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, connect_node.position))\n            dist = math.dist(nearest_node.position, connect_node.position)\n            if dist > self.step_size:\n                return None\n\n            if not is_collision_free_node(connect_node.position):\n                return None\n            if not is_collision_free_edge(nearest_node.position, connect_node.position):\n                return None\n\n            neighbors = near_nodes(tree, connect_node.position)\n\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, connect_node.position)\n                if cost_through_neighbor < min_cost and is_collision_free_edge(neighbor.position, connect_node.position):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(connect_node.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        success_state = False\n        final_path = []\n\n        # Alternate tree starts with start tree\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                final_path = path_a + path_b[1:]  # avoid duplicate connection node\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -12.01814,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 316.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027533936500549316,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 160.569386712611,
                    "smoothness_avg": 0.02450451608453697,
                    "success_improvement": 0.0,
                    "time_improvement": -10.476158588791257,
                    "length_improvement": 11.989374758062796,
                    "smoothness_improvement": 283.54888913137535,
                    "objective_score": 0.672771820632059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052264285087585446,
                    "num_nodes_avg": 325.9,
                    "path_length_avg": 240.06426952247952,
                    "smoothness_avg": 0.017266584034611274,
                    "success_improvement": 0.0,
                    "time_improvement": 67.66187370339429,
                    "length_improvement": 19.8596369665261,
                    "smoothness_improvement": 344.28164382833637,
                    "objective_score": 25.99189772346519
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042936849594116214,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.98176033662389,
                    "smoothness_avg": 0.03298287097098217,
                    "success_improvement": 0.0,
                    "time_improvement": 13.759280001647332,
                    "length_improvement": 18.321370546532442,
                    "smoothness_improvement": 319.53968420860195,
                    "objective_score": 9.389756530843698
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified yet effective bidirectional RRT* inspired planner using dual trees growing simultaneously from start and goal with goal bias sampling and rewiring. The Node class supports parent updates and child management to maintain tree consistency. Goal bias accelerates convergence, rewiring improves path quality by locally optimizing connections, and collision checking ensures safe expansions. The planner alternates tree expansions, attempts incremental connection with rewiring, and merges paths upon successful connection, balancing exploration and exploitation for efficient, robust pathfinding.",
          "planning_mechanism": "The planner initializes two trees from start and goal points. At each iteration, it samples a point biased towards the goal, extends one tree towards the sample with rewiring to optimize costs, then incrementally attempts to connect the other tree back with rewiring. Collision and edge checks guarantee validity. Upon connection, paths are concatenated to produce the final solution. This alternation and rewiring enable fast convergence to high-quality, smooth paths with reduced computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For collision/status checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n\n        # Find optimal parent among neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor == nearest:\n                continue\n            candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = candidate_cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors through new_node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        current = nearest\n\n        while True:\n            new_pos = self._steer(current.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = current.cost + math.dist(current.position, new_pos)\n            best_parent = current\n            for neighbor in neighbors:\n                if neighbor == current:\n                    continue\n                candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.84193,
          "time_improvement": 18.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 331.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01887509822845459,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 151.17482827913645,
                    "smoothness_avg": 0.02102342809722014,
                    "success_improvement": 0.0,
                    "time_improvement": 24.26624702849299,
                    "length_improvement": 17.138681101754965,
                    "smoothness_improvement": 229.06230282631154,
                    "objective_score": 11.85292184303045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07972452640533448,
                    "num_nodes_avg": 392.1,
                    "path_length_avg": 235.8839930063653,
                    "smoothness_avg": 0.01930007836028916,
                    "success_improvement": 0.0,
                    "time_improvement": 50.67105960576548,
                    "length_improvement": 21.25513359019308,
                    "smoothness_improvement": 396.60491749478894,
                    "objective_score": 21.435369187242205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06023519039154053,
                    "num_nodes_avg": 310.7,
                    "path_length_avg": 122.75329360888414,
                    "smoothness_avg": 0.03676825833269663,
                    "success_improvement": 0.0,
                    "time_improvement": -20.985266448523078,
                    "length_improvement": 18.4731072686807,
                    "smoothness_improvement": 367.68953204137927,
                    "objective_score": -0.7625108206138871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm is a bidirectional RRT* inspired planner with enhanced efficiency through goal-biased random sampling, dynamic local rewiring during tree expansions, and incremental connection attempts between start and goal trees. It incorporates efficient nearest neighbor querying, adaptive steering with step size limits, and rigorous collision checking for node positions and edges. The rewiring optimizes cost and path quality while alternating tree expansions accelerates convergence. This leads to faster planning times, improved path smoothness, and higher success rates.",
          "planning_mechanism": "The planner grows two trees simultaneously, sampling mostly towards the goal to improve search focus. On each iteration, one tree is extended toward a sampled point with rewiring of nearby nodes to minimize cost. Then it attempts connecting the other tree to the newly added node via rewiring to form a continuous path. Collision checks ensure validity at every step. By alternating expansions and rewiring, the method quickly converges to a collision-free, optimized path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Efficient nearest search: linear for simplicity, can be optimized with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Re-assign parent\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, connect_to_node):\n            nearest_node = nearest(tree, connect_to_node.position)\n            dist = math.dist(nearest_node.position, connect_to_node.position)\n            if dist > self.step_size:\n                return None\n            if self._is_in_obstacle(connect_to_node.position, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, connect_to_node.position, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, connect_to_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, connect_to_node.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, connect_to_node.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(connect_to_node.position, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Alternate tree expansion each iteration to balance growth\n        start_tree = tree_start\n        goal_tree = tree_goal\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = try_extend(start_tree, sample)\n            if new_node_start is None:\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            new_node_goal = try_connect(goal_tree, new_node_start)\n            if new_node_goal:\n                # Paths connecting start_tree root to new_node_start, and goal_tree root to new_node_goal\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path_goal.reverse()\n                extracted_path = path_start + path_goal[1:]  # Avoid duplicating connecting node\n                success_state = True\n                break\n\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -10.74705,
          "time_improvement": 23.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 218.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021436524391174317,
                    "num_nodes_avg": 147.8,
                    "path_length_avg": 161.4200586584748,
                    "smoothness_avg": 0.018596289666266766,
                    "success_improvement": 0.0,
                    "time_improvement": 13.988874486413575,
                    "length_improvement": 11.523107984775253,
                    "smoothness_improvement": 191.07231576642934,
                    "objective_score": 7.45664552171127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06319136619567871,
                    "num_nodes_avg": 366.1,
                    "path_length_avg": 251.15246650705654,
                    "smoothness_avg": 0.0131187349704594,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90082591838002,
                    "length_improvement": 16.15807765702018,
                    "smoothness_improvement": 237.55449983278646,
                    "objective_score": 22.689635806081974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05267148017883301,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 130.14155852635278,
                    "smoothness_avg": 0.025465211964407646,
                    "success_improvement": 0.0,
                    "time_improvement": -5.793192023664093,
                    "length_improvement": 13.566173501866952,
                    "smoothness_improvement": 223.915616540841,
                    "objective_score": 2.094855175978368
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighbor radius, incremental connection attempts, goal bias sampling, rewiring for path cost optimization, and path smoothing. It enforces collision-free node and edge checks, bounds clamping, and stops planning once a time limit is reached to ensure practical execution time.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansion with goal-biased sampling. It extends one tree towards samples, rewires neighbors to minimize path costs, then incrementally connects the other tree to the new node with rewiring. When connected, paths are merged and smoothed. Execution halts if time exceeds 30 seconds, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update costs of descendants for consistency\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.time()\n\n        # Utility functions\n        def _random():\n            import random\n            return random.random()\n\n        def sample_free(goal_bias_for_start=True):\n            # Goal biasing for alternating trees\n            if _random() < self.goal_sample_rate:\n                return goal_position if goal_bias_for_start else start_position\n            while True:\n                sample = tuple(_random() * bounds[d] for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def try_extend_and_rewire(tree, point):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improvement possible\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.time() - start_time > self.time_limit_sec:\n                return None\n            curr_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                if time.time() - start_time > self.time_limit_sec:\n                    return None\n                curr_node = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) < 3:\n                    break\n                i = int(_random() * (len(path) - 2))\n                j = i + 2 + int(_random() * (len(path) - i - 2))\n                if j >= len(path):\n                    j = len(path) - 1\n                if j <= i + 1:\n                    attempts += 1\n                    continue\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    del path[i + 1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break  # Time limit exceeded\n\n            sample = sample_free(goal_bias_for_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge and smooth final path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # avoid duplicate node\n                extracted_path = path_smoothing(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.42336,
          "time_improvement": 2.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1407.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04564192295074463,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 164.0663458293772,
                    "smoothness_avg": 0.037275524225553885,
                    "success_improvement": 0.0,
                    "time_improvement": -92.49927348747131,
                    "length_improvement": 10.072636053299995,
                    "smoothness_improvement": 483.4428992263453,
                    "objective_score": -23.318040339449666
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06323657035827637,
                    "num_nodes_avg": 276.4,
                    "path_length_avg": 241.39358297851035,
                    "smoothness_avg": 0.09835034963146143,
                    "success_improvement": 0.0,
                    "time_improvement": 73.63539600771674,
                    "length_improvement": 19.415873872736682,
                    "smoothness_improvement": 2430.6253349110125,
                    "objective_score": 38.12692025141742
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08017446994781494,
                    "num_nodes_avg": 365.3,
                    "path_length_avg": 128.70032423974,
                    "smoothness_avg": 0.11066732728565867,
                    "success_improvement": 0.0,
                    "time_improvement": 23.393763084696577,
                    "length_improvement": 14.523372690833355,
                    "smoothness_improvement": 1307.6802344611865,
                    "objective_score": 16.461204635881575
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner integrating adaptive informed sampling with goal bias, rewiring for path cost optimization, and incremental connection of trees. It balances exploration and exploitation by focusing samples within an ellipsoidal informed region when a solution is found, uses fixed-radius rewiring to improve solution quality dynamically, and performs collision-aware incremental connections to swiftly merge two trees. Post-processing smoothing via random shortcutting further refines the path for length and smoothness improvements.",
          "planning_mechanism": "The planner alternates growing start and goal trees with rewiring of neighbors to minimize path costs. It samples with goal bias and informed ellipsoidal sampling towards the goal to accelerate convergence. When trees approach, an incremental rewiring-enhanced connection is performed to join them. After a valid path is found, path smoothing is applied to reduce detours and shorten the path. The structure maintains robust parent-child relations and ensures strict collision checks for nodes and edges throughout the process.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float) -> None:\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 7000,\n        step_size: float = 4.0,\n        goal_sample_rate: float = 0.15,\n        neighbor_radius: float = 20.0,\n        smoothing_iters: int = 50,\n        collision_resolution: float = 0.5,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        # Trees and data structures\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Variables for informed sampling\n        c_best = math.inf\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2.0 for s, g in zip(start_position, goal_position))\n        # Rotation matrix from unit vector along x axis to vector from start to goal\n        def rotation_to_goal():\n            \"\"\"Calculate rotation matrix to align x-axis with vector from start to goal in dimension D.\"\"\"\n            a1 = np.array(goal_position) - np.array(start_position)\n            a1 = a1 / np.linalg.norm(a1)\n            Id = np.eye(dimension)\n            if dimension == 2:\n                # 2D rotation matrix\n                angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s], [s, c]])\n            else:\n                # For 3D, use Householder transformation\n                e1 = np.zeros(dimension)\n                e1[0] = 1.0\n                v = a1 - e1\n                if np.linalg.norm(v) < 1e-10:\n                    return Id\n                v = v / np.linalg.norm(v)\n                H = Id - 2.0 * np.outer(v, v)\n                return H\n\n        rotation_matrix = rotation_to_goal()\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid defined by current best cost c_best\n            if c_best == math.inf:\n                return uniform_sample()\n            r1 = c_best/2.0\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            while True:\n                # Sample unit ball in dimension\n                if dimension == 2:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    unit_ball = np.array([x, y])\n                else:\n                    # Sample 3D unit ball via rejection\n                    while True:\n                        px = random.uniform(-1,1)\n                        py = random.uniform(-1,1)\n                        pz = random.uniform(-1,1)\n                        if px*px+py*py+pz*pz <= 1:\n                            unit_ball = np.array([px, py, pz])\n                            break\n                L = np.diag([r1] + [r2]*(dimension-1))\n                sample_local = L @ unit_ball\n\n                # Rotate and translate sample\n                sample_world = rotation_matrix @ sample_local + np.array(x_center)\n\n                point = tuple(np.clip(sample_world, [0]*dimension, bounds))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def uniform_sample():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def sample():\n            # Goal bias applied along with informed sampling when c_best is finite\n            if c_best < math.inf:\n                p_goal = random.random()\n                if p_goal < self.goal_sample_rate:\n                    return goal_position\n                if random.random() < 0.5:\n                    return informed_sample()\n                return uniform_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                not collision_free_edge(nearest_node.position, new_pos)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent by cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(curr_node.position, new_pos)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_final_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate node position at connection\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n\n                p1 = new_path[i]\n                p2 = new_path[j]\n\n                if collision_free_edge(p1, p2):\n                    # Shortcut by removing intermediate points\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                extracted_path = extract_final_path(new_node_a, new_node_b)\n                # Update c_best and informed sampling parameters\n                c_best = sum(math.dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1))\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = path_smoothing(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -8.07632,
          "time_improvement": -4.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1103.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03546233177185058,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 160.4244848049874,
                    "smoothness_avg": 0.035022633560391106,
                    "success_improvement": 0.0,
                    "time_improvement": -42.28776145674394,
                    "length_improvement": 12.068797789748949,
                    "smoothness_improvement": 448.1802680861655,
                    "objective_score": -8.031667538642562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08922274112701416,
                    "num_nodes_avg": 355.5,
                    "path_length_avg": 229.67382658668322,
                    "smoothness_avg": 0.06373306979660538,
                    "success_improvement": 0.0,
                    "time_improvement": 44.79411195887387,
                    "length_improvement": 23.3282658908123,
                    "smoothness_improvement": 1539.897790941334,
                    "objective_score": 25.803375720531292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05740001201629639,
                    "num_nodes_avg": 222.1,
                    "path_length_avg": 117.09146594625352,
                    "smoothness_avg": 0.11160099977024449,
                    "success_improvement": 0.0,
                    "time_improvement": -15.29067481648307,
                    "length_improvement": 22.233423614938765,
                    "smoothness_improvement": 1319.556479548584,
                    "objective_score": 6.457264675785753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified, goal-biased bidirectional RRT* algorithm with incremental rewiring to optimize path cost and improve planning efficiency. Two trees grow from start and goal positions alternating expansions, where each new node connects through the lowest-cost parent within a fixed neighbor radius. Rewiring of nearby nodes reduces path costs dynamically. Collision checks on nodes and edges ensure feasibility and robustness. Once the two trees connect, their root paths are combined to form a smooth, optimized route.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling points biased towards each opposite root to accelerate convergence. Each extension involves cost-based parent selection and rewiring of neighbors to refine path quality. After every extension, an incremental connection attempt with rewiring is made to join trees earlier and improve path smoothness. Collision and boundary checks maintain reliability and avoid invalid expansions, resulting in improved success rates and reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free(tree_from, tree_to_root):\n            if random.random() < self.goal_sample_rate:\n                # bias sample towards opposing tree root\n                return tree_to_root.position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            sample_point = sample_free(tree_a[0], tree_b[0])\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.54897,
          "time_improvement": 10.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 237.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024068188667297364,
                    "num_nodes_avg": 118.1,
                    "path_length_avg": 162.16088273051918,
                    "smoothness_avg": 0.018111696645408973,
                    "success_improvement": 0.0,
                    "time_improvement": 3.4296811100641387,
                    "length_improvement": 11.117050571779089,
                    "smoothness_improvement": 183.48738267941727,
                    "objective_score": 4.169751360772146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07468876838684083,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 243.3674034244215,
                    "smoothness_avg": 0.013951704330297302,
                    "success_improvement": 0.0,
                    "time_improvement": 53.78689632922378,
                    "length_improvement": 18.756955794620104,
                    "smoothness_improvement": 258.98740142499486,
                    "objective_score": 21.18239706481613
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06368763446807861,
                    "num_nodes_avg": 330.2,
                    "path_length_avg": 117.95792484222511,
                    "smoothness_avg": 0.02891657606089635,
                    "success_improvement": 0.0,
                    "time_improvement": -27.91966582177128,
                    "length_improvement": 21.657962872573307,
                    "smoothness_improvement": 267.81671309497943,
                    "objective_score": -2.7052236065418245
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with goal-biased informed sampling, dynamic rewiring, and incremental tree connection. It enforces rigorous collision checks on nodes and edges, manages parent-child relationships for efficient rewiring, and limits execution time to ensure timely response while optimizing path cost and smoothness.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal toward randomly sampled points biased by a goal-oriented heuristic within map bounds and obstacles. For each new sampled point, it selects the best parent node minimizing path cost in a neighborhood and rewires neighbors if the new path is cheaper. The planner tries to incrementally connect the two trees with rewiring to form a full path. It terminates upon success or after 30 seconds, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]: spatial coordinate (2D or 3D)\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # List of child nodes\n        self.valid = True             # Node validity flag (e.g., collision free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, neighbor_radius: float=20.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def valid_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_free(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if valid_node(node.position) and edge_free(nearest_node.position, node.position):\n                    return nearest_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success = False\n\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                # Time limit reached; return best found path so far.\n                break\n\n            sample = sample_free()\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not valid_node(new_pos):\n                    continue\n                if not edge_free(nearest_node.position, new_pos):\n                    continue\n\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_via_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_via_neighbor < min_cost and edge_free(neighbor.position, new_pos):\n                        min_cost = cost_via_neighbor\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost and edge_free(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = potential_cost\n                        edges.append((new_node, neighbor))\n\n                connect_node = try_connect(tree_b, new_node)\n                if connect_node:\n                    conn_neighbors = near_nodes(tree_b, new_node.position)\n                    min_conn_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_conn_parent = connect_node\n                    for neighbor in conn_neighbors:\n                        cost_try = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if cost_try < min_conn_cost and edge_free(neighbor.position, new_node.position):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                    new_node_other = Node(new_node.position)\n                    best_conn_parent.add_child(new_node_other)\n                    new_node_other.cost = min_conn_cost\n                    tree_b.append(new_node_other)\n                    nodes.append(new_node_other)\n                    edges.append((best_conn_parent, new_node_other))\n\n                    for neighbor in conn_neighbors:\n                        if neighbor is best_conn_parent:\n                            continue\n                        cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                        if cost_via_new < neighbor.cost and edge_free(new_node_other.position, neighbor.position):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_other.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n\n                    total_cost = new_node.cost + new_node_other.cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success = True\n\n                    # Stop immediately on first successful connection\n                    break\n\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -5.84492,
          "time_improvement": 1.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 428.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04308300018310547,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 163.1762654561707,
                    "smoothness_avg": 0.027824464800794584,
                    "success_improvement": 0.0,
                    "time_improvement": -81.70676647122058,
                    "length_improvement": 10.560503210080563,
                    "smoothness_improvement": 335.5132959248345,
                    "objective_score": -20.722362819725888
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07495694160461426,
                    "num_nodes_avg": 349.9,
                    "path_length_avg": 233.93850869422153,
                    "smoothness_avg": 0.02168014879726888,
                    "success_improvement": 0.0,
                    "time_improvement": 68.7489364037006,
                    "length_improvement": 21.90459225124772,
                    "smoothness_improvement": 457.84584413372045,
                    "objective_score": 27.294828592028328
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08740341663360596,
                    "num_nodes_avg": 319.6,
                    "path_length_avg": 123.78660059659566,
                    "smoothness_avg": 0.046524904337205866,
                    "success_improvement": 0.0,
                    "time_improvement": 16.486546824704362,
                    "length_improvement": 17.786833968233932,
                    "smoothness_improvement": 491.79334905804063,
                    "objective_score": 10.962297586348297
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT*-style path planner that grows two trees from start and goal positions simultaneously, employing goal-biased sampling, incremental tree expansion with cost-based rewiring, and frequent incremental connection attempts between the two trees. It ensures collision-free nodes and edges while dynamically optimizing path cost through rewiring in both trees. The algorithm promotes efficiency, robustness, and quality by balancing exploration and exploitation with structured incremental connections and rewiring to produce smooth, shorter paths.",
          "planning_mechanism": "The planner alternates growth between two trees using goal-biased random samples, extends and rewires one tree towards samples, then incrementally connects and rewires the opposite tree towards the newly added node. This frequent attempt to link the trees combined with rewiring optimizes path cost on the fly. Collision checking for nodes and edges ensures validity. Upon successful connection, paths are merged to output a smooth and optimized final route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Update costs recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(child.position))\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._within_bounds(pos, bounds)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            \n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n                rewire(tree, new_node, neighbors)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Merge paths from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.40105,
          "time_improvement": 0.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 291.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021263980865478517,
                    "num_nodes_avg": 90.2,
                    "path_length_avg": 155.46314810612068,
                    "smoothness_avg": 0.02029841917168108,
                    "success_improvement": 0.0,
                    "time_improvement": 14.681181810789734,
                    "length_improvement": 14.78818505180875,
                    "smoothness_improvement": 217.71433875954466,
                    "objective_score": 8.450563247396394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07615876197814941,
                    "num_nodes_avg": 383.7,
                    "path_length_avg": 238.22231704511987,
                    "smoothness_avg": 0.015554505787950446,
                    "success_improvement": 0.0,
                    "time_improvement": 52.87734904791542,
                    "length_improvement": 20.474533721131174,
                    "smoothness_improvement": 300.2286373816369,
                    "objective_score": 21.459254645509045
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08309917449951172,
                    "num_nodes_avg": 392.6,
                    "path_length_avg": 115.95748746207536,
                    "smoothness_avg": 0.035670171688152404,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90867420064964,
                    "length_improvement": 22.986558129877153,
                    "smoothness_improvement": 353.72195097510166,
                    "objective_score": -13.706680879343953
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* planner by integrating informed ellipsoidal goal-biased sampling to focus exploration on promising regions, dynamically adjusting neighbor radius based on the node count and dimension for efficient rewiring, and incremental rewiring to continuously improve path quality. A balance of exploration and exploitation is achieved by alternating tree growth, ensuring collision-free node and edge connections. The planner uses numpy for efficient linear algebra operations in sampling, employs adaptive step sizing, and terminates early upon finding a feasible low-cost path, thereby reducing planning time and improving path smoothness and quality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately, samples points biased towards the dynamically defined ellipsoidal informed subset around the current best path cost, extends trees towards sampled points with constrained steps, performs collision checks, rewires neighbors within an adaptive radius, attempts connection between trees at each iteration, and returns an optimized smooth path on success or after reaching iteration limits.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal bias\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of 2D or 3D boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        # Current best path and its cost, initialize with None and infinity\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        # Adaptive neighbor radius: \u03b3 * (log(n)/n)^(1/d), \u03b3 ~ 30 (tuned)\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        # Ellipsoidal informed sampling between start and goal constrained by current best cost\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):  # No solution found yet: uniform random sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoid parameters\n            c_min = dist(start, goal)\n            if best_cost < c_min:\n                # Numerics: clamp to c_min to avoid pathological ellipsoid\n                c_cost = c_min\n            else:\n                c_cost = best_cost\n\n            # Center of ellipsoid\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n\n            # Rotation matrix aligning x-axis to start-goal vector\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)  # start==goal rare case\n\n            e1 = a1 / norm_a1  # Unit vector from start to goal\n\n            # Construct basis via QR decomposition for dimension d\n            I = np.eye(dim)\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            # Ellipsoid radii\n            r1 = c_cost / 2.0\n            if c_cost * c_cost - c_min * c_min <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_cost * c_cost - c_min * c_min) / 2.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Sample uniformly from unit ball in dim-dimensions\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 0:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n\n            # Scale and transform sample to ellipsoid\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            # Final collision check for sample is omitted here (usually acceptable)\n            return sample_point\n\n        # Rewiring logic\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n                    # Update edges list: remove old edge\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        # Extension + rewiring for one tree towards a sampled point\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            # Choose best parent with min cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Attempt to connect two trees via the newly added node in tree_a by extending tree_b towards it incrementally,\n        # rewiring and choosing lower cost parents until connection or failure\n        def connect_and_rewire(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                # Direct check\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir == 0:\n                return None\n\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            # Choose best parent among neighbors\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_to, new_node, neighbors)\n\n            # Recursively attempt to connect further or reach the target\n            if dist(new_pos, current_pos) <= self.step_size:\n                # Final connection attempt\n                if collision_free_edge(new_pos, current_pos):\n                    final_connect = Node(current_pos)\n                    final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                    tree_to.append(final_connect)\n                    nodes.append(final_connect)\n                    edges.append((new_node, final_connect))\n                    rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                    return final_connect\n                return None\n\n            # Continue extending towards current_pos if possible\n            return connect_and_rewire(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    # Reconstruct full path from start to goal\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_and_rewire(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping for good solution, can be commented out for longer optimization\n                        break\n\n            grow_start = not grow_start\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.28427,
          "time_improvement": 13.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 128.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028359365463256837,
                    "num_nodes_avg": 110.4,
                    "path_length_avg": 171.9092710773572,
                    "smoothness_avg": 0.017696900898962236,
                    "success_improvement": 0.0,
                    "time_improvement": -13.788079533551127,
                    "length_improvement": 5.773804445778623,
                    "smoothness_improvement": 176.99492850414552,
                    "objective_score": -2.0966883283888853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06134157180786133,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 289.6449868661758,
                    "smoothness_avg": 0.007427513234392058,
                    "success_improvement": 0.0,
                    "time_improvement": 62.04537203502058,
                    "length_improvement": 3.3081664153793446,
                    "smoothness_improvement": 91.11526534244898,
                    "objective_score": 19.730821220294285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05503737926483154,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 144.51516822016083,
                    "smoothness_avg": 0.016953867316359176,
                    "success_improvement": 0.0,
                    "time_improvement": -10.545213714792496,
                    "length_improvement": 4.019906340982156,
                    "smoothness_improvement": 115.65194085977592,
                    "objective_score": -1.7813231419424378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a bidirectional RRT* style planner with goal-biased sampling, incremental connection, and local rewiring to improve planning speed and path quality. It simultaneously grows two trees from start and goal positions, extends toward sampled points with bias toward the goal, and rewires paths locally to minimize costs while avoiding collisions in 2D or 3D space. The planner enforces node and edge collision checks, alternates tree expansions for balanced growth, and enforces a strict 30-second planning time limit, returning the best path found within this budget.",
          "planning_mechanism": "The planner samples nodes using goal biasing and extends trees alternately toward samples by a fixed step size within bounds. It locally rewires nearby nodes to reduce cost after each extension. On every iteration, the planner attempts to connect the two trees and, if successful, extracts and returns a smooth, optimized path. Collision checks ensure all nodes and edges remain valid. Time budget enforcement guarantees termination with the best known solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        self.parent = new_parent\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time = max_time  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            else:\n                ratio = self.step_size / d\n                return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def near_nodes(nodes, position):\n            radius = self.neighbor_radius\n            return [node for node in nodes if dist(node.position, position) <= radius]\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            if not within_bounds(to_pos):\n                return False\n            return True\n\n        # Attempt to extend tree towards point with rewiring\n        def extend_and_rewire(tree_nodes, point):\n            nearest_node = nearest(tree_nodes, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_nodes, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost < min_cost and collision_free(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_nodes.append(new_node)\n\n            # Rewire neighbors if beneficial\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Update parent\n                    neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        # Try connecting one tree to a node added in another tree, with rewiring on connect side\n        def connect_and_rewire(connect_tree, node_to_connect):\n            nearest_node = nearest(connect_tree, node_to_connect.position)\n            if dist(nearest_node.position, node_to_connect.position) > self.step_size:\n                return None\n            if not collision_free(nearest_node.position, node_to_connect.position):\n                return None\n\n            neighbors = near_nodes(connect_tree, node_to_connect.position)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, node_to_connect.position)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + dist(neighbor.position, node_to_connect.position)\n                if cost < min_cost and collision_free(neighbor.position, node_to_connect.position):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(node_to_connect.position)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            connect_tree.append(new_node)\n\n            # Rewire neighbors in connect_tree\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        start_time = time.time()\n\n        # Initialize trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        # Alternate trees to grow for balanced bidirectional expansion\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time:\n                break\n\n            sample_point = sample_free()\n\n            # Extend tree_a towards sampled point\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Connected successful, extract path\n\n                # Build edges list from start tree\n                edges.clear()\n                for n in nodes:\n                    for c in n.children:\n                        edges.append((n, c))\n\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n\n                # Combine paths: start path + reversed goal path except duplicate connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                break\n\n            nodes = tree_start + tree_goal\n\n            # Swap trees for next iteration expansion\n            tree_a, tree_b = tree_b, tree_a\n\n        # On timeout or no success, try to find best path that connects trees if any (optional)\n        if not success_state:\n            # Check all pairs for potential connection to produce best path found so far\n            best_cost = float('inf')\n            best_connection = None\n            for n_start in tree_start:\n                for n_goal in tree_goal:\n                    if dist(n_start.position, n_goal.position) <= self.step_size and collision_free(n_start.position, n_goal.position):\n                        total_cost = n_start.cost + dist(n_start.position, n_goal.position) + n_goal.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (n_start, n_goal)\n            if best_connection is not None:\n                path_start = best_connection[0].path_from_root()\n                path_goal = best_connection[1].path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n\n            # Build edges list\n            edges.clear()\n            for n in nodes:\n                for c in n.children:\n                    edges.append((n, c))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -3.67201,
          "time_improvement": 0.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 224.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03826737403869629,
                    "num_nodes_avg": 134.9,
                    "path_length_avg": 169.84564253571372,
                    "smoothness_avg": 0.019400254248835798,
                    "success_improvement": 0.0,
                    "time_improvement": -61.39639227453224,
                    "length_improvement": 6.904911949740244,
                    "smoothness_improvement": 203.6561073206688,
                    "objective_score": -16.019654755808276
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07387025356292724,
                    "num_nodes_avg": 326.5,
                    "path_length_avg": 251.31283072739484,
                    "smoothness_avg": 0.012996142372631875,
                    "success_improvement": 0.0,
                    "time_improvement": 69.20199860678825,
                    "length_improvement": 16.104543464443104,
                    "smoothness_improvement": 234.40010399080512,
                    "objective_score": 25.15350879487912
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11241765022277832,
                    "num_nodes_avg": 363.6,
                    "path_length_avg": 128.46614711876808,
                    "smoothness_avg": 0.02626908746048357,
                    "success_improvement": 0.0,
                    "time_improvement": -7.414407005537998,
                    "length_improvement": 14.678901984266721,
                    "smoothness_improvement": 234.14085351500984,
                    "objective_score": 1.8821625627669942
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an improved bidirectional RRT* variant that integrates goal-biased sampling, adaptive neighborhood rewiring, incremental connection attempts between two alternating trees, and post-processing path smoothing for enhanced path quality and smoothness. It enforces strict collision checks and bounded sampling, adapts rewiring neighborhood size dynamically, and limits execution to 30 seconds to ensure practical planning times. The Node class manages parent-child relationships robustly to maintain tree consistency and supports cost-based rewiring for path optimization.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions using goal-biased sampling toward the opposing root, steering incrementally with a fixed step size. Each newly added node rewires its neighbors within an adaptively calculated radius to minimize path cost. After extending one tree, the planner incrementally connects the other tree to the new node, with rewiring for optimization. Collision checks ensure feasible nodes and edges. Upon successful connection, the combined path is extracted and smoothed via random shortcutting within collision constraints. If planning time exceeds 30 seconds, the best found solution is returned immediately.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Recursively update cost for descendants\n        for c in self.children:\n            dist = self._distance(c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def _distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0, goal_sample_rate: float = 0.2,\n                 neighbor_factor: float = 20.0, smoothing_iters: int = 50, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math, time\n\n        start_time = time.time()\n        MAX_TIME = 30.0  # max 30 seconds planning time enforced\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def sample_free(tree_from):\n            # Goal bias biased toward opposite tree root for directed sampling\n            if random.random() < self.goal_sample_rate:\n                return tree_from[0].position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            # Adaptive neighbor radius based on sample count, clamped min 5.0 and max neighbor_factor\n            n = max(len(tree), 1)\n            r = min(max(self.neighbor_factor * (math.log(n) / n) ** (1.0 / dimension), 5.0), self.neighbor_factor)\n            return [node for node in tree if math.dist(node.position, position) <= r]\n\n        def collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree_from, sample):\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_from, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                if collision_free_edge(neighbor.position, new_pos):\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost:\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_from, new_node, neighbors)\n            return new_node\n\n        def try_incremental_connect(tree_to, target_node):\n            nearest = min(tree_to, key=lambda n: math.dist(n.position, target_node.position))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree_to, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    if collision_free_edge(neighbor.position, new_pos):\n                        cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_to, new_node, neighbors)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    # Last connection edge\n                    final_dist = math.dist(new_node.position, target_node.position)\n                    if final_dist <= self.step_size and \\\n                        collision_free_node(target_node.position) and \\\n                        collision_free_edge(new_node.position, target_node.position):\n                        # Connect final node\n                        final_node = Node(target_node.position)\n                        min_cost_final = new_node.cost + final_dist\n                        final_best_parent = new_node\n                        for neighbor in neighbors:\n                            if neighbor != new_node and collision_free_edge(neighbor.position, target_node.position):\n                                c = neighbor.cost + math.dist(neighbor.position, target_node.position)\n                                if c < min_cost_final:\n                                    min_cost_final = c\n                                    final_best_parent = neighbor\n                        final_best_parent.add_child(final_node)\n                        final_node.cost = min_cost_final\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((final_best_parent, final_node))\n\n                        rewire(tree_to, final_node, neighbors)\n                        return final_node\n\n                    return None\n                curr_node = new_node\n\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            path_b.reverse()\n            return path_a + path_b[1:]  # avoid duplicated node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not collision_free_edge(path[i], path[j]):\n                    continue\n                # shortcut if collision free\n                del path[i + 1:j]\n            return path\n\n        tree_a, tree_b = tree_start, tree_goal\n        success = False\n        final_path = []\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > MAX_TIME:\n                break\n            # Sample biased toward root of other tree for better directed growth\n            sample = sample_free(tree_b if tree_a is tree_start else tree_a)\n\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a)\n            if new_node_b:\n                final_path = extract_path(new_node_a, new_node_b)\n                final_path = path_smoothing(final_path)\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success but still have nodes, extract best partial path via closest node to goal\n        if not success:\n            # Check closest node to goal in start tree\n            closest_node = min(tree_start, key=lambda n: math.dist(n.position, goal_pos))\n            if closest_node:\n                final_path = closest_node.path_from_root()\n                final_path = path_smoothing(final_path)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.06862,
          "time_improvement": -27.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 998.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06343424320220947,
                    "num_nodes_avg": 172.6,
                    "path_length_avg": 165.01787273572657,
                    "smoothness_avg": 0.023010741858143564,
                    "success_improvement": 0.0,
                    "time_improvement": -167.5401241054343,
                    "length_improvement": 9.551089078021201,
                    "smoothness_improvement": 260.1680787056673,
                    "objective_score": -47.05097902249771
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10997071266174316,
                    "num_nodes_avg": 415.3,
                    "path_length_avg": 249.15139230771564,
                    "smoothness_avg": 0.06530571321983464,
                    "success_improvement": 0.0,
                    "time_improvement": 54.15098773305682,
                    "length_improvement": 16.826093822487405,
                    "smoothness_improvement": 1580.3630389502953,
                    "objective_score": 27.512330279166
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07000374794006348,
                    "num_nodes_avg": 327.3,
                    "path_length_avg": 123.25143869798683,
                    "smoothness_avg": 0.0985977029059624,
                    "success_improvement": 0.0,
                    "time_improvement": 33.11182845179706,
                    "length_improvement": 18.14226301961878,
                    "smoothness_improvement": 1154.1555032384506,
                    "objective_score": 19.332778655655126
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring, and incremental tree connection. It incorporates ellipsoidal heuristic sampling focused around the current best path cost to bias exploration towards promising regions. The planner maintains two growing trees from start and goal states, performs collision-aware rewiring in both trees for path cost optimization, and incrementally connects the two trees with rewiring-enhanced procedures to ensure robustness and shorter paths. Post solution, path smoothing via random shortcutting enhances path smoothness and quality.",
          "planning_mechanism": "The planner samples states within the ellipsoidal informed subset guided by current best path cost or uniformly if no path exists, growing two trees bidirectionally with rewiring to minimize costs. It extends one tree toward sampled points and incrementally connects the other tree towards the new node, rewiring neighbors to reduce path cost. Once connected, the path is extracted and smoothed by repeatedly attempting collision-free shortcuts, reducing overall path length and improving smoothness while maintaining collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, neighbor_radius_factor: float = 50.0,\n                 collision_check_resolution: float = 0.5, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.collision_check_resolution = collision_check_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_uniform_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def rot_matrix_ellipsoid(start, goal):\n            \"\"\"Compute rotation matrix aligning unit vector to vector from start to goal in dim-space.\"\"\"\n            import numpy as np\n            unit_x = np.zeros(dim)\n            unit_x[0] = 1.0\n            vec = np.array(goal) - np.array(start)\n            length = np.linalg.norm(vec)\n            if length == 0:\n                return np.eye(dim)\n            vec = vec / length\n            if dim == 2:\n                # 2D rotation matrix to align x-axis to vec\n                c = vec[0]\n                s = vec[1]\n                return np.array([[c, -s],[s, c]])\n            elif dim == 3:\n                # 3D: compute axis-angle rotation matrix aligning x-axis to vec\n                v = np.cross(unit_x, vec)\n                s = np.linalg.norm(v)\n                c = np.dot(unit_x, vec)\n                if s == 0:\n                    return np.eye(3) if c > 0 else -np.eye(3)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                return R\n            else:\n                return np.eye(dim)\n\n        def informed_sample(start, goal, c_max):\n            import numpy as np\n            if c_max == float('inf'):\n                return sample_uniform_free()\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                return sample_uniform_free()\n\n            # Sample in unit n-ball\n            while True:\n                a = np.random.normal(0, 1, dim)\n                norm_a = np.linalg.norm(a)\n                sample_ball = a / norm_a * (random.random() ** (1 / dim))\n                # Scale ellipsoid radii\n                r1 = c_max / 2.0\n                if dim == 2:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2])\n                elif dim == 3:\n                    r2 = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r2, r2])\n                else:\n                    # fallback uniform if higher dims\n                    return sample_uniform_free()\n                # Rotate and translate sample\n                R = rot_matrix_ellipsoid(np.array(start), np.array(goal))\n                pt = np.dot(R, L @ sample_ball) + (np.array(start) + np.array(goal)) / 2.0\n                pt_tuple = tuple(pt.tolist())\n                if within_bounds(pt_tuple) and not self._is_in_obstacle(pt_tuple, obstacles, is_3d):\n                    return pt_tuple\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def can_connect(n1, n2):\n            if self._is_in_obstacle(n2.position, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, self.collision_check_resolution):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n\n            radius = self._calc_neighbor_radius(len(tree))\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent for minimal cost connection\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                        min_cost = tentative_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if new_node offers lower cost path\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.remove_child(nb)\n                            except ValueError:\n                                pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]):\n            nearest_node = nearest(tree, target_pos)\n            current = nearest_node\n            radius = self._calc_neighbor_radius(len(tree))\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nb in neighbors:\n                    tentative_cost = nb.cost + dist(nb.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                            min_cost = tentative_cost\n                            best_parent = nb\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if path costs improve\n                for nb in neighbors:\n                    if nb == best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost < nb.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                    nb.parent.remove_child(nb)\n                                except ValueError:\n                                    pass\n                            nb.update_parent(new_node, new_cost)\n                            edges.append((new_node, nb))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current = new_node\n\n        def try_connect_trees(node_in_a: Node, tree_b: List[Node]):\n            # Attempt incremental connect from tree_b to node_in_a.position\n            return incremental_connect_and_rewire(tree_b, node_in_a.position)\n\n        def path_smooth(path: List[Tuple[float, ...]]):\n            # Random shortcutting path smoothing\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_check_resolution):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        tree_a = start_tree\n        tree_b = goal_tree\n\n        for iter_count in range(self.max_iter):\n            # Informed sampling using current best cost or uniform\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = informed_sample(start_pos, goal_pos, best_cost)\n\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect_trees(new_node_a, tree_b)\n            if new_node_b:\n                # Successfully connected trees\n                cost_path = new_node_a.cost + new_node_b.cost + dist(new_node_a.position, new_node_b.position)\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    # Extract path: start root \u2192 new_node_a + reversed(goal root \u2192 new_node_b)\n                    path_from_start = new_node_a.path_from_root()\n                    path_from_goal = new_node_b.path_from_root()\n                    # Ensure no duplicate node at connection point\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n                    extracted_path = path_smooth(combined_path)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _calc_neighbor_radius(self, n):\n        # According to Karaman and Frazzoli (RRT*) scaling for neighbor radius\n        # r_n = min{max_radius, gamma * (log(n)/n)^(1/d)}\n        if n <= 1:\n            return self.neighbor_radius_factor\n        gamma_rrt_star = self.neighbor_radius_factor\n        radius = gamma_rrt_star * (math.log(n) / n) ** (1 / 2.0)  # 2D/3D same formula for simplicity\n        radius = max(radius, self.step_size)\n        radius = min(radius, gamma_rrt_star)\n        return radius\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.6295,
          "time_improvement": 15.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1412.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043416929244995114,
                    "num_nodes_avg": 83.9,
                    "path_length_avg": 164.18372191414562,
                    "smoothness_avg": 0.03720324769360068,
                    "success_improvement": 0.0,
                    "time_improvement": -74.2044970799114,
                    "length_improvement": 10.008300361295342,
                    "smoothness_improvement": 482.3116145502763,
                    "objective_score": -17.84813097896297
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050745177268981936,
                    "num_nodes_avg": 229.8,
                    "path_length_avg": 238.21428623172022,
                    "smoothness_avg": 0.08991796263875351,
                    "success_improvement": 0.0,
                    "time_improvement": 68.60181003685484,
                    "length_improvement": 20.47721463779812,
                    "smoothness_improvement": 2213.653943985784,
                    "objective_score": 35.74425565854499
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.024538660049438478,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 118.18445541862111,
                    "smoothness_avg": 0.1289315433122978,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 50.71292536683033,
                    "length_improvement": 21.507512049957953,
                    "smoothness_improvement": 1539.9997141958427,
                    "objective_score": -22.784621408980087
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of unidirectional and bidirectional RRT* algorithms by growing two trees simultaneously from start and goal, utilizing goal-biased sampling to accelerate convergence. It uses adaptive neighbor radius for rewiring to optimize path cost dynamically. Incremental extension steps and rewiring in both trees improve path quality and smoothness. Node parent-child updates support effective rewiring, and robust collision checks prevent invalid expansions. Once a connection is made between trees, the combined path is smoothed via a post-processing step to reduce unnecessary turns and shorten path lengths, ensuring robust, efficient, and high-quality path planning in 2D or 3D environments.",
          "planning_mechanism": "The planner alternates tree expansion between start and goal trees with goal-biased sampling towards the other tree\u2019s root, extending nodes incrementally with fixed step size. Adaptive neighborhood radius is used to find neighbors for rewiring to minimize cost dynamically during tree growth. After each extension, an incremental connection attempt is made from the opposite tree towards the new node with rewiring. Upon successful connection, the two trees' paths are merged and smoothed before returning the final optimized path. Collision checks ensure all nodes and edges are obstacle-free, and bounds are respected throughout the sampling and extension process.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 10.0,\n                 max_neighbor_radius: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 25.0\n            radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, radius))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_connect_trees(connect_node, other_tree, nodes, edges):\n            curr_node = nearest(other_tree, connect_node.position)\n            while True:\n                new_pos = steer(curr_node.position, connect_node.position)\n                if (not in_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    c = nbr.cost + math.dist(nbr.position, new_node.position)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, connect_node.position) <= self.step_size:\n                    # Check direct connection without obstacle\n                    if (not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed_path = path[:]\n\n            for _ in range(max_trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                if can_connect(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        success_state = False\n        final_node_a = None\n        final_node_b = None\n\n        for _ in range(self.max_iter):\n            # Sample with bias towards opposite tree's root to focus growth\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            # Extend tree_a towards sample with rewiring\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n\n            # Try connecting tree_b incrementally to new_node\n            connect_node = try_connect_trees(new_node, tree_b, nodes, edges)\n            if connect_node:\n                # Merge paths from both trees at connection nodes\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                # Remove duplicate connection point at start of path_b\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = path_smoothing(extracted_path)\n                success_state = True\n                final_node_a = new_node\n                final_node_b = connect_node\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.30597,
          "time_improvement": -43.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1370.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05125737190246582,
                    "num_nodes_avg": 114.6,
                    "path_length_avg": 157.05829791223314,
                    "smoothness_avg": 0.028447812996236242,
                    "success_improvement": 0.0,
                    "time_improvement": -105.66320210074187,
                    "length_improvement": 13.913858166312298,
                    "smoothness_improvement": 345.27004880576834,
                    "objective_score": -27.18983875293126
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09705915451049804,
                    "num_nodes_avg": 435.7,
                    "path_length_avg": 233.61929174719415,
                    "smoothness_avg": 0.10187133667784667,
                    "success_improvement": 0.0,
                    "time_improvement": 39.94539116832186,
                    "length_improvement": 22.011156056315826,
                    "smoothness_improvement": 2521.2228676789655,
                    "objective_score": 28.99196290015455
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0812455415725708,
                    "num_nodes_avg": 400.2,
                    "path_length_avg": 120.27345826984924,
                    "smoothness_avg": 0.10552908652875204,
                    "success_improvement": 0.0,
                    "time_improvement": -63.18556363843585,
                    "length_improvement": 20.12009582379838,
                    "smoothness_improvement": 1242.3221912988151,
                    "objective_score": -8.720038970277002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines the strengths of bidirectional RRT* with goal-biased and informed sampling, adaptive rewiring via neighbor radius, efficient incremental connection and rewiring, and post-processing path smoothing. It incorporates collision and edge checking to ensure safety and leverages a single unified tree per iteration by alternating expansion between two trees for fast convergence and path quality improvement. It enforces time constraints to balance speed and solution optimality.",
          "planning_mechanism": "The planning mechanism grows two trees from start and goal positions alternately; for each iteration, it samples intelligently with goal bias and local informed sampling, extends one tree towards the sample using step-size limited steering, rewires nearby nodes to optimize cost, then incrementally attempts connection and rewiring from the other tree towards the newly added node. If a valid connection is made, the path is extracted and refined with shortcut smoothing within the execution time limit. The planner terminates either upon success or when the time limit expires, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.2, neighbor_radius_factor: float=20.0, smoothing_iter: int=50, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.smoothing_iter = smoothing_iter\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        success_state = False\n\n        start_time = time.time()\n\n        # Precompute maximum radius for neighbor searching (adaptive)\n        # A simple radius clamped to neighbor_radius_factor:\n        def neighbor_radius(n_nodes):\n            r = self.neighbor_radius_factor * (math.log(n_nodes + 1) / (n_nodes + 1))**(1.0/dim)\n            return min(r, self.neighbor_radius_factor)\n\n        # Alternate expansion trees: tree_a expands each iteration, tree_b tries to connect\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                # Time exceeded - stop and return best found path so far\n                break\n\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a towards sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds, neighbor_radius)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Incrementally try to connect and rewire tree_b towards new_node_a.position\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds, neighbor_radius)\n            if new_node_b:\n                # Connection successful - extract path joining roots via these connecting nodes\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                candidate_path = path_a + path_b[::-1]\n\n                # Update best path and success flag\n                if (not best_path) or (self._path_length(candidate_path) < self._path_length(best_path)):\n                    best_path = candidate_path\n                success_state = True\n\n                # Attempt path smoothing within remaining time budget\n                time_left = self.time_limit_sec - (time.time() - start_time)\n                self._post_smooth_path(best_path, obstacles, is_3d, time_left)\n\n                # Can break early on success if desired or continue for better path until time out:\n                # Here return immediately to reduce planning time.\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Swap expansion trees each iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success, attempt to return best found path if any\n        if best_path:\n            time_left = max(0.0, self.time_limit_sec - (time.time() - start_time))\n            self._post_smooth_path(best_path, obstacles, is_3d, time_left)\n            return PlannerResult(True, best_path, nodes, edges)\n        # No path found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _path_length(self, path):\n        length = 0.0\n        for i in range(len(path)-1):\n            length += math.dist(path[i], path[i+1])\n        return length\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds, neighbor_radius_func):\n        dim = len(bounds)\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        # Clamp within bounds\n        new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n\n        radius = neighbor_radius_func(len(tree))\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                continue\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds, neighbor_radius_func):\n        dim = len(bounds)\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            # Clamp within bounds\n            new_pos = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n\n            radius = neighbor_radius_func(len(tree))\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _post_smooth_path(self, path, obstacles, is_3d, time_budget_sec):\n        if len(path) < 3 or time_budget_sec <= 0:\n            return\n\n        start_time = time.time()\n        path_pts = path[:]\n\n        def check_segment(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        for _ in range(self.smoothing_iter):\n            if time.time() - start_time > time_budget_sec:\n                break\n\n            if len(path_pts) < 3:\n                break\n\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i+2, len(path_pts) - 1)\n\n            p_i = path_pts[i]\n            p_j = path_pts[j]\n\n            if check_segment(p_i, p_j):\n                # Shortcut is collision-free: remove intermediate points\n                del path_pts[i+1:j]\n\n        # Update original list in place\n        path.clear()\n        path.extend(path_pts)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.31977,
          "time_improvement": 18.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 836.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.034394049644470216,
                    "num_nodes_avg": 89.5,
                    "path_length_avg": 153.79127280230273,
                    "smoothness_avg": 0.02197335694220786,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -45.0602678593874,
                    "length_improvement": 15.704566398390895,
                    "smoothness_improvement": 243.93075205387262,
                    "objective_score": -59.15751331786868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0800093173980713,
                    "num_nodes_avg": 358.4,
                    "path_length_avg": 239.33035388936665,
                    "smoothness_avg": 0.04861846941764689,
                    "success_improvement": 0.0,
                    "time_improvement": 66.64249884296626,
                    "length_improvement": 20.104639129449392,
                    "smoothness_improvement": 1150.988236584119,
                    "objective_score": 29.76861866170035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06975092887878417,
                    "num_nodes_avg": 280.7,
                    "path_length_avg": 121.57578404337112,
                    "smoothness_avg": 0.09548067700690545,
                    "success_improvement": 0.0,
                    "time_improvement": 33.35339558554516,
                    "length_improvement": 19.255153055114366,
                    "smoothness_improvement": 1114.5071638773652,
                    "objective_score": 19.429585106073247
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines goal-biased informed sampling with bidirectional RRT* style growth and dynamic rewiring. It maintains two trees grown from start and goal positions respectively, alternating expansions and incremental connect-and-rewire steps to efficiently explore the space. The sampling is guided by an ellipsoidal informed region after the first solution, focusing search and improving convergence speed. The planner uses adaptive neighbor radius recalculated per iteration for rewiring to optimize path cost continuously. Path smoothing is performed at the end to enhance smoothness and reduce unnecessary waypoints. Robust collision and edge validity checks ensure feasible expansions within bounds.",
          "planning_mechanism": "The planner alternates expansions of start and goal trees by sampling informed points biased toward the current best path. Each expansion attempts to connect the opposite tree via incremental steps and performs rewiring on neighborhood nodes to optimize the tree costs. Once a path is found, it extracts and smooths the path before returning. The informed sampler shrinks the ellipsoidal sampling domain as better returns are found, focusing effort on promising regions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float,...] (2D/3D)\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Path cost from root\n        self.children = []\n        self.valid = True                     # Validity flag (collision-free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, neighbor_factor: float = 2.5,\n                 goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix from unit vector a1 to x-axis (for informed sampling)\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])\n                R = eye + vx + (vx @ vx) * ((1 - c)/(s_**2))\n                return R\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)/2 for s,g in zip(start_pos, goal_pos))\n        rotation = _rotation_matrix() if np else None\n\n        def informed_sample():\n            if np is None or c_best == float('inf'):\n                # fallback uniform sampling inside bounds\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            else:\n                r2 = 0.0\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D sampling inside unit ball\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Initialize trees and data\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        edges = []\n        path_found = False\n        best_goal_node = None\n\n        def nearest_node(tree, pos):\n            return min(tree, key=lambda n: dist(n.position, pos))\n\n        def get_near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def try_connect(tree_from, tree_to, new_node, radius):\n            # Incremental connect and rewire from new_node towards nearest in tree_to within radius\n            # Returns connected goal node if success else None\n            connected_goal_node = None\n            nearest_in_to = nearest_node(tree_to, new_node.position)\n            direction = tuple(nearest_in_to.position[d] - new_node.position[d] for d in range(dim))\n            dist_to_nearest = dist(new_node.position, nearest_in_to.position)\n            steps = max(1, int(dist_to_nearest / self.step_size))\n\n            last_node = new_node\n            for i in range(1, steps + 1):\n                interm_pos = tuple(new_node.position[d] + direction[d]* i/steps for d in range(dim))\n                if not within_bounds(interm_pos):\n                    return None\n                if self._is_in_obstacle(interm_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, interm_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, interm_pos)\n                interm_node = Node(interm_pos, parent=last_node, cost=new_cost)\n                last_node.add_child(interm_node)\n                tree_from.append(interm_node)\n                edges.append((last_node, interm_node))\n\n                # Rewire near nodes around interm_node\n                neighbor_radius = min(self.step_size,\n                                      self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n                near_nodes = get_near_nodes(tree_from, interm_node.position, neighbor_radius)\n                for near in near_nodes:\n                    if near == interm_node.parent:\n                        continue\n                    if self._is_edge_in_obstacle(interm_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        continue\n                    cost_through_interm = interm_node.cost + dist(interm_node.position, near.position)\n                    if cost_through_interm < near.cost:\n                        near.update_parent(interm_node, cost_through_interm)\n\n                last_node = interm_node\n\n            # Final connection to nearest_in_to node\n            if (self._is_edge_in_obstacle(last_node.position, nearest_in_to.position, obstacles, is_3d, self.collision_resolution)\n                    or self._is_in_obstacle(nearest_in_to.position, obstacles, is_3d)):\n                return None\n            cost_connect = last_node.cost + dist(last_node.position, nearest_in_to.position)\n            connect_node = Node(nearest_in_to.position, parent=last_node, cost=cost_connect)\n            last_node.add_child(connect_node)\n            tree_from.append(connect_node)\n            edges.append((last_node, connect_node))\n\n            # Rewire near nodes in tree_from around connect_node\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n            near_nodes = get_near_nodes(tree_from, connect_node.position, neighbor_radius)\n            for near in near_nodes:\n                if near == connect_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(connect_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_connect = connect_node.cost + dist(connect_node.position, near.position)\n                if cost_through_connect < near.cost:\n                    near.update_parent(connect_node, cost_through_connect)\n\n            return connect_node\n\n        # Main loop alternating expansions of start and goal trees\n        for it in range(self.max_iter):\n            # Alternate trees\n            if it % 2 == 0:\n                tree_from = start_tree\n                tree_to = goal_tree\n            else:\n                tree_from = goal_tree\n                tree_to = start_tree\n\n            # Sample point\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_from is start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            # Nearest node in tree_from\n            nearest = nearest_node(tree_from, sample)\n\n            # Steer towards sample\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Dynamic neighbor radius for rewiring\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n\n            # Find neighbors to possibly rewire\n            near_nodes = get_near_nodes(tree_from, new_node.position, neighbor_radius)\n\n            # Choose best parent among near nodes (including current)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in near_nodes:\n                if self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_near = near.cost + dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if shorter through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    try:\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                    except (ValueError, AttributeError):\n                        pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect tree_from's new_node to tree_to\n            connect_node = try_connect(tree_from, tree_to, new_node, neighbor_radius)\n            if connect_node is not None:\n                # Path found, extract full path\n                if tree_from is start_tree:\n                    path_start = connect_node.path_from_root()\n                    # Corresponding node in tree_to has same position as connect_node.parent or connect_node itself at connection point\n                    # Find corresponding node in tree_to for path merging\n                    counterpart = nearest_node(tree_to, connect_node.position)\n                    path_goal = counterpart.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + counterpart.cost\n                else:\n                    path_start = nearest_node(tree_to, connect_node.position).path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + nearest_node(tree_to, connect_node.position).cost\n\n                # Update best solution\n                if cost_path < c_best:\n                    c_best = cost_path\n                    best_goal_node = connect_node if tree_from is start_tree else nearest_node(tree_to, connect_node.position)\n                    extracted_path = full_path\n                    path_found = True\n                    center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                    # update rotation for informed sampling to bias future samples\n                    rotation = _rotation_matrix() if np else None\n\n                # Optional early stop to allow better rewiring in remaining iterations or break immediately\n                # Here break on first found path for planning efficiency\n                break\n\n        # If found path, apply simple path smoothing by shortcuts along path\n        def path_smoothing(path, iterations=30):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if path_found:\n            extracted_path = path_smoothing(extracted_path, iterations=40)\n\n        # Combine all nodes from both trees and edges\n        all_nodes = start_tree + [n for n in goal_tree if n not in start_tree]\n\n        return PlannerResult(\n            success=path_found,\n            path=extracted_path if path_found else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.56739,
          "time_improvement": -32.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 729.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015814971923828126,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 164.28036986617082,
                    "smoothness_avg": 0.023170487001020087,
                    "success_improvement": 0.0,
                    "time_improvement": 36.54458575876863,
                    "length_improvement": 9.955326087305531,
                    "smoothness_improvement": 262.66843708381487,
                    "objective_score": 14.26778313051077
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10339927673339844,
                    "num_nodes_avg": 621.6,
                    "path_length_avg": 246.6354463547729,
                    "smoothness_avg": 0.038038996749436046,
                    "success_improvement": 0.0,
                    "time_improvement": 36.02248907874998,
                    "length_improvement": 17.66598899906865,
                    "smoothness_improvement": 878.7707847448972,
                    "objective_score": 18.73379844716321
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13381729125976563,
                    "num_nodes_avg": 728.5,
                    "path_length_avg": 137.74339529427704,
                    "smoothness_avg": 0.09003650182892373,
                    "success_improvement": 0.0,
                    "time_improvement": -168.77844219043237,
                    "length_improvement": 8.51739548117924,
                    "smoothness_improvement": 1045.257657460649,
                    "objective_score": -43.70376527359062
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner employs bidirectional RRT* with adaptive rewiring and goal biasing strategies. It grows two trees from start and goal positions alternately, samples points with bias toward the goal, and uses a fixed neighbor radius for efficient rewiring, enabling faster convergence and better path optimization. Collision checks are rigorously applied for nodes and edges to guarantee feasible paths. The rewiring step ensures smoother and lower-cost paths dynamically, while incremental connections accelerate success detection and reduce planning time. The planner parameters are tuned for balanced exploration and exploitation to optimize success rate and path quality.",
          "planning_mechanism": "The planner samples random points favoring the goal, extends both start and goal trees toward these samples by a fixed step size, and rewires nearby nodes to minimize path cost while maintaining collision-free constraints. It frequently attempts to connect the two trees incrementally. The bidirectional growth with rewiring and goal biasing greatly reduces the search space and time, improves path smoothness and length, and robustly avoids obstacles through continuous validation during expansion and connection.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):  # limit retries for efficiency\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n            return goal_position  # fallback\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def valid_new_node(pos, obstacles, is_3d):\n            return (self._within_bounds(pos, bounds) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_extend_and_rewire(tree, other_tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if (not valid_new_node(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost_try = neighbor.cost + edge_dist\n                if cost_try < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n            # Try to connect to the other tree\n            connection_node = try_connect(other_tree, new_node)\n            if connection_node:\n                # Create a connecting node in the other tree at new_node's position, with rewiring\n                connecting_neighbors = near_nodes(other_tree, new_node.position)\n                min_conn_cost = connection_node.cost + math.dist(connection_node.position, new_node.position)\n                best_conn_parent = connection_node\n                for neighbor in connecting_neighbors:\n                    edge_dist = math.dist(neighbor.position, new_node.position)\n                    cost_try = neighbor.cost + edge_dist\n                    if cost_try < min_conn_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                new_node_other = Node(new_node.position)\n                best_conn_parent.add_child(new_node_other)\n                new_node_other.cost = min_conn_cost\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((best_conn_parent, new_node_other))\n\n                # Rewire in other tree through new_node_other\n                for neighbor in connecting_neighbors:\n                    if neighbor == best_conn_parent:\n                        continue\n                    cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                    if cost_via_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                # Extract combined path: start root to new_node, and goal root to new_node_other, reversed\n                path_start = new_node.path_from_root()\n                path_goal = new_node_other.path_from_root()\n                extracted = path_start + path_goal[::-1][1:]  # remove duplicate connecting node\n                return extracted\n            return None\n\n        def try_connect(tree, node):\n            # Find nearest node in tree to node.position that can connect within step_size and collision free edge\n            nearest_node = nearest(tree, node.position)\n            if math.dist(nearest_node.position, node.position) <= self.step_size:\n                # Node position collision and edge collision checked outside usually, but safe to check here too:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        # Main loop: alternate expansions from start and goal trees\n        for iter_num in range(self.max_iter):\n            sample = sample_free()\n            # First extend start tree toward sample, then goal tree toward start tree's new node and vice versa\n            extracted_path = try_extend_and_rewire(tree_start, tree_goal, sample)\n            if extracted_path:\n                success_state = True\n                break\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 3.74921,
          "time_improvement": -31.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 449.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052749800682067874,
                    "num_nodes_avg": 179.5,
                    "path_length_avg": 167.67689676740173,
                    "smoothness_avg": 0.029109394951206242,
                    "success_improvement": 0.0,
                    "time_improvement": -111.65136868689285,
                    "length_improvement": 8.093635871327926,
                    "smoothness_improvement": 355.6252430492584,
                    "objective_score": -30.098557216555978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06149802207946777,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 234.39611255074652,
                    "smoothness_avg": 0.023209304182747068,
                    "success_improvement": 0.0,
                    "time_improvement": 61.9485696271455,
                    "length_improvement": 21.751830912542975,
                    "smoothness_improvement": 497.1921136081793,
                    "objective_score": 25.42089763869314
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07147982120513915,
                    "num_nodes_avg": 325.3,
                    "path_length_avg": 120.17915296485121,
                    "smoothness_avg": 0.04661454427600806,
                    "success_improvement": 0.0,
                    "time_improvement": -43.570646294679634,
                    "length_improvement": 20.182728917042017,
                    "smoothness_improvement": 492.9335624630725,
                    "objective_score": -6.569980292680125
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner using two trees grown from the start and goal. It integrates goal-biased sampling and informed heuristics to focus growth toward promising regions. The planner performs rewiring after each new node addition to improve path cost locally and incrementally tries to connect the two trees with rewiring-enhanced incremental connection steps. The Node class supports dynamic parent updates allowing robust rewiring. This approach balances exploration, exploitation, and path cost optimization, ensuring improved path length, smoothness, and planning efficiency.",
          "planning_mechanism": "The planner alternates sampling points biased towards the opposing tree\u2019s root and extends one tree towards these samples with rewiring to minimize costs. After each extension, it incrementally attempts to connect the other tree to the newly added node, also rewiring whenever better connections are identified. If the trees connect, their paths are merged for the final planning outcome. Collision checks for nodes and edges ensure validity throughout the process. This dual-tree rewiring hybrid speeds up convergence while producing lower cost, smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0, connect_threshold: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.connect_threshold = connect_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position  # bias towards other tree's root to encourage connection\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b and self._dist(new_node_a.position, new_node_b.position) <= self.connect_threshold:\n                # Connection successful, merge paths\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplicate node at connection\n                if path_goal[0] == path_start[-1]:\n                    path_goal = path_goal[1:]\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(\n                max(0.0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds))\n            )\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._position_in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for better paths\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._position_in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + self._dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if self._dist(new_node.position, target_pos) <= self.connect_threshold:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _position_in_bounds(self, pos, bounds):\n        for dim in range(len(bounds)):\n            if pos[dim] < 0 or pos[dim] > bounds[dim]:\n                return False\n        return True",
          "objective": 5.1084,
          "time_improvement": -34.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 402.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0566575288772583,
                    "num_nodes_avg": 117.3,
                    "path_length_avg": 169.87638754539265,
                    "smoothness_avg": 0.029805058432856506,
                    "success_improvement": 0.0,
                    "time_improvement": -127.33059420574068,
                    "length_improvement": 6.888060122749372,
                    "smoothness_improvement": 366.5138871945143,
                    "objective_score": -34.988996801199754
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06383743286132812,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 238.30680555959853,
                    "smoothness_avg": 0.020901029227638895,
                    "success_improvement": 0.0,
                    "time_improvement": 60.50107711487519,
                    "length_improvement": 20.446329023131142,
                    "smoothness_improvement": 437.7985364299979,
                    "objective_score": 24.428581621238777
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06713318824768066,
                    "num_nodes_avg": 232.0,
                    "path_length_avg": 122.82911290223119,
                    "smoothness_avg": 0.03935130317222395,
                    "success_improvement": 0.0,
                    "time_improvement": -34.840225703431656,
                    "length_improvement": 18.422751704166362,
                    "smoothness_improvement": 400.5456717396294,
                    "objective_score": -4.764789011498077
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased sampling, rewiring for dynamic path cost optimization, and rigorous collision checks for nodes and edges. It grows two trees from start and goal positions alternately, rewires nearby nodes to improve path cost, and attempts frequent connections between the trees to find a feasible and optimized path efficiently. The planner enforces a maximum execution time limit to ensure timely response.",
          "planning_mechanism": "The planner alternately extends two trees toward randomly sampled points biased toward the goal. Each extension involves steering from the nearest node within a fixed step size, validating the new node and edge collision-free status, then rewiring neighbors within a radius to minimize path cost. Frequent connection attempts between the two trees combine their branches to form complete paths, from which the lowest-cost path is selected and returned. The process terminates when a path is found or when the maximum iteration/time limits are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def can_add_node(pos):\n            return (self._within_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = list(start_tree) + list(goal_tree)\n        edges = []\n        success = False\n        path_found = []\n        start_time = time.time()\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_time_sec:\n                break  # Time limit exceeded\n\n            sample = sample_free()\n            # Alternate expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not can_add_node(new_pos):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Choose best parent among neighbors\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_via_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_via_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_via_neighbor\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors via new_node if cheaper\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n                # Attempt connection to other tree with rewiring\n                connect_node = try_connect(tree_b, new_node)\n                if connect_node:\n                    # Connect by creating corresponding node in other tree and rewiring\n                    connect_neighbors = near_nodes(tree_b, new_node.position)\n                    min_conn_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_conn_parent = connect_node\n                    for neighbor in connect_neighbors:\n                        cost_try = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if cost_try < min_conn_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                    new_node_other = Node(new_node.position)\n                    best_conn_parent.add_child(new_node_other)\n                    new_node_other.cost = min_conn_cost\n                    tree_b.append(new_node_other)\n                    nodes.append(new_node_other)\n                    edges.append((best_conn_parent, new_node_other))\n\n                    # Rewire in other tree\n                    for neighbor in connect_neighbors:\n                        if neighbor is best_conn_parent:\n                            continue\n                        cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                        if cost_via_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                    # Extract path and finish\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_other.path_from_root()\n                    path_found = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            if success:\n                break\n\n        return globals().get('PlannerResult', None)(\n            success=success,\n            path=path_found,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 7.49771,
          "time_improvement": -39.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 301.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03216714859008789,
                    "num_nodes_avg": 157.0,
                    "path_length_avg": 176.0886278207755,
                    "smoothness_avg": 0.02335284570679442,
                    "success_improvement": 0.0,
                    "time_improvement": -35.66809488806679,
                    "length_improvement": 3.483032788565441,
                    "smoothness_improvement": 265.52274682745093,
                    "objective_score": -8.676208174569695
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04357435703277588,
                    "num_nodes_avg": 321.2,
                    "path_length_avg": 242.29733352155344,
                    "smoothness_avg": 0.017133539181904456,
                    "success_improvement": 0.0,
                    "time_improvement": 81.83297005389949,
                    "length_improvement": 19.11417592845185,
                    "smoothness_improvement": 340.85830393985594,
                    "objective_score": 30.077017721559493
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2758242845535278,
                    "num_nodes_avg": 591.6,
                    "path_length_avg": 122.78746466934895,
                    "smoothness_avg": 0.031140316530623123,
                    "success_improvement": 0.0,
                    "time_improvement": -163.5484899776065,
                    "length_improvement": 18.450412477371014,
                    "smoothness_improvement": 296.1025277304565,
                    "objective_score": -43.89395185915546
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with informed ellipsoidal sampling and adaptive rewiring to efficiently explore and optimize paths in 2D/3D spaces with obstacles. It balances exploration and exploitation by alternating tree expansions, dynamically adjusts neighbor radius for rewiring, and uses collision checks to ensure validity. The planner enforces a 30-second time limit, terminating early with the best solution found.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points biased toward the informed ellipsoidal subset defined by the best path cost to focus on promising areas. It extends and rewires trees incrementally, attempting to connect them each iteration. Collision-free nodes and edges are guaranteed by checking sampling bounds and obstacles. On successful connection or time limit, the planner extracts the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2, time_limit_s: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_s = time_limit_s\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success_state = False\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            factor = max_step / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def neighbor_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma = 30.0\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 10)\n\n        def informed_sample() -> Tuple[float, ...]:\n            if best_cost == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = dist(start, goal)\n            c_cost = max(best_cost, c_min)\n            center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(center)\n\n            e1 = a1 / norm_a1\n            I = np.eye(dim)\n            # Construct orthonormal basis: first is e1, rest orthogonal\n            Q, _ = np.linalg.qr(np.vstack((e1, I[1:])).T)\n            C = Q.T\n\n            r1 = c_cost / 2.0\n            rad = c_cost * c_cost - c_min * c_min\n            r2 = math.sqrt(rad) / 2.0 if rad > 0 else 0.0\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(direction)\n                if norm_dir > 1e-8:\n                    break\n            unit_ball_sample = direction / norm_dir * np.random.rand() ** (1.0 / dim)\n            sample_local = radii * unit_ball_sample\n            sample_global = C.dot(sample_local) + center\n            sample_point = tuple(float(np.clip(sample_global[i], 0, bounds[i])) for i in range(dim))\n            return sample_point\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges\n                    for idx in range(len(edges) - 1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree: List[Node], target: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target, self.step_size)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, neighbor_radius(len(tree)))\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def connect_trees(tree_from: List[Node], tree_to: List[Node], new_node_from: Node) -> Optional[Node]:\n            current_pos = new_node_from.position\n            nearest_to = nearest(tree_to, current_pos)\n            if dist(current_pos, nearest_to.position) <= self.step_size:\n                if collision_free_node(new_node_from.position) and collision_free_edge(nearest_to.position, new_node_from.position):\n                    connect_node = Node(new_node_from.position)\n                    connect_node.update_parent(nearest_to, nearest_to.cost + dist(nearest_to.position, new_node_from.position))\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_to, connect_node))\n                    neighbors = near_nodes(tree_to, connect_node.position, neighbor_radius(len(tree_to)))\n                    rewire(tree_to, connect_node, neighbors)\n                    return connect_node\n                else:\n                    return None\n\n            direction = tuple((current_pos[d] - nearest_to.position[d]) for d in range(dim))\n            norm_dir = math.dist((0,) * dim, direction)\n            if norm_dir < 1e-8:\n                return None\n            direction = tuple(direction[d] / norm_dir for d in range(dim))\n            new_pos = tuple(nearest_to.position[d] + direction[d] * self.step_size for d in range(dim))\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_to.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree_to, new_pos, neighbor_radius(len(tree_to)))\n\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_to.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_to, new_node, neighbors)\n\n            if dist(new_pos, current_pos) <= self.step_size and collision_free_edge(new_pos, current_pos):\n                final_connect = Node(current_pos)\n                final_connect.update_parent(new_node, new_node.cost + dist(new_pos, current_pos))\n                tree_to.append(final_connect)\n                nodes.append(final_connect)\n                edges.append((new_node, final_connect))\n                rewire(tree_to, final_connect, near_nodes(tree_to, final_connect.position, neighbor_radius(len(tree_to))))\n                return final_connect\n\n            return connect_trees(tree_from, tree_to, new_node_from)\n\n        grow_start = True\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_s:\n                break\n\n            sample = informed_sample() if random.random() < 0.9 else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_trees(tree_start, tree_goal, new_node)\n                if connecting_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        # Early stopping after first feasible path\n                        break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connecting_node = connect_trees(tree_goal, tree_start, new_node)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    full_path = path_start + path_goal[::-1][1:]\n                    full_cost = new_node.cost + connecting_node.cost + dist(new_node.position, connecting_node.position)\n                    if full_cost < best_cost:\n                        best_cost = full_cost\n                        best_path = full_path\n                        success_state = True\n                        break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 7.87217,
          "time_improvement": 23.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 137.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.015906238555908205,
                    "num_nodes_avg": 76.3,
                    "path_length_avg": 165.26782543891485,
                    "smoothness_avg": 0.018902057356556,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 32.91388337789611,
                    "length_improvement": 9.414086040649659,
                    "smoothness_improvement": 195.85824410462277,
                    "objective_score": -37.26372655797812
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06239161491394043,
                    "num_nodes_avg": 326.4,
                    "path_length_avg": 291.9621728168473,
                    "smoothness_avg": 0.007540697523224979,
                    "success_improvement": 0.0,
                    "time_improvement": 73.98767500632194,
                    "length_improvement": 2.5346230485456958,
                    "smoothness_improvement": 94.02757861746808,
                    "objective_score": 23.173365004693057
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1447190523147583,
                    "num_nodes_avg": 443.6,
                    "path_length_avg": 140.38566972611858,
                    "smoothness_avg": 0.01737140685228871,
                    "success_improvement": 0.0,
                    "time_improvement": -38.278207701262275,
                    "length_improvement": 6.762522615137764,
                    "smoothness_improvement": 120.96301293723695,
                    "objective_score": -9.526142722664943
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* path planner that grows two trees from start and goal positions, alternately expanding them using goal-biased sampling. It performs incremental extension with rewiring to optimize path costs, ensuring collision-free nodes and edges. The planner halts successfully upon connecting the trees or stops if the maximum iterations or time limit (30 seconds) is reached, returning the best path found for efficient, smooth, and robust navigation.",
          "planning_mechanism": "The planner samples points with goal bias, extends the current tree towards the sample by stepping within bounds and avoiding obstacles, rewires nearby nodes locally to maintain low-cost paths, then incrementally connects the other tree towards the new node, rewiring as it goes. Trees alternate growth each iteration, with full collision checks on nodes and edges. The best connecting path is extracted by merging paths from start and goal trees. Planning terminates on success or time expiry, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]: (x,y) or (x,y,z)\n        self.parent = parent           # Parent node or None\n        self.cost = cost               # Cost from start to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Validity flag (e.g. collision free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_path_cost = float('inf')\n        best_path = []\n\n        def _sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position if tree_a is start_tree else start_position\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp within bounds\n            clamped = tuple(max(0, min(bounds[d], new_p[d])) for d in range(len(bounds)))\n            return clamped\n\n        def _near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def _extend_and_rewire(tree, sample):\n            nearest = _nearest(tree, sample)\n            new_pos = _steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = _near_nodes(tree, new_pos)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for n in neighbors:\n                cost = n.cost + math.dist(n.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = n\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost via new_node\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    n.update_parent(new_node, new_cost)\n                    edges.append((new_node, n))\n\n            return new_node\n\n        def _incremental_connect_and_rewire(tree, target_pos):\n            curr_node = _nearest(tree, target_pos)\n            while True:\n                new_pos = _steer(curr_node.position, target_pos)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for n in neighbors:\n                    cost = n.cost + math.dist(n.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = n\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if better cost via new_node\n                for n in neighbors:\n                    if n is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                    if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.update_parent(new_node, new_cost)\n                        edges.append((new_node, n))\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > 30:\n                break\n\n            sample = _sample_free()\n            new_node_a = _extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = _incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                candidate_path = path_a + path_b[::-1]\n                cand_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    cand_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if cand_cost < best_path_cost:\n                    best_path_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                break  # Stop at first success for efficiency\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_path:\n            extracted_path = best_path\n        elif success_state:\n            extracted_path = best_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        try:\n            distance = math.dist(from_pos, to_pos)\n        except Exception:\n            # Fallback Manhattan if math.dist unavailable (unlikely)\n            distance = sum(abs(from_pos[d] - to_pos[d]) for d in range(len(from_pos)))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.28803,
          "time_improvement": 61.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 287.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01827681064605713,
                    "num_nodes_avg": 94.9,
                    "path_length_avg": 163.38675770681954,
                    "smoothness_avg": 0.021414164422488623,
                    "success_improvement": 0.0,
                    "time_improvement": 22.915763763264508,
                    "length_improvement": 10.445129072036783,
                    "smoothness_improvement": 235.17817481427437,
                    "objective_score": 10.139645817458081
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.02677924633026123,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 244.2306058817266,
                    "smoothness_avg": 0.015574591067521687,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 88.83519108153628,
                    "length_improvement": 18.468793968466542,
                    "smoothness_improvement": 300.745446091847,
                    "objective_score": -18.151956651386566
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.030116820335388185,
                    "num_nodes_avg": 203.0,
                    "path_length_avg": 119.26924702636245,
                    "smoothness_avg": 0.03339223708825981,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 71.22355439019334,
                    "length_improvement": 20.787045116321536,
                    "smoothness_improvement": 324.74679100410987,
                    "objective_score": -22.851790704657134
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional, anytime RRT* planner with adaptive informed sampling, dynamic rewiring, and path smoothing. It grows two trees simultaneously from start and goal, leveraging adaptive informed regions around the current best path to bias sampling efficiently. The planner performs incremental expansion and rewiring in both trees, attempts frequent, incremental connections reducing connection failures, and applies path smoothing on the extracted path for improved smoothness and shorter path length. The approach integrates rigorous collision checks, bounding constraints, and flexible parameters to improve planning speed, success rate, robustness, and path quality.",
          "planning_mechanism": "The planner alternates between expanding two RRT* trees rooted at start and goal with adaptive informed sampling that focuses search in the ellipsoidal region defined by the current best solution. Each expansion incrementally extends and rewires nodes to reduce path cost. Frequent incremental attempts connect the opposing tree with rewiring to ensure low-cost merges. Upon connection, the best path is extracted and refined through shortcut smoothing, yielding shorter and smoother collision-free paths faster and more reliably.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.5, goal_sample_rate: float=0.1,\n                 neighbor_factor: float=2.0, collision_resolution: float=0.5, smoothing_iters: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:  # 3D\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_rewire(tree, neighbors, new_node):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if c_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, c_through_new)\n                        edges.append((new_node, nbr))\n\n        def incrementally_connect(tree, target_node):\n            curr_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if (not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                radius = self._adaptive_radius(len(tree), dim)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = c\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                try_rewire(tree, neighbors, new_node)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def _adaptive_radius(num_nodes, dim):\n            from math import log, pow, pi\n            gamma = self.neighbor_factor\n            unit_ball_volume = pi if dim == 2 else 4/3 * pi\n            radius = min(self.step_size, gamma * pow((log(num_nodes) / num_nodes), 1/dim))\n            return radius\n\n        def try_extend(tree, sample):\n            if not self._within_bounds(sample, bounds):\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = _adaptive_radius(len(tree), dim)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            try_rewire(tree, neighbors, new_node)\n            return new_node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _within_bounds(pos, bounds):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        self._within_bounds = _within_bounds\n        self._adaptive_radius = _adaptive_radius\n\n        tree_active, tree_opposite = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            # Sample point biased by informed sampling & goal bias\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_opposite[0].position\n                else:\n                    sample = sample_free()\n\n            new_node = try_extend(tree_active, sample)\n            if new_node is None:\n                tree_active, tree_opposite = tree_opposite, tree_active\n                continue\n\n            connect_node = incrementally_connect(tree_opposite, new_node)\n            if connect_node:\n                # Extract combined path\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_new = 0.0\n                for idx in range(1, len(full_path)):\n                    c_new += math.dist(full_path[idx-1], full_path[idx])\n                if c_new < c_best:\n                    c_best = c_new\n                    center = tuple((s + g) * 0.5 for s, g in zip(full_path[0], full_path[-1]))\n                \n                extracted_path = path_smoothing(full_path)\n                success_state = True\n                break\n\n            tree_active, tree_opposite = tree_opposite, tree_active\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.97471,
          "time_improvement": 38.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1438.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025354552268981933,
                    "num_nodes_avg": 80.2,
                    "path_length_avg": 164.87912207597097,
                    "smoothness_avg": 0.03844395041869222,
                    "success_improvement": 0.0,
                    "time_improvement": -1.7316771018180572,
                    "length_improvement": 9.627140513278148,
                    "smoothness_improvement": 501.7313064270491,
                    "objective_score": 3.914581504245458
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.05082085132598877,
                    "num_nodes_avg": 266.0,
                    "path_length_avg": 219.54202937674887,
                    "smoothness_avg": 0.08683182190470087,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.55498729339317,
                    "length_improvement": 26.710551427101343,
                    "smoothness_improvement": 2134.2453200412874,
                    "objective_score": -63.420166926355336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026004457473754884,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 121.5085305076238,
                    "smoothness_avg": 0.1397939934905283,
                    "success_improvement": 0.0,
                    "time_improvement": 47.768800997209595,
                    "length_improvement": 19.2998196512885,
                    "smoothness_improvement": 1678.1692786802648,
                    "objective_score": 26.581450622821905
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "time_expert",
          "algorithm_description": "The algorithm implements a bidirectional RRT* planner featuring goal-biased sampling, dynamic rewiring of nodes in local neighborhoods, and incremental connection attempts between two simultaneously grown trees from start and goal. It integrates efficient collision checking, adaptive neighbor search, and path smoothing to reduce planning time while improving path quality, length, and smoothness robustly in 2D or 3D spaces. The Node class maintains parent-child relationships and cumulative costs for path optimization.",
          "planning_mechanism": "The planning mechanism alternates expansion between two trees grown from start and goal. Each iteration samples a point with goal bias, extends one tree toward the sample with collision-checked steering, locally rewires node connections to optimize costs, then incrementally connects and rewires the other tree toward the newly added node. Upon successful connection, paths from both trees are merged and smoothed. This approach narrows search space, improves path optimality dynamically, and reduces redundant exploration, thereby minimizing planning time and improving path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def descendants(self):\n        \"\"\"Yield all descendant nodes in subtree rooted at this node.\"\"\"\n        for child in self.children:\n            yield child\n            yield from child.descendants()\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.2, neighbor_radius: float = 20.0, smoothing_iters: int = 15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        # Precompute max bounds limits for clamping\n        max_bounds = tuple(bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling: sample near goal of the opposite tree to direct growth\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, max_bounds)\n            if new_node_b:\n                # Extract path from start tree root to new_node_a\n                path_from_start = new_node_a.path_from_root()\n                # Extract path from goal tree root to new_node_b\n                path_from_goal = new_node_b.path_from_root()\n\n                # Remove duplicate connecting node at junction if present\n                if path_from_goal and path_from_goal[0] == path_from_start[-1]:\n                    path_from_goal = path_from_goal[1:]\n\n                # Combine paths: start -> connection -> goal (reversed)\n                raw_path = path_from_start + path_from_goal[::-1]\n                # Smooth path to improve trajectory quality\n                extracted_path = self._smooth_path(raw_path, obstacles, is_3d)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        r_sq = radius * radius\n        return [node for node in tree if (sum((node.position[d] - position[d])**2 for d in range(len(position)))) <= r_sq]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        # Add node and edge to lists\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path cost improves\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path[:]\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            p1, p2 = smoothed[i], smoothed[j]\n\n            # Check if direct edge between p1 and p2 is free\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate nodes between i+1 and j-1 as they are not needed\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed",
          "objective": 11.58068,
          "time_improvement": 48.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 680.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0206784725189209,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 158.40561102660482,
                    "smoothness_avg": 0.03188515116292793,
                    "success_improvement": 0.0,
                    "time_improvement": 17.030454060621132,
                    "length_improvement": 13.175374498782666,
                    "smoothness_improvement": 399.07185541379243,
                    "objective_score": 9.739570395011835
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0508305549621582,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 238.8534003722645,
                    "smoothness_avg": 0.034152573568993594,
                    "success_improvement": 0.0,
                    "time_improvement": 68.54898324279806,
                    "length_improvement": 20.26385994180389,
                    "smoothness_improvement": 778.7703170346437,
                    "objective_score": 28.511318546373413
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.020598220825195312,
                    "num_nodes_avg": 124.4,
                    "path_length_avg": 112.12845794943728,
                    "smoothness_avg": 0.07567514147955685,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 58.6274863795938,
                    "length_improvement": 25.52961721337948,
                    "smoothness_improvement": 862.5822138620559,
                    "objective_score": -72.99291957413567
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner combining goal bias sampling, rewiring with neighborhood optimization, and incremental connection with rewiring to minimize path length and enhance planning efficiency. It grows two trees simultaneously from start and goal, alternating their expansions, dynamically rewiring to reduce path costs and ensuring collision-free nodes and edges for robust and smooth path construction.",
          "planning_mechanism": "The planner alternates between expanding the two trees by sampling points with goal bias, steering towards samples, and rewiring locally to optimize cost. After a new node is added to one tree, it incrementally attempts connection to the other tree through rewiring-enhanced extension steps. When the trees connect successfully, the final path is constructed by concatenating the optimal paths from both trees, ensuring minimized path length and improved success rate through repeated collision checking and neighborhood-based rewiring.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._inside_bounds(new_pos, obstacles, is_3d):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if not self._inside_bounds(new_pos, obstacles, is_3d):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _inside_bounds(self, pos, obstacles, is_3d):\n        # Position must be within map bounds (assumed origin at 0)\n        # Using obstacles only for dimension info, bounds check done in _sample_free\n        # but nodes from steered positions can violate bounds so check\n        dims = len(pos)\n        for d in range(dims):\n            if pos[d] < 0:\n                return False\n            if is_3d:\n                # bounds unknown here, we rely on positive checking only (sampling enforces bounds)\n                # this method is a placeholder - \n                # safer if we reject negative coords only\n                continue\n            else:\n                continue\n        return True",
          "objective": 12.18696,
          "time_improvement": 0.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 270.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023809289932250975,
                    "num_nodes_avg": 77.7,
                    "path_length_avg": 165.54940495088522,
                    "smoothness_avg": 0.020562554204645422,
                    "success_improvement": 0.0,
                    "time_improvement": 4.468476914320158,
                    "length_improvement": 9.259747848225805,
                    "smoothness_improvement": 221.84862560384113,
                    "objective_score": 4.301735771960415
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04926056861877441,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 244.04682856696945,
                    "smoothness_avg": 0.015542087807597499,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 69.52040027397354,
                    "length_improvement": 18.53014412586919,
                    "smoothness_improvement": 299.90911380284587,
                    "objective_score": -23.938305523619864
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0860180139541626,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 124.42837862466763,
                    "smoothness_avg": 0.03042426300596567,
                    "success_improvement": 0.0,
                    "time_improvement": -72.77130311982366,
                    "length_improvement": 17.36059556017419,
                    "smoothness_improvement": 286.994379750387,
                    "objective_score": -16.92429992516032
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a time-constrained hybrid ARRT* inspired planner that combines informed sampling with a single-tree rewiring RRT* approach incorporating dynamic neighborhood radius adjustment and path smoothing. It maintains one incrementally optimized tree rooted at the start, biases sampling within a shrinking ellipsoidal informed set after an initial solution, and rewires neighbors to improve path cost dynamically. Collision checks ensure safety for nodes and edges. Planning halts at path optimality, or maximum iterations, or after a 30-second timeout, returning the best path found to balance planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner iteratively samples informed or uniform points, extends the tree with collision-free steps, rewires nearby nodes to optimize costs, and tracks the best goal node when reachable. It dynamically shrinks the ellipsoid based on the best path cost to focus search. When a path to the goal is found or time expires, it runs path smoothing to enhance smoothness. The approach balances exploration and exploitation, ensures feasible connections, and respects problem bounds and obstacles.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children: List[Node] = []\n        self.valid = True               # Collision-free flag\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.5, collision_resolution: float = 0.5, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles: 2D (x,y,w,h), 3D (x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.time()\n        best_cost = float('inf')\n        best_goal_node = None\n\n        nodes: List[Node] = [Node(start_position, None, 0.0)]\n        edges: List[Tuple[Node, Node]] = []\n\n        # Utility functions\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix for ellipsoidal informed sample alignment toward x-axis\n        def compute_rotation():\n            if best_cost == float('inf'):\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c_, s_ = math.cos(angle), math.sin(angle)\n                return [[c_, -s_], [s_, c_]]\n            else:\n                import numpy as np\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c_ = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c_) / (s_ ** 2))\n                return R\n\n        def mat_vec_mult(mat, vec):\n            if dim == 2:\n                return (mat[0][0] * vec[0] + mat[0][1] * vec[1],\n                        mat[1][0] * vec[0] + mat[1][1] * vec[1])\n            else:\n                import numpy as np\n                return tuple(mat @ vec)\n\n        def informed_sample():\n            if best_cost == float('inf'):\n                return uniform_sample()\n            import numpy as np\n            r1 = best_cost / 2.0\n            val = best_cost ** 2 - c_min ** 2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            rotation = compute_rotation()\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + np.array(mat_vec_mult(rotation, sample_ellipsoid))\n                    else:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + rotation @ sample_ellipsoid\n                    else:\n                        sample_world = np.array(start_position) * 0.5 + np.array(goal_position) * 0.5 + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        # Dynamic neighbor radius as function of node count and dimension\n        def compute_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.step_size * self.neighbor_factor\n            return min(self.step_size * self.neighbor_factor,\n                       self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1 / dim)))\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations=40) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        c_min = dist(start_position, goal_position)\n\n        for it in range(self.max_iter):\n            current_time = time.time()\n            if current_time - start_time > self.time_limit:\n                # Time limit reached\n                break\n\n            sample_pos = None\n            if best_cost < float('inf') and random.random() > self.goal_sample_rate:\n                sample_pos = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pos = goal_position\n                else:\n                    sample_pos = uniform_sample()\n\n            nearest = nearest_node(nodes, sample_pos)\n            new_pos = steer(nearest.position, sample_pos, self.step_size)\n\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewiring nearby nodes to new_node if cheaper\n            neighbor_radius = compute_neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, neighbor_radius)\n\n            # Choose best parent among neighbors for new_node (better cost)\n            min_cost = new_node.cost\n            min_parent = nearest\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_via_neighbor = neighbor.cost + dist(neighbor.position, new_pos)\n                if cost_via_neighbor < min_cost:\n                    min_cost = cost_via_neighbor\n                    min_parent = neighbor\n            if min_parent != nearest:\n                # Re-parent new_node\n                try:\n                    min_node_prev_parent = new_node.parent\n                    if min_node_prev_parent:\n                        min_node_prev_parent.remove_child(new_node)\n                        edges.remove((min_node_prev_parent, new_node))\n                except ValueError:\n                    pass\n                new_node.update_parent(min_parent, min_cost)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if shorter\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    try:\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            edges.remove((old_parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Check if new_node can connect directly to goal\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, new_node, new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n            # Early stop if path found quickly\n            if best_goal_node and (it > 100 or (time.time() - start_time) > self.time_limit * 0.5):\n                # Allows some improvements but avoids overrun\n                break\n\n        success_state = best_goal_node is not None\n        if success_state:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = path_smoothing(extracted_path, iterations=50)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.42541,
          "time_improvement": -73.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1324.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0748063325881958,
                    "num_nodes_avg": 274.9,
                    "path_length_avg": 184.66634185534946,
                    "smoothness_avg": 0.02547004180083661,
                    "success_improvement": 0.0,
                    "time_improvement": -215.5030231971177,
                    "length_improvement": -1.2185481963615001,
                    "smoothness_improvement": 298.66146326411604,
                    "objective_score": -63.40130928208703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.26328799724578855,
                    "num_nodes_avg": 851.1,
                    "path_length_avg": 246.12792532501567,
                    "smoothness_avg": 0.10066838613582856,
                    "success_improvement": 0.0,
                    "time_improvement": -9.770086264617973,
                    "length_improvement": 17.835414126984485,
                    "smoothness_improvement": 2490.2700837825864,
                    "objective_score": 13.087407364924438
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09783074855804444,
                    "num_nodes_avg": 443.3,
                    "path_length_avg": 134.27656907669714,
                    "smoothness_avg": 0.10089219278204406,
                    "success_improvement": 0.0,
                    "time_improvement": 6.523292183694897,
                    "length_improvement": 10.819896382371397,
                    "smoothness_improvement": 1183.3412451005838,
                    "objective_score": 10.037673157085667
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner that grows two rewiring-enabled trees simultaneously from the start and goal positions, using goal-biased sampling and incremental connection attempts with adaptive rewiring to efficiently find a collision-free, low-cost, and smooth path. It incorporates adaptive neighbor radius calculations, robust obstacle and edge collision checking, and an explicit path smoothing step to improve path quality and smoothness. A 30-second maximum execution time is enforced during planning to guarantee timely termination.",
          "planning_mechanism": "The planner alternates expansions between two trees, sampling random points with a goal bias, extending and rewiring trees towards these samples while ensuring collision-free nodes and edges. After each expansion, the algorithm tries an incremental rewiring-enabled connection from the other tree to the newly added node. Upon connection, it merges paths from both trees and smooths the final path before returning. If the time limit is reached before success, it returns the best partial path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15, neighbor_factor: float = 25.0, collision_resolution: float = 0.5, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        start_time = time.time()\n        best_cost = float('inf')\n        # For early return if disconnected but partial path exists\n        best_path_node_start = None\n        best_path_node_goal = None\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if not (0 <= pos[i] <= bounds[i]):\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Alternate goal bias depending on which tree is growing\n                # This will be handled outside this function (see usage)\n                return None\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 2\n            radius = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(radius, self.step_size * 4)\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def extend_and_rewire(tree, target_point):\n            # Find nearest\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_point))\n            new_pos = steer(nearest.position, target_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(nodes)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            # Select best parent among neighbors\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost from new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            curr = nearest\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(nodes)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + math.dist(curr.position, new_pos)\n                best_parent = curr\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                # Check if close enough to target\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr = new_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n\n            def can_connect(p1, p2):\n                return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution))\n\n            smoothed = path[:]\n            for _ in range(max_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # Alternate growth between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_count in range(self.max_iter):\n            current_time = time.time()\n            if current_time - start_time > self.max_time_sec:\n                # Time limit reached: if partial path found return best else failure\n                if best_path_node_start and best_path_node_goal:\n                    p_start = best_path_node_start.path_from_root()\n                    p_goal = best_path_node_goal.path_from_root()\n                    merged = p_start + p_goal[::-1]\n                    best_path = path_smoothing(merged)\n                    success = False\n                break\n\n            # Sample with goal bias\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = sample_free()\n                if sample is None:\n                    # Should not happen but fallback to uniform random\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Track best partial connection to goal, for possible time-out fallback\n            dist_to_goal = math.dist(new_node_a.position, goal_pos if tree_a is start_tree else start_pos)\n            if dist_to_goal < best_cost:\n                # No direct connection guaranteed, only update if closer\n                best_cost = dist_to_goal\n                if tree_a is start_tree:\n                    best_path_node_start = new_node_a\n                    best_path_node_goal = None\n                else:\n                    best_path_node_goal = new_node_a\n                    best_path_node_start = None\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Connected two trees: extract combined path\n                path_a = new_node_a.path_from_root()  # path from start or goal root\n                path_b = new_node_b.path_from_root()\n                # If tree_b is start_tree, reverse roles accordingly\n                if tree_a is start_tree:\n                    combined_path = path_a + path_b[::-1]\n                else:\n                    combined_path = path_b + path_a[::-1]\n\n                # Smooth path before return\n                best_path = path_smoothing(combined_path)\n                success = True\n                break\n\n            # Swap trees for balanced growth\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.58232,
          "time_improvement": 28.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.036344480514526364,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 163.66370323275214,
                    "smoothness_avg": 0.03885407991558977,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -53.28640079157184,
                    "length_improvement": 10.293330840790432,
                    "smoothness_improvement": 508.15072366395304,
                    "objective_score": -61.3865004509937
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050847983360290526,
                    "num_nodes_avg": 298.5,
                    "path_length_avg": 238.10198581018213,
                    "smoothness_avg": 0.08444492151217213,
                    "success_improvement": 0.0,
                    "time_improvement": 78.80044826110951,
                    "length_improvement": 20.514703750895944,
                    "smoothness_improvement": 2072.8286537266613,
                    "objective_score": 38.10721849714535
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.04482736587524414,
                    "num_nodes_avg": 248.3,
                    "path_length_avg": 116.2701895470298,
                    "smoothness_avg": 0.13091655796525054,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.16771420175093,
                    "length_improvement": 22.778876294323574,
                    "smoothness_improvement": 1565.2489540628608,
                    "objective_score": -20.467665710295698
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal bias sampling and incremental rewiring for path cost minimization. Two trees grow simultaneously from start and goal, each expanding toward sampled points with step size control and rewiring nearby nodes within a fixed radius to improve path quality. The planner attempts incremental, rewiring-enhanced connections between the trees at each iteration. Collision checks on nodes and edges ensure path feasibility. Clean rewiring via the Node's `update_parent` method maintains an optimized tree structure supporting shorter, smoother paths with higher success rates and reduced planning time.",
          "planning_mechanism": "The planner alternates growth between two trees, sampling points biased towards the opposing tree\u2019s root to accelerate connection. Each extension rewires neighbors for cost improvement. After extending one tree, it incrementally connects and rewires the other tree toward the new node. Upon successful connection, it concatenates the two root paths into a final optimized path. Robust collision checks and parent-child updates ensure path smoothness and reliability.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling towards the other tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Construct final path by merging roots paths at connection nodes\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicated connection point in path_b\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if cheaper through new_node\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.69474,
          "time_improvement": -63.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 216.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02477607727050781,
                    "num_nodes_avg": 130.2,
                    "path_length_avg": 156.00336705470224,
                    "smoothness_avg": 0.01769763222411566,
                    "success_improvement": 0.0,
                    "time_improvement": 0.5893747997072792,
                    "length_improvement": 14.49208248577416,
                    "smoothness_improvement": 177.00637533089463,
                    "objective_score": 3.960260813721489
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0780069351196289,
                    "num_nodes_avg": 444.3,
                    "path_length_avg": 245.59103894997367,
                    "smoothness_avg": 0.013820258121187475,
                    "success_improvement": 0.0,
                    "time_improvement": 51.733806065035225,
                    "length_improvement": 18.014642252390974,
                    "smoothness_improvement": 255.60519578772144,
                    "objective_score": 20.40109624892737
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17042129039764403,
                    "num_nodes_avg": 567.8,
                    "path_length_avg": 126.69445055050053,
                    "smoothness_avg": 0.02473458198827077,
                    "success_improvement": 0.0,
                    "time_improvement": -242.29932856916415,
                    "length_improvement": 15.85557848578538,
                    "smoothness_improvement": 214.62205717387496,
                    "objective_score": -68.4455725877228
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements an improved unidirectional RRT* variant with informed sampling using ellipsoidal regions aligned along the start-goal vector, combined with adaptive neighbor radius rewiring, goal biasing, and post-planning path smoothing. It dynamically shrinks the sampling domain based on the cost of the best path found, ensures collision-free nodes and edges, and maintains efficient parent-child relationships to optimize path cost and smoothness.",
          "planning_mechanism": "The planner initializes from the start and iteratively samples points biased towards an informed ellipsoid or the goal with a set probability. It extends the tree towards samples by fixed steps while verifying nodes and edges for collisions. It then rewires neighbors inside an adaptive radius to optimize path costs. Upon nearing the goal, it connects directly if collision-free and extracts the path, applying shortcut smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, \n                 goal_sample_rate: float = 0.15, neighbor_factor: float = 30.0, \n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        # Precompute rotation matrix for ellipsoidal informed sampling\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                import numpy as np\n                a1v = np.array(a1)\n                eye = np.eye(dim)\n                v = np.cross([1] + [0]*(dim-1), a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1] + [0]*(dim-1), a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # fallback uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                # no solution found yet - uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                arg = c_best ** 2 - c_min ** 2\n                r2 = math.sqrt(arg) / 2.0 if arg > 0 else 0.0\n\n                if dim == 2:\n                    while True:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        sample_world = sample_ellipsoid\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid\n                        sample_world = sample_world + np.array(center)\n                        clipped = np.clip(sample_world, [0] * dim, bounds)\n                        p = tuple(clipped)\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    while True:\n                        sample_unit = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(sample_unit) <= 1:\n                            sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                            sample_world = sample_ellipsoid\n                            if rotation is not None:\n                                sample_world = rotation @ sample_ellipsoid\n                            sample_world = sample_world + np.array(center)\n                            clipped = np.clip(sample_world, [0] * dim, bounds)\n                            p = tuple(clipped)\n                            if not self._is_in_obstacle(p, obstacles, is_3d):\n                                return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n_nodes):\n            import math\n            if n_nodes <= 1:\n                return self.step_size * 2\n            radius = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(radius, self.step_size * 3)\n\n        for _ in range(self.max_iter):\n            if c_best < float(\"inf\") and random.random() < (1 - self.goal_sample_rate):\n                sample = _informed_sample()\n            else:\n                sample = _sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            min_cost = new_cost\n            min_parent = nearest_node\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.71326,
          "time_improvement": -90.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1889.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06702051162719727,
                    "num_nodes_avg": 308.1,
                    "path_length_avg": 169.29886988839934,
                    "smoothness_avg": 0.04100510499933652,
                    "success_improvement": 0.0,
                    "time_improvement": -168.9106467242872,
                    "length_improvement": 7.2046067019003015,
                    "smoothness_improvement": 541.8189372503213,
                    "objective_score": -46.523177990654496
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21944727897644042,
                    "num_nodes_avg": 830.9,
                    "path_length_avg": 237.7122159268916,
                    "smoothness_avg": 0.14466695389978618,
                    "success_improvement": 0.0,
                    "time_improvement": -35.78132392118496,
                    "length_improvement": 20.64482015684237,
                    "smoothness_improvement": 3622.3849232366215,
                    "objective_score": 11.506491471196092
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08296387195587158,
                    "num_nodes_avg": 462.0,
                    "path_length_avg": 125.36556539524406,
                    "smoothness_avg": 0.12610706940062055,
                    "success_improvement": 0.0,
                    "time_improvement": -66.63691255787805,
                    "length_improvement": 16.738160731195663,
                    "smoothness_improvement": 1504.0726145202857,
                    "objective_score": -9.123078548522853
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm improves path length and planning efficiency by integrating bidirectional RRT* with goal biasing and dynamic rewiring for cost minimization. It grows two trees simultaneously from start and goal, alternating expansions, and rewires neighbors within a radius for lower-cost connections. Incremental connection attempts between trees incorporate rewiring to ensure optimal linkage. Sampling is biased towards the goal to accelerate convergence, and obstacle collisions are thoroughly checked for nodes and edges. A time limit of 30 seconds is imposed to guarantee bounded execution.",
          "planning_mechanism": "The planner repeatedly samples points (goal-biased), extends one tree towards the sample with rewiring to minimize path cost, then incrementally connects the other tree towards the new node using rewiring-enhanced steps. If connection succeeds, the two partial paths are combined. The search alternates between trees each iteration. The process terminates upon successful connection or timeout, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For internal use if needed\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius: float = 25.0,\n                 time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.time_limit = time_limit  # seconds max planning time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            # Enforce time limit\n            if time.time() - start_time > self.time_limit:\n                # Timeout reached; return best known solution\n                break\n\n            # Goal biased sampling towards the other tree's root\n            if self._rand() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n\n            if new_node_a is None:\n                # Swap trees to explore from opposite side next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(\n                tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds\n            )\n\n            if new_node_b:\n                # Connected both trees - extract combined path\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                combined_path = path_a + path_b[::-1]\n\n                # Compute combined cost\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success_state = True\n                    # Since better path found, can stop to prioritize quality\n                    break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no connection found but nodes exist, optionally extract best partial path to goal\n        if not success_state:\n            # Find node in start_tree closest to goal, and path towards goal if available\n            candidate = min(start_tree, key=lambda n: math.dist(n.position, goal_position))\n            if candidate:\n                candidate_path = candidate.path_from_root()\n                if candidate_path:\n                    best_path = candidate_path\n\n        return type('PlannerResult', (), {})() if False else PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _rand(self):\n        import random\n        return random.random()\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d) and self._in_bounds(point, bounds):\n                return point\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if not (0 <= pos[d] <= bounds[d]):\n                return False\n        return True\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        # Reject if out of map bounds or in obstacle or edge to new node intersects obstacle\n        if (not self._in_bounds(new_pos, bounds) or\n            self._is_in_obstacle(new_pos, obstacles, is_3d) or\n            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Choose parent with lowest cost to new_node\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            dist_to_new = math.dist(neighbor.position, new_pos)\n            cost = neighbor.cost + dist_to_new\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if better through new_node\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            dist_new_to_neighbor = math.dist(new_node.position, neighbor.position)\n            new_cost = new_node.cost + dist_new_to_neighbor\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            # Check bounds and obstacles for node and edge\n            if (not self._in_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                dist_to_new = math.dist(neighbor.position, new_pos)\n                cost = neighbor.cost + dist_to_new\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                dist_new_to_neighbor = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_new_to_neighbor\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.87826,
          "time_improvement": 41.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 547.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02672531604766846,
                    "num_nodes_avg": 85.8,
                    "path_length_avg": 170.74402950468647,
                    "smoothness_avg": 0.03011435237968433,
                    "success_improvement": 0.0,
                    "time_improvement": -12.716633969413078,
                    "length_improvement": 6.412491816193766,
                    "smoothness_improvement": 371.35500910492533,
                    "objective_score": -0.6757167820605434
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.0459500789642334,
                    "num_nodes_avg": 231.5,
                    "path_length_avg": 224.6036070984503,
                    "smoothness_avg": 0.028590005048021772,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 80.84248357489228,
                    "length_improvement": 25.02085109416065,
                    "smoothness_improvement": 635.6414224338793,
                    "objective_score": -17.56487759653078
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.04721369743347168,
                    "num_nodes_avg": 200.6,
                    "path_length_avg": 120.70682076110688,
                    "smoothness_avg": 0.057753124249035656,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 54.88758836085628,
                    "length_improvement": 19.832277091609335,
                    "smoothness_improvement": 634.6154775555324,
                    "objective_score": -26.39419068564358
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner implements a bidirectional RRT* variant with informed ellipsoidal sampling, adaptive neighbor rewiring, incremental connect-and-rewire steps, and goal biasing to rapidly find and optimize collision-free paths in 2D/3D environments. It smartly toggles between growing two trees from start and goal, rewires neighbors for path cost minimization, and applies path smoothing to return high-quality solutions efficiently.",
          "planning_mechanism": "The planner alternately extends two trees towards sampled points, using ellipsoidal informed sampling biased by the current best path cost and goal biasing. Each extension involves rewiring nearby nodes to reduce path cost. After each successful extension, the planner attempts incremental connection and rewiring of the opposite tree to the newly added node. On successfully connecting the trees, it merges and smooths the combined path, then terminates early to return the optimized route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # Children nodes list\n        self.valid = True               # Validity for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.2,\n                 neighbor_factor: float = 25.0, collision_resolution: float = 0.5, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            try:\n                import numpy as np\n                diff = [g - s for s, g in zip(start_position, goal_position)]\n                norm = math.dist(start_position, goal_position)\n                if norm < 1e-9:\n                    return np.eye(dim)\n                a1 = np.array(diff) / norm\n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    c, s_ = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s_], [s_, c]])\n                else:\n                    e1 = np.array([1.0] + [0.0]*(dim-1))\n                    v = np.cross(e1, a1)\n                    s_v = np.linalg.norm(v)\n                    if s_v < 1e-9:\n                        return np.eye(dim)\n                    c = np.dot(e1, a1)\n                    vx = np.zeros((dim, dim))\n                    # Construct skew-symmetric matrix vx for 3D only\n                    if dim == 3:\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = np.eye(dim) + vx + vx@vx*((1 - c) / (s_v**2))\n                    return R\n            except ImportError:\n                return None\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # No solution yet - uniform sampling free from obstacles\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            r1 = c_best / 2.0\n            val = max(0.0, c_best**2 - c_min**2)\n            r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = [radius * math.cos(theta), radius * math.sin(theta)]\n                    ellipsoid_sample = [r1 * unit_sample[0], r2 * unit_sample[1]]\n                    if rotation is not None:\n                        import numpy as np\n                        sample_world = rotation @ ellipsoid_sample + np.array(center)\n                    else:\n                        sample_world = [center[0] + ellipsoid_sample[0], center[1] + ellipsoid_sample[1]]\n                    p = tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                else:\n                    import numpy as np\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, dim)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    ellipsoid_sample = np.array([r1] + [r2]*(dim-1)) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ ellipsoid_sample + np.array(center)\n                    else:\n                        sample_world = np.array(center) + ellipsoid_sample\n                    p = tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(pos[d], bounds[d])) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            import math\n            if n_nodes <= 1:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 6.0)\n\n        def near_nodes(tree_nodes, position, radius):\n            return [node for node in tree_nodes if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree, point):\n            nearest = min(tree, key=lambda node: math.dist(node.position, point))\n            new_pos = steer(nearest.position, point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cand_cost < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n            radius = adaptive_neighbor_radius(len(tree))\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cand_cost < min_cost:\n                        if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                            min_cost = cand_cost\n                            best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.collision_resolution):\n                            if nbr.parent:\n                                try:\n                                    edges.remove((nbr.parent, nbr))\n                                    nbr.parent.remove_child(nbr)\n                                except ValueError:\n                                    pass\n                            nbr.update_parent(new_node, cost_through_new)\n                            edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        def path_smoothing(path):\n            import random\n\n            def can_connect(p1, p2):\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n            smoothed = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path: List[tuple] = []\n        best_cost_path = float('inf')\n\n        for _ in range(self.max_iter):\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample_point = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample_point = uniform_sample()\n\n            new_node_a = extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path_b.reverse()\n                if len(path_b) > 0 and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                combined_path = path_a + path_b\n                path_cost = new_node_a.cost + new_node_b.cost\n\n                if path_cost < best_cost_path:\n                    best_cost_path = path_cost\n                    c_best = path_cost\n                    center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n                extracted_path = path_smoothing(combined_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 14.97902,
          "time_improvement": 25.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1457.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030217814445495605,
                    "num_nodes_avg": 83.5,
                    "path_length_avg": 157.0391117014654,
                    "smoothness_avg": 0.039521206483810835,
                    "success_improvement": 0.0,
                    "time_improvement": -21.24485217798908,
                    "length_improvement": 13.924374432459064,
                    "smoothness_improvement": 518.5927031451425,
                    "objective_score": -0.9956172511791981
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04668238162994385,
                    "num_nodes_avg": 279.7,
                    "path_length_avg": 229.11793200634392,
                    "smoothness_avg": 0.0964909836890141,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 71.11563373639149,
                    "length_improvement": 23.513839502267878,
                    "smoothness_improvement": 2382.782509964687,
                    "objective_score": -12.048629428805535
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.03779945373535156,
                    "num_nodes_avg": 225.5,
                    "path_length_avg": 123.93051226029738,
                    "smoothness_avg": 0.12335843121327912,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 24.077985774535055,
                    "length_improvement": 17.691254693540266,
                    "smoothness_improvement": 1469.1101396606693,
                    "objective_score": -31.892802630628076
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* with goal biasing, adaptive neighborhood radius, incremental connection and rewiring, and ellipsoidal informed sampling for efficient, robust, and high-quality path planning. It dynamically balances exploration and refinement, applies collision checks on nodes and edges, and performs path smoothing after connection. A strict 30-second time limit is enforced to guarantee timely results.",
          "planning_mechanism": "The planner grows two trees from start and goal alternating expansions, sampling points within an ellipsoidal informed region biased towards the best current path cost. It adaptively adjusts neighbor radius based on tree size and dimensionality for rewiring local nodes to optimize costs. Incremental connection attempts rewire nodes to improve path quality. Upon successful connection, path extraction and iterative shortcut smoothing are applied. Early termination occurs if time limit is exceeded, returning the best partial solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if self not in new_parent.children:\n            new_parent.children.append(self)\n        # Propagate cost update to children recursively\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, time_limit: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit = time_limit  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n\n        # Precompute Euclidean distance between start and goal (for ellipsoidal sampling)\n        line_dist = math.dist(start_position, goal_position)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def update_neighbor_radius(n_nodes):\n            if n_nodes == 0:\n                return self.max_neighbor_radius\n            val = self.min_neighbor_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dimension)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, val))\n\n        def is_in_ellipsoid(p, focus1, focus2, c_max):\n            # Check if p is inside ellipsoid defined by foci and sum of distances <= c_max\n            return (dist(p, focus1) + dist(p, focus2)) <= c_max\n\n        def informed_sample(cost_best, focus1, focus2):\n            # Ellipsoidal informed sampling\n\n            if cost_best == math.inf:\n                # No solution yet, sample uniform random free point\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n            \n            a = cost_best / 2.0  # Major axis\n            c = dist(focus1, focus2) / 2.0\n            if a < c:\n                # Numerical issue, revert to uniform sampling\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n            b = math.sqrt(max(a*a - c*c, 0))\n\n            # Build ellipsoid coordinate frame\n            center = tuple((focus1[d] + focus2[d]) / 2.0 for d in range(dimension))\n            # Unit vector along foci\n            if dist(focus1, focus2) < 1e-12:\n                unit_vector = np.eye(dimension)[0]  # arbitrary unit vector\n            else:\n                unit_vector = np.array([(focus2[d] - focus1[d]) / (2*c) for d in range(dimension)])\n\n            # Create orthonormal basis for dimension\n            if dimension == 2:\n                R = np.array([[unit_vector[0], -unit_vector[1]],\n                              [unit_vector[1], unit_vector[0]]])\n            elif dimension == 3:\n                # Create basis from unit_vector using Gram-Schmidt\n                basis = np.zeros((3,3))\n                basis[:,0] = unit_vector\n                if abs(unit_vector[0]) < 1e-9 and abs(unit_vector[1]) < 1e-9:\n                    basis[:,1] = np.array([1.0,0,0])\n                else:\n                    basis[:,1] = np.array([-unit_vector[1], unit_vector[0], 0])\n                basis[:,1] /= (np.linalg.norm(basis[:,1]) + 1e-12)\n                basis[:,2] = np.cross(basis[:,0], basis[:,1])\n                R = basis\n            else:\n                # For general dimensionality fallback to uniform sampling\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n            for _ in range(100):\n                if dimension == 2:\n                    # Sample point within unit circle scaled by ellipsoid\n                    r = random.random()**(0.5)  # sqrt for uniform area\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r * math.cos(theta)\n                    y = r * math.sin(theta)\n                    sample_local = np.array([a*x, b*y])\n                    sample_global = R @ sample_local + np.array(center)\n                    sample_point = tuple(sample_global)\n                elif dimension == 3:\n                    # Sample within unit sphere scaled by ellipsoid axes\n                    while True:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        z = random.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            break\n                    sample_local = np.array([a*x, b*y, b*z])\n                    sample_global = R @ sample_local + np.array(center)\n                    sample_point = tuple(sample_global)\n                else:\n                    # Should not reach here, fallback handled above\n                    sample_point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n                if not within_bounds(sample_point):\n                    continue\n                if self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    continue\n                # Informed region by definition, so no extra check needed here\n                return sample_point\n\n            # If no acceptable found, uniform random\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n        def sample_free(tree_from, tree_to_root):\n            # Bias sample to opposing root with goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root.position\n            # If best_path_cost known, informed sample within ellipsoid else uniform\n            return informed_sample(best_path_cost, start_position, goal_position)\n\n        def try_extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = update_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n            count_extend = 0\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = update_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                try:\n                                    edges.remove((neighbor.parent, neighbor))\n                                    neighbor.parent.remove_child(neighbor)\n                                except ValueError:\n                                    pass\n                            neighbor.update_parent(new_node, new_cost)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n                count_extend += 1\n                # Safety: avoid infinite loops in case of no progress\n                if count_extend > 50:\n                    return None\n\n        def smooth_path(path: List[Tuple[float, ...]], max_attempts=75) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]  # copy\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # Shortcut possible, remove intermediate points\n                    del path[i+1:j]\n                    attempts = 0  # reset attempts after successful shortcut\n                else:\n                    attempts += 1\n            return path\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for iter_count in range(self.max_iter):\n            # Check time limit\n            if (time.time() - start_time) > self.time_limit:\n                # Time limit exceeded: return best found so far (success if path found else False)\n                success_state = len(best_path) > 0\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            sample_point = sample_free(tree_a[0], tree_b[0])\n            new_node_a = try_extend_and_rewire(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if len(path_b) > 0 and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                raw_path = path_a + path_b[::-1]\n\n                smoothed = smooth_path(raw_path)\n                path_cost = 0.0\n                for idx in range(len(smoothed) - 1):\n                    path_cost += dist(smoothed[idx], smoothed[idx+1])\n\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    best_path = smoothed\n                    success_state = True\n\n                    # Early break: path found, optionally can continue to improve within time\n                    # Here choose to break for efficiency\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 15.87111,
          "time_improvement": 20.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1550.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04622418880462646,
                    "num_nodes_avg": 77.5,
                    "path_length_avg": 162.76620770586774,
                    "smoothness_avg": 0.04239511365574141,
                    "success_improvement": 0.0,
                    "time_improvement": -94.95503666751468,
                    "length_improvement": 10.785262360802484,
                    "smoothness_improvement": 563.5755911751673,
                    "objective_score": -23.51158057221807
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04702725410461426,
                    "num_nodes_avg": 233.5,
                    "path_length_avg": 239.64783903510056,
                    "smoothness_avg": 0.10579508900876347,
                    "success_improvement": 0.0,
                    "time_improvement": 80.39338749258465,
                    "length_improvement": 19.998653449500182,
                    "smoothness_improvement": 2622.1838413180244,
                    "objective_score": 41.22866614426555
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.027116107940673827,
                    "num_nodes_avg": 162.6,
                    "path_length_avg": 112.00513948871972,
                    "smoothness_avg": 0.12295759691400274,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 74.09071752546319,
                    "length_improvement": 25.611519463194014,
                    "smoothness_improvement": 1464.0115569603843,
                    "objective_score": -65.33042306492031
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a unidirectional, informed RRT* planner with adaptive neighbor radius and rewiring, focusing sampling within an ellipsoidal informed region between start and goal to efficiently find near-optimal paths. It maintains rigorous collision checks and bounds enforcement for nodes and edges, dynamically refines its tree structure to improve path quality and success rate.",
          "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling points biased towards the informed ellipsoid around the current best path cost or globally sampling otherwise. It steers towards these samples with fixed step size while ensuring node and edge collision-free validity. Neighboring nodes are evaluated within an adaptive radius for rewiring to reduce path costs. The process terminates once the goal is connected or iteration limit is reached, extracting the best found path by backtracking.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_factor: float=2.5, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf'):\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n            while True:\n                if dim == 2 and np is not None:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                elif dim == 3 and np is not None:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    p = sample_free()\n\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        for _ in range(self.max_iter):\n            sample = None\n            if c_best < float('inf') and random.random() < 1 - self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            gamma = self.neighbor_factor\n            unit_ball_volume = math.pi if dim == 2 else 4/3 * math.pi\n            radius = min(self.step_size, gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            near_nodes = [n for n in nodes if n != new_node and math.dist(n.position, new_node.position) <= radius]\n\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n\n            for near in near_nodes:\n                cost_candidate = near.cost + math.dist(near.position, new_node.position)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_candidate\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                        except (ValueError, AttributeError):\n                            pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.63382,
          "time_improvement": -53.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.048303866386413576,
                    "num_nodes_avg": 282.5,
                    "path_length_avg": 197.33983891595304,
                    "smoothness_avg": 0.009950325225839406,
                    "success_improvement": 0.0,
                    "time_improvement": -93.81266471834658,
                    "length_improvement": -8.165092759690593,
                    "smoothness_improvement": 55.74419726145427,
                    "objective_score": -29.49809698113482
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.20108270645141602,
                    "num_nodes_avg": 842.6,
                    "path_length_avg": 306.1422547803274,
                    "smoothness_avg": 0.006399543535369534,
                    "success_improvement": 0.0,
                    "time_improvement": -24.418385258536347,
                    "length_improvement": -2.19909646189272,
                    "smoothness_improvement": 64.6648645699531,
                    "objective_score": -7.442010547089683
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0702040433883667,
                    "num_nodes_avg": 439.0,
                    "path_length_avg": 157.72117905085278,
                    "smoothness_avg": 0.012441624227179402,
                    "success_improvement": 0.0,
                    "time_improvement": -41.00818541279275,
                    "length_improvement": -4.750897250104076,
                    "smoothness_improvement": 58.256541824548854,
                    "objective_score": -12.961352364735896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner integrating adaptive step sizing, goal-biased sampling, and efficient incremental rewiring for expedited convergence. It alternates growth between start and goal trees, uses dynamic neighbor radius scaling based on tree size for efficient rewiring, and incorporates direct path attempts to speed up connection. The planner performs robust collision checking on nodes and edges, applies pruning of suboptimal nodes, and smooths the final path by shortcutting unnecessary waypoints to deliver efficient, smooth, and feasible paths rapidly.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by sampling within bounds with a goal bias. Each iteration alternates expansion between trees, steering incrementally towards samples. New nodes are connected via minimal-cost parents within a dynamically scaled neighbor radius, followed by rewiring neighbors for local cost improvements. Frequent attempts are made to directly connect the two trees when close. Upon success, the path is reconstructed and smoothed by shortcutting feasible segments, enhancing smoothness and reducing path length while maintaining collision-free constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost to reach this node from root\n        self.children = []\n        self.valid = True                 # Validity flag for collision etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    \n    def disconnect_children(self):\n        for child in self.children[:]:\n            child.parent = None\n        self.children.clear()\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0, goal_sample_rate: float=0.2, max_neighbor_radius: float=30.0, min_neighbor_radius: float=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.3)\n\n        def adaptive_neighbor_radius(num_nodes):\n            # Radius scaled based on tree size (RRT* radius decreasing with more nodes)\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, 50.0 * (math.log(num_nodes + 1) / (num_nodes + 1))**(1/dim)))\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-6 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree_from, node_from, tree_to):\n            # Attempt direct connection within step_size from node_from to nodes in tree_to\n            candidates = near_nodes(tree_to, node_from.position, self.step_size)\n            min_cost = float('inf')\n            best_connect = None\n            for candidate in candidates:\n                if collision_free_edge(node_from.position, candidate.position):\n                    total_cost = node_from.cost + dist(node_from.position, candidate.position) + candidate.cost\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_connect = candidate\n            return best_connect\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove overlap at meeting point\n            return path_start + path_goal[::-1][1:]\n\n        def path_smooth(path):\n            # Shortcut smoothing by checking straight-line feasibility between non-adjacent nodes\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal[:] \n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n\n        for iter_count in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n            if grow_start:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_start, new_node, tree_goal)\n                if connect_node is not None:\n                    # Connect by linking the two trees at best_connect\n                    connecting_node = Node(new_node.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n\n                    # Rewire near nodes in goal tree to connecting_node\n                    n_radius = adaptive_neighbor_radius(len(tree_goal))\n                    neighbors = near_nodes(tree_goal, connecting_node.position, n_radius)\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    # Reconstruct path\n                    final_path = reconstruct_path(new_node, connecting_node)\n                    # Apply smoothing\n                    final_path = path_smooth(final_path)\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = try_connect(tree_goal, new_node, tree_start)\n                if connect_node is not None:\n                    connecting_node = Node(new_node.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + dist(connect_node.position, new_node.position)\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n\n                    n_radius = adaptive_neighbor_radius(len(tree_start))\n                    neighbors = near_nodes(tree_start, connecting_node.position, n_radius)\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    final_path = reconstruct_path(connecting_node, new_node)\n                    final_path = path_smooth(final_path)\n                    success = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.10016,
          "time_improvement": -94.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1560.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07176172733306885,
                    "num_nodes_avg": 94.8,
                    "path_length_avg": 164.07408821044345,
                    "smoothness_avg": 0.041678064989647254,
                    "success_improvement": 0.0,
                    "time_improvement": -187.93412701069983,
                    "length_improvement": 10.068392331551712,
                    "smoothness_improvement": 552.3522224546931,
                    "objective_score": -51.60479852462613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09400091171264649,
                    "num_nodes_avg": 329.3,
                    "path_length_avg": 231.65746108796742,
                    "smoothness_avg": 0.1097279862570906,
                    "success_improvement": 0.0,
                    "time_improvement": 41.837655487576846,
                    "length_improvement": 22.666071598530273,
                    "smoothness_improvement": 2723.3801202688687,
                    "objective_score": 30.70141156732345
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11801156997680665,
                    "num_nodes_avg": 341.0,
                    "path_length_avg": 122.79671989611192,
                    "smoothness_avg": 0.11829656009312739,
                    "success_improvement": 0.0,
                    "time_improvement": -137.03189356329554,
                    "length_improvement": 18.444265596441586,
                    "smoothness_improvement": 1404.7235126408002,
                    "objective_score": -30.397097386496338
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid path planner combining bidirectional RRT*'s rewiring and incremental cost optimization with goal-biased, informed sampling from unidirectional informed RRT*. It maintains two trees growing alternately from start and goal, uses ellipsoidal informed sampling to focus exploration, applies rewiring within neighborhoods for path cost improvement, and ensures rigorous collision checking for nodes and edges to produce high-quality, smooth, and efficient paths.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points biased by an ellipsoidal informed region around the best found path cost to concentrate search efforts. Each extension attempts to connect the other tree incrementally with rewiring to reduce path costs progressively. Goal biasing, adaptive neighborhood rewiring, and strict collision checks help improve planning time, path quality, and success rate while simplifying the connectivity logic by integrating RRT* rewiring with dual-tree bidirectional search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            direction = np.array([(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)])\n            if dim == 2:\n                angle = math.atan2(direction[1], direction[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1 = direction\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + vx @ vx * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            if c_best == float('inf') or np is None:\n                return sample_free()\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) * 0.5\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0, 1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0] * dim, bounds))\n                else:\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0] * dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pos = tuple(\n                max(0, min(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio, bounds[d]))\n                for d in range(dim)\n            )\n            return new_pos\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            radius = min(self.step_size * 3,\n                         self.neighbor_factor * ((math.log(n + 1) / (n + 1)) ** (1 / dim)))\n            return [node for node in tree if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n        def connect_nodes(new_node, other_tree):\n            curr_nearest = nearest(other_tree, new_node.position)\n            # Incrementally extend from curr_nearest towards new_node with rewiring\n            direction = new_node.position\n            last_node = curr_nearest\n\n            while True:\n                pos_next = steer(last_node.position, direction)\n                if pos_next == last_node.position:\n                    break\n                if self._is_in_obstacle(pos_next, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, pos_next, obstacles, is_3d, self.collision_resolution):\n                    return None\n                cost_to_next = last_node.cost + math.dist(last_node.position, pos_next)\n                candidate_node = Node(pos_next, parent=last_node, cost=cost_to_next)\n                # Rewire candidate_node parent among neighbours in other_tree\n                neighbors = near_nodes(other_tree, candidate_node)\n                min_cost = cost_to_next\n                min_parent = last_node\n                for near in neighbors:\n                    cost_via_near = near.cost + math.dist(near.position, pos_next)\n                    if cost_via_near < min_cost and not self._is_edge_in_obstacle(near.position, pos_next,\n                                                                                  obstacles, is_3d,\n                                                                                  self.collision_resolution):\n                        min_cost = cost_via_near\n                        min_parent = near\n                if min_parent != last_node:\n                    candidate_node.parent = min_parent\n                    candidate_node.cost = min_cost\n                    min_parent.add_child(candidate_node)\n                else:\n                    last_node.add_child(candidate_node)\n                other_tree.append(candidate_node)\n                nodes.append(candidate_node)\n                edges.append((candidate_node.parent, candidate_node))\n\n                # Attempt to rewire neighbors through candidate_node\n                for near in neighbors:\n                    if near == candidate_node.parent:\n                        continue\n                    cost_through_candidate = candidate_node.cost + math.dist(candidate_node.position, near.position)\n                    if cost_through_candidate < near.cost and not self._is_edge_in_obstacle(candidate_node.position,\n                                                                                            near.position,\n                                                                                            obstacles, is_3d,\n                                                                                            self.collision_resolution):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = candidate_node\n                        near.cost = cost_through_candidate\n                        candidate_node.add_child(near)\n                        edges.append((candidate_node, near))\n\n                if math.dist(pos_next, direction) < self.step_size * 0.5:\n                    return candidate_node\n                last_node = candidate_node\n\n            return None\n\n        # Main loop alternating expansion of start and goal trees\n        for i in range(self.max_iter):\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Sampling\n                sample = None\n                if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                    sample = informed_sample()\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    else:\n                        sample = sample_free()\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire near nodes in tree_a around new_node\n                neighbors = near_nodes(tree_a, new_node)\n                min_cost = new_node.cost\n                min_parent = new_node.parent\n\n                for near in neighbors:\n                    cost_candidate = near.cost + math.dist(near.position, new_node.position)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_node.position,\n                                                                                  obstacles, is_3d,\n                                                                                  self.collision_resolution):\n                        min_cost = cost_candidate\n                        min_parent = near\n                if min_parent != new_node.parent:\n                    new_node.update_parent(min_parent, min_cost)\n                    try:\n                        edges.remove((new_node.parent, new_node))\n                    except (ValueError, AttributeError):\n                        pass\n                    edges.append((min_parent, new_node))\n\n                for near in neighbors:\n                    if near == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                    if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position,\n                                                                                     near.position, obstacles,\n                                                                                     is_3d,\n                                                                                     self.collision_resolution):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n                # Attempt to connect to the other tree incrementally with rewiring\n                connected_node = connect_nodes(new_node, tree_b)\n                if connected_node is not None:\n                    # Extract path combining new_node (in tree_a) and connected_node (in tree_b)\n                    path_a = []\n                    curr = new_node\n                    while curr is not None:\n                        path_a.append(curr.position)\n                        curr = curr.parent\n                    path_b = []\n                    curr = connected_node\n                    while curr is not None:\n                        path_b.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path_a[::-1] + path_b\n                    success_state = True\n\n                    # Update best cost\n                    path_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if path_cost < c_best:\n                        c_best = path_cost\n                        center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n                        # rotation unchanged (depends only on start and goal)\n\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.76404,
          "time_improvement": -2.0,
          "length_improvement": -3.0,
          "smoothness_improvement": -3.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015021467208862304,
                    "num_nodes_avg": 117.6,
                    "path_length_avg": 187.22071853496146,
                    "smoothness_avg": 0.006201579148821495,
                    "success_improvement": 0.0,
                    "time_improvement": 39.72841502087828,
                    "length_improvement": -2.618642531145551,
                    "smoothness_improvement": -2.9318193762760227,
                    "objective_score": 11.380136903152994
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04503486156463623,
                    "num_nodes_avg": 368.9,
                    "path_length_avg": 301.49843150421884,
                    "smoothness_avg": 0.0037699475174776927,
                    "success_improvement": 0.0,
                    "time_improvement": 72.13502416445965,
                    "length_improvement": -0.648854587285943,
                    "smoothness_improvement": -2.996534991858748,
                    "objective_score": 21.49575365692141
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.10808990001678467,
                    "num_nodes_avg": 513.7,
                    "path_length_avg": 158.2287978503895,
                    "smoothness_avg": 0.007558457089107224,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -117.10374398951838,
                    "length_improvement": -5.088033486546662,
                    "smoothness_improvement": -3.856983733824273,
                    "objective_score": -86.16801481283395
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a time-limited bidirectional RRT* algorithm with adaptive neighbor radius, goal-biased sampling, incremental rewiring, and path smoothing. The algorithm carefully manages node parents and children relationships, performs rigorous collision checks on nodes and edges, and interleaves alternate expansions of start and goal trees to improve planning efficiency, path quality, and success rate. It stops planning once a path is found or 30 seconds elapsed, returning the best available solution.",
          "planning_mechanism": "The planner grows two trees from start and goal by repeatedly sampling free points biased towards the goal. Each tree extends towards sampled points with adaptive rewiring within a dynamic radius to optimize path costs. Incremental connection attempts with rewiring join the trees efficiently. Collision checks ensure safety. After connection, the path is extracted and smoothed. The search terminates early if time exceeds 30 seconds, returning the best found path so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision and validity\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        self.parent = new_parent\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_factor: float = 50.0,\n                 smoothing_iters: int = 100,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n        self.time_limit_secs = 30.0  # max time allowed in seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        start_time = time.time()\n\n        def sample_free(goal_bias=True):\n            if random.random() < self.goal_sample_rate:\n                return goal_position if goal_bias else start_position\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            # fallback if sampling fails\n            return goal_position if goal_bias else start_position\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.step_size * 10\n            r = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1 / dimension))\n            return max(min(r, self.step_size * 10), self.step_size)\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def is_valid_node(pos: Tuple[float, ...]) -> bool:\n            return self._within_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_valid_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_valid_node(new_pos) or not is_valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree) + 1\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_candidate = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_candidate < min_cost and is_valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper by going through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            current_node = nearest(tree, target_pos)\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if not is_valid_node(new_pos) or not is_valid_edge(current_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost_candidate = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_candidate < min_cost and is_valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                        if neighbor.parent is not None:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.smoothing_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iter_count in range(self.max_iter):\n            # Enforce time limit\n            if time.time() - start_time > self.time_limit_secs:\n                break\n\n            rand_point = sample_free(goal_bias=(tree_a is tree_start))\n            new_node_a = try_extend(tree_a, rand_point)\n\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]\n                extracted_path = smooth_path(raw_path)\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 18.15242,
          "time_improvement": 16.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1247.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04627528190612793,
                    "num_nodes_avg": 75.6,
                    "path_length_avg": 153.77258218145383,
                    "smoothness_avg": 0.03854894926455513,
                    "success_improvement": 0.0,
                    "time_improvement": -95.1705268196248,
                    "length_improvement": 15.71481102385002,
                    "smoothness_improvement": 503.37476637344685,
                    "objective_score": -22.8913220092502
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05351574420928955,
                    "num_nodes_avg": 217.6,
                    "path_length_avg": 234.26644914681214,
                    "smoothness_avg": 0.08523518387063529,
                    "success_improvement": 0.0,
                    "time_improvement": 77.68820485620178,
                    "length_improvement": 21.79511628893042,
                    "smoothness_improvement": 2093.1626734128877,
                    "objective_score": 38.13129808171105
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.03571488857269287,
                    "num_nodes_avg": 181.3,
                    "path_length_avg": 114.3116354459535,
                    "smoothness_avg": 0.09786911689609942,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 65.87463294507333,
                    "length_improvement": 24.079654671934268,
                    "smoothness_improvement": 1144.8879429716185,
                    "objective_score": -69.69723946723303
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that grows two trees simultaneously from start and goal positions, employing goal-biased sampling, adaptive rewiring with neighborhood consideration, and incremental connection attempts. It improves planning efficiency and path quality by dynamically optimizing parent-child relations and costs during both tree extensions and inter-tree connections, while rigorously checking for collisions in 2D/3D environments.",
          "planning_mechanism": "The planner alternates growing two trees toward random, goal-biased samples, extending toward them with step size limits. Each extension involves rewiring nearby nodes to minimize path costs. Incremental, rewiring-enabled connections from one tree to the other efficiently merge the trees. Continuous collision checking maintains path validity, and path extraction merges start and goal tree paths upon successful connection.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(tree_from_start=True):\n            # Goal biasing: sample goal_pos from start tree; start_pos from goal tree, else random\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_from_start else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr_node = nearest(tree, target_pos)\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    if neighbor == curr_node:\n                        continue\n                    cost_candidate = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, new_cost)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                curr_node = new_node\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            sample = sample_free(tree_from_start=(tree_a is start_tree))\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Add all new edges from rewiring: reconstruct edges list for correctness\n            edges.clear()\n            for tree in [start_tree, goal_tree]:\n                for node in tree:\n                    for child in node.children:\n                        edges.append((node, child))\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Add edges from incremental connection rewiring:\n                edges.clear()\n                for tree in [start_tree, goal_tree]:\n                    for node in tree:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Merge start -> goal path, avoid duplicate connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # Collect all nodes - may have duplicates if reused, but here both trees combined\n        all_nodes_set = set(start_tree) | set(goal_tree)\n        nodes = list(all_nodes_set)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 18.69555,
          "time_improvement": 33.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 315.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.029830431938171385,
                    "num_nodes_avg": 122.3,
                    "path_length_avg": 168.03885929839015,
                    "smoothness_avg": 0.021687404577900745,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -19.690532790609794,
                    "length_improvement": 7.895238472429828,
                    "smoothness_improvement": 239.4549765969684,
                    "objective_score": -53.13083725971212
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0477452278137207,
                    "num_nodes_avg": 245.4,
                    "path_length_avg": 245.717339118139,
                    "smoothness_avg": 0.015576380313218563,
                    "success_improvement": 0.0,
                    "time_improvement": 70.45800579663793,
                    "length_improvement": 17.97247962090861,
                    "smoothness_improvement": 300.7914846723692,
                    "objective_score": 26.235855086534947
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.02552957534790039,
                    "num_nodes_avg": 160.6,
                    "path_length_avg": 119.1512117893651,
                    "smoothness_avg": 0.039598764619383234,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 48.72262450394522,
                    "length_improvement": 20.865438500501185,
                    "smoothness_improvement": 403.69336308179146,
                    "objective_score": -29.191658133307232
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* inspired planner with goal biasing and adaptive rewiring to minimize planning time while maintaining path quality and robustness. It grows two trees from start and goal positions, alternately extending towards sampled points guided by a goal bias to concentrate search efforts. Dynamic rewiring locally improves path costs, and thorough collision checking guarantees valid expansions. The planner enforces a 30-second maximum execution time, returning the best path found if time runs out.",
          "planning_mechanism": "The planner samples points within bounds (using goal biasing), extends each tree toward samples by a controlled step size, rewires neighbors to reduce cost, and attempts to connect the two trees incrementally. Alternate tree expansions, efficient rewiring, and robust collision checks combine to accelerate convergence while ensuring feasible, optimized, and smooth final paths. Execution time is capped at 30 seconds to avoid excessive computation.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple of coordinates (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children: List[Node] = []     # List of children nodes\n        self.valid = True                   # Validity (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius: float = 15.0, max_runtime: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_runtime = max_runtime  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        # Initialization\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n        nodes: List[Node] = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        import random\n\n        start_time = time.time()\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...]) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def rewire(tree: List[Node], new_node: Node):\n            neighbors = near_nodes(tree, new_node.position)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_new_to_neigh = math.dist(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + dist_new_to_neigh\n                if cost_through_new + 1e-8 < neighbor.cost:\n                    # Check collision for edge before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove from old parent children\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        # Reassign parent and update cost\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n                        # Recursively update descendants cost\n                        update_descendant_costs(neighbor)\n\n        def update_descendant_costs(node: Node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + math.dist(node.position, child.position)\n                if abs(child.cost - old_cost) > 1e-8:\n                    update_descendant_costs(child)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost + 1e-8 < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node)\n\n            return new_node\n\n        def try_connect(tree: List[Node], new_node: Node) -> Node or None:\n            nearest_node = nearest(tree, new_node.position)\n            dist = math.dist(nearest_node.position, new_node.position)\n\n            if (dist <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, new_node.position, obstacles, is_3d) and\n                not self._is_in_obstacle(new_node.position, obstacles, is_3d)):\n                return nearest_node\n            return None\n\n        def connect_trees(node_from_start: Node, tree_goal: List[Node]) -> Tuple[Node, Node] or None:\n            # Try to connect the goal tree to this start tree node by incremental extension + rewiring\n            nearest_goal_node = nearest(tree_goal, node_from_start.position)\n            dist = math.dist(nearest_goal_node.position, node_from_start.position)\n            if dist > self.step_size:\n                # Steer towards start node position from goal tree nearest node\n                new_pos = steer(nearest_goal_node.position, node_from_start.position)\n            else:\n                new_pos = node_from_start.position\n\n            if (not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_goal_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree_goal, new_pos)\n\n            min_cost = nearest_goal_node.cost + math.dist(nearest_goal_node.position, new_pos)\n            best_parent = nearest_goal_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost + 1e-8 < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node_goal = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node_goal)\n            tree_goal.append(new_node_goal)\n            nodes.append(new_node_goal)\n            edges.append((best_parent, new_node_goal))\n\n            rewire(tree_goal, new_node_goal)\n\n            # If fully connected nodes (positions coincide), return pair\n            if math.dist(new_node_goal.position, node_from_start.position) < 1e-6:\n                return node_from_start, new_node_goal\n            return None\n\n        for iter_num in range(self.max_iter):\n            if (time.time() - start_time) > self.max_runtime:\n                # Time limit exceeded\n                break\n\n            sample_point = sample_free()\n\n            # Alternate expansion: start tree grows on even iterations, goal tree on odd\n            if iter_num % 2 == 0:\n                new_node_start = try_extend(tree_start, sample_point)\n                if new_node_start is None:\n                    # Swap trees and continue\n                    tree_start, tree_goal = tree_goal, tree_start\n                    continue\n                connection = connect_trees(new_node_start, tree_goal)\n                if connection:\n                    start_connect_node, goal_connect_node = connection\n                    path_start = start_connect_node.path_from_root()\n                    path_goal = goal_connect_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node pos\n                    success_state = True\n                    break\n            else:\n                new_node_goal = try_extend(tree_goal, sample_point)\n                if new_node_goal is None:\n                    tree_start, tree_goal = tree_goal, tree_start\n                    continue\n                connection = connect_trees(new_node_goal, tree_start)\n                if connection:\n                    goal_connect_node, start_connect_node = connection\n                    path_start = start_connect_node.path_from_root()\n                    path_goal = goal_connect_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    success_state = True\n                    break\n\n            # Swap trees every iteration for balanced exploration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        # If no successful path but time/iteration exhausted, try best connection between trees for path\n        if not success_state:\n            best_pair = None\n            best_cost = float('inf')\n            for node_start in tree_start:\n                for node_goal in tree_goal:\n                    dist = math.dist(node_start.position, node_goal.position)\n                    total_cost = node_start.cost + dist + node_goal.cost\n                    if dist <= self.step_size and total_cost < best_cost:\n                        if (not self._is_edge_in_obstacle(node_start.position, node_goal.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(node_start.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(node_goal.position, obstacles, is_3d)):\n                            best_cost = total_cost\n                            best_pair = (node_start, node_goal)\n            if best_pair:\n                start_node, goal_node = best_pair\n                path_start = start_node.path_from_root()\n                path_goal = goal_node.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": 20.67442,
          "time_improvement": -86.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 298.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035030674934387204,
                    "num_nodes_avg": 146.9,
                    "path_length_avg": 165.730455893525,
                    "smoothness_avg": 0.022068133214212804,
                    "success_improvement": 0.0,
                    "time_improvement": -47.74529727686009,
                    "length_improvement": 9.160510957629162,
                    "smoothness_improvement": 245.41420652071872,
                    "objective_score": -11.264415958928602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1291945457458496,
                    "num_nodes_avg": 482.7,
                    "path_length_avg": 231.19433763532234,
                    "smoothness_avg": 0.01724827780300528,
                    "success_improvement": 0.0,
                    "time_improvement": 46.13618326778135,
                    "length_improvement": 22.82067553729267,
                    "smoothness_improvement": 343.81061130366845,
                    "objective_score": 20.12404314431128
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.37153284549713134,
                    "num_nodes_avg": 661.5,
                    "path_length_avg": 119.77040977688375,
                    "smoothness_avg": 0.03184786115094011,
                    "success_improvement": 0.0,
                    "time_improvement": -254.9974599457362,
                    "length_improvement": 20.45419668023097,
                    "smoothness_improvement": 305.1024430753773,
                    "objective_score": -70.88288643229777
               }
          ],
          "success_rate": 1.0
     }
]