{
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm inspired by RRT* with goal bias and informed sampling.\n    The algorithm adaptively adjusts its sampling region towards the goal area, uses a heuristic cost to guide vertex connections,\n    and implements rewiring to optimize path cost (similar to RRT*). It applies early stopping if a path is found or exceeds a 10-second timeout.\n    After finding a path, it attempts path smoothing by shortcutting collisions. This design improves efficiency, path quality, and robustness,\n    reducing iterations needed and enhancing success rate in cluttered or complex grid spaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=True), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0\n        self._iterations = 8000\n        self._goal_sample_rate = 0.15  # probability of sampling the goal directly\n        self._rewire_radius_factor = 30.0  # radius factor for rewiring nearby vertices\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with self._goal_sample_rate probability, sample goal directly; else random valid position\n        if np.random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            for _ in range(100):\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # fallback in a worst case\n            return self._get_grid().goal.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Movement cost between vertices + cost to come of frm\n        return frm.cost + self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        # Choose the best parent for q_new that minimizes cost and valid path exists\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            c = self._cost(q_near, q_new)\n            if c < min_cost:\n                min_cost = c\n                best_parent = q_near\n        if best_parent is None:\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # For each nearby vertex, if going through q_new reduces cost and path valid, rewire tree\n        for q_near in near_vertices:\n            if q_near == q_new.parents or q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            new_cost = self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old edge(s)\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_end: Vertex) -> None:\n        # Trace back parent links from q_end to start to create path\n        path: List[Vertex] = [q_end]\n        while len(path[-1].parents) != 0:\n            # Parents should always have exactly one parent if rewired properly\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path smoothing by shortcutting collisions\n        smoothed_path = []\n        i = 0\n        while i < len(path):\n            smoothed_path.append(path[i])\n            j = len(path) - 1\n            while j > i:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    i = j\n                    break\n                j -= 1\n            else:\n                i += 1  # increment at least by 1 if can't shortcut\n\n        # Animate agent movements along the smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time as _time\n        start_time = _time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n        found_goal = False\n        last_added = None\n\n        for i in range(self._iterations):\n            if _time.time() - start_time > 10.0:\n                # Timeout, stop searching\n                break\n\n            q_rand = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_rand)\n            if q_near.position == q_rand:\n                continue\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Reject if invalid line\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices in radius for rewiring and choosing best parent\n            radius = self._rewire_radius_factor * (math.log(self._graph.size + 1) / (self._graph.size + 1))**(1.0 / self._get_grid().size.n_dim)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n            if not near_vertices:\n                near_vertices = [q_near]\n\n            parent = self._choose_parent(q_new, near_vertices)\n            if parent is None:\n                # No suitable parent with valid path found, skip\n                continue\n\n            self._graph.add_edge(parent, q_new)\n            last_added = q_new\n\n            # Rewire nearby vertices through q_new if improves cost\n            self._rewire(q_new, near_vertices)\n\n            self._graph.size += 1\n\n            # Check if q_new near an agent goal radius to end\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex, link from q_new to goal, set cost\n                goal_vertex = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    goal_vertex.cost = self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    break\n\n            # Visualization frame\n            self.key_frame()\n\n        if found_goal and last_added is not None:\n            self._extract_path(self._graph.root_vertex_goal)\n        else:\n            # Path not found before timeout or iterations exhausted\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved variant inspired by RRT* combined with heuristic-guided, goal-biased sampling.\n    It adaptively adjusts its step size based on distance to goal to balance exploration and exploitation.\n    It performs rewiring to optimize path costs, improving path quality.\n    A heuristic (Euclidean + cost-so-far) is used to guide vertex expansions.\n    Early stopping is enforced by time limit (10s max).\n    The final path is shortcut-smoothed to reduce unnecessary waypoints and produce a shorter, smoother trajectory.\n    This approach improves efficiency by prioritizing goal direction and pruning,\n    robustness by extensive rewiring and obstacle validation,\n    and path quality through smoothing and cost optimization.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _time_limit_sec: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._max_dist = 15.0\n        self._iterations = 5000\n        self._time_limit_sec = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.2) -> Point:\n        # With goal_bias probability sample goal directly for goal-directed bias\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new)\n\n    def _calc_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost from frm to to plus cost-to-frm (path cost so far)\n        return frm.cost + self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the neighbor that results in the lowest cost path to q_new\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = self._calc_cost(neighbor, q_new)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        for neighbor in neighbors:\n            if neighbor.position == q_new.position:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    # Add new parent\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self) -> None:\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Find the lowest cost vertex near goal (or goal itself if connected)\n        goal_candidates = self._near(start_vertex, goal_vertex, 0.1)\n        if goal_vertex in goal_candidates:\n            final_goal = goal_vertex\n        elif len(goal_candidates) > 0:\n            # Choose candidate with min cost + heuristic to goal\n            min_cost = math.inf\n            final_goal = None\n            for v in goal_candidates:\n                cost_est = v.cost + Map.get_distance(v.position, goal_vertex.position)\n                if cost_est < min_cost:\n                    min_cost = cost_est\n                    final_goal = v\n        else:\n            # No connection found to goal vicinity\n            return\n        \n        # Backtrack path from final_goal to start_vertex\n        path = []\n        current = final_goal\n        path.append(current.position)\n        while current is not start_vertex:\n            if not current.parents:\n                break\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current.position)\n        path.reverse()\n\n        # Shortcut smoothing: iteratively try to connect non-consecutive waypoints directly\n        def shortcut_smooth(path: List[Point]) -> List[Point]:\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while idx < len(path) -1:\n                next_idx = len(path) -1\n                while next_idx > idx+1:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed[-1], path[next_idx])):\n                        break\n                    next_idx -= 1\n                smoothed.append(path[next_idx])\n                idx = next_idx\n            return smoothed\n\n        smoothed_path = shortcut_smooth(path)\n\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(self._iterations):\n            if time.time() - start_time > self._time_limit_sec:\n                # Timeout: no path found within 10 seconds\n                break\n\n            sample = self._get_random_sample(goal_bias=0.3)  # Increased bias to goal for efficiency\n            q_near = self._get_nearest_vertex(start_vertex, sample)\n\n            # Adaptive max step size: closer to goal smaller steps, far larger steps (min 5 max 25)\n            dist_to_goal = Map.get_distance(q_near.position, self._graph.root_vertex_goal.position)\n            adaptive_max_dist = max(5.0, min(25.0, dist_to_goal / 2.0))\n\n            q_new = self._get_new_vertex(q_near, sample, adaptive_max_dist)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._near(start_vertex, q_new, radius=self._max_dist * 2)\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n            else:\n                q_new.cost = self._calc_cost(parent, q_new)\n\n            # Add new vertex and edge to graph\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewiring step to optimize paths locally\n            self._rewire(neighbors, q_new)\n\n            self.key_frame()\n\n            # Check if we can connect to goal directly from q_new\n            line_to_goal = self._get_grid().get_line_sequence(q_new.position, self._graph.root_vertex_goal.position)\n            if self._get_grid().is_valid_line_sequence(line_to_goal):\n                goal_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                if self._graph.root_vertex_goal.cost == 0.0 or goal_cost < self._graph.root_vertex_goal.cost:\n                    # Rewire goal connection\n                    if self._graph.root_vertex_goal.parents:\n                        for p in list(self._graph.root_vertex_goal.parents):\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                    self._graph.root_vertex_goal.cost = goal_cost\n\n                    self._extract_path()\n                    return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a heuristic-guided, goal-biased path planning approach combining adaptive sampling,\n    dynamic step sizing, and local rewiring to improve planning efficiency, path quality, and success rate.\n    \n    Key ideas:\n    - Uses heuristic (Euclidean) cost-to-go to bias sampling towards the goal with adaptively increasing probability.\n    - Adjusts max step size dynamically based on distance to goal to allow faster expansion early and finer control near goal.\n    - Employs lazy collision checking for rewiring within a dynamically computed radius.\n    - Uses local shortcut smoothing after path extraction to improve path quality.\n    - Runs with a maximum timeout of 10 seconds for robustness and timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_time_sec: float\n    _max_step_initial: float\n    _max_step_final: float\n    _rewire_constant: float\n    _goal_bias_initial: float\n    _goal_bias_final: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time_sec = 10.0\n        self._max_step_initial = 20\n        self._max_step_final = 5\n        self._rewire_constant = 40\n        self._goal_bias_initial = 0.05\n        self._goal_bias_final = 0.3\n        self._init_displays()\n\n    # Override or add helpers as needed\n\n    def _get_random_sample(self, goal_bias: float) -> Point:\n        # With probability goal_bias, return the goal position to bias sampling\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        # Otherwise sample uniformly valid position\n        while True:\n            coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        vec_norm = vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * vec_norm)\n        return Vertex(q_new_pos)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _heuristic_cost(self, position: Point) -> float:\n        return Map.get_distance(position, self._get_grid().goal.position)\n\n    def _line_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_reached: Vertex) -> None:\n        # Traverse backwards from goal to start through parents to build path\n        path = [q_reached]\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing: Try to iteratively skip intermediate vertices if direct connection is valid\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            # Try skipping intermediate vertices from last added smoothed_path vertex to path[i]\n            last = smoothed_path[-1]\n            if self._line_collision_free(last.position, path[i].position):\n                # Can shortcut - replace last with current i path vertex (tentatively)\n                if i == len(path) - 1 or not self._line_collision_free(last.position, path[i+1].position):\n                    smoothed_path.append(path[i])\n            else:\n                # If no direct path possible, append previous vertex before i\n                smoothed_path.append(path[i-1])\n                # then also append current vertex if last of path or direct line possible\n                if i == len(path)-1 or self._line_collision_free(smoothed_path[-1].position, path[i].position):\n                    smoothed_path.append(path[i])\n\n        # Ensure goal is included if not there\n        if smoothed_path[-1].position != path[-1].position:\n            smoothed_path.append(path[-1])\n\n        # Move agent along the smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            # ROS extension waypoint publishing if applicable\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        dim = self._get_grid().size.n_dim\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._max_time_sec:\n                # Timeout reached without path\n                return\n\n            # Adaptive goal bias increasing linearly from initial to final\n            goal_bias = min(self._goal_bias_final,\n                            self._goal_bias_initial + (self._goal_bias_final - self._goal_bias_initial) * iteration / self._max_iterations)\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size decreases as approaching goal\n            dist_to_goal = self._heuristic_cost(q_nearest.position)\n            max_dist = max(self._max_step_final,\n                           self._max_step_initial * dist_to_goal / max(Map.get_distance(start_vertex.position, goal_vertex.position), 1e-5))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._line_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate cost through q_nearest\n            c_new = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = c_new\n\n            # Find neighbors within radius following the RRT* dynamic radius formula\n            card_v = max(1, self._graph.size)  # prevent zero division\n            radius = min(self._rewire_constant * ((math.log(card_v) / card_v) ** (1.0 / dim)), max_dist * 2)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost to q_new (rewiring)\n            c_min = c_new\n            q_min = q_nearest\n            for v_near in near_vertices:\n                if self._line_collision_free(v_near.position, q_new.position):\n                    c_v = v_near.cost + Map.get_distance(v_near.position, q_new.position)\n                    if c_v < c_min:\n                        c_min = c_v\n                        q_min = v_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through q_new for potential cost improvement\n            for v_near in near_vertices:\n                if v_near is q_min:\n                    continue\n                if self._line_collision_free(q_new.position, v_near.position):\n                    potential_cost = q_new.cost + Map.get_distance(q_new.position, v_near.position)\n                    if potential_cost < v_near.cost:\n                        # Remove old parent edge\n                        old_parent = next(iter(v_near.parents))\n                        self._graph.remove_edge(old_parent, v_near)\n                        # Add new edge from q_new to v_near\n                        v_near.cost = potential_cost\n                        self._graph.add_edge(q_new, v_near)\n\n            # Check if q_new reaches goal radius; if yes, add goal as child and break\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attach goal vertex to q_new\n                dist_to_goal = Map.get_distance(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Heuristic-Guided Adaptive Sampling Tree (H-GAST) planner.\n    Key points:\n    - Uses heuristic goal-biased sampling with a dynamic bias that increases if progress slows.\n    - Adaptive max step size (max_dist) based on distance to goal for faster expansion when far,\n      and finer steps when near the goal.\n    - Incorporates rewiring similar to RRT*, but adds a smoothing shortcut step after path extraction.\n    - Early stopping if path found or after 10 seconds timeout.\n    - Uses a priority queue (heap) to always expand the vertex with the lowest f = cost + heuristic estimate,\n      which brings A*-style guided exploration to sample-based planning.\n    - The graph is a Forest structure connecting starting tree to goal by gradual growth.\n    - This approach yields faster convergence, smoother paths and robust goal connection.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        # Additional variables:\n        self._timeout_seconds = 10\n        self._goal_bias_min = 0.1\n        self._goal_bias_max = 0.5\n        self._goal_bias = self._goal_bias_min\n        self._last_expand_time = time.time()\n        self._last_progress_cost = None\n\n    def _heuristic(self, p1: Point, p2: Point) -> float:\n        # Euclidean heuristic for A* style guidance\n        return float(Map.get_distance(p1, p2))\n\n    def _adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        dist = self._heuristic(current_pos, goal_pos)\n        if dist > 30:\n            return 15.0\n        elif dist > 10:\n            return 10.0\n        else:\n            return 5.0\n\n    def _get_goal_biased_sample(self) -> Point:\n        # Increase goal bias if no progress recently, else decay it\n        now = time.time()\n        if now - self._last_expand_time > 1.0:  # every 1 second without progress relax bias\n            self._goal_bias = min(self._goal_bias + 0.05, self._goal_bias_max)\n        else:\n            self._goal_bias = max(self._goal_bias * 0.95, self._goal_bias_min)\n\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\" Attempt to shortcut the path by removing unnecessary waypoints \"\"\"\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Try to find farthest reachable vertex from current new_path[-1]\n            j = len(path)-1\n            while j > i+1:\n                line_seq = self._get_grid().get_line_sequence(new_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _extract_path(self, connection_vertex: Vertex) -> None:\n        # Trace parents back to start vertex\n        path = [connection_vertex]\n        current = connection_vertex\n        while current.parents:\n            # Just pick the first parent (should be single tree parent)\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path to smooth it\n        smoothed_path = self._shortcut_path(path)\n\n        # Move agent along smoothed path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        open_heap = gen_heap()  # Min-heap by f = cost + heuristic\n        start = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize open set with start vertex\n        open_heap.push((start.cost + self._heuristic(start.position, goal_pos), start))\n\n        max_iterations = 15000\n        iteration = 0\n\n        while iteration < max_iterations:\n            iter_time = time.time()\n            if iter_time - start_time > self._timeout_seconds:\n                # Timeout reached: stop and fail silently (or could log failure)\n                break\n\n            if open_heap.empty():\n                # No more vertices to expand => fail\n                break\n\n            f_cost, q_nearest = open_heap.pop()\n\n            # Sample goal biased point, adaptive bias\n            q_sample = self._get_goal_biased_sample()\n\n            # Adaptive step size based on current to goal distance\n            max_dist = self._adaptive_max_dist(q_nearest.position, goal_pos)\n\n            # Generate new vertex toward sample\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if q_new.position == q_nearest.position:\n                iteration += 1\n                continue\n\n            # Check validity of edge q_nearest -> q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            # Calculate cost for q_new via q_nearest\n            dist_cost = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            new_cost = q_nearest.cost + dist_cost\n\n            # Rewiring step: radius depends on graph size and dimension (2D)\n            card_v = float(self._graph.size)\n            radius = min(50.0, 30 * ((math.log(card_v) / card_v) ** 0.5)) if card_v > 1 else 30.0\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n\n            # Find best parent among near vertices\n            q_min = q_nearest\n            c_min = new_cost\n            for near_v in near_vertices:\n                line_seq_near = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost_thru_near = near_v.cost + float(torch.norm(near_v.position.to_tensor() - q_new.position.to_tensor()))\n                    if cost_thru_near < c_min:\n                        q_min = near_v\n                        c_min = cost_thru_near\n\n            # Set cost and add q_new to graph\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better through q_new\n            for near_v in near_vertices:\n                if near_v == q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, near_v.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                cost_thru_new = q_new.cost + float(torch.norm(q_new.position.to_tensor() - near_v.position.to_tensor()))\n                if cost_thru_new < near_v.cost:\n                    # Remove old edge\n                    old_par = next(iter(near_v.parents))\n                    self._graph.remove_edge(old_par, near_v)\n                    # Add new edge from q_new to near_v\n                    near_v.cost = cost_thru_new\n                    self._graph.add_edge(q_new, near_v)\n\n            # Add q_new to open set for expansion\n            f_new = q_new.cost + self._heuristic(q_new.position, goal_pos)\n            open_heap.push((f_new, q_new))\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            # Update last expansion time and progress if cost improved near goal\n            if self._last_progress_cost is None or c_min < self._last_progress_cost - 1e-3:\n                self._last_expand_time = iter_time\n                self._last_progress_cost = c_min\n\n            iteration += 1\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved version of the RRT* (RRT-star) path planning algorithm,\n    incorporating the following enhancements:\n    - Goal-biased sampling: with a certain probability, directly sample the goal point to bias \n      exploration towards the goal.\n    - Adaptive step size: sets a max extension distance based on obstacle density around the sampled\n      vertex vicinity, allowing smarter expansion in open spaces.\n    - Rewiring of vertices within a radius (RRT* style) to improve path optimality and shorten the path.\n    - Early stopping criteria: terminates if a path to the goal is found and no better path has been \n      found for a certain number of iterations.\n    - Uses a cost-aware nearest vertex search and rewiring, minimizing cumulative path cost.\n    - Shortcut smoothing at the end to improve path quality by removing unnecessary intermediate vertices.\n    - Time budget limit: terminates search after 10 seconds if no path found.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring\n        self._goal_bias = 0.1  # 10% chance to sample goal directly\n        self._max_dist_default = 15.0\n        self._rewire_radius = 25.0\n        self._improvement_timeout_iters = 200\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, vertex: Vertex) -> float:\n        # Estimate obstacle density around vertex position by sampling neighbors\n        neighbors = self._get_grid().get_next_positions(vertex.position)\n        if not neighbors:\n            return self._max_dist_default * 0.5\n        invalid_count = 0\n        for nb in neighbors:\n            if not self._get_grid().is_agent_valid_pos(nb):\n                invalid_count += 1\n        density = invalid_count / len(neighbors)\n        # More obstacles nearby => smaller max_dist to proceed cautiously\n        return max(5.0, self._max_dist_default * (1.0 - density))\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist == 0:\n            # Same position, no new vertex\n            return None\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        # Check line validity between q_near and new_pos\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability _goal_bias sample goal, else random valid point\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos_np = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos_np)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _compute_cost(self, parent: Vertex, child: Vertex) -> float:\n        # Cost to move from parent to child vertex\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # From neighbors, pick the vertex that results in minimum cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in q_near_vertices:\n            cost = self._compute_cost(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_vertices: List[Vertex]) -> None:\n        # Try to rewire each neighbor to pass through q_new if it improves cost\n        for q_near in q_near_vertices:\n            current_cost = q_near.cost\n            new_cost = self._compute_cost(q_new, q_near)\n            if new_cost < current_cost:\n                # Check validity of path q_new -> q_near\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edge parent->q_near\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add edge q_new->q_near\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path by backtracking parents from goal to start\n        path: List[Vertex] = [goal_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Choose parent with minimum cost (in case multiple parents)\n            min_parent = None\n            min_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        # Remove the last vertex pointing to start root vertex if duplicated, so ignore it to avoid duplicate rendering\n        if path[-1].position == self._graph.root_vertex_start.position:\n            path.pop()\n\n        path.reverse()\n\n        # Path shortcutting: try to remove unnecessary intermediate points\n        path = self._shortcut_path(path)\n\n        # Animate moving agent along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by skipping intermediate vertices where possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            max_j = i + 1\n            for j in range(len(path) - 1, i, -1):\n                line_seq = self._get_grid().get_line_sequence(shortcut_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    max_j = j\n                    break\n            shortcut_path.append(path[max_j])\n            i = max_j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex_pos = self._graph.root_vertex_goal.position\n\n        max_iterations = 10000\n        no_improve_iters = 0\n        best_goal_vertex: Optional[Vertex] = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Time limit exceeded; stop and treat as failure\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                # Sampled exactly at an existing vertex - skip iteration\n                continue\n\n            adaptive_max_dist = self._get_adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n            if q_new is None:\n                continue\n\n            # Get nearby vertices within rewire radius\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            if not neighbors:\n                neighbors = [q_near]  # At least connect to nearest vertex\n\n            # Choose the best parent for q_new (lowest cost)\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            q_new.cost = self._compute_cost(best_parent, q_new)\n\n            # Add edge from best parent to q_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Cost from q_new to goal vertex\n                dist_to_goal = Map.get_distance(q_new.position, goal_vertex_pos)\n                total_cost = q_new.cost + dist_to_goal\n\n                if total_cost < best_goal_cost:\n                    # Create a temporary goal vertex connected to q_new to extract path\n                    best_goal_vertex = Vertex(goal_vertex_pos)\n                    best_goal_vertex.cost = total_cost\n                    self._graph.add_edge(q_new, best_goal_vertex)\n\n                    best_goal_cost = total_cost\n                    no_improve_iters = 0\n                else:\n                    no_improve_iters += 1\n            else:\n                no_improve_iters += 1\n\n            # Early stopping if no improvement in a while after a path found\n            if best_goal_vertex is not None and no_improve_iters >= self._improvement_timeout_iters:\n                break\n\n            self.key_frame()\n\n        # If a path was found, extract and animate it\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)\n        else:\n            # No path found - optionally could log or keep agent at start position\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired approach with heuristic goal-biasing, adaptive step sizing, \n    rewiring for path cost optimization, and path shortcutting for smoother final paths. \n    \n    Key improvements:\n    - Adaptive max_dist step size depending on distance to goal (larger steps when far, smaller near goal).\n    - Goal biasing in sampling to increase chance of connecting to goal.\n    - Rewiring nearby vertices after adding a new vertex to reduce costs and improve path quality.\n    - Early stop if found path and no significant improvement within a fixed iteration window.\n    - Shortcut path smoothing at the end to reduce unnecessary waypoints.\n    - Timeout of 10 seconds to avoid long runs.\n\n    These enhancements aim to improve planning efficiency, path quality, robustness, and success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring (removable edges)\n        self._init_displays()\n\n        # Set base parameters\n        self._base_max_dist = 10.0\n        self._goal_sample_rate = 0.2  # 20% samples directly towards goal\n        self._rewire_radius_factor = 15.0  # radius factor for rewire neighborhood\n        self._max_iterations = 8000\n\n    def _get_adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        dist = Map.get_distance(current_pos, goal_pos)\n        # Make steps larger when far, smaller near goal (between 3 and base_max_dist)\n        return max(3.0, min(self._base_max_dist, dist / 4))\n\n    def _heuristic_cost(self, from_p: Point, to_p: Point) -> float:\n        # Euclidean distance heuristic cost\n        return Map.get_distance(from_p, to_p)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Find vertices within radius in the graph\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # For each neighbor vertex, try to update its parent if a lower cost connection via q_new exists\n        for q_near in neighbors:\n            if q_near.position == q_new.position:\n                continue\n            # Cost to go from root to q_new + cost q_new to neighbor\n            tentative_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if tentative_cost < q_near.cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                # Remove old edge\n                # There can be multiple parents in cyclic graph, remove one valid parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = tentative_cost\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new_pos: Point) -> Vertex:\n        # Choose the best parent vertex among neighbors minimizing cost to q_new\n        min_cost = math.inf\n        best_parent = None\n        for q_near in q_near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n                continue\n            cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent, min_cost\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with _goal_sample_rate probability sample the goal directly\n        if np.random.rand() < self._goal_sample_rate:\n            goal_pos = self._get_grid().goal.get_position()\n            return goal_pos\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract best path from start to goal by backtracking parents\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            # Pick parent with lowest cost if multiple parents exist\n            min_cost = math.inf\n            min_parent = None\n            for parent in path[-1].parents:\n                if parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        # Perform post processing to shortcut path for smoothing\n        path_points = [p.position for p in path]\n        smooth_path_points = self._shortcut_path(path_points)\n\n        # Animate smooth path\n        for pnt in smooth_path_points:\n            self.move_agent(pnt)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_points: List[Point]) -> List[Point]:\n        # Shortcut path by attempting to connect non-consecutive points if line is valid\n        if len(path_points) < 3:\n            return path_points\n\n        shortened_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            connected = False\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortened_path.append(path_points[j])\n                    i = j\n                    connected = True\n                    break\n                j -= 1\n            if not connected:\n                # Can't shortcut, just add next point\n                shortened_path.append(path_points[i + 1])\n                i += 1\n        # Remove duplicates that can appear\n        deduped = []\n        last = None\n        for pt in shortened_path:\n            if pt != last:\n                deduped.append(pt)\n                last = pt\n        return deduped\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.get_position()\n\n        start_vertex.cost = 0.0\n\n        # Add root vertex\n        self._graph.root_vertices = [start_vertex]\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost = math.inf\n\n        iterations_since_last_improvement = 0\n        max_no_improve_iter = 400\n\n        for i in range(self._max_iterations):\n            # Check timeout 10 seconds\n            if time.time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Get nearest vertex in graph\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist\n            max_dist = self._get_adaptive_max_dist(q_near.position, goal_pos)\n\n            # Create new vertex in direction towards q_sample, limited by max_dist\n            dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_tensor)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n            # Validate edge feasibility\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring\n            neighborhood_radius = self._rewire_radius_factor * math.sqrt((math.log(max(1, self._graph.size + 1)) / (self._graph.size + 1)))\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new_pos, neighborhood_radius)\n\n            # Choose parent with min cost from neighbors (including q_near if applicable)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n            best_parent, best_parent_cost = self._choose_parent(neighbors, q_new_pos)\n            if best_parent is None:\n                continue\n\n            # Create new vertex and set cost\n            q_new = Vertex(q_new_pos)\n            q_new.cost = best_parent_cost\n\n            # Add edge from best_parent to q_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to try to improve their cost with q_new as parent\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to graph roots for later search (conventionally)\n            self._graph.root_vertices.append(q_new)\n\n            # Check if new vertex reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Estimate total cost to goal using heuristic (distance to goal)\n                total_cost = q_new.cost + self._heuristic_cost(q_new.position, goal_pos)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    iterations_since_last_improvement = 0\n            else:\n                iterations_since_last_improvement += 1\n\n            # Early stopping if no improvement for many iterations and have found a path\n            if best_goal_vertex is not None and iterations_since_last_improvement > max_no_improve_iter:\n                break\n\n            self.key_frame()\n\n        # If found a best goal vertex, extract and smooth path\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining heuristic-based informed sampling,\n    adaptive step size, and aggressive rewiring to improve planning efficiency, path quality, and robustness:\n    - Uses a goal-biased sampling distribution that increasingly focuses near the goal as iterations progress.\n    - Implements heuristic-guided vertex selection combining cost-to-come and heuristic-to-goal (like A* guidance).\n    - Adaptive max step distance that shrinks near obstacles or cramped areas for finer exploration.\n    - Heuristic rewiring with shortcutting to improve path smoothness and reduce total cost.\n    - Early stopping if time exceeds 10 seconds or goal reached.\n    - Path extraction includes shortcut smoothing via collision checking with direct lines.\n    This algorithm blends ideas from RRT*, Informed-RRT*, and heuristic A*-style searches on sample based trees to\n    achieve faster, more reliable planning on discrete grids with obstacles.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize start and goal vertices in forest, cost set in start to zero\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Start with empty vertex list to add samples dynamically\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        # Parameters\n        self._max_iterations = 5000\n        self._initial_max_dist = 15.0\n        self._min_max_dist = 5.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._goal_sample_rate = 0.2  # 20% goal bias\n        self._time_limit_secs = 10.0\n        self._init_displays()\n\n    def _get_heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance as heuristic cost (to-go)\n        return float(Map.get_distance(from_pos, to_pos))\n\n    def _get_informed_sample(self, iteration: int) -> Point:\n        \"\"\"\n        Generates a goal-biased sample that also focuses more near the goal over time.\n        Uses uniform sampling initially, then biased elliptical sampling around start-goal line.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        start_pos = self._graph.root_vertex_start.position\n\n        # With probability goal_sample_rate, return exact goal pos (to bias)\n        if random.random() < self._goal_sample_rate:\n            return goal_pos\n\n        # Adaptive elliptical sampling radius shrinks over time toward straight line connecting start and goal\n        max_dist = Map.get_distance(start_pos, goal_pos)\n        shrink_factor = min(1.0, iteration / (self._max_iterations * 0.7))\n        radius_horizontal = max_dist * (1.0 - 0.8 * shrink_factor)  # horizontal ellipse axis\n        radius_vertical = max_dist * 0.5 * (1.0 - 0.95 * shrink_factor)  # vertical ellipse axis\n\n        # Sample uniformly in ellipse aligned along start-goal vector\n        while True:\n            # Sample in unit circle\n            angle = random.uniform(0, 2 * math.pi)\n            r = random.uniform(0, 1) ** 0.5  # sqrt for uniform in circle\n            x = r * math.cos(angle) * radius_horizontal\n            y = r * math.sin(angle) * radius_vertical\n\n            # Rotate and translate into world reference frame\n            dir_vec = (goal_pos.to_tensor() - start_pos.to_tensor())\n            length = torch.norm(dir_vec)\n            if length == 0:\n                sample_pos = start_pos\n            else:\n                dir_unit = dir_vec / length\n                # Orthogonal vector in 2D\n                ortho_vec = torch.tensor([-dir_unit[1], dir_unit[0]])\n                sample_tensor = start_pos.to_tensor() + x * dir_unit + y * ortho_vec\n                sample_pos = Point.from_tensor(sample_tensor)\n\n            if self._get_grid().is_agent_valid_pos(sample_pos):\n                return sample_pos\n\n    def _get_nearest_vertex_with_heuristic(self, q_sample: Point) -> Vertex:\n        \"\"\"\n        Return the vertex in the current tree minimizing (cost-to-come + heuristic-to-goal)\n        Heuristic guides the vertex towards those promising shortest overall path (A*-like).\n        \"\"\"\n        best_vertex = None\n        best_cost = float('inf')\n        goal_pos = self._graph.root_vertex_goal.position\n        for v in self._graph.root_vertices + list(self._graph.root_vertex_start.connectivity) + [self._graph.root_vertex_start]:\n            # Combine cost-to-come + heuristic to goal\n            cost_to_come = v.cost if v.cost is not None else float('inf')\n            heuristic_cost = self._get_heuristic_cost(v.position, q_sample)\n            total_cost = cost_to_come + heuristic_cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_vertex = v\n        if best_vertex is None:\n            best_vertex = self._graph.root_vertex_start\n        return best_vertex\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"\n        Shrinks max_dist adaptively near obstacles by checking 8-neighborhood of q_near\n        if obstacles nearby reduces step for finer exploration.\n        \"\"\"\n        base_dist = self._initial_max_dist\n        neighbors = self._get_grid().get_next_positions(q_near.position)\n        obstacle_nearby = any(not self._get_grid().is_agent_valid_pos(n) for n in neighbors)\n        if obstacle_nearby:\n            return max(self._min_max_dist, base_dist * 0.5)\n        return base_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse existing logic, but override with adaptive max_dist from above\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to rewire nearby vertices to new vertex q_new for lower cost paths.\n        Optimizes the tree by connecting vertices if they get cheaper cost routes.\n        \"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge(s)\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Perform shortcut smoothing on path by skipping intermediate vertices where possible.\n        Attempts to connect non-adjacent vertices directly if collision free.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, move next step by one\n                shortcut_path.append(path[i + 1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path by walking parents backward from goal to root\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while len(current.parents) > 0:\n            # Pick lowest cost parent if multiple\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            current = min_cost_parent\n            path.append(current)\n        # Reverse path so it goes from start to goal\n        path.reverse()\n\n        # Smooth path with shortcuts\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # ROS published waypoints if applicable\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.perf_counter()\n\n        for iteration in range(self._max_iterations):\n\n            if time.perf_counter() - start_time > self._time_limit_secs:\n                # time limit exceeded - fail gracefully\n                return\n\n            # Sample with increasing goal bias and informed elliptical sampling\n            q_sample = self._get_informed_sample(iteration)\n\n            # Select nearest vertex with heuristic guidance (cost to come + heuristic)\n            q_nearest = self._get_nearest_vertex_with_heuristic(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            adaptive_max_dist = self._adaptive_max_dist(q_nearest)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_max_dist)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            # Check collision between q_nearest and q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate cost for q_new\n            cost_q_new = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = cost_q_new\n            self._graph.add_edge(q_nearest, q_new)\n\n            # Get neighbors within radius for rewiring\n            card_V = torch.tensor(float(self._graph.size))\n            log_card_V = torch.log(card_V)\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1 / self._dimension)), self._max_radius)\n            Q_near = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Cost-based rewiring to improve tree quality\n            self._rewire(q_new, Q_near)\n\n            # Early goal check with path extraction if close enough to goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex if possible\n                goal_vertex = self._graph.root_vertex_goal\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning Algorithm inspired by RRT* with goal biasing, adaptive step size,\n      rewiring for path optimization, and early stopping on timeout.\n      \n      Key features:\n      - Goal-biased sampling to guide the search toward the goal more frequently.\n      - Adaptive max_dist based on current tree spread and iteration count to balance exploration and refinement.\n      - Rewiring step to optimize the path incrementally (like RRT*).\n      - Extracted path is shortcut-smoothed for better quality.\n      - Early stop if path is found or timeout of 10 seconds is reached.\n      \n      Expected improvements:\n      - Faster convergence to feasible solutions.\n      - Higher quality (shorter, smoother) paths.\n      - Robustness via rewiring to escape poor initial connections.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_step_size_initial: float\n    _max_step_size_min: float\n    _goal_sample_rate: float  # Probability of sampling exactly the goal point\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring (edges can be removed)\n        self._init_displays()\n\n        self._max_step_size_initial = 15.0\n        self._max_step_size_min = 3.0\n        self._goal_sample_rate = 0.15  # 15% samples are goal biased\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing: with self._goal_sample_rate chance sample goal directly\n        if np.random.uniform(0, 1) < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\" Extract path from q_new to start by following parents, then shortcut-smooth it. \"\"\"\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertex_start.position:\n            if len(current.parents) == 0:\n                break  # No path found - disconnected graph\n            # Take parent with minimum cost\n            min_parent = min(current.parents, key=lambda v: v.cost)\n            path.append(min_parent)\n            current = min_parent\n        path.reverse()\n\n        # Shortcut smoothing on the path to improve path quality\n        smoothed_path = self._shortcut_smooth_path([v.position for v in path])\n\n        # Show animation moving the agent along the smoothed path\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\" Attempt rewiring neighbors through q_new if cost improved and path valid \"\"\"\n        for neighbor in neighbors:\n            # Cost to neighbor via q_new candidate\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if potential_cost < neighbor.cost:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    # remove edges from old parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    # add new edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _get_near_radius(self, n_vertices: int, dim: int = 2) -> float:\n        \"\"\" Radius formula for near vertex searches as in RRT* \"\"\"\n        gamma_rrt_star = 50.0  # Tunable parameter, depends on environment size, here chosen empirically\n        return min(gamma_rrt_star * (math.log(n_vertices + 1) / (n_vertices + 1)) ** (1 / dim), self._max_step_size_initial)\n\n    def _shortcut_smooth_path(self, positions: List[Point], max_attempts: int = 100) -> List[Point]:\n        \"\"\" Attempt to shortcut path by iteratively connecting non-adjacent points directly if valid \"\"\"\n        if len(positions) <= 2:\n            return positions\n\n        path = positions[:]\n        for _ in range(max_attempts):\n            if len(path) <= 2:\n                break\n            i = np.random.randint(0, len(path) - 2)\n            j = np.random.randint(i + 2, len(path))\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i], path[j])):\n                # shortcut is valid, remove intermediate points\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 10.0\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iteration = 0\n        max_iterations = 10000\n\n        while iteration < max_iterations:\n            iteration += 1\n            elapsed_time = time.time() - start_time\n            if elapsed_time > max_time_sec:\n                # Fail graceful if timeout\n                break\n\n            # Adaptive max step size, decrease with iterations for refinement\n            max_dist = max(self._max_step_size_min,\n                           self._max_step_size_initial * math.exp(-iteration / 2000.0))\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue  # redundant sample\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue  # invalid path to new vertex\n\n            # Assign cost for q_new: cost to q_near + movement cost q_near->q_new\n            new_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = new_cost\n\n            # Find neighbors within radius for rewiring\n            near_radius = self._get_near_radius(self._graph.size)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, near_radius)\n\n            # Choose parent with minimum cost + valid path\n            min_cost = q_new.cost\n            best_parent = q_near\n            for vertex in neighbors:\n                c = vertex.cost + self._get_grid().get_movement_cost(vertex.position, q_new.position)\n                if c < min_cost:\n                    # Check path validity from vertex to q_new\n                    seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(seq):\n                        min_cost = c\n                        best_parent = vertex\n            q_new.cost = min_cost\n\n            # Connect q_new to best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if cheaper cost through q_new\n            self._rewire(q_new, neighbors)\n\n            # Add q_new vertex to forest root_vertices\n            self._graph.root_vertices.append(q_new)\n            self._graph.size += 1\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "An improved path planning algorithm inspired by RRT*, incorporating:\n    - Goal-biased sampling (20% samples biased towards goal) to improve convergence speed.\n    - Adaptive step size (max_dist) which decreases near obstacles or goal for finer expansions.\n    - Rewiring to optimize paths locally, ensuring shorter, smoother paths.\n    - Heuristic combined cost (cost from start + heuristic to goal) for vertex selection.\n    - Shortcut smoothing after path extraction to reduce unnecessary waypoints.\n    - Early termination if goal reached or after 10 seconds to limit run-time.\n    This algorithm builds a tree expanding from start towards goal, rewiring around new nodes for optimality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _start_time: float\n    _time_limit: float\n    _goal_bias_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # needed for rewiring\n        self._init_displays()\n        self._max_dist = 15.0\n        self._time_limit = 10.0  # seconds\n        self._goal_bias_rate = 0.2\n        self._rewire_radius = 20.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        distance = torch.norm(dir).item()\n        if distance <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / distance\n        # Adaptive step size smaller near goal or obstacles\n        adaptive_max_dist = max_dist\n        dist_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        if dist_goal < max_dist * 3:\n            adaptive_max_dist = max_dist * (dist_goal / (max_dist * 3))\n            adaptive_max_dist = max(adaptive_max_dist, max_dist * 0.2)  # at least 20% max_dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + adaptive_max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability goal_bias_rate pick goal directly\n        if random.random() < self._goal_bias_rate:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _calculate_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _heuristic(self, pos: Point) -> float:\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent that yields lowest cost to q_new (cost_from_start + movement cost)\n        min_cost = float(\"inf\")\n        best_parent = None\n        for parent in q_near_list:\n            cost = parent.cost + self._calculate_cost(parent, q_new)\n            if cost < min_cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(parent.position, q_new.position)):\n                min_cost = cost\n                best_parent = parent\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        for neighbor in near_vertices:\n            if neighbor == q_new:\n                continue\n            cost_through_new = q_new.cost + self._calculate_cost(q_new, neighbor)\n            if cost_through_new < neighbor.cost:\n                # Check edge collision before rewiring\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    # Remove old edge parents (assuming single parent to simplify structure)\n                    for p in neighbor.parents.copy():\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # RRT* normally has one parent (tree), choose any parent\n            p = next(iter(path[-1].parents))\n            path.append(p)\n        path.reverse()\n        path_positions = [v.position for v in path]\n\n        # Shortcut smoothing: attempt to shortcut between non-adjacent points\n        def shortcut_path(points: List[Point]) -> List[Point]:\n            if len(points) < 3:\n                return points\n            smoothed = [points[0]]\n            i = 0\n            while i < len(points) - 1:\n                j = len(points) - 1\n                while j > i + 1:\n                    line = self._get_grid().get_line_sequence(points[i], points[j])\n                    if self._get_grid().is_valid_line_sequence(line):\n                        break\n                    j -= 1\n                smoothed.append(points[j])\n                i = j\n            return smoothed\n\n        smoothed_positions = shortcut_path(path_positions)\n\n        for pos in smoothed_positions:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_vertex: Vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.add_edge(None, start_vertex)  # Add start vertex with no parent (root of tree)\n\n        self._start_time = time.time()\n        iterations = 0\n        max_iterations = 15000\n\n        while True:\n            iterations += 1\n            if iterations > max_iterations:\n                break\n            if (time.time() - self._start_time) > self._time_limit:\n                # Time limit reached, no path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            # Find near vertices within radius for rewiring and parent selecting\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_sample, self._rewire_radius)\n            if not near_vertices:\n                # if no vertices near, pick nearest vertex in tree anyway\n                q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n                near_vertices = [q_near]\n\n            # Choose best parent for new vertex from near vertices\n            best_parent = self._choose_parent(near_vertices, Vertex(q_sample))\n            if best_parent is None:\n                continue\n\n            q_new = self._get_new_vertex(best_parent, q_sample, self._max_dist)\n\n            # Line from best parent to q_new must be valid\n            line_seq = self._get_grid().get_line_sequence(best_parent.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and add new vertex and edge\n            q_new.cost = best_parent.cost + self._calculate_cost(best_parent, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighborhood to optimize paths\n            neighbors_for_rewire = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            self._rewire(q_new, neighbors_for_rewire)\n\n            # Check if goal reached (within agent radius from goal)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal to q_new if path valid\n                goal_pos = self._get_grid().goal.position\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + self._calculate_cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning: An improved sample-based algorithm that incorporates:\n      - Adaptive goal-biased sampling with increasing bias over iterations.\n      - An RRT* inspired rewiring step to improve path quality dynamically.\n      - Heuristic-guided extension using Euclidean + path cost (A*-style cost).\n      - Adaptive step size (max_dist) that shrinks near obstacles or goal vicinity.\n      - Early stopping based on reaching goal and time limit (10 seconds).\n      - Shortcut smoothing on extracted path to reduce unnecessary waypoints.\n      This hybrid approach improves efficiency by focusing samples toward goal,\n      while rewiring for a more optimized and shorter path, and ensures robustness\n      by adapting sampling and extension dynamically.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # to allow rewiring edges\n        self._init_displays()\n\n        self._iterations = 5000\n        self._max_dist = 15.0  # initial max extension length\n        self._rewiring_radius = 20.0\n        self._goal_bias_increment = 0.0002  # increase goal bias over iterations\n        self._base_goal_bias = 0.05  # initial bias for goal sampling\n\n    def _get_heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance as heuristic\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Cost is cost to from_vertex + movement cost from from_vertex to to_point\n        current_cost = from_vertex.cost if hasattr(from_vertex, 'cost') else float('inf')\n        move_cost = self._get_grid().get_movement_cost(frm=from_vertex.position, to=to_point)\n        return current_cost + move_cost\n\n    def _get_new_vertex_limited(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Direction vector and distance\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_random_sample_goal_biased(self, iteration: int) -> Point:\n        # Adaptive goal bias, increases with iteration to improve goal approach\n        goal_bias = min(1.0, self._base_goal_bias + iteration * self._goal_bias_increment)\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)]\n                sample_point = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n    def _nearest_vertices_within_radius(self, position: Point, radius: float) -> List[Vertex]:\n        # Get vertices within rewiring radius for rewiring step\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, radius)\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        improved_vertices = 0\n        q_new.cost = q_new.cost if hasattr(q_new, 'cost') else 0.0\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n\n            # Compute potential new cost via q_new\n            cost_through_q_new = q_new.cost + self._get_grid().get_movement_cost(frm=q_new.position, to=q_near.position)\n            if cost_through_q_new < (q_near.cost if hasattr(q_near, 'cost') else float('inf')):\n                # Check path validity before rewiring\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges of q_near to improve connectivity\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    # Add edge from q_new to q_near\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_q_new\n                    improved_vertices += 1\n\n    def _extract_path(self) -> None:\n        path: List[Vertex] = []\n\n        # Start from goal and trace back to start\n        current_vertex = self._graph.root_vertex_goal\n        if not hasattr(current_vertex, 'cost') or current_vertex.cost == float('inf'):\n            # No path found\n            return\n\n        # Use parents with minimal cost to trace shortest path backward\n        while current_vertex is not self._graph.root_vertex_start:\n            path.append(current_vertex)\n            if len(current_vertex.parents) == 0:\n                break  # no path\n            # Select parent with minimum cost\n            current_vertex = min(current_vertex.parents, key=lambda p: p.cost if hasattr(p, 'cost') else float('inf'))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing for path quality\n        smoothed_path: List[Point] = [path[0].position]\n        for i in range(len(path)):\n            for j in range(len(path) - 1, i, -1):\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j].position)\n                    i = j\n                    break\n\n        # Move agent with visualization frames\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for i in range(self._iterations):\n            # Time limit 10 seconds\n            if time.time() - start_time > 10.0:\n                # Stop if no path found in 10 seconds\n                break\n\n            q_rand: Point = self._get_random_sample_goal_biased(i)\n            # Find nearest vertex biased by heuristic cost + distance from sample (best parent candidate)\n            candidates = []\n            best_cost = float('inf')\n            best_near = None\n\n            # Search best parent among all existing vertices in the forest\n            for root in self._graph.root_vertices:\n                nearest_candidate = self._graph.get_nearest_vertex([root], q_rand)\n                if nearest_candidate is None:\n                    continue\n\n                tentative_cost = self._get_cost(nearest_candidate, q_rand) + self._get_heuristic_cost(q_rand, self._get_grid().goal.position)\n                if tentative_cost < best_cost:\n                    best_cost = tentative_cost\n                    best_near = nearest_candidate\n\n            if best_near is None:\n                continue\n\n            # Adaptive max_dist based on proximity to goal and obstacles (shrink near goal or obstacles to enhance precision)\n            dist_to_goal = self._get_grid().get_distance(best_near.position, self._get_grid().goal.position)\n            max_dist_adaptive = self._max_dist\n            if dist_to_goal < self._max_dist * 2:\n                max_dist_adaptive = self._max_dist * 0.3\n            # Shrink max_dist if obstacle nearby (simple heuristic: check line to sample for collision)\n            line_to_sample = self._get_grid().get_line_sequence(best_near.position, q_rand)\n            if not self._get_grid().is_valid_line_sequence(line_to_sample):\n                max_dist_adaptive = self._max_dist * 0.2\n\n            q_new = self._get_new_vertex_limited(best_near, q_rand, max_dist_adaptive)\n            line_seq_new = self._get_grid().get_line_sequence(best_near.position, q_new.position)\n\n            if not self._get_grid().is_valid_line_sequence(line_seq_new):\n                # Skip invalid extensions\n                continue\n\n            q_new.cost = self._get_cost(best_near, q_new.position)\n            self._graph.add_edge(best_near, q_new)\n\n            # Rewire step: connect q_new to all vertices within rewiring radius if cost improved\n            near_vertices = self._nearest_vertices_within_radius(q_new.position, self._rewiring_radius)\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new is close enough to goal to try direct connection\n            dist_to_goal = self._get_grid().get_distance(q_new.position, self._get_grid().goal.position)\n            if dist_to_goal <= self._max_dist:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = float('inf')\n                    # Add edge and update cost if better path found\n                    tentative_goal_cost = q_new.cost + self._get_grid().get_movement_cost(frm=q_new.position, to=self._get_grid().goal.position)\n                    if tentative_goal_cost < (goal_vertex.cost if hasattr(goal_vertex, 'cost') else float('inf')):\n                        self._graph.add_edge(q_new, goal_vertex)\n                        goal_vertex.cost = tentative_goal_cost\n\n                    if goal_vertex.cost < float('inf'):\n                        self._extract_path()\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning Algorithm:\nThis algorithm implements an improved sample-based path planner combining goal-biased adaptive sampling,\nheuristic-guided vertex expansion, and adaptive step sizing. It integrates:\n- Goal biasing for focused exploration.\n- Adaptive max_dist depending on distance to goal to improve progress and smoothness.\n- A* inspired cost combining path cost and heuristic to guide expansion.\n- Rewiring similar to RRT* to optimize the tree structure dynamically.\n- Early stopping criteria including time limit (10 seconds) and successful path found.\n- Shortcut smoothing during path extraction for higher path quality.\nThis results in faster convergence, smoother, shorter, and more robust paths compared to existing methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_iterations: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_radius = 30.0\n        self._goal_bias = 0.2  # 20% chance sample is goal-biased\n        self._smooth_passes = 3  # number of shortcut smoothing passes\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        size = self._get_grid().size\n        dim = self._get_grid().size.n_dim\n\n        if torch.rand(1).item() < self._goal_bias:\n            # Goal biased sampling: sample near goal with some Gaussian noise\n            goal_pos = self._get_grid().goal.position\n            # Add small gaussian noise within max radius\n            noise = torch.randint(-5, 6, (dim,)).float()\n            sample = Point(*(torch.clamp(torch.tensor(goal_pos.to_list(), dtype=torch.float32) + noise, 0, torch.tensor(size.to_list(), dtype=torch.float32) - 1).int().tolist()))\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        \n        # Uniform random sampling across grid\n        while True:\n            rand_pos = [int(torch.randint(0, size[i], (1,)).item()) for i in range(dim)]\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        \n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(new_pos_tensor))\n        return q_new\n\n    def _heuristic_cost(self, point_a: Point, point_b: Point) -> float:\n        # Euclidean distance heuristic\n        return float(torch.norm(point_a.to_tensor() - point_b.to_tensor()))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from start to goal by traversing parents\n        path: List[Vertex] = [q_new]\n        while len(path[-1].parents) > 0:\n            parent_vertex = next(iter(path[-1].parents))\n            path.append(parent_vertex)\n        path.reverse()\n\n        # Perform shortcut smoothing on the path\n        path = self._shortcut_smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Publish waypoint if ROS map\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt shortcut smoothing on extracted path by removing unnecessary intermediate vertices\n        if len(path) < 3:\n            return path\n\n        def can_connect(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        for _ in range(self._smooth_passes):\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if can_connect(path[i].position, path[j].position):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            path = new_path\n            if len(path) < 3:\n                break\n        return path\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Adaptive step size: larger steps when far from goal, smaller near goal\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = self._heuristic_cost(q_near.position, goal_pos)\n        max_step = 15.0\n        min_step = 3.0\n        threshold_dist = 40.0\n        if dist_to_goal > threshold_dist:\n            return max_step\n        # scale linearly between min_step and max_step\n        scaled = min_step + (max_step - min_step) * (dist_to_goal / threshold_dist)\n        return float(max(min_step, min(scaled, max_step)))\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time = 10.0  # seconds timeout\n        max_iterations = self._max_iterations\n        dimension = self._get_grid().size.n_dim\n        lambda_rrt_star = 50.0\n        max_radius = self._max_radius\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > max_time:\n                # Timeout: no path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size according to distance to goal\n            max_dist = self._adaptive_max_dist(q_nearest)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check valid line between nearest and new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            vertex_count = torch.tensor(float(self._graph.size))\n            radius = min(lambda_rrt_star*((torch.log(vertex_count)/vertex_count)**(1/dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n            goal_pos = self._get_grid().goal.position\n\n            for q_near in Q_near:\n                line_valid = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                if not line_valid:\n                    continue\n\n                cost_to_new = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                # f-value for A* guidance: cost + heuristic to goal\n                f_val = cost_to_new + self._heuristic_cost(q_new.position, goal_pos)\n                c_min_f = c_min + self._heuristic_cost(q_min.position, goal_pos)\n\n                if cost_to_new < c_min or (cost_to_new == c_min and f_val < c_min_f):\n                    q_min = q_near\n                    c_min = cost_to_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: attempt to improve neighbors cost via new vertex\n            for q_near in Q_near:\n                if q_near is q_min:\n                    continue\n                line_valid = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                if not line_valid:\n                    continue\n\n                cost_through_new = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove previous parent edge\n                    q_near_parent = next(iter(q_near.parents), None)\n                    if q_near_parent is not None:\n                        self._graph.remove_edge(q_near_parent, q_near)\n\n                    # Reconnect with new parent q_new\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Add q_new vertex to graph root vertices for future expansions\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new is inside goal radius -> success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is an enhanced heuristic-guided sampling-based planner that integrates \n    adaptive goal-biased sampling and A*-inspired vertex expansion to efficiently find high-quality paths on discrete grids. \n\n    Key features:\n    - Adaptive goal bias with progressive increase towards the goal sampling probability, improving convergence speed.\n    - Sample rejection based on a heuristic threshold: only samples that improve estimated cost (distance + heuristic) are considered.\n    - Dynamic step size (max_dist) adapts to local environment complexity, shortening near obstacles for safety.\n    - Incorporates a rewiring step similar to RRT* but uses an A*-like cost function (cost from start + heuristic to goal) for neighborhood rewiring.\n    - Early stopping if a path is found or if search exceeds 10 seconds.\n    - Path extraction includes simple shortcut smoothing by checking line-of-sight between non-adjacent vertices on the path.\n    - Robustness is improved by goal bias and adaptive sampling, efficiency by heuristic pruning, and path quality by smoothing.\n\n    This design differs from classical RRT* by integrating heuristic guidance and adaptive sampling, and from SPRM by avoiding cyclic graphs and adding path smoothing.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters\n        self._max_dist_base = 10.0  # Base step size\n        self._max_radius = 20.0  # Radius for rewiring neighborhood\n        self._dimension = self._get_grid().size.n_dim\n        self._lambda_rrt_star = 50.0  # Parameter for radius calculation in rewiring\n        self._max_iterations = 10000\n        self._goal_sample_rate_init = 0.1  # Initial probability to sample goal\n        self._goal_sample_rate_max = 0.5  # Max probability for goal sampling\n        self._goal_sample_rate_growth = 0.00004  # Growth per iteration\n\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        # With probability goal_sample_rate, sample the goal directly; else uniform random\n        if random.random() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._dimension)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _heuristic(self, pos: Point) -> float:\n        # Euclidean distance heuristic from pos to goal\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _cost(self, from_vertex: Vertex, to_pos: Point) -> float:\n        # Cost to move from from_vertex.position to to_pos (movement cost + from_vertex.cost)\n        move_cost = self._get_grid().get_movement_cost(from_vertex.position, to_pos)\n        if from_vertex.cost is None:\n            return float('inf')\n        return from_vertex.cost + move_cost\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Collect path vertices from goal to start\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while len(current.parents) != 0:\n            # Select parent with lowest cost for path\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing: try to skip intermediate vertices if line sequence is valid\n        smoothed_path: List[Vertex] = []\n        i = 0\n        n = len(path)\n        while i < n:\n            smoothed_path.append(path[i])\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    i = j\n                    break\n                j -= 1\n            else:\n                i += 1\n\n        # Move agent along smoothed path with key frames\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            grid = self._get_grid()\n            # If ROS map, optionally publish wp\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        goal_sample_rate = self._goal_sample_rate_init\n        max_dist = self._max_dist_base\n        iter_count = 0\n\n        while iter_count < self._max_iterations:\n\n            iter_count += 1\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: treat search as failed\n                break\n\n            # Increase goal bias progressively, capped by max_goal_sample_rate\n            goal_sample_rate = min(self._goal_sample_rate_max, goal_sample_rate + self._goal_sample_rate_growth)\n\n            # Sample point with goal bias\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max_dist: shorten step if near obstacles by sampling neighbor points and checking collisions\n            max_dist_current = max_dist\n            # Evaluate surroundings for obstacle density near q_nearest.position (simple check within radius 3)\n            neighbors = self._get_vertices_within_radius(q_nearest, 3.0)\n            if len(neighbors) > 5:\n                max_dist_current = max_dist * 0.5  # reduce step size to increase safety near dense areas\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist_current)\n\n            # Check line validity from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute estimated cost for q_new (using cost to reach + heuristic to goal)\n            cost_to_q_new = self._cost(q_nearest, q_new.position)\n            if cost_to_q_new == float('inf'):\n                continue\n            heuristic_q_new = self._heuristic(q_new.position)\n            total_estimated_cost = cost_to_q_new + heuristic_q_new\n\n            # Heuristic pruning: abandon samples with estimated cost worse than current best path (if any)\n            # Find best known cost to goal (if exists)\n            best_goal_cost = None\n            goal_vertex = self._graph.root_vertex_goal\n            if len(goal_vertex.parents) > 0 and goal_vertex.cost is not None:\n                best_goal_cost = goal_vertex.cost\n\n            if best_goal_cost is not None and total_estimated_cost > best_goal_cost * 1.1:\n                # Sample probably won't improve path enough; skip to improve efficiency\n                continue\n\n            # Assign cost to new vertex\n            q_new.cost = cost_to_q_new\n\n            # Add edge from q_nearest to q_new\n            self._graph.add_edge(q_nearest, q_new)\n\n            # Rewire near vertices within radius with A*-style cost improvement\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(1.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            for q_near in Q_near:\n                if q_near == q_nearest:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                potential_cost = self._cost(q_near, q_new.position)\n                if potential_cost < q_new.cost:\n                    # Rewire q_new parent\n                    parent_to_remove = None\n                    for p in q_new.parents:\n                        parent_to_remove = p\n                        break\n                    if parent_to_remove is not None:\n                        self._graph.remove_edge(parent_to_remove, q_new)\n                    q_new.cost = potential_cost\n                    self._graph.add_edge(q_near, q_new)\n\n            # Also consider rewiring neighbors to use q_new as parent if it improves cost\n            for q_near in Q_near:\n                if q_near == q_new:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                if q_near.cost is None or cost_through_new < q_near.cost:\n                    parent_to_remove = None\n                    for p in q_near.parents:\n                        parent_to_remove = p\n                        break\n                    if parent_to_remove is not None:\n                        self._graph.remove_edge(parent_to_remove, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add final edge to goal vertex and update cost\n                dist_to_goal = self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._graph.root_vertex_goal.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n\n                self._extract_path(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Description:\n    This algorithm implements a heuristic-biased Rapidly-exploring Random Graph with Adaptive Step size (HRRG-AS).\n    Key improvements:\n    - Goal biasing with increasing probability over iterations to accelerate goal connectivity attempts.\n    - Heuristic-guided adaptive sampling favoring nodes closer to the goal.\n    - Adaptive step size based on local obstacle density: smaller steps near obstacles, larger steps in free space.\n    - Graph maintained as a Forest with rewiring to improve path quality.\n    - A timeout of 10 seconds to stop planning early if no solution is found.\n    - Shortcut path smoothing using line-of-sight post-processing to produce better quality paths.\n    - Early stopping once a path meeting a cost threshold is found to improve efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias_initial: float\n    _goal_bias_max: float\n    _sampling_bias_increment: float\n    _time_limit_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist_base = 15.0  # Base adaptive max step distance\n        self._goal_bias_initial = 0.1  # Starting goal sampling bias probability\n        self._goal_bias_max = 0.5  # Maximum goal sampling bias probability\n        self._sampling_bias_increment = 0.0001  # Increment per iteration of goal bias probability\n        self._time_limit_seconds = 10.0  # Timeout for pathfinding\n\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias: float) -> Point:\n        \"\"\"Sample points with goal biasing and heuristic biasing towards goal vicinity.\"\"\"\n        grid = self._get_grid()\n        if random.random() < goal_bias:\n            # Biased to goal position, plus small Gaussian noise\n            goal_pos = grid.goal.position\n            noise = np.clip(np.random.normal(0, 4, grid.size.n_dim), -7, 7).astype(int)\n            biased_sample_coords = np.array(goal_pos) + noise\n            # Clamp coords within size\n            biased_sample_coords = np.maximum(np.minimum(biased_sample_coords, grid.size - 1), 0)\n            sample = Point(*biased_sample_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # General heuristic-biased sampling around the tree towards the goal\n        for _ in range(50):  # small max attempts to find a valid sample\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            # Heuristic bias: probability to keep sample grows if closer to goal than agent\n            dist_sample_to_goal = Map.get_distance(sample, grid.goal.position)\n            dist_agent_to_goal = Map.get_distance(grid.agent.position, grid.goal.position)\n            prob_accept = 1.0 if dist_sample_to_goal < dist_agent_to_goal else 0.3\n            if random.random() < prob_accept and grid.is_agent_valid_pos(sample):\n                return sample\n        # Fallback uniform random sample\n        while True:\n            fallback_sample_coords = np.random.randint(0, grid.size, grid.size.n_dim)\n            fallback_sample = Point(*fallback_sample_coords)\n            if grid.is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_obstacle_density(self, q: Point, radius: float = 5.0) -> float:\n        \"\"\"Estimate obstacle density in a radius around point q by sampling points.\"\"\"\n        grid = self._get_grid()\n        count_checks = 0\n        count_obstacles = 0\n        for _ in range(20):\n            random_offset_coords = np.array([random.uniform(-radius, radius) for _ in range(grid.size.n_dim)])\n            sample_coords = np.array(q) + random_offset_coords\n            sample_coords = np.clip(sample_coords, 0, grid.size - 1).astype(int)\n            sample_point = Point(*sample_coords)\n            if not grid.is_agent_valid_pos(sample_point):\n                count_obstacles += 1\n            count_checks += 1\n        if count_checks == 0:\n            return 0.0\n        return count_obstacles / count_checks\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Adaptive step based on obstacle density near q_near\n        density = self._get_obstacle_density(q_near.position, radius=5.0)\n        adaptive_max_dist = max_dist * (1.0 - 0.7 * density)\n        adaptive_max_dist = max(3.0, adaptive_max_dist)  # enforce minimal step size\n\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= adaptive_max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_norm = dir_vec / dist\n            q_new_pos_tensor = q_near.position.to_tensor() + adaptive_max_dist * dir_norm\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            return Vertex(q_new_pos)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        # Backtrack parents until start vertex reached\n        current = q_goal\n        while True:\n            if len(current.parents) == 0:\n                break\n            # pick the parent with lowest cost\n            min_cost_parent = None\n            min_cost = None\n            for par in current.parents:\n                if par.cost is not None and (min_cost is None or par.cost < min_cost):\n                    min_cost = par.cost\n                    min_cost_parent = par\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            current = min_cost_parent\n\n        path = list(reversed(path))\n\n        # Smooth path shortcuts by attempting line-of-sight shortcuts\n        path_smoothed = [path[0]]\n        grid = self._get_grid()\n        for i in range(1, len(path)):\n            if grid.is_valid_line_sequence(grid.get_line_sequence(path_smoothed[-1].position, path[i].position)):\n                # Skip intermediate vertices if direct line is valid\n                continue\n            else:\n                path_smoothed.append(path[i - 1])\n        # Final vertex always added\n        if path_smoothed[-1] != path[-1]:\n            path_smoothed.append(path[-1])\n\n        # Move agent along smoothed path\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            grid_obj = self._get_grid()\n            if hasattr(grid_obj, \"publish_wp\") and callable(getattr(grid_obj, \"publish_wp\")):\n                grid_obj.publish_wp(grid_obj.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        max_iter = 10000\n        max_dist = self._max_dist_base\n        goal_reached_cost_threshold = 2000  # threshold to stop early if path cost good enough\n        start_time = time.perf_counter()\n        goal_bias = self._goal_bias_initial\n\n        for i in range(max_iter):\n\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self._time_limit_seconds:\n                # Timeout reached - end planning attempt\n                return\n\n            # Gradually increase goal bias probability up to max limit over iterations\n            if goal_bias < self._goal_bias_max:\n                goal_bias = min(self._goal_bias_max, goal_bias + self._sampling_bias_increment)\n\n            # Sample a point with goal bias\n            q_sample: Point = self._get_random_sample(goal_bias=goal_bias)\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Collision check for trajectory between q_nearest and q_new\n            grid = self._get_grid()\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate the cost of q_new by adding movement cost from q_nearest\n            move_cost = grid.get_movement_cost(q_nearest.position, q_new.position)\n            q_new.cost = (q_nearest.cost if q_nearest.cost is not None else 0) + move_cost\n\n            # Find neighbors within a radius for rewiring and cost improvement\n            radius = min(\n                50,\n                15.0 * ((math.log(max(1, self._graph.size)) / max(1, self._graph.size)) ** (1 / grid.size.n_dim)),\n            )\n            neighbors: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with lowest cost + distance and collision free edge\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                line_check = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                if not line_check:\n                    continue\n                cost_through_near = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n                if cost_through_near < c_min:\n                    c_min = cost_through_near\n                    q_min = q_near\n            # Set q_new cost to best cost\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Attempt rewiring neighbors through q_new if cost improves and collision-free\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_check = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                if not line_check:\n                    continue\n                cost_through_new = q_new.cost + grid.get_movement_cost(q_new.position, q_near.position)\n                if cost_through_new < (q_near.cost if q_near.cost is not None else float('inf')):\n                    # Rewire: remove old edge and add new edge from q_new to q_near\n                    old_parent = None\n                    for par in q_near.parents:\n                        old_parent = par\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new node is within goal radius, and cost is reasonable\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex connected to q_new\n                goal_vertex = self._graph.root_vertex_goal\n                dist_to_goal = grid.get_distance(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                if goal_vertex.cost <= goal_reached_cost_threshold:\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved Informed RRT* style planner with goal biasing, adaptive step size, heuristic-guided rewiring,\n    and path smoothing. It samples points focused within an ellipse defined by the start and goal vertices to improve exploration efficiency \n    in promising regions and uses rewiring to optimize the path cost locally. Adaptive max step size reduces as solution improves to \n    encourage refined paths near solution. It includes early stopping after success or 10 seconds time limit.\n    Path extraction includes shortcut smoothing to improve path quality.\n    Goals:\n    - Improve planning efficiency by focused sampling and early stopping.\n    - Enhance path quality via rewiring and smoothing.\n    - Robustness by adaptive step and heuristic guidance.\n    - High success rate through goal biasing and informed sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _goal_bias: float\n    _time_limit: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring in RRT*\n\n        self._max_dist_base = 15.0  # base max distance to extend\n        self._iterations = 15000\n        self._goal_bias = 0.2  # 20% of samples are goal biased\n        self._time_limit = 10.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ellipse=None) -> Point:\n        \"\"\"\n        Samples a random point either goal biased or inside informed ellipse.\n        If informed_ellipse is None, samples entire grid space.\n        \"\"\"\n        grid_size = self._get_grid().size\n\n        if random.random() < self._goal_bias:\n            # Goal biasing: return goal position directly sometimes\n            return self._get_grid().goal.position\n\n        if informed_ellipse is not None:\n            # informed_ellipse = (center: Point, c_major: float, c_minor: float, rot_angle: float)\n            center, c_major, c_minor, rot = informed_ellipse\n\n            # Sample random point inside ellipse aligned with rot\n            while True:\n                # Sample in unit circle\n                r1 = random.random()\n                r2 = random.random()\n                angle = 2 * math.pi * r2\n                radius = math.sqrt(r1)\n                x_ellipse = radius * math.cos(angle)\n                y_ellipse = radius * math.sin(angle)\n\n                # Scale by ellipse axes\n                x_scaled = x_ellipse * c_major\n                y_scaled = y_ellipse * c_minor\n\n                # Rotate back\n                cos_rot = math.cos(rot)\n                sin_rot = math.sin(rot)\n                x_rot = cos_rot * x_scaled - sin_rot * y_scaled\n                y_rot = sin_rot * x_scaled + cos_rot * y_scaled\n\n                sample_x = int(round(center.x + x_rot))\n                sample_y = int(round(center.y + y_rot))\n\n                sample_point = Point(sample_x, sample_y)\n\n                if 0 <= sample_x < grid_size.width and 0 <= sample_y < grid_size.height:\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        return sample_point\n\n            # fallback to uniform sampling if something weird happens\n        while True:\n            rand_pos = np.random.randint(0, grid_size, grid_size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _compute_informed_ellipse(self, start: Point, goal: Point, c_best: float):\n        \"\"\"\n        Compute parameters of ellipse for informed sampling:\n        - center: midpoint between start and goal\n        - c_major: half distance start-goal\n        - c_minor: sqrt(c_best^2 - c_major^2) if c_best known, else c_major\n        - rot: angle of major axis\n        \"\"\"\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n        c_major = self._euclidean_distance(start, goal) / 2\n\n        if c_best == float('inf') or c_best == 0:\n            c_minor = c_major\n        else:\n            val = c_best ** 2 - (2 * c_major) ** 2 / 4\n            c_minor = math.sqrt(val) / 2 if val > 0 else c_major\n\n        dx = goal.x - start.x\n        dy = goal.y - start.y\n        rot = math.atan2(dy, dx)\n\n        return (center, c_major, c_minor, rot)\n\n    def _steer(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_point_tensor = q_near.position.to_tensor() + dir_norm * max_dist\n        new_point = Point.from_tensor(new_point_tensor)\n        return Vertex(new_point)\n\n    def _get_near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Vertex:\n        \"\"\"\n        Choose best parent for new_vertex from near_vertices minimizing cost + edge cost, and valid path exist.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n\n        for near_v in near_vertices:\n            line_seq = grid.get_line_sequence(near_v.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = near_v.cost + grid.get_movement_cost(near_v.position, new_vertex.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = near_v\n\n        if best_parent is None:\n            # fallback: attach to nearest vertex without checking path\n            best_parent = near_vertices[0] if near_vertices else None\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex):\n        \"\"\"\n        For each near vertex, check if going through new_vertex reduces cost. If so, rewire edges.\n        \"\"\"\n        grid = self._get_grid()\n        cost_new = new_vertex.cost\n\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, near_v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = cost_new + grid.get_movement_cost(new_vertex.position, near_v.position)\n            if cost_through_new < near_v.cost:\n                # Rewire: remove old parent edge and add new parent edge\n                # Remove old parent edges (only one parent expected in tree)\n                for p in list(near_v.parents):\n                    self._graph.remove_edge(p, near_v)\n                self._graph.add_edge(new_vertex, near_v)\n                near_v.cost = cost_through_new\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Extract path by tracing parents from goal_vertex to root(start).\n        \"\"\"\n        path = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        return path\n\n    def _shortcut_smoothing(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempts to shortcut the path by checking line validity between non-adjacent vertices.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        smoothed_path = [path[0]]\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 1:\n            next_i = len(path) - 1\n            for j in range(len(path) - 1, i, -1):\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    next_i = j\n                    break\n            smoothed_path.append(path[next_i])\n            i = next_i\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        c_best = float('inf')  # best cost found so far\n        solution_found = False\n        best_goal_vertex = None\n\n        # Main loop\n        for i in range(self._iterations):\n\n            current_time = time.time()\n            if current_time - start_time > self._time_limit:\n                # time out, stop planning\n                break\n\n            # Adaptive max distance: reduce max_dist as cost improves\n            max_dist = max(3.0, self._max_dist_base * (c_best / (c_best + 1.0)))\n\n            # Informed sampling ellipse params\n            informed_ellipse = None\n            if c_best < float('inf'):\n                informed_ellipse = self._compute_informed_ellipse(start_vertex.position, goal_vertex.position, c_best)\n\n            q_sample = self._get_random_sample(informed_ellipse=informed_ellipse)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            q_new = self._steer(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                self.key_frame()\n                continue\n\n            # Find near vertices for rewiring (radius based on sample number, RRT* style)\n            r = min(max_dist * 2.5, 50)\n            near_vertices = self._get_near_vertices(q_new, r)\n\n            # Choose parent minimizing cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            cost_parent_to_new = self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            q_new.cost = best_parent.cost + cost_parent_to_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices around new vertex to reduce path costs\n            self._rewire(near_vertices, q_new)\n\n            # Add vertex to graph manually\n            # The add_edge already adds vertex and edges\n\n            # Check if q_new is within goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Check cost to reach goal from q_new via direct edge\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    cost_to_goal = self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    total_cost = q_new.cost + cost_to_goal\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        if best_goal_vertex is not None:\n                            # Remove old goal connection\n                            for p in list(best_goal_vertex.parents):\n                                self._graph.remove_edge(p, best_goal_vertex)\n                            self._graph.remove_edge(best_goal_vertex, goal_vertex)\n                        # Connect q_new to goal vertex\n                        q_goal = Vertex(goal_vertex.position)\n                        q_goal.cost = total_cost\n                        self._graph.add_edge(q_new, q_goal)\n                        best_goal_vertex = q_goal\n                        solution_found = True\n\n            self.key_frame()\n\n            if solution_found and (time.time() - start_time > 0.5):\n                # Early stopping: found solution and iterated some min time\n                break\n\n        if solution_found and best_goal_vertex is not None:\n            path = self._extract_path(best_goal_vertex)\n            path = self._shortcut_smoothing(path)\n\n            for vertex in path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No solution found\n            pass",
     "objective": null,
     "other_inf": null
}
