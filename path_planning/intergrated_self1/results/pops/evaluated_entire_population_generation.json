Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0221,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic Guided RRT with Goal Biasing and Post-Processing Smoothing.\n    It dynamically adjusts step size based on local obstacle density, biases sampling towards the goal with progressive increase,\n    and incorporates heuristic cost (A*-inspired) to guide vertex connection and rewiring for optimal path quality.\n    It also performs a shortcut smoothing pass on the final path.\n    A time limit of 10 seconds is enforced to stop planning early if no solution is found.\n    This approach improves efficiency by focusing growth near promising areas, maintains robustness via adaptive sampling,\n    and yields smoother, shorter paths due to heuristic-guided rewiring and post-processing smoothing.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional members\n        self._max_step_base = 8.0\n        self._max_step_min = 3.0\n        self._max_step_max = 15.0\n        self._goal_bias_start = 0.1\n        self._goal_bias_end = 0.5\n        self._goal_bias_current = self._goal_bias_start\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample_goal_biased(self) -> Point:\n        import random\n        if random.random() < self._goal_bias_current:\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sample valid for the agent\n            while True:\n                sample = self._get_random_sample()\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_random_sample(self) -> Point:\n        size = self._get_grid().size\n        while True:\n            import numpy as np\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_max_step_dynamic(self, position: Point) -> float:\n        \"\"\"\n        Adaptive step size based on local obstacle density.\n        Sample points in the vicinity and reduce step if close to obstacles.\n        \"\"\"\n        check_radius = 5.0\n        nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, position, check_radius)\n        if len(nearby_vertices) > 15:\n            return self._max_step_min\n        elif len(nearby_vertices) > 5:\n            return (self._max_step_min + self._max_step_base) / 2\n        else:\n            return min(self._max_step_max, self._max_step_base + len(nearby_vertices))\n\n    def _heuristic_cost(self, from_pos: Point) -> float:\n        \"\"\"\n        Heuristic cost: Euclidean from current position to goal.\n        \"\"\"\n        return self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> \"List[Vertex]\":\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Modified to use adaptive max_dist\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(q_new_pos)\n\n    def _cost_between(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_distance(frm.position, to.position)\n\n    def _add_and_rewire(self, q_new: Vertex, Q_near: \"List[Vertex]\") -> None:\n        \"\"\"\n        Connect q_new to best parent in Q_near minimizing cost + heuristic and rewire neighbors optimizing path cost.\n        \"\"\"\n        # Choose best parent\n        c_min = float('inf')\n        q_min = None\n        for q_near in Q_near:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._cost_between(q_near, q_new)\n            # Heuristic-guided: include heuristic in cost for rewiring (although primarily on path extraction)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n\n        if q_min is None:\n            return  # Cannot connect, skip\n\n        q_new.cost = c_min\n        self._graph.add_edge(q_min, q_new)\n\n        # Rewire nearby vertices if beneficial\n        for q_near in Q_near:\n            if q_near is q_min:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            new_cost = q_new.cost + self._cost_between(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old parent edge\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path_with_smoothing(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal and perform shortcut smoothing between path points.\n        \"\"\"\n\n        path = [q_goal]\n        current = q_goal\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                path.append(parent)\n                current = parent\n                break\n        path.reverse()\n        positions = [v.position for v in path]\n\n        # Shortcut smoothing post-processing\n        smoothed_positions = self._shortcut_smooth_path(positions)\n\n        for pos in smoothed_positions:\n            self.move_agent(pos)\n            # Send waypoint if ROS map\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, positions: \"List[Point]\") -> \"List[Point]\":\n        \"\"\"\n        Performs shortcut smoothing by attempting to connect non-adjacent path points directly.\n        \"\"\"\n        if len(positions) <= 2:\n            return positions\n\n        smoothed = [positions[0]]\n        i = 0\n        while i < len(positions) - 1:\n            j = len(positions) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(positions[i], positions[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(positions[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found\n                smoothed.append(positions[i + 1])\n                i += 1\n\n        return smoothed\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations = 8000\n        dimension = 2\n        lambda_rrt_star = 30\n        max_radius_cap = 35\n\n        start_time = time.time()\n\n        for i in range(max_iterations):\n            # Enforce 10 seconds max time limit\n            if time.time() - start_time > 10:\n                return  # Fail gracefully after 10 seconds without path\n\n            # Gradually increase goal bias to focus more on goal in later steps\n            self._goal_bias_current = min(self._goal_bias_end, self._goal_bias_start + (i / max_iterations)*(self._goal_bias_end - self._goal_bias_start))\n\n            q_sample = self._get_random_sample_goal_biased()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size based on local environment from nearest vertex\n            max_step = self._get_max_step_dynamic(q_nearest.position)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Nearby vertices for rewiring and parent selection\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)).item() if card_v > 1 else max_radius_cap, max_radius_cap)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            self._add_and_rewire(q_new, Q_near)\n\n            # Add q_new to graph root vertices collection\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal can be connected with near q_new\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().get_distance(q_new.position, goal_pos) <= max_step:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path_with_smoothing(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": 1602.73,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.0,
          "average_steps": 10.9,
          "average_distance": 11.52,
          "average_smoothness": 0.34,
          "average_clearance": 2.14,
          "average_time": 0.2318,
          "average_distance_from_goal": 0.3,
          "average_original_distance_from_goal": 8.42,
          "average memory": 36.77,
          "goal_found_perc_improvement": -1.37,
          "average_steps_improvement": -20.31,
          "average_distance_improvement": -20.5,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 5.94,
          "average_time_improvement": -963.3,
          "average_distance_from_goal_improvement": -50.0,
          "average_path_deviation": 1.959999999999999,
          "average_memory_improvement": 1.21
     }
}
{
     "algorithm": "PathPlanning is a hybrid informed-sample-based algorithm that uses goal-biased sampling, \n    heuristic-guided expansion, and adaptive step size to efficiently construct a tree \n    from start toward goal while simultaneously attempting shortcut connections to improve path quality. \n    It maintains a Forest data structure like RRT*, but differs by:\n    - Using adaptive max_dist step size based on proximity to the goal.\n    - Incorporating a heuristic (Euclidean + cost) for choosing parents.\n    - Aggressively rewiring nearby nodes for cost improvements.\n    - Prioritizing goal connection attempts regularly.\n    - Applying a shortcut smoothing step after path extraction.\n    It includes a strict 10-second timeout to abort in case of long or failed searches.\n    This aims to improve success rate, reduce iterations, and produce shorter/smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _max_radius: float\n    _goal_bias_prob: float\n    _dimension: int\n    _lambda_rrt_star: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        # Base max step length\n        self._max_dist_base = 12.0\n        # Radius for neighbor search (rewiring)\n        self._max_radius = 30.0\n        # Probability of sampling the goal for goal bias\n        self._goal_bias_prob = 0.15\n        self._dimension = 2\n        self._lambda_rrt_star = 35.0\n        self._timeout_sec = 10.0\n        self._init_displays()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias_prob:\n            # Goal-biased sampling\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)])\n            if self._get_grid().is_agent_valid_pos(rand_pos):\n                return rand_pos\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dir_norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _heuristic_cost(self, point: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(point, goal_pos)\n\n    def _extract_path(self, q_goal_reached: Vertex) -> None:\n        path: List[Vertex] = [q_goal_reached]\n        # Backtrack using parents\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Smooth path shortcutting\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # ROS waypoint publishing support, if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Search for furthest reachable vertex with collision-free line\n            for check_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[check_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = check_idx\n                    break\n            new_path.append(path[next_idx])\n            idx = next_idx\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations = 5000\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n\n        for iteration in range(max_iterations):\n            curr_time = time.time()\n            if curr_time - start_time > self._timeout_sec:\n                # Timeout: path not found within 10 seconds\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                # Sampled exactly at existing vertex, no extension needed\n                self.key_frame()\n                continue\n\n            # Adaptive max_dist based on distance to goal, smaller as closer to reduce overshoot and improve smoothing\n            dist_to_goal = Map.get_distance(q_nearest.position, goal_pos)\n            max_dist = self._max_dist_base * (dist_to_goal / max(self._get_grid().size[0], 1))\n            max_dist = max(3.0, min(max_dist, self._max_dist_base))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate line from nearest to new\n            line_seq_near_new = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                self.key_frame()\n                continue\n\n            # Radius for near neighbors for rewiring using RRT* heuristic formula\n            card_v = max(float(self._graph.size), 1.0)\n            radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with min cost + heuristic (like A*) among neighbors + q_nearest\n            c_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            q_min = q_nearest\n\n            for q_near_cand in Q_near:\n                line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_cand):\n                    continue\n                cost_cand = q_near_cand.cost + Map.get_distance(q_near_cand.position, q_new.position)\n                # Add heuristic to prioritize vertices closer to goal (aiming smoother optimization)\n                cost_cand += self._heuristic_cost(q_new.position) * 0.2\n                if cost_cand < c_min:\n                    c_min = cost_cand\n                    q_min = q_near_cand\n\n            # Set cost and add edge\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if shorter path via q_new exists\n            for q_near_cand in Q_near:\n                if q_near_cand == q_min:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, q_near_cand.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_near_cand.position)\n                if cost_through_new < q_near_cand.cost:\n                    # Remove old parent edge\n                    parent_old = next(iter(q_near_cand.parents), None)\n                    if parent_old is not None:\n                        self._graph.remove_edge(parent_old, q_near_cand)\n                    # Add new edge with q_new as parent\n                    q_near_cand.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near_cand)\n\n            # Attempt to directly connect newly added vertex to the goal if close enough and path is free\n            dist_to_goal_new = Map.get_distance(q_new.position, goal_pos)\n            connection_threshold = 10.0\n            if dist_to_goal_new <= connection_threshold:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    cost_goal = q_new.cost + dist_to_goal_new\n                    # If no parents yet (not connected) or better cost, connect goal to q_new\n                    if not goal_vertex.parents or cost_goal < goal_vertex.cost:\n                        goal_vertex.parents.clear()\n                        goal_vertex.cost = cost_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": 892.995,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.46,
          "average_distance": 11.25,
          "average_smoothness": 0.34,
          "average_clearance": 2.1,
          "average_time": 0.1516,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 32.67,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -14.44,
          "average_distance_improvement": -16.46,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 5.0,
          "average_time_improvement": -595.41,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.5899999999999999,
          "average_memory_improvement": 12.06
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0075,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0078,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
